const e={base:Error,internal:Error,package:Error,already_overridden:Error,invalid_chain:Error};Object.seal(e);const t="lib-wrapper";let r=!1;const i=function(e,t,r,i=!0){if(Object.isFrozen(e))throw new Error(`libWrapper: Enum '${e.name}' is frozen.`);if(t!==t.toUpperCase())throw new Error("libWrapper: Enum keys must be all uppercase.");const n=new(Function("x",`return class ${t} extends x {}`)(e.value_cls));if(n.name!=t)throw new Error(`libWrapper: Incorrect value_obj name ${n.name}. Expected ${t}.`);if(void 0!==r&&(n.value=r),Object.freeze(n),Object.freeze(n.prototype),Object.freeze(n.constructor),Object.freeze(n.constructor.prototype),t in e)throw new Error(`libWrapper: Name '${t}' is already present in ${e.name}.`);if(e[t]=n,void 0!==r){if(e.reverse.has(r))throw new Error(`libWrapper: Value '${r}' is already present in ${e.name}.`);e.reverse.set(r,n)}return e.list.push(n),i&&e.sort_list_by_value(),n},n=function(e,t,r=!0){let n;if("string"!=typeof e)throw new Error("libWrapper: Enum name must be a string");if("object"!=typeof t)throw new Error("libWrapper: Enum collection must be a dictionary or an array");const s=!(t instanceof Array),a=`${e}Enum`,o={[a]:class{constructor(e,t){return this.constructor.get(e,t)}static get(t,r){if(t instanceof n)return t;if("string"==typeof t){const e=this[t.toUpperCase()];if(e)return e}{const e=this.reverse.get(t);if(void 0!==e)return e}if(void 0===r)throw new Error(`libWrapper: '${t}' is not a valid key or value for the enum ${e}.`);return r}static has(e){return e instanceof n}static toString(){return this.name}static get value_cls(){return n}static sort_list_by_value(){return this.list.sort((function(e,t){return(e.value??0)-(t.value??0)}))}}}[a],c=`${e}Value`;if(n={[c]:class{static toString(){return c}get name(){return this.constructor.name}get enum(){return o}toString(){return this.name}get lower(){return this.name.toLowerCase()}}}[c],Object.freeze(n),Object.freeze(n.prototype),o.list=[],s&&(o.reverse=new Map),t instanceof Array)for(const e of t)i(o,e,void 0,!1);else for(const e in t)i(o,e,t[e],!1);return o.sort_list_by_value(),r&&(Object.freeze(o),Object.freeze(o.prototype),Object.freeze(o.list),s&&Object.freeze(o.reverse)),o};var s={"lib-wrapper":{settings:{yes:"Yes",no:"No",save:"Save",reload:"Reload",reset:"Reset","notify-issues-gm":{name:"Notify GM of Issues",hint:"Whether to notify GMs when an issue is detected, for example a conflict."},"notify-issues-player":{name:"Notify Players of Issues",hint:"Whether to notify Players when an issue is detected, for example a conflict."},"high-performance-mode":{name:"High-Performance Mode",hint:"This disables most dynamic conflict detection capabilities in exchange for performance, especially relevant on low-end systems. Note that this will significantly decrease the chance conflicts are detected. As such, it is recommended to turn this off when installing or updating packages."},menu:{title:"libWrapper Settings Menu",priorities:{name:"Priorities","package-inactive":"Inactive","statistics-disabled":"Note: Statistics collection is disabled, not able to show unprioritized packages.",prioritized:{title:"Prioritized Packages",hint:"These packages will be prioritized compared to any package not in this list.\nHigher positions in the list result in a higher priority."},unprioritized:{title:"Unprioritized Packages",hint:"These packages will be neither prioritized nor deprioritized.\nPriorities among these packages are decided on a first-come-first-served basis.\nNew packages will default to this list."},deprioritized:{title:"Deprioritized Packages",hint:"These packages will be deprioritized compared to any package not in this list.\nHigher positions in the list result in a higher priority.",note:"Note that packages that do not use libWrapper are deprioritized even compared to these."}},conflicts:{name:"Conflicts","none-detected":"No conflicts have been detected.","statistics-disabled":"Statistics collection is disabled.","show-ignored":"Show ignored conflicts"},"active-wrappers":{name:"Active Wrappers","none-active":"No wrappers are active right now."},about:{name:"About","full-name":"About libWrapper",credits:"{name} {version} by {author}.","credits-translation":"",description:"'libWrapper' is a library which provides package developers with a simple way to modify core Foundry VTT code, while reducing the likelihood of conflict with other packages.",info:'You can find more information about this module in the <a href="{repo_url}">Foundry VTT package repository</a>, as well as the project\'s <a href="{github_url}">Github page</a>.',support:"<b>If you encounter any issues</b>, the easiest way to find support is to ask the community. The largest community-provided support channels are:","issue-tracker":'If you encounter an <b>internal libWrapper error</b>, or are a <b>package developer</b>, you may also submit a support request in the <a href="{issues_url}">libWrapper Github Issue Tracker</a>.'},"warning-reset-priorities":"Resetting the package priorities will move all packages back to 'Unprioritized'. This action cannot be undone. Are you sure you want to continue?","warning-save":"It is recommended you reload this page to apply the new package priorities. Do you wish to reload?"}},packages:{"unknown-title":"Unknown","type-plus-id":"{type} {id}","type-plus-title":"{type} {title}",types:{module:"module",system:"system",world:"world script",unknown:"package"}},error:{"see-js-console":"(See JS Console)","tech-details":"== Technical Details:","community-support":"Ask the community for support:","not-lw":"This is *not* a libWrapper bug.",external:{notification:"{title}: Error detected in {type}.",message:"Error detected in {type} {title}.",info:"Find information about this {type} here: {url}",report:"Report this issue here: {url}","likely-not-updated":"It is likely this {type} has not been updated for FVTT {version}."},internal:{message:"Internal error detected.","message-with-package":"Internal error detected, involving {type} {title}.",info:"Find information about libWrapper here: {url}",report:"Report this issue here: {url}"},conflict:{potential:"Potential conflict detected between {main} and {other}.",confirmed:"Conflict detected between {main} and {other}.",info:"Find information about these packages here:",report:"Report this conflict here:"}},"support-channels":[{title:"FoundryVTT Discord's #modules-troubleshooting channel",url:"https://discord.gg/foundryvtt"},{title:"FoundryVTT Reddit",url:"https://www.reddit.com/r/FoundryVTT"}]}};const a=["en","es","ja","pt-BR","pt-PT"],o=import.meta?.url?.endsWith("dist/lib-wrapper.js")?"../lang":"./lang";class c{static async _fetch(e){if(Array.isArray(a)&&!a.includes(e))return null;try{const t=new URL(`${o}/${e}.json`,import.meta.url),r=await fetch(t);return 200===r.status&&r.ok?r.json():null}catch(e){return console.warn(`libWrapper: Failed to load or parse ${url.href}.`,e),null}}static async init(){this.jsons=[];const e=[];try{const t=localStorage?.["core.language"];if(t){const r=JSON.parse(t);r&&"en"!==r&&e.push(r)}}catch(e){console.debug("libWrapper: Could not find or parse client language settings.")}const t=game?.i18n?.lang;if(t&&"en"!==t&&e.push(t),e.length>0){const t=await Promise.all(e.map((e=>this._fetch(e))));for(const e of t)e&&this.jsons.push(e)}}static localize(e){if(game?.i18n){const t=game.i18n.localize(e);if(t!==e)return t}try{const t=e.split(".");if(this.jsons)for(const e of this.jsons){const r=t.reduce(((e,t)=>e?.[t]),e);if(r)return r}return t.reduce(((e,t)=>e?.[t]),s)??e}catch(t){return console.error(t),e}}static format(e,t){if(game?.i18n){const r=game.i18n.format(e,t);if(r!==e)return r}const r=this.localize(e);if(r===e)return r;try{return r.replace(/\{(.*?)\}/g,((e,r)=>t?.[r]))}catch(t){return console.error(t),e}}}const l=function(t=!1){const r=game?.user?.data;if(r)return r;const i=game?.userId??game?.data?.userId;if(!i){if(t)return null;throw new e.internal("Unable to obtain the current user ID")}const n=game?.data?.users?.find((e=>e._id==i));if(!n){if(t)return null;throw new e.internal("Unable to obtain the current user data object")}return n},p=n("PackageType",["UNKNOWN","MODULE","SYSTEM","WORLD"]),d=[":","~"],u=new RegExp("^[a-z0-9_-]+$","i"),h=/^.*?\/(worlds|systems|modules)\/(.+?)(?=\/).*?$/gim;const _=function(e,t,r){if(void 0===t){const e=Error.stackTraceLimit;try{Error.stackTraceLimit=1/0,t=Error().stack}finally{Error.stackTraceLimit=e}}if(!t||"string"!=typeof t)throw new Error("libWrapper: Could not collect stack trace.");const i=t.matchAll(h);if(i){for(const t of i){const i=t[1],n=t[2];if(!i||!n)continue;let s,a;if("worlds"===i){const e=game?.data?.world?.id;if(e&&n!=e)continue;s=n,a=p.WORLD}else if("systems"===i){const e=game?.data?.system?.id;if(e&&n!=e)continue;s=n,a=p.SYSTEM}else{if("modules"!==i)throw new Error(`libWrapper: Invalid script type: ${i}`);if(game?.modules&&!game.modules.has(n))continue;if(r&&(n===r||r?.includes?.(n)))continue;s=n,a=p.MODULE}if(!1===e(s,a,t[0]))return!1}return!0}};class f{static get UNKNOWN(){return new f("«unknown»",p.UNKNOWN)}static collect_all(e,t,r){const i=new Set;_(((e,r,n)=>{const s=`${r.lower}:${e}`;return!!i.has(s)||(void 0!==t&&!t(e,r,n)||(i.add(s),!0))}),e,r);const n=[];for(const e of i)n.push(new f(e));return n}static is_valid_id(e){return!(!e||"string"!=typeof e)&&!!u.test(e)}constructor(e=null,t=null){this.set(e,t)}set(e=null,t=null,r=!0){if(!e)return this.detect_id();if("string"!=typeof e)throw new Error("libWrapper: PackageInfo IDs must be strings");if("«unknown»"!==e){if(null!==t||!this.from_key(e,!1)){if(!this.constructor.is_valid_id(e))throw new Error(`libWrapper: Invalid package ID '${e}'`);if(null!==t&&!p.has(t))throw new Error(`libWrapper: Package type for '${e}' must belong to the PACKAGE_TYPES enum, but got '${t}'.`);this.id=e,this.type=t,t||this.detect_type(),r&&Object.freeze(this)}}else this.set_unknown()}set_unknown(){this.id="«unknown»",this.type=p.UNKNOWN}equals(e){return e&&e.constructor===this.constructor&&e.id===this.id&&e.type===this.type}detect_id(e){this.set_unknown(),_(((e,t)=>(this.set(e,t),!1)),e,"lib-wrapper")}detect_type(){game?.modules?game.modules?.get(this.id)?.active?this.type=p.MODULE:this.id===game.data?.system?.id?this.type=p.SYSTEM:this.id===game.data?.world?.id?this.type=p.WORLD:this.type=p.UNKNOWN:this.id===t?this.type=p.MODULE:this.type=p.UNKNOWN}from_key(e,t=!0){let r;for(const t of d)if(r=e.split(t),2===r.length)break;if(2!==r.length){if(t)throw new Error(`libWrapper: Invalid key '${e}'`);return!1}const i=r[1],n=p[r[0]];return this.set(i,n),!0}toString(){return this.key}get known(){return this.type!=p.UNKNOWN}get exists(){switch(this.type){case p.MODULE:return game.modules.get(this.id)?.active;case p.SYSTEM:return game.data.system.id===this.id;case p.WORLD:return game.data.world.id===this.id;default:return!1}}get data(){if(!this.exists)return null;switch(this.type){case p.MODULE:return game.modules.get(this.id)?.data;case p.SYSTEM:return game.data.system.data;case p.WORLD:return game.data.world;default:return null}}static get unknown_title(){return c.localize("lib-wrapper.packages.unknown-title")}get title(){if(!this.exists)return this.constructor.unknown_title;switch(this.type){case p.MODULE:case p.SYSTEM:case p.WORLD:return this.data.title;default:return this.constructor.unknown_title}}get key(){return`${this.type.lower}:${this.id}`}get type_i18n(){return c.localize(`lib-wrapper.packages.types.${this.type.lower}`)}get type_plus_id(){return`${this.type.lower} ${this.id}`}get type_plus_id_capitalized(){let e=this.type_plus_id;return e.charAt(0).toUpperCase()+e.slice(1)}get type_plus_id_i18n(){return c.format("lib-wrapper.packages.type-plus-id",{type:this.type_i18n,id:this.id})}get type_plus_title(){return`${this.type.lower} ${this.title}`}get type_plus_title_i18n(){return c.format("lib-wrapper.packages.type-plus-title",{type:this.type_i18n,title:this.title})}get logId(){return this.type==p.MODULE?this.id:this.key}get settingsName(){switch(this.type){case p.MODULE:return this.id;case p.SYSTEM:return`${this.id} [System]`;case p.WORLD:return`${this.id} [World]`;default:return this.id}}get url(){return this.data?.url}get bugs(){return this.data?.bugs}get version(){return this.data?.version}get core_version_range(){const e=this.data;return e?[e.minimumCoreVersion,e.compatibleCoreVersion]:null}get compatible_with_core(){const t=this.core_version_range,r=function(t=!0){const r=game?.version??game?.release?.version??game?.data?.version??null;if(!t&&null===r)throw new e.internal("Unable to obtain the Foundry version");return r}(!0);if(!t||!r)return!0;const[i,n]=t;return!(i&&i!==r&&!isNewerVersion(r,i))&&(!n||!isNewerVersion(r,n))}}Object.freeze(f);const g=eval;function w(e,t){try{e.displayName=t,Object.defineProperty(e,"name",{value:t,writable:!1,enumerable:!1,configurable:!0})}catch(e){}}function m(e,t=""){return""!==t?`🎁${e}#${t}`:`🎁${e}`}function y(e){const t=Object.getOwnPropertyNames(e);t.push(...Object.getOwnPropertySymbols(e));for(const r of t){const t=Object.getOwnPropertyDescriptor(e,r);"function"==typeof t.value&&w(t.value,m(r)),"function"==typeof t.get&&w(t.get,m(r,"getter")),"function"==typeof t.set&&w(t.set,m(r,"setter"))}e.prototype&&y(e.prototype)}function b(e){return null!=e&&"object"==typeof e&&("message"in e&&"stack"in e)}const k=["/listeners.js",m("call_wrapped"),m("Application.prototype._render")];function v(e,r){const i=function(e,r){return f.collect_all(e,((e,r,i)=>{if(e!==t||r!==p.MODULE)return!0;for(const e of k)if(i.includes(e))return!1;return!0}),r)}(e,r),n=i.length;return n<=0?"[No packages detected]":1==n?`[Detected 1 package: ${i[0].logId}]`:`[Detected ${n} packages: ${i.map((e=>e.logId)).join(", ")}]`}function E(e,t){if(!(t in e))return!1;const r=Object.getOwnPropertyDescriptor(e,t);if(r){if(!("value"in r))return!1;if("string"!=typeof r.value)return!1;if(!r.writable)return!1}else{if("string"!=typeof e[t])return!1}return!0}function O(e,t){if(!b(e))return;if(e.skip_package_detection)return;if(!function(e){return!Object.isFrozen(e)&&!(!E(e,"message")||!E(e,"stack"))}(e))return;const r=v(e.stack,t);if(e.message.endsWith(r))return void(e.skip_package_detection=!0);const i=e.message;e.message+=`\n${r}`,e.stack=e.stack.replace(i,e.message),e.skip_package_detection=!0}class W extends Error{get notification_fn(){return"error"}constructor(e,r,...i){super(r,...i),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.ui_msg=e,this.console_msg=r,O(this,this instanceof z?null:t)}onUnhandled(){}}Object.freeze(W),e.base=W;class z extends W{static construct_message(e,t){const r="lib-wrapper.error",i=`${r}.internal`,n=t.known?c.format(`${type.prefix}.message-with-package`,{type:t.type_i18n,title:t.title}):c.localize(`${i}.message`);return[`libWrapper: ${n}`,`${n}\n\n${c.format(`${i}.info`,{url:"https://github.com/ruipin/fvtt-lib-wrapper"})}\n${c.format(`${i}.report`,{url:"https://github.com/ruipin/fvtt-lib-wrapper/issues"})}\n\n${c.localize(`${r}.tech-details`)}\nInternal libWrapper error.\n${t.known?`Related Package ID= ${t.logId}\n`:""}Error= ${e}\n`]}constructor(e,...t){const r=new f,[i,n]=z.construct_message(e,r);super(i,n,...t),this.package_info=r}get package_id(){return this.package_info?.id}}Object.freeze(z),e.internal=z;class A extends W{static get_community_support_message(){const e=[],t=c.localize("lib-wrapper.support-channels");if(Array.isArray(t))for(const r of t)"title"in r&&"url"in r&&e.push(`- ${r.title}: ${r.url}`);return e.length>0?e.join("\n"):null}static construct_message(t,r){const i="lib-wrapper.error",n=`${i}.external`,s=r.title,a=r.type_i18n;let o=c.format(`${n}.notification`,{title:s,type:a}),l=c.format(`${n}.message`,{title:s,type:a});if(!r.compatible_with_core){const t=function(t=!0){const r=game?.release?.display??game?.version??game?.data?.version??null;if(!t&&null===r)throw new e.internal("Unable to obtain the Foundry display version");return r}(!0);if(t){const e=` ${c.format(`${n}.likely-not-updated`,{type:a,version:t})}`;o+=e,l+=e}}let p=`${l}\n\n${c.localize(`${i}.not-lw`)}\n\n`;const d=r.url;"string"==typeof d&&(p+=c.format(`${n}.info`,{type:a,url:d}));const u=r.bugs;if("string"==typeof u)p+="\n",p+=c.format(`${n}.report`,{url:u});else{const e=this.get_community_support_message();e&&(p+="\n\n",p+=c.localize(`${i}.community-support`),p+="\n",p+=e)}return p+="\n\n",p+=c.localize(`${i}.tech-details`),p+=`\nDetected by libWrapper.\nPackage ID= ${r.logId}\nError= ${t}\n`,[o,p]}constructor(e,t,...r){t?t?.constructor!==f&&(t=new f(t)):t=new f;const[i,n]=A.construct_message(e,t);super(i,n,...r),this.package_info=t}get package_id(){return this.package_info?.id}}function T(e,r){try{return game?.settings?.get(t,e)}catch(e){if(void 0!==r)return r;throw e}}function I(){const e=function(e=!1){const t=game?.user?.isGM;if(void 0!==t)return t;const r=l(e);return r?4===r.role:null}(!0);return null===e||T(e?"notify-issues-gm":"notify-issues-player",!0)}Object.freeze(A),e.package=A;class P{static init(){this.NOTIFICATION_SET=new Set,Object.seal(this)}static get ui_notifications_enabled(){try{if(!I())return!1}catch(e){return console.error("libWrapper: Could not decide whether to show notifications or not. Defaulting to 'yes'.\n",e),!0}return!0}static _ui(e,t,r){if(!this.ui_notifications_enabled)return;if(this.NOTIFICATION_SET.has(e))return;this.NOTIFICATION_SET.add(e);let i=globalThis?.ui?.notifications;i&&i[t].call(i,r?`libWrapper: ${e}`:e,{permanent:"error"==t})}static ui(e,t="error",r=!0){globalThis.game?.ready?this._ui(e,t,r):Hooks.once("ready",this._ui.bind(this,e,t))}static console_ui(e,t,r="error",...i){console[r].call(console,`libWrapper: ${e}\n${t}`,...i),this.ui(`${e} ${c.localize("lib-wrapper.error.see-js-console")}`,r)}static conflict(e,t,r,i){let n;n=Array.isArray(t)?t.length>1?`[${t.map((e=>e.type_plus_title_i18n)).join(", ")}]`:t[0].type_plus_title_i18n:t.type_plus_title_i18n;const s={main:e.type_plus_title_i18n,other:n};this.console_ui(r?c.format("lib-wrapper.error.conflict.potential",s):c.format("lib-wrapper.error.conflict.confirmed",s),i,r?"warn":"error")}}y(P);class j{static _collect_stats(){try{return function(e,t=!1){const r=game?.user?.can;if(r)return r(e);const i=l(t);if(!i)return null;if(4===i.role)return!0;if(e in i.permissions)return i.permissions[e];const n=game?.data?.settings?.find((e=>"core.permissions"===e.key));if(n?.value){const t=JSON.parse(n.value)[e];if(t&&t.includes(i.role))return!0}return!1}("SETTINGS_MODIFY")}catch(e){return P.console_ui("A non-critical error occurred while initializing libWrapper.","Could not read user permissions during initialization.\n","warn",e),!0}}static init(){this.collect_stats=this._collect_stats(),this.collect_stats&&(this.PACKAGES=new Set,this.CONFLICTS=new Map,Object.seal(this))}static register_package(e){this.collect_stats&&e.id!=t&&this.PACKAGES.add(e.key)}static register_conflict(e,t,r,i){if(!this.collect_stats)return;const n=`${e.key}/${t.key}`;let s=this.CONFLICTS.get(n);s||(s={count:0,ignored:0,package_info:e,other_info:t,targets:new Map},this.CONFLICTS.set(n,s));const a=r.name;let o=s.targets.get(a);o||(o={count:0,ignored:0},s.targets.set(a,o)),i?(s.ignored++,o.ignored++):(s.count++,o.count++)}static get conflicts(){return this.CONFLICTS}static get packages(){return this.PACKAGES}}class R{constructor(e,t,r){this.ignore_infos=new Set(e.map((e=>e.key))),this.targets=new Set(t),this.ignore_errors=r,Object.seal(this)}is_ignored(e,t,r){if(!r&&!this.ignore_errors)return!1;if(!this.ignore_infos.has(e.key))return!1;return void 0!==t.names.find((e=>this.targets.has(e)))}}class N{static init(){this.IGNORED=new Map,Object.seal(this)}static register_ignore(e,t,r,i){const n=new R(t,r,i),s=e.key;let a=this.IGNORED.get(s);a||(a=[],this.IGNORED.set(s,a)),a.push(n)}static clear_ignores(){this.IGNORED.clear()}static _is_ignored_oneway(e,t,r,i){const n=e.key,s=this.IGNORED.get(n);if(!s)return!1;for(const e of s)if(e.is_ignored(t,r,i))return!0;return!1}static _is_ignored(e,t,r,i){return this._is_ignored_oneway(e,t,r,i)||this._is_ignored_oneway(t,e,r,i)}static register_conflict(t,i,n,s,a){if(!i)return!1;if(Array.isArray(i)){let e=!1;return i.forEach((r=>{e|=this.register_conflict(t,r,n,s,a)})),e}if(t.constructor!==f)throw new e.internal(`LibWrapperConflicts.register_conflict: 'package_info' must be a PackageInfo object, but got '${t}'.`);if(i.constructor!==f)throw new e.internal(`LibWrapperConflicts.register_conflict: 'other_info' must be a PackageInfo object, but got '${i}'.`);if(null!=s&&"string"!=typeof s)throw new e.internal(`LibWrapperConflicts.register_conflict: 'target' must be a string, or null, but got '${s}'.`);if("boolean"!=typeof a)throw new e.internal(`LibWrapperConflicts.register_conflict: 'is_warning' must be a boolean, but got '${a}'.`);let o=!1;return!o&&this._is_ignored(t,i,n,a)&&(o=!0,r&&console.debug(`Conflict between ${t.type_plus_id} and ${i.type_plus_id} over '${n.name}' ignored through 'ignore_conflicts' API.`)),o||!1!==Hooks.call("libWrapper.ConflictDetected",t.id,i.id,s,n.frozen_names)||(o=!0,r&&console.debug(`Conflict between ${t.type_plus_id} and ${i.type_plus_id} over '${n.name}' ignored, as 'libWrapper.ConflictDetected' hook returned false.`)),j.register_conflict(t,i,n,o),!o}}class D extends W{static construct_message(e,t,r){const i="lib-wrapper.error",n=`${i}.conflict`,s=e.type_plus_title_i18n,a=s.charAt(0).toUpperCase()+s.slice(1),o=t.type_plus_title_i18n,l=o.charAt(0).toUpperCase()+o.slice(1),p=c.format(`${n}.confirmed`,{main:s,other:o});let d=`libWrapper: ${p}`,u=`${p}\n\n${c.localize(`${i}.not-lw`)}\n\n`,h="";const _=e.url;"string"==typeof _&&(h+=`\n- ${a}: ${_}`);const f=t.url;"string"==typeof f&&(h+=`\n- ${l}: ${f}`),h&&(u+=`${c.localize(`${n}.info`)}${h}\n\n`);let g="";const w=e.bugs;"string"==typeof w&&(g+=`\n- ${a}: ${w}`);const m=t.bugs;"string"==typeof m&&(g+=`\n- ${l}: ${m}`),g&&(u+=`${c.localize(`${n}.report`)}${g}\n\n`);const y=A.get_community_support_message();return y&&(u+=c.localize(`${i}.community-support`),u+="\n",u+=y,u+="\n\n"),u+=c.localize(`${i}.tech-details`),u+=`\nDetected by libWrapper.\nPackage IDs= ${e.logId}, ${t.logId}\nError= ${r}\n`,[d,u]}constructor(e,t,r,i,...n){e?.constructor!==f&&(e=new f(e)),t?.constructor!==f&&(t=new f(t));const[s,a]=D.construct_message(e,t,`Failed to wrap '${i}' for ${e.type_plus_id} with type OVERRIDE. An OVERRIDE wrapper for the same method has already been registered by ${t.type_plus_id}.`);super(s,a,...n),this.package_info=e,this.conflicting_info=t,this.target=i,this._wrapper=r}get package_id(){return this.package_info?.id}get module(){return this.package_id}get conflicting_id(){return this.conflicting_info?.id}get conflicting_module(){return this.conflicting_id}onUnhandled(){super.onUnhandled(),N.register_conflict(this.package_info,this.conflicting_info,this._wrapper,this.target,!1)}}Object.freeze(D),e.already_overridden=D;class S extends A{constructor(e,t,r,...i){t?.constructor!==f&&(t=new f(t)),super(r,t,...i),this._wrapper=e}}Object.freeze(S),e.invalid_chain=S,Error.stackTraceLimit=1/0;const x=function(e){try{if(!b(e))return;e instanceof W&&function(e){e.ui_msg&&e.notification_fn&&P.ui(`${e.ui_msg} ${c.localize("lib-wrapper.error.see-js-console")}`,e.notification_fn,!1),e.onUnhandled&&e.onUnhandled.apply(e)}(e),function(e){O(e)}(e)}catch(e){console.warn("libWrapper: Exception thrown while processing an unhandled error.",e)}},C=function(e){try{const t=e.reason??e.error??e;return x(t)}catch(e){console.warn("libWrapper: Exception thrown while processing an unhandled error event.",e)}};const U="1.11.4.0",L=1,M=11,F=4,V=0,G="",H="cdd8b5f965e0cbbef245097c8517834979c38016",Y="1.11.4.0 (cdd8b5f)",K=function(e,t=0,r=0,i=0){return L==e?M==t?F==r?V==i:F>=r:M>t:L>e},q=n("WrapperType",{WRAPPER:1,MIXED:2,OVERRIDE:3}),B=n("PerformanceMode",{NORMAL:1,AUTO:2,FAST:3});const X=new class{constructor(){this.clear()}index_for_id(e){return Math.floor(e/2)}index_for_wrapper(e){return this.index_for_id(e.getter_id)}get_next_id_pair(){return[this.next_id++,this.next_id++]}_delete(e){this.data.delete(e)}_set(e,t){if(null==t)return this._delete(e);const r=new WeakRef(t);this.data.set(e,r)}_deref(e,t){const r=t?.deref();return r||this._delete(e),r}_get(e){const t=this.data.get(e);return this._deref(e,t)}exists(t,r){void 0===r&&(r=this.index_for_wrapper(t));const i=this._get(r);if(i){if(i!==t)throw new e.internal(`Sanity check failed: The WrapperStorage index ${r} does not contain the wrapper object '${t.name}'.`);return!0}return!1}add(e){const t=this.index_for_wrapper(e);this.exists(e,t)||this._set(t,e)}remove(e){const t=this.index_for_wrapper(e);this.exists(e,t)&&this._delete(t)}clear(){this.data=new Map,this.next_id=0}*wrappers(){for(const[e,t]of this.data.entries()){const r=this._deref(e,t);r&&(yield r)}}forEach(e){for(const t of this.wrappers())e(t)}find(e){for(const t of this.wrappers())if(e(t))return t}find_by_id(e){const t=this.index_for_id(e);return this._get(t)}};class Z{get_id(e=!1){return e?this.setter_id:this.getter_id}get name(){return this.names[0]}get frozen_names(){return Object.freeze(this.names),this.names}get_name(e=!1){return e?`${this.name}#set`:this.name}get_names(e=!1){return e?this.names.map((e=>`${e}#set`)):this.frozen_names}_add_name(e){this.names.includes(e)||(Object.isFrozen(this.names)&&(this.names=this.names.slice()),this.names.push(e))}_callstack_name(e,t=this.name){return m(t,e)}constructor(t,r,i,n){this.fn_name=r,this.object=t;let s=Object.getOwnPropertyDescriptor(t,r);if(s){if(s.get?._lib_wrapper){const t=s.get?._lib_wrapper;if(!(t instanceof this.constructor))throw new e.internal(`libWrapper: '${i}' cannot be wrapped, the descriptor already has a wrapper, but of an unexpected class ('${t.constructor.name}' vs '${this.constructor.name}').`);return t._add_name(i),t}if(!1===s.configurable)throw new e.package(`libWrapper: '${i}' cannot be wrapped, the corresponding descriptor has 'configurable=false'.`,n);s.get?(this.is_property=!0,this._wrapped_getter=s.get,this._wrapped_setter=s.set):(this.is_property=!1,this._wrapped=s.value)}else{if(s=this._get_inherited_descriptor(),!s)throw new e.package(`libWrapper: Can't wrap '${i}', target does not exist or could not be found.`,n);const t=s.get?._lib_wrapper;t?this.is_property=t.is_property:s.get??s.set?this.is_property=!0:this.is_property=!1}[this.getter_id,this.setter_id]=X.get_next_id_pair(),this.names=[],this.getter_data=[],this.is_property&&(this.setter_data=[]),this.active=!1,this._outstanding_wrappers=0,this.is_property||(this._current_handler_id=0,this._pending_wrapped_calls=[],this._pending_wrapped_calls_cnt=0),this.use_static_dispatch=!1,i||(i=r),this._add_name(i),this._wrap()}_get_handler(){if(this.is_property)throw new e.internal("Unreachable: _get_handler with is_property=false");const t=this._current_handler_id;if(t===this._cached_handler_id)return this._cached_handler;const r=this,i=this._callstack_name(t),n=this._wrapped??null,s={[i]:function(...e){const i=r.use_static_dispatch;return r.should_skip_wrappers(this,t,i)?r.get_wrapped(this,!1,n).apply(this,e):i?r.get_static_dispatch_chain(this).apply(this,e):r.call_wrapper(null,this,...e)}}[i];return s.toString=function(){return"/* WARNING: libWrapper wrappers present! */\n"+r.get_wrapped(this).toString()},this._cached_handler=s,this._cached_handler_id=t,s}should_skip_wrappers(t,r,i){if(r==this._current_handler_id)return!1;if(r>this._current_handler_id)throw new e.internal(`Unreachable: handler_id=${r} > this._current_handler_id=${this._current_handler_id}`);if(!this.is_property){if(this._pending_wrapped_calls_cnt<=0)return!1;if(!i){if(this._pending_wrapped_calls.indexOf(t)<0)return!1}}return!0}skip_existing_handlers(){this._current_handler_id++}_get_static_dispatch_chain_cache(e){return this._static_dispatch_weakmap?.get(e)??this._static_dispatch_strongmap?.get(e)}_set_static_dispatch_chain_cache(e,t){try{this._static_dispatch_weakmap||(this._static_dispatch_weakmap=new WeakMap),this._static_dispatch_weakmap.set(e,t)}catch{this._static_dispatch_strongmap||(this._static_dispatch_strongmap=new Map),this._static_dispatch_strongmap.set(e,t)}}clear_static_dispatch_chain_cache(){this._static_dispatch_weakmap?.clear?this._static_dispatch_weakmap.clear():delete this._static_dispatch_weakmap,this._static_dispatch_strongmap?.clear()}get_static_dispatch_chain(t){if(this.is_property)throw new e.internal("Unreachable: get_static_dispatch_chain with is_property=false");let r=this._get_static_dispatch_chain_cache(t);if(!r){r=this.call_wrapped.bind(this,null,t);const e=this.get_fn_data(!1);for(let i=e.length-1;i>=0;i--){const n=e[i],s=n.fn;r=n.chain?s.bind(t,r):s.bind(t)}this._set_static_dispatch_chain_cache(t,r)}return r}_calc_use_static_dispatch(){if(this.is_property)return!1;let e=B.AUTO;const t=this.get_fn_data(!1);for(const r of t)if(r.perf_mode)if(e===B.AUTO)e=r.perf_mode;else if(e!==r.perf_mode){e=B.AUTO;break}return e===B.AUTO&&(e=T("high-performance-mode",!1)?B.FAST:B.NORMAL),e===B.FAST}update_use_static_dispatch(){this.use_static_dispatch=this._calc_use_static_dispatch()}_wrap(){if(this.active)return;const e=this._callstack_name("getter"),t=this._callstack_name("setter");let r;if(this.is_property){const i=this;r={[e]:function(...e){return i.call_wrapper(null,this,...e)},[t]:function(...e){return i.call_wrapper({setter:!0},this,...e)}}}else{const i=this;r={[e]:()=>i._get_handler(),[t]:function(e){return i.set_nonproperty(e,this)}}}const i=r[e],n=r[t];i._lib_wrapper=this,Object.defineProperty(this.object,this.fn_name,{get:i,set:n,configurable:false}),this.active=!0,console.debug(`libWrapper: Wrapped '${this.name}'.`)}unwrap(){if(this.active)throw new e.internal("libWrapper: Cannot unwrap when PROPERTIES_CONFIGURABLE==false")}_get_inherited_descriptor(){let e=Object.getPrototypeOf(this.object);for(;e;){const t=Object.getOwnPropertyDescriptor(e,this.fn_name);if(t)return t;e=Object.getPrototypeOf(e)}return null}get_wrapped(t,r=!1,i){let n;if(n=void 0!==i?i:this.is_property?r?this._wrapped_setter:this._wrapped_getter:this._wrapped,null===n&&(n=void 0),void 0===n){const i=this._get_inherited_descriptor();if(i)if(this.is_property){if(!i.get&&!i.set)throw new e.internal("This wrapper is set up to wrap a property, but the inherited descriptor is a method.");n=r?i.set:i.get}else n=i.value??i.get.apply(t)}return void 0===n&&console.warn(`libWrapper: There is no wrapped method for '${this.name}', returning 'undefined'.`),n}call_wrapped(e,t,...r){e&&this._call_wrapper_update_state(e);const i=e?.setter??!1,n=!!e;let s,a;this.is_property||(this._pending_wrapped_calls_cnt++,n&&(s=t,this._pending_wrapped_calls.push(s)));try{a=this.get_wrapped(this.object,i)?.apply(t,r)}catch(e){throw this.is_property||this._cleanup_call_wrapped(s,n),e}return this.is_property||("function"==typeof a?.then?a=a.then((e=>(this._cleanup_call_wrapped(s,n),e)),(e=>{throw this._cleanup_call_wrapped(s,n),e})):this._cleanup_call_wrapped(s,n)),a}_cleanup_call_wrapped(t,r){if(!this._pending_wrapped_calls_cnt)throw new e.internal(`this._pending_wrapped_calls_cnt=${this._pending_wrapped_calls_cnt} should be unreachable at this point.`);if(this._pending_wrapped_calls_cnt--,r){const r=this._pending_wrapped_calls.indexOf(t);if(r<0)throw new e.internal("Could not find 'pend' inside 'this._pending_wrapped_calls'.");this._pending_wrapped_calls.splice(r,1)}}call_wrapper(t,r,...i){t&&this._call_wrapper_update_state(t);const n=t?.index??0,s=t?.setter??!1,a=t?.fn_data??this.get_fn_data(s),o=a[n];if(!o){if(a.length>0)throw new e.internal(`Must not have 'data===${o}' when 'fn_data.length==${a.length}'.`);return this.call_wrapped(t,r,...i)}const c=o.fn;if(!o.chain)return c.apply(r,i);const l=n+1,p=l>=a.length,d={index:l,called:!1,valid:!0,setter:s,prev_data:o,fn_data:a},u=p?this.call_wrapped.bind(this,d,r):this.call_wrapper.bind(this,d,r);let h;this._outstanding_wrappers++;try{h=c.call(r,u,...i)}catch(e){return this._cleanup_call_wrapper_thrown(d,e)}return h="function"==typeof h?.then?h.then((e=>this._cleanup_call_wrapper(e,d,o,a,u,r,i)),(e=>this._cleanup_call_wrapper_thrown(d,e))):this._cleanup_call_wrapper(h,d,o,a,u,r,i),h}_call_wrapper_update_state(t){if("valid"in t&&!t.valid)throw new e.invalid_chain(this,t.prev_data?.package_info,`This wrapper function for '${this.name}' is no longer valid, and must not be called.`);t.called=!0}_invalidate_state(t){if(t.valid=!1,this._outstanding_wrappers--,this._outstanding_wrappers<0)throw new e.internal(`Outstanding wrappers = ${this._outstanding_wrappers}, should never fall below 0.`)}_cleanup_call_wrapper_thrown(e,t){throw this._invalidate_state(e),t}_cleanup_call_wrapper(t,r,i,n,s,a,o){try{if(!r.called){let c=!i.warned_conflict||j.collect_stats,l=null,p=!1,d=!1;if(c&&(l=n.slice(r.index).filter((e=>!e.package_info.equals(i.package_info))).map((e=>e.package_info)),p=0==l.length,p||(d=N.register_conflict(i.package_info,l,this,null,!0))),i.type===q.WRAPPER){const r=new e.package(`The wrapper for '${i.target}' registered by ${i.package_info.type_plus_id} with type WRAPPER did not chain the call to the next wrapper, which breaks a libWrapper API requirement. This wrapper will be unregistered.`,i.package_info);x(r),console.error(r),globalThis.libWrapper.unregister(i.package_info.id,this.get_id(i.setter)),p||(t=s.apply(a,o))}else d&&!i.warned_conflict&&(P.conflict(i.package_info,l,!0,`${i.package_info.type_plus_id_capitalized} did not chain the wrapper for '${i.target}'.`),i.warned_conflict=!0)}}finally{this._invalidate_state(r)}return t}set_nonproperty(t,r=null){if(this.is_property)throw new e.internal("Must not call 'set_nonproperty' for a property wrapper.");r!==this.object?Object.defineProperty(r,this.fn_name,{value:t,configurable:!0,enumerable:!0,writable:!0}):(this._wrapped=t,this.skip_existing_handlers(),this.warn_classic_wrapper())}get_affected_packages(){return this.getter_data.map((e=>e.package_info))}warn_classic_wrapper(){const e=new f,t=this.get_affected_packages();if(t.length>0){N.register_conflict(e,t,this,null,!0)&&(P.conflict(e,t,!0,`Detected non-libWrapper wrapping of '${this.name}' by ${e.type_plus_id}. This will potentially lead to conflicts.`),r&&console.trace&&console.trace())}this.detected_classic_wrapper||(this.detected_classic_wrapper=[]),this.detected_classic_wrapper.push(e.key)}get_fn_data(t,r=!1){if(t&&!this.is_property)throw new e.internal(`libWrapper: '${this.name}' does not wrap a property, thus setter=true is illegal.`);const i=t?"setter_data":"getter_data";let n=this[i];return r&&this._outstanding_wrappers>0&&(n=this[i].slice(0),this[i]=n),n}_post_update_fn_data(){this.update_use_static_dispatch(),this.clear_static_dispatch_chain_cache()}sort(){for(let e of[!1,!0]){if(e&&!this.is_property)continue;this.get_fn_data(e).sort(((e,t)=>e.type.value-t.type.value||t.priority-e.priority))}}add(e){const t=e.fn;t.name&&"anonymous"!==t.name||w(t,this._callstack_name(e.package_info.id??"<unknown>"));this.get_fn_data(e.setter,!0).splice(0,0,e),this.sort(e.setter),this._post_update_fn_data()}remove(e){const t=this.get_fn_data(e.setter,!0),r=t.indexOf(e);t.splice(r,1),this._post_update_fn_data()}clear(){this.getter_data=[],this.is_property&&(this.setter_data=[]),this._post_update_fn_data()}is_empty(){return!this.getter_data.length&&!this.setter_data?.length}}y(Z),Object.freeze(Z);const J=new Map,Q=function(e=null){J.clear();const r=e??game?.settings?.get(t,"module-priorities");if(r)for(let e of["prioritized","deprioritized"]){const t=r[e];if(!t)continue;const i="prioritized"==e?1e4:-1e4;Object.entries(t).forEach((e=>{let[t,r]=e;r.id||(r=new f(t,p.MODULE),t=r.key),J.has(t)||J.set(t,i-r.index)}))}};class ee extends FormApplication{static init(){game.settings.register(t,"notify-issues-gm",{name:"lib-wrapper.settings.notify-issues-gm.name",hint:"lib-wrapper.settings.notify-issues-gm.hint",default:!0,type:Boolean,scope:"world",config:!0}),game.settings.register(t,"notify-issues-player",{name:"lib-wrapper.settings.notify-issues-player.name",hint:"lib-wrapper.settings.notify-issues-player.hint",default:!1,type:Boolean,scope:"world",config:!0}),game.settings.register(t,"high-performance-mode",{name:"lib-wrapper.settings.high-performance-mode.name",hint:"lib-wrapper.settings.high-performance-mode.hint",default:!1,type:Boolean,scope:"world",config:!0}),game.settings.registerMenu(t,"menu",{name:"",label:"lib-wrapper.settings.menu.title",icon:"fas fa-cog",type:ee,restricted:!0}),game.settings.register(t,"module-priorities",{name:"",default:{},type:Object,scope:"world",config:!1,onChange:e=>Q()}),this.show_ignored_conflicts=!1,Q(),Object.seal(this)}static get defaultOptions(){return{...super.defaultOptions,template:"modules/lib-wrapper/templates/settings.html",height:700,title:c.localize("lib-wrapper.settings.menu.title"),width:600,classes:[t,"settings"],tabs:[{navSelector:".tabs",contentSelector:"form",initial:"name"}],submitOnClose:!1,closeOnSubmit:!1}}constructor(e={},t){super(e,t)}static showYesNoDialog(e,t){new Dialog({content:e,buttons:{yes:{icon:'<i class="fas fa-check"></i>',label:c.localize("lib-wrapper.settings.yes"),callback:t},no:{icon:'<i class="fas fa-times"></i>',label:c.localize("lib-wrapper.settings.no")}}}).render(!0)}getActiveWrappers(){let e=[];return X.forEach((r=>{for(let i of[!1,!0]){if(i&&!r.is_property)continue;const n=[];if(r.get_fn_data(i).forEach((e=>{if(e.package_info.id==t)return;const r={name:e.package_info.settingsName,type:e.type.name,perf_mode:e.perf_mode.name};"AUTO"==r.perf_mode?r.perf_mode=null:r.perf_mode=`, ${r.perf_mode}`,n.push(r)})),r.detected_classic_wrapper&&r.detected_classic_wrapper.forEach((e=>{n.push({name:new f(e).settingsName,type:"MANUAL",perf_mode:null})})),n.length<=0)continue;const s=r.get_id(i),a=r.get_names(i);e.push({id:s,name:a[0],names:a.slice(1),packages:n})}})),e.sort(((e,t)=>t.packages.length-e.packages.length)),e}getConflicts(){if(!j.collect_stats)return null;let e=[];return j.conflicts.forEach((t=>{let r=t.count;if(this.show_ignored_conflicts&&(r+=t.ignored),0==r)return;const i=[];e.push({count:t.count,ignored:this.show_ignored_conflicts?t.ignored:0,total:r,package_id:t.package_info.settingsName,other_id:t.other_info.settingsName,targets:i}),t.targets.forEach(((e,t)=>{let r=e.count;this.show_ignored_conflicts&&(r+=e.ignored),r>0&&i.push({target:t,count:e.count,total:r,ignored:this.show_ignored_conflicts?e.ignored:0})})),i.sort(((e,t)=>e.total-t.total))})),e.sort(((e,t)=>e.total-t.total)),e}getPackages(){let e={prioritized:[],normal:[],deprioritized:[]};const r=game.settings.get(t,"module-priorities"),i=r.prioritized??{},n=r.deprioritized??{},s=c.localize("lib-wrapper.settings.menu.priorities.package-inactive");return j.collect_stats&&(j.packages.forEach((t=>{const r=new f(t);r.key in i||r.key in n||e.normal.push(r)})),e.normal.sort(((e,t)=>e.id.localeCompare(t.id)))),Object.entries(i).forEach((t=>{let[r,i]=t;i.id||(i=new f(r,p.MODULE),r=i.key),e.prioritized.push({key:r,id:i.id,title:i.title??`${i.title} <${s}>`,index:i.index})})),e.prioritized.sort(((e,t)=>e.index-t.index)),Object.entries(n).forEach((t=>{let[r,n]=t;r in i||(n.id||(n=new f(r,p.MODULE),r=n.key),e.deprioritized.push({key:r,id:n.id,title:n.title??`${n.title} <${s}>`,index:n.index}))})),e.deprioritized.sort(((e,t)=>e.index-t.index)),e}getData(){const e=[];{const t="lib-wrapper.support-channels",r=c.localize(t);if(Array.isArray(r))for(const t of r)"title"in t&&"url"in t&&e.push(t)}return{about:{name:"libWrapper",version:Y,collect_stats:j.collect_stats,translation_credits:c.localize("lib-wrapper.settings.menu.about.credits-translation"),support:e},wrappers:this.getActiveWrappers(),conflicts:this.getConflicts(),packages:this.getPackages(),show_ignored_conflicts:this.show_ignored_conflicts}}activateListeners(e){super.activateListeners(e);let t=this;e.find(".caret.has-nested").on("click",(function(e){const t=$(this);t.parent().find(".nested").toggleClass("active"),t.toggleClass("caret-down")})),e.find("button.reload").on("click",(function(e){t.render(!0)})),e.find(".lw-show-ignored-conflicts").on("change",(function(e){const r=$(this).find("input[type=checkbox]").prop("checked");t.show_ignored_conflicts=r,t.render(!0)})),e.find(".package-priority-group").on("click",(function(e){const t=$(this).find("select");t.is(":focus")||t.focus()})),e.find("button.change-priority").on("click",(function(t){const r=$(this),i=r.data("which"),n="up"===r.data("direction"),s=e.find(`.${i}`).find("option:selected"),a=n?s.prev():s.next();a.length&&(n?a.before(s):a.after(s))})),e.find("button.change-category").on("click",(function(t){const r=$(this),i=r.data("from"),n=r.data("to"),s=e.find(`.${i}`),a=e.find(`.${n}`),o=s.find("option:selected");let c=o.next();if(0==c.length&&(c=o.prev()),a.append(o),"packages-normal"==n){const e=a.find("option");e.sort(((e,t)=>$(e).val()>$(t).val()?1:-1)),a.empty().append(e)}c.length&&s.val(c.val()),s.focus()})),e.find(".submit").on("click",(function(t){for(let t of["packages-prioritized","packages-deprioritized"]){const r=e.find(`.${t}`).find("option");let i=[];r.each(((e,t)=>{i.push($(t).val())})),$("<input>").attr("type","hidden").attr("name",`${t}-hidden`).attr("value",i.join(",")).appendTo(e)}e.submit()})),e.find(".reset").on("click",(function(t){$("input[type=hidden]").remove(),ee.showYesNoDialog(`<p>${c.localize("lib-wrapper.settings.menu.warning-reset-priorities")}</p>`,(()=>{for(let t of["packages-prioritized","packages-deprioritized"])$("<input>").attr("type","hidden").attr("name",`${t}-hidden`).attr("value","").appendTo(e);e.submit()}))}))}async _updateObject(e,r){const i=game.settings.get(t,"module-priorities");for(let e of["prioritized","deprioritized"]){const t=`packages-${e}-hidden`;if(!(t in r))continue;const n=r[t],s=""===n?[]:n.split(",");let a=i[e]??{},o={},c=0;s.forEach((e=>{if(!e)return;const t=a[e],r=new f(e);o[e]={id:r.id,title:r.exists?r.title:t.title,index:c++}})),i[e]=o}Object.keys(i.deprioritized).forEach((e=>{e in i.prioritized&&delete i.deprioritized[e]})),await game.settings.set(t,"module-priorities",i),this.render(!0),ee.showYesNoDialog(`<p>${c.localize("lib-wrapper.settings.menu.warning-save")}</p>`,(()=>location.reload()))}}let te=!1,re=!0;const ie=new RegExp(["(","[^.[]+","|","\\[","(","'","(","[^'\\\\]","|","\\\\.",")+?","'","|",'"',"(",'[^"\\\\]',"|","\\\\.",")+?",'"',")","\\]",")"].join(""),"g"),ne=new RegExp(["(","^\\['","|","'\\]$","|",'^\\["',"|",'"\\]$',")"].join(""),"g");function se(e){let t=e.endsWith("#set");return[t?e.slice(0,-4):e,t]}function ae(e){return/^[a-zA-Z_$][0-9a-zA-Z_$]*?([.[]|$)/.test(e)}function oe(t,r){const i=se(t)[0];if(!ae(i))throw new e.package(`Invalid target '${i}'.`,r);const n=i.match(ie).map((e=>e.replace(/\\(.)/g,"$1").replace(ne,""))),s=n.splice(0,1)[0];if(!/^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(s))throw new e.package(`Invalid target '${i}': Invalid root scope '${s}'.`,r);if("libWrapper"==s)throw new e.package("Not allowed to wrap libWrapper internals.",r);let a,o;if(0==n.length){if(!(s in globalThis))throw new e.package(`Could not find target '${i}': Could not find scope 'globalThis.${s}'.`,r);o=s,a=globalThis}else{o=n.pop();const t=function(e){try{return globalThis[e]??g(e)}catch(e){return}}(s);if(!t)throw new e.package(`Could not find target '${i}': Could not find root scope '${s}'.`,r);a=t;for(const t of n)if(a=a[t],!a)throw new e.package(`Could not find target '${i}': Could not find scope '${t}'.`,r)}return[a,o,i]}function ce(e,t){return function(e,t,r,i){const n=new Z(e,t,r,i);return X.add(n),n}(...oe(e,t),t)}function le(e,t){return function(e,t){return Object.getOwnPropertyDescriptor(e,t)?.get?._lib_wrapper??null}(...oe(e,t))}function pe(e){const t=X.find_by_id(e);return[t,e===t?.setter_id]}function de(e,t,r){return t.get_fn_data(r).find((t=>t.package_info?.equals(e)))}function ue(t,r,i){const n=function(e,t){let r,i=null;if("number"==typeof t)[i,r]=pe(t);else{const e=se(t);i=le(e[0]),r=e[1]}return i?r&&!i.is_property?null:de(e,i,r):null}(t,r);if(!n){if(i)throw new e.package(`Cannot unregister '${r}' by ${t.type_plus_id} as no such wrapper has been registered`,t);return}const s=n.wrapper;return s.remove(n),function(e){e.is_empty()}(s),n}function he(r){let i=new f;if(!f.is_valid_id(r))throw new e.package("Parameter 'package_id' is invalid.",i);if(i.exists){if(r!=i.id)throw new e.package(`${i.type_plus_id_capitalized} is not allowed to call libWrapper with package_id='${r}'.`,i)}else i=new f(r);if(r==t){if(!re)throw new e.package(`Not allowed to call libWrapper with package_id='${r}'.`,i)}else if(!i.exists&&game.modules?.size)throw new e.package(`Package '${r}' is not a valid package.`,i);return i}class _e{static get version(){return U}static get versions(){return[L,M,F,V,G]}static get git_version(){return H}static get is_fallback(){return!1}static get debug(){return r}static set debug(e){r=e}static get LibWrapperError(){return e.base}static get Error(){return e.base}static get LibWrapperInternalError(){return e.internal}static get InternalError(){return e.internal}static get LibWrapperPackageError(){return e.package}static get PackageError(){return e.package}static get LibWrapperAlreadyOverriddenError(){return e.already_overridden}static get AlreadyOverriddenError(){return e.already_overridden}static get LibWrapperInvalidWrapperChainError(){return e.invalid_chain}static get InvalidWrapperChainError(){return e.invalid_chain}static get onUnhandledError(){return x}static get WRAPPER(){return q.WRAPPER}static get MIXED(){return q.MIXED}static get OVERRIDE(){return q.OVERRIDE}static get PERF_NORMAL(){return B.NORMAL}static get PERF_AUTO(){return B.AUTO}static get PERF_FAST(){return B.FAST}static get version_at_least(){return K}static register(i,n,s,a="MIXED",o={}){const c=he(i);if(i!=t&&!te)throw new e.package("Not allowed to register wrappers before the 'libWrapperReady' hook fires",c);if("string"!=typeof n&&"number"!=typeof n)throw new e.package("Parameter 'target' must be a number or a string.",c);if(!(s&&s instanceof Function))throw new e.package("Parameter 'fn' must be a function.",c);if(null===(a=q.get(a,null)))throw new e.package(`Parameter 'type' must be one of [${q.list.join(", ")}].`,c);const l=o?.chain??a.value<q.OVERRIDE.value;if("boolean"!=typeof l)throw new e.package("Parameter 'chain' must be a boolean.",c);const p=B.get(o?.perf_mode??"AUTO",null);if(null===p)throw new e.package(`Parameter 'perf_mode' must be one of [${PERF_MODE.list.join(", ")}].`,c);let d,u;if("number"==typeof n){if([d,u]=pe(n),!d)throw new e.package(`Could not find target '${n}': Invalid or unknown unique identifier.`,c)}else{const t=se(n),r=t[0];if(u=t[1],d=ce(n,c),!d)throw new e.internal("Sanity check failed: 'wrapper' must not be falsy after _create_wrapper call");if(u&&!d.is_property)throw new e.package(`Cannot register a wrapper for '${n}' by ${c.type_plus_id}' because '${r}' is not a property, and therefore has no setter.`,c)}const h=d.get_id(u),_=d.get_name(u);if(de(c,d,u))throw new e.package(`A wrapper for '${_}' (ID=${h}) has already been registered by ${c.type_plus_id}.`,c);const f=function(e,r){if(e.id===t)return Number.MAX_VALUE;const i=J.get(e.key);return void 0!==i?i:0}(c);if(c.id!=t&&j.register_package(c),a.value>=q.OVERRIDE.value){const t=d.get_fn_data(u).find((e=>e.type===q.OVERRIDE));if(t){if(f<=t.priority)throw new e.package(c,t.package_info,d,n);if(!1!==Hooks.call("libWrapper.OverrideLost",t.package_info.id,c.id,d.name,d.frozen_names)){N.register_conflict(c,t.package_info,d,null,!1)&&P.conflict(t.package_info,c,!1,`${c.type_plus_id_capitalized} has higher priority, and is replacing the 'OVERRIDE' registered by ${c.type_plus_id} for '${_}'.`)}}}let g={package_info:c,target:n,setter:u,fn:s,type:a,wrapper:d,priority:f,chain:l,perf_mode:p};return d.add(g),(r||c.id!=t)&&(Hooks.callAll("libWrapper.Register",c.id,"number"==typeof n?_:n,a,o,h),console.info(`libWrapper: Registered a wrapper for '${_}' (ID=${h}) by ${c.type_plus_id} with type ${a}.`)),h}static unregister(i,n,s=!0){const a=he(i);if("string"!=typeof n&&"number"!=typeof n)throw new e.package("Parameter 'target' must be a number or a string.",a);const o=ue(a,n,s);if(o&&(r||a.id!=t)){const e=o.wrapper.get_id(o.setter),t=o.wrapper.get_name(o.setter);Hooks.callAll("libWrapper.Unregister",a.id,"number"==typeof n?t:n,e),console.info(`libWrapper: Unregistered the wrapper for '${t}' (ID=${e}) by ${a.type_plus_id}.`)}}static unregister_all(e){const i=he(e);X.forEach((e=>{this.unregister(i.id,e.getter_id,!1),e.is_property&&this.unregister(i.id,e.setter_id,!1)})),(r||i.id!=t)&&(Hooks.callAll("libWrapper.UnregisterAll",i.id),console.info(`libWrapper: Unregistered all wrapper functions by ${i.type_plus_id}.`))}static ignore_conflicts(i,n,s,a={}){const o=he(i);if(!te)throw new e.package("Not allowed to ignore conflicts before the 'libWrapperReady' hook fires",o);Array.isArray(n)||(n=[n]),Array.isArray(s)||(s=[s]);const c=e=>"string"==typeof e;if(!n.every(c))throw new e.package("Parameter 'ignore_ids' must be a string, or an array of strings.",o);if(!s.every(c))throw new e.package("Parameter 'targets' must be a string, or an array of strings.",o);if(!s.every((e=>ae(e))))throw new e.package("Parameter 'targets' must only contain valid targets.",o);const l=a.ignore_errors??!1;if("boolean"!=typeof l)throw new e.package("Parameter 'options.ignore_errors' must be a boolean.",o);const p=n.map((e=>new f(e))).filter((e=>e.exists));0!=p.length?(N.register_ignore(o,p,s,l),(r||o.id!=t)&&console.debug(`libWrapper: Ignoring conflicts involving ${o.type_plus_id} and [${p.map((e=>e.type_plus_id)).join(", ")}] for targets [${s.join(", ")}].`)):console.debug(`libWrapper: Ignoring 'ignore_conflict' call for ${o.type_plus_id} since none of the package IDs provided exist or are active.`)}}y(_e),Object.freeze(_e),delete globalThis.libWrapper,Object.defineProperty(globalThis,"libWrapper",{get:()=>_e,set:t=>{throw new e.package("Not allowed to re-assign the global instance of libWrapper")},configurable:!1}),globalThis.addEventListener("error",C),globalThis.addEventListener("unhandledrejection",C),Hooks.onError?function(){try{libWrapper.register("lib-wrapper","Hooks.onError",(function(e,...t){const r=t[1];return x(r),e(...t)}),"WRAPPER",{perf_mode:"FAST"})}catch(e){P.console_ui("A non-critical error occurred while initializing libWrapper.","Could not setup 'Hooks.onError' wrapper.\n","warn",e)}}():function(){try{const e="() => function "+Hooks._call.toString(),t=e.replace(/catch[\s\n]*\((.*)\)[\s\n]*{/gim,"$& globalThis.libWrapper.onUnhandledError($1);");if(e===t)throw new Error(`Could not patch 'Hooks._call' method:\n${e}`);r&&console.log(`Patched Hooks._call: ${t}`);const i=g(t)?.();if("function"!=typeof i)throw new Error(`Evaluation of patched 'Hooks._call' method did not return a function:\nPatched Method: ${t}\nReturned: ${i}`);Hooks._call=i}catch(e){P.console_ui("A non-critical error occurred while initializing libWrapper.","Could not setup 'Hooks._call' wrapper.\n","warn",e)}try{libWrapper.register("lib-wrapper","Application.prototype._render",(function(e,...t){return e(...t).catch((e=>{throw x(e),e}))}),"WRAPPER",{perf_mode:"FAST"})}catch(e){P.console_ui("A non-critical error occurred while initializing libWrapper.","Could not setup 'Application.prototype._render' wrapper.\n","warn",e)}}();{let t,r;const i=m("libWrapperInit"),n={[i]:async function(e,...i){{const e=new f("lib-wrapper",p.MODULE);ue(e,r,!0),ue(e,t,!0)}return te=!0,await c.init(),ee.init(),j.init(),N.init(),P.init(),console.info(`libWrapper ${Y}: Ready.`),Hooks.callAll("libWrapper.Ready",_e),e(...i)}};t=_e.register("lib-wrapper","Game.prototype.initialize",n[i],_e.WRAPPER,{perf_mode:_e.PERF_FAST}),r=_e.register("lib-wrapper","Game.toString",(function(){throw new e.package("Using 'Game.toString()' before libWrapper initialises is not allowed for compatibility reasons.")}),_e.WRAPPER,{perf_mode:_e.PERF_FAST}),Hooks.once("init",(()=>{if(!te)throw new e.internal("Could not successfuly initialise libWrapper, likely due to a compatibility issue with another module.")}))}re=!1;//# sourceMappingURL=lib-wrapper.js.map
